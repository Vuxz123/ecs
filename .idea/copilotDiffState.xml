<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    id(&quot;java&quot;)&#10;    id(&quot;application&quot;)&#10;    `java-library`&#10;    id(&quot;me.champeau.jmh&quot;) version &quot;0.7.3&quot;&#10;}&#10;&#10;group = &quot;com.ethnicthv&quot;&#10;version = &quot;1.0-SNAPSHOT&quot;&#10;&#10;java {&#10;    toolchain {&#10;        languageVersion.set(JavaLanguageVersion.of(25))&#10;    }&#10;}&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    // Enable our annotation processor for compile&#10;    annotationProcessor(project(&quot;:ecs-processor&quot;))&#10;    // Enable it for tests as well&#10;    testAnnotationProcessor(project(&quot;:ecs-processor&quot;))&#10;    jmhAnnotationProcessor(project(&quot;:ecs-processor&quot;))&#10;&#10;    testImplementation(platform(&quot;org.junit:junit-bom:5.10.0&quot;))&#10;    testImplementation(&quot;org.junit.jupiter:junit-jupiter&quot;)&#10;    testImplementation(&quot;org.junit.platform:junit-platform-suite-api&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-launcher&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-suite-engine&quot;)&#10;&#10;    // JMH for benchmarking&#10;    implementation (&quot;org.openjdk.jmh:jmh-core:0.9&quot;)&#10;    annotationProcessor (&quot;org.openjdk.jmh:jmh-generator-annprocess:0.9&quot;)&#10;    // proc ('org.openjdk.jmh:jmh-generator-bytecode:0.9')&#10;&#10;    // Fix for &quot;NoClassDefFoundError: javax/annotation/Generated&quot; on JDK 9+&#10;    annotationProcessor(&quot;javax.annotation:javax.annotation-api:1.3.2&quot;)&#10;    implementation(&quot;javax.annotation:javax.annotation-api:1.3.2&quot;)&#10;}&#10;&#10;application {&#10;    // updated to use the demo package where the entry points were moved&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ECSDemo&quot;)&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;tasks.withType&lt;JavaCompile&gt; {&#10;    options.compilerArgs.addAll(listOf(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;    ))&#10;}&#10;&#10;tasks.withType&lt;Test&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.withType&lt;JavaExec&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the performance benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.PerformanceBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ComponentManager demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runImproved&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the improved demo with Query API and true SoA&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ImprovedDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the Archetype-based ECS demo&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Benchmark Archetype vs SparseSet ECS&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeVsSparseSetBenchmark&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeQueryDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ArchetypeQuery demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeQueryDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run Component Manager + Archetype ECS benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;,&#10;        &quot;-Xms2G&quot;,&#10;        &quot;-Xmx4G&quot;&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;    id(&quot;java&quot;)&#10;    id(&quot;application&quot;)&#10;    `java-library`&#10;    id(&quot;me.champeau.jmh&quot;) version &quot;0.7.3&quot;&#10;}&#10;&#10;group = &quot;com.ethnicthv&quot;&#10;version = &quot;1.0-SNAPSHOT&quot;&#10;&#10;java {&#10;    toolchain {&#10;        languageVersion.set(JavaLanguageVersion.of(25))&#10;    }&#10;}&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    // Enable our annotation processor for compile&#10;    annotationProcessor(project(&quot;:ecs-processor&quot;))&#10;    // Enable it for tests as well&#10;    testAnnotationProcessor(project(&quot;:ecs-processor&quot;))&#10;    jmhAnnotationProcessor(project(&quot;:ecs-processor&quot;))&#10;&#10;    testImplementation(platform(&quot;org.junit:junit-bom:5.10.0&quot;))&#10;    testImplementation(&quot;org.junit.jupiter:junit-jupiter&quot;)&#10;    testImplementation(&quot;org.junit.platform:junit-platform-suite-api&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-launcher&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-suite-engine&quot;)&#10;&#10;    // JMH for benchmarking&#10;    implementation (&quot;org.openjdk.jmh:jmh-core:0.9&quot;)&#10;    annotationProcessor (&quot;org.openjdk.jmh:jmh-generator-annprocess:0.9&quot;)&#10;    // proc ('org.openjdk.jmh:jmh-generator-bytecode:0.9')&#10;&#10;    // Fix for &quot;NoClassDefFoundError: javax/annotation/Generated&quot; on JDK 9+&#10;    annotationProcessor(&quot;javax.annotation:javax.annotation-api:1.3.2&quot;)&#10;    implementation(&quot;javax.annotation:javax.annotation-api:1.3.2&quot;)&#10;}&#10;&#10;application {&#10;    // updated to use the demo package where the entry points were moved&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ECSDemo&quot;)&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;tasks.withType&lt;JavaCompile&gt; {&#10;    options.compilerArgs.addAll(listOf(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;    ))&#10;}&#10;&#10;tasks.withType&lt;Test&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.withType&lt;JavaExec&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the performance benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.PerformanceBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ComponentManager demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runImproved&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the improved demo with Query API and true SoA&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ImprovedDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the Archetype-based ECS demo&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Benchmark Archetype vs SparseSet ECS&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeVsSparseSetBenchmark&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeQueryDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ArchetypeQuery demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeQueryDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run Component Manager + Archetype ECS benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;,&#10;        &quot;-Xms2G&quot;,&#10;        &quot;-Xmx4G&quot;&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ecs-processor/src/main/java/com/ethnicthv/ecs/processor/ComponentProcessor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ecs-processor/src/main/java/com/ethnicthv/ecs/processor/ComponentProcessor.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.processor;&#10;&#10;import javax.annotation.processing.*;&#10;import javax.lang.model.SourceVersion;&#10;import javax.lang.model.element.*;&#10;import javax.lang.model.type.TypeMirror;&#10;import javax.lang.model.util.Elements;&#10;import javax.tools.JavaFileObject;&#10;import java.io.IOException;&#10;import java.io.Writer;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Annotation processor that generates per-component metaclasses with:&#10; * - integer field-index constants (IDX_&lt;NAME&gt;)&#10; * - a prebuilt ComponentDescriptor (DESCRIPTOR)&#10; * - a type-safe &lt;Component&gt;Access with getX/setX(ComponentHandle) API&#10; * Also generates a central registry com.ethnicthv.ecs.generated.GeneratedComponents&#10; * with registerAll(ComponentManager) for quick startup registration.&#10; */&#10;@SupportedAnnotationTypes({&#10;        &quot;com.ethnicthv.ecs.core.components.Component.Field&quot;,&#10;        &quot;com.ethnicthv.ecs.core.components.Component.Layout&quot;,&#10;})&#10;@SupportedSourceVersion(SourceVersion.RELEASE_25)&#10;public class ComponentProcessor extends BaseProcessor {&#10;    // ---------------------------------------------------------------------&#10;    // Constants&#10;    // ---------------------------------------------------------------------&#10;    private static final String ANNO_LAYOUT = &quot;com.ethnicthv.ecs.core.components.Component.Layout&quot;;&#10;    private static final String ANNO_FIELD = &quot;com.ethnicthv.ecs.core.components.Component.Field&quot;;&#10;    private static final String COMPONENT_IFACE = &quot;com.ethnicthv.ecs.core.components.Component&quot;;&#10;&#10;    private Elements elementUtils;&#10;    // Accumulate discovered component types to generate a central registry (FQNs)&#10;    private final Set&lt;String&gt; collectedComponents = new LinkedHashSet&lt;&gt;();&#10;    // In-memory descriptors for already-processed component types within a round&#10;    private final Map&lt;String, LocalDescriptor&gt; generatedDescriptors = new LinkedHashMap&lt;&gt;();&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Lifecycle&#10;    // ---------------------------------------------------------------------&#10;    @Override&#10;    public synchronized void init(ProcessingEnvironment processingEnv) {&#10;        super.init(processingEnv);&#10;        this.elementUtils = processingEnv.getElementUtils();&#10;        note(&quot;ComponentProcessor init&quot;);&#10;    }&#10;&#10;    @Override&#10;    public SourceVersion getSupportedSourceVersion() {&#10;        return SourceVersion.latestSupported();&#10;    }&#10;&#10;    @Override&#10;    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {&#10;        note(&quot;Processing round: annotations=%d over=%s&quot;, annotations.size(), roundEnv.processingOver());&#10;        generatedDescriptors.clear();&#10;        Set&lt;TypeElement&gt; candidates = collectCandidateComponentTypes(roundEnv);&#10;        note(&quot;Found %d candidate component types&quot;, candidates.size());&#10;        if (!candidates.isEmpty()) {&#10;            DependencyGraph graph = buildDependencyGraph(candidates);&#10;            List&lt;TypeElement&gt; ordered = topoSort(graph);&#10;            note(&quot;Topologically sorted component order (size=%d)&quot;, ordered.size());&#10;&#10;            TypeElement componentInterface = getTypeElement(COMPONENT_IFACE);&#10;            TypeMirror componentMirror = componentInterface != null ? componentInterface.asType() : null;&#10;            for (TypeElement compType : ordered) {&#10;                note(&quot;Processing component type (topo): %s&quot;, compType.getQualifiedName());&#10;                try {&#10;                    boolean generated = generateForComponent(compType);&#10;                    if (generated) {&#10;                        boolean isComponent = componentMirror != null &amp;&amp; processingEnv.getTypeUtils().isAssignable(compType.asType(), componentMirror);&#10;                        if (isComponent) collectedComponents.add(compType.getQualifiedName().toString());&#10;                    } else {&#10;                        note(&quot;Deferring generation for %s due to unresolved composite dependencies&quot;, compType.getQualifiedName());&#10;                    }&#10;                } catch (IOException ex) {&#10;                    error(&quot;Failed to generate meta/handle for %s: %s&quot;, compType.getQualifiedName(), ex.getMessage());&#10;                }&#10;            }&#10;        }&#10;        if (roundEnv.processingOver() &amp;&amp; !collectedComponents.isEmpty()) {&#10;            try { generateCentralRegistry(); } catch (IOException ex) { error(&quot;Failed to generate central registry: %s&quot;, ex.getMessage()); }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Candidate discovery&#10;    // ---------------------------------------------------------------------&#10;    private Set&lt;TypeElement&gt; collectCandidateComponentTypes(RoundEnvironment roundEnv) {&#10;        Set&lt;TypeElement&gt; result = new LinkedHashSet&lt;&gt;();&#10;        TypeElement layoutAnno = getTypeElement(ANNO_LAYOUT);&#10;        TypeElement fieldAnno = getTypeElement(ANNO_FIELD);&#10;&#10;        if (layoutAnno != null) {&#10;            for (Element e : roundEnv.getElementsAnnotatedWith(layoutAnno)) {&#10;                if (e.getKind().isClass()) result.add((TypeElement) e);&#10;            }&#10;        }&#10;        if (fieldAnno != null) {&#10;            for (Element e : roundEnv.getElementsAnnotatedWith(fieldAnno)) {&#10;                Element owner = e.getEnclosingElement();&#10;                if (owner != null &amp;&amp; owner.getKind().isClass()) result.add((TypeElement) owner);&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Dependency Graph Construction (Phase 1)&#10;    // ---------------------------------------------------------------------&#10;    private static final class DependencyGraph {&#10;        final Map&lt;String, TypeElement&gt; nodes = new LinkedHashMap&lt;&gt;(); // fqn -&gt; element&#10;        final Map&lt;String, Set&lt;String&gt;&gt; edges = new LinkedHashMap&lt;&gt;(); // component fqn -&gt; set of dependency fqns&#10;    }&#10;&#10;    private DependencyGraph buildDependencyGraph(Set&lt;TypeElement&gt; candidates) {&#10;        DependencyGraph graph = new DependencyGraph();&#10;        for (TypeElement te : candidates) {&#10;            String fqn = te.getQualifiedName().toString();&#10;            graph.nodes.put(fqn, te);&#10;            graph.edges.put(fqn, new LinkedHashSet&lt;&gt;());&#10;        }&#10;        for (TypeElement comp : candidates) {&#10;            String compFqn = comp.getQualifiedName().toString();&#10;            for (Element e : comp.getEnclosedElements()) {&#10;                if (e.getKind() != ElementKind.FIELD) continue;&#10;                if (!hasFieldAnnotation(e)) continue;&#10;                VariableElement ve = (VariableElement) e;&#10;                String fieldTypeFqn = ve.asType().toString();&#10;                if (isPrimitiveOrBoxed(fieldTypeFqn)) continue;&#10;                if (graph.nodes.containsKey(fieldTypeFqn)) {&#10;                    // Invert edge: dependency -&gt; component&#10;                    graph.edges.get(fieldTypeFqn).add(compFqn);&#10;                    note(&quot;Dependency edge (inverted): %s -&gt; %s&quot;, fieldTypeFqn, compFqn);&#10;                }&#10;            }&#10;        }&#10;        return graph;&#10;    }&#10;&#10;    private boolean isPrimitiveOrBoxed(String fqn) {&#10;        return switch (fqn) {&#10;            case &quot;byte&quot;, &quot;java.lang.Byte&quot;,&#10;                 &quot;short&quot;, &quot;java.lang.Short&quot;,&#10;                 &quot;int&quot;, &quot;java.lang.Integer&quot;,&#10;                 &quot;long&quot;, &quot;java.lang.Long&quot;,&#10;                 &quot;float&quot;, &quot;java.lang.Float&quot;,&#10;                 &quot;double&quot;, &quot;java.lang.Double&quot;,&#10;                 &quot;boolean&quot;, &quot;java.lang.Boolean&quot;,&#10;                 &quot;char&quot;, &quot;java.lang.Character&quot; -&gt; true;&#10;            default -&gt; false;&#10;        };&#10;    }&#10;&#10;    private List&lt;TypeElement&gt; topoSort(DependencyGraph graph) {&#10;        // Kahn's algorithm using edges: component -&gt; dependency&#10;        Map&lt;String, Integer&gt; indegree = new LinkedHashMap&lt;&gt;();&#10;        for (String node : graph.nodes.keySet()) indegree.put(node, 0);&#10;        for (Map.Entry&lt;String, Set&lt;String&gt;&gt; e : graph.edges.entrySet()) {&#10;            for (String dep : e.getValue()) indegree.put(dep, indegree.get(dep) + 1);&#10;        }&#10;        Deque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();&#10;        for (Map.Entry&lt;String, Integer&gt; entry : indegree.entrySet()) {&#10;            if (entry.getValue() == 0) queue.add(entry.getKey());&#10;        }&#10;        List&lt;String&gt; orderedNames = new ArrayList&lt;&gt;();&#10;        while (!queue.isEmpty()) {&#10;            String n = queue.removeFirst();&#10;            orderedNames.add(n);&#10;            for (String dep : graph.edges.getOrDefault(n, Collections.emptySet())) {&#10;                int remaining = indegree.compute(dep, (k, v) -&gt; v - 1);&#10;                if (remaining == 0) queue.add(dep);&#10;            }&#10;        }&#10;        if (orderedNames.size() != graph.nodes.size()) {&#10;            // Cycle detection: produce diagnostics for involved nodes&#10;            Set&lt;String&gt; cycleNodes = new LinkedHashSet&lt;&gt;();&#10;            for (Map.Entry&lt;String, Integer&gt; entry : indegree.entrySet()) if (entry.getValue() &gt; 0) cycleNodes.add(entry.getKey());&#10;            error(&quot;Cycle detected in component dependency graph: %s&quot;, cycleNodes);&#10;            // Fallback: return original insertion order to proceed (graceful degrade)&#10;            return new ArrayList&lt;&gt;(graph.nodes.values());&#10;        }&#10;        List&lt;TypeElement&gt; out = new ArrayList&lt;&gt;(orderedNames.size());&#10;        for (String name : orderedNames) out.add(graph.nodes.get(name));&#10;        return out;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Generation pipeline for one component&#10;    // ---------------------------------------------------------------------&#10;    private boolean generateForComponent(TypeElement compType) throws IOException {&#10;        String pkg = elementUtils.getPackageOf(compType).getQualifiedName().toString();&#10;        String simpleName = compType.getSimpleName().toString();&#10;        String compFqn = compType.getQualifiedName().toString();&#10;        ComponentLayout layout = readLayout(compType);&#10;        List&lt;VariableElement&gt; rawFields = collectAnnotatedFields(compType);&#10;        List&lt;GeneratedField&gt; genFields;&#10;        List&lt;CompositeFieldInfo&gt; compositeInfos = new ArrayList&lt;&gt;();&#10;        try {&#10;            genFields = layoutAndSizeFields(layout, rawFields, compType, compositeInfos);&#10;        } catch (UnresolvedCompositeException uce) {&#10;            note(&quot;Unresolved composite for %s: %s&quot;, compType.getQualifiedName(), uce.getMessage());&#10;            return false;&#10;        }&#10;        compositeFieldMap.put(compFqn, compositeInfos);&#10;        long totalSize = computeTotalSize(layout, genFields);&#10;        int maxAlignment = 1;&#10;        for (GeneratedField f : genFields) maxAlignment = Math.max(maxAlignment, f.alignment);&#10;        generatedDescriptors.put(compFqn, new LocalDescriptor(genFields, totalSize, maxAlignment));&#10;        generateMetaSource(pkg, simpleName, compType, genFields, totalSize, layout);&#10;        generateHandleSource(pkg, simpleName, genFields, compType, compositeInfos);&#10;        return true;&#10;    }&#10;&#10;    private List&lt;VariableElement&gt; collectAnnotatedFields(TypeElement compType) {&#10;        return compType.getEnclosedElements().stream()&#10;                .filter(e -&gt; e.getKind() == ElementKind.FIELD)&#10;                .map(VariableElement.class::cast)&#10;                .filter(this::hasFieldAnnotation)&#10;                .filter(f -&gt; !f.getModifiers().contains(Modifier.STATIC))&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    private boolean hasFieldAnnotation(Element e) {&#10;        for (AnnotationMirror am : e.getAnnotationMirrors()) {&#10;            Element el = am.getAnnotationType().asElement();&#10;            if (el instanceof TypeElement te &amp;&amp; te.getQualifiedName().contentEquals(ANNO_FIELD)) return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    // Exception used to defer generation when a composite dependency isn't ready yet&#10;    private static final class UnresolvedCompositeException extends RuntimeException {&#10;        UnresolvedCompositeException(String msg) { super(msg); }&#10;    }&#10;&#10;    private List&lt;GeneratedField&gt; layoutAndSizeFields(ComponentLayout layout, List&lt;VariableElement&gt; fields, TypeElement ownerType, List&lt;CompositeFieldInfo&gt; compositeOut) {&#10;        List&lt;VariableElement&gt; work = new ArrayList&lt;&gt;(fields);&#10;        if (layout.type == LayoutType.EXPLICIT) {&#10;            work.sort(Comparator.comparingInt(f -&gt; readField(f).offset));&#10;        }&#10;        List&lt;GeneratedField&gt; out = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0L;&#10;        int maxAlignment = 1;&#10;        for (VariableElement ve : work) {&#10;            FieldAttrs attrs = readField(ve);&#10;            String name = ve.getSimpleName().toString();&#10;            String typeFqn = ve.asType().toString();&#10;            FieldType primitive = tryMapPrimitive(typeFqn);&#10;            if (primitive != null) {&#10;                int alignment = attrs.alignment &gt; 0 ? attrs.alignment : primitive.naturalAlignment;&#10;                long size = attrs.size &gt; 0 ? attrs.size : primitive.size;&#10;                long offset;&#10;                if (layout.type == LayoutType.EXPLICIT &amp;&amp; attrs.offset &gt;= 0) {&#10;                    offset = attrs.offset;&#10;                } else if (layout.type == LayoutType.PADDING) {&#10;                    offset = alignUp(currentOffset, alignment);&#10;                } else {&#10;                    offset = currentOffset;&#10;                }&#10;                out.add(new GeneratedField(name, primitive, offset, size, alignment));&#10;                currentOffset = offset + size;&#10;                maxAlignment = Math.max(maxAlignment, alignment);&#10;                continue;&#10;            }&#10;            LocalDescriptor sub = generatedDescriptors.get(typeFqn);&#10;            if (sub == null) {&#10;                throw new UnresolvedCompositeException(&quot;Missing descriptor for composite type '&quot; + typeFqn + &quot;' used in &quot; + ownerType.getQualifiedName());&#10;            }&#10;            int compositeAlign = attrs.alignment &gt; 0 ? attrs.alignment : sub.maxAlignment();&#10;            long compositeSize = attrs.size &gt; 0 ? attrs.size : sub.totalSize();&#10;            long baseOffset;&#10;            if (layout.type == LayoutType.EXPLICIT &amp;&amp; attrs.offset &gt;= 0) {&#10;                baseOffset = attrs.offset;&#10;            } else if (layout.type == LayoutType.PADDING) {&#10;                baseOffset = alignUp(currentOffset, compositeAlign);&#10;            } else {&#10;                baseOffset = currentOffset;&#10;            }&#10;            compositeOut.add(new CompositeFieldInfo(name, typeFqn, baseOffset));&#10;            for (GeneratedField sf : sub.fields()) {&#10;                String flatName = name + &quot;_&quot; + sf.name;&#10;                long flatOffset = baseOffset + sf.offset;&#10;                out.add(new GeneratedField(flatName, sf.ft, flatOffset, sf.size, sf.alignment));&#10;            }&#10;            currentOffset = baseOffset + compositeSize;&#10;            maxAlignment = Math.max(maxAlignment, compositeAlign);&#10;        }&#10;        return out;&#10;    }&#10;&#10;    private long computeTotalSize(ComponentLayout layout, List&lt;GeneratedField&gt; fields) {&#10;        if (layout.sizeOverride &gt; 0) return layout.sizeOverride;&#10;        long currentOffset = 0L;&#10;        int maxAlignment = 1;&#10;        for (GeneratedField f : fields) {&#10;            currentOffset = Math.max(currentOffset, f.offset + f.size);&#10;            maxAlignment = Math.max(maxAlignment, f.alignment);&#10;        }&#10;        if (layout.type == LayoutType.PADDING &amp;&amp; !fields.isEmpty()) {&#10;            return alignUp(currentOffset, maxAlignment);&#10;        }&#10;        return currentOffset;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Individual source generation helpers&#10;    // ---------------------------------------------------------------------&#10;    private void generateMetaSource(String pkg, String simpleName, TypeElement compType,&#10;                                    List&lt;GeneratedField&gt; genFields, long totalSize, ComponentLayout layout) throws IOException {&#10;        String metaName = simpleName + &quot;Meta&quot;;&#10;        String fqn = pkg.isEmpty() ? metaName : pkg + &quot;.&quot; + metaName;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn, compType);&#10;        // Compute explicit ComponentKind from annotations&#10;        boolean hasManaged = BaseProcessor.hasAnnotation(compType, &quot;com.ethnicthv.ecs.core.components.Component.Managed&quot;);&#10;        boolean hasShared = BaseProcessor.hasAnnotation(compType, &quot;com.ethnicthv.ecs.core.components.Component.Shared&quot;);&#10;        String kindLiteral;&#10;        if (hasShared) {&#10;            kindLiteral = hasManaged&#10;                ? &quot;com.ethnicthv.ecs.core.components.ComponentDescriptor.ComponentKind.SHARED_MANAGED&quot;&#10;                : &quot;com.ethnicthv.ecs.core.components.ComponentDescriptor.ComponentKind.SHARED_UNMANAGED&quot;;&#10;        } else {&#10;            kindLiteral = hasManaged&#10;                ? &quot;com.ethnicthv.ecs.core.components.ComponentDescriptor.ComponentKind.INSTANCE_MANAGED&quot;&#10;                : &quot;com.ethnicthv.ecs.core.components.ComponentDescriptor.ComponentKind.INSTANCE_UNMANAGED&quot;;&#10;        }&#10;        try (Writer w = file.openWriter()) {&#10;            if (!pkg.isEmpty()) w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            w.write(&quot;public final class &quot; + metaName + &quot; {\n&quot;);&#10;&#10;            // Field index constants&#10;            for (int i = 0; i &lt; genFields.size(); i++) {&#10;                w.write(&quot;    public static final int IDX_&quot; + genFields.get(i).name.toUpperCase(Locale.ROOT) + &quot; = &quot; + i + &quot;;\n&quot;);&#10;            }&#10;            w.write(&quot;\n&quot;);&#10;&#10;            // Descriptor build with explicit kind&#10;            w.write(&quot;    public static final com.ethnicthv.ecs.core.components.ComponentDescriptor DESCRIPTOR =\n&quot;);&#10;            w.write(&quot;        new com.ethnicthv.ecs.core.components.ComponentDescriptor(\n&quot;);&#10;            w.write(&quot;            &quot; + compType.getQualifiedName() + &quot;.class,\n&quot;);&#10;            w.write(&quot;            &quot; + totalSize + &quot;L,\n&quot;);&#10;            w.write(&quot;            java.util.List.of(\n&quot;);&#10;            for (int i = 0; i &lt; genFields.size(); i++) {&#10;                GeneratedField f = genFields.get(i);&#10;                w.write(&quot;                new com.ethnicthv.ecs.core.components.ComponentDescriptor.FieldDescriptor(\&quot;&quot; + f.name + &quot;\&quot;, &quot;);&#10;                w.write(&quot;com.ethnicthv.ecs.core.components.ComponentDescriptor.FieldType.&quot; + f.ft.enumName + &quot;, &quot;);&#10;                w.write(f.offset + &quot;L, &quot; + f.size + &quot;L, &quot; + f.alignment + &quot;)&quot;);&#10;                if (i &lt; genFields.size() - 1) w.write(&quot;,&quot;);&#10;                w.write(&quot;\n&quot;);&#10;            }&#10;            w.write(&quot;            ),\n&quot;);&#10;            w.write(&quot;            com.ethnicthv.ecs.core.components.Component.LayoutType.&quot; + layout.type.name() + &quot;,\n&quot;);&#10;            w.write(&quot;            &quot; + kindLiteral + &quot;\n&quot;);&#10;            w.write(&quot;        );\n\n&quot;);&#10;&#10;            w.write(&quot;    public static com.ethnicthv.ecs.core.components.ComponentDescriptor descriptor() { return DESCRIPTOR; }\n\n&quot;);&#10;            w.write(&quot;    private &quot; + metaName + &quot;() {}\n&quot;);&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    private void generateHandleSource(String pkg, String simpleName, List&lt;GeneratedField&gt; genFields, TypeElement compType, List&lt;CompositeFieldInfo&gt; compositeInfos) throws IOException {&#10;        String handleName = simpleName + &quot;Handle&quot;;&#10;        String fqn = pkg.isEmpty() ? handleName : pkg + &quot;.&quot; + handleName;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn, compType);&#10;        boolean isInterface = compType.getKind() == ElementKind.INTERFACE;&#10;        try (Writer w = file.openWriter()) {&#10;            if (!pkg.isEmpty()) w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            if (isInterface) {&#10;                w.write(&quot;public final class &quot; + handleName + &quot; implements &quot; + compType.getQualifiedName() + &quot;, com.ethnicthv.ecs.core.components.IBindableHandle {\n&quot;);&#10;            } else {&#10;                w.write(&quot;public final class &quot; + handleName + &quot; implements com.ethnicthv.ecs.core.components.IBindableHandle {\n&quot;);&#10;            }&#10;            w.write(&quot;  private com.ethnicthv.ecs.core.components.ComponentHandle __internalHandle;\n&quot;);&#10;            w.write(&quot;  private long __baseOffset;\n&quot;);&#10;            w.write(&quot;  public void __bind(com.ethnicthv.ecs.core.components.ComponentHandle h) { this.__internalHandle = h; this.__baseOffset = 0L; }\n&quot;);&#10;            w.write(&quot;  void __setBaseOffset(long off) { this.__baseOffset = off; }\n&quot;);&#10;            w.write(&quot;  public com.ethnicthv.ecs.core.components.ComponentHandle __raw() { return __internalHandle; }\n\n&quot;);&#10;            String meta = simpleName + &quot;Meta&quot;;&#10;            for (GeneratedField f : genFields) {&#10;                String prop = toCamelCase(f.name);&#10;                String idxConst = meta + &quot;.IDX_&quot; + f.name.toUpperCase(Locale.ROOT);&#10;                String valueLayout;&#10;                switch (f.ft) {&#10;                    case FLOAT -&gt; valueLayout = &quot;JAVA_FLOAT&quot;;&#10;                    case INT -&gt; valueLayout = &quot;JAVA_INT&quot;;&#10;                    case LONG -&gt; valueLayout = &quot;JAVA_LONG&quot;;&#10;                    case DOUBLE -&gt; valueLayout = &quot;JAVA_DOUBLE&quot;;&#10;                    case BOOLEAN -&gt; valueLayout = &quot;JAVA_BOOLEAN&quot;;&#10;                    case BYTE -&gt; valueLayout = &quot;JAVA_BYTE&quot;;&#10;                    case SHORT -&gt; valueLayout = &quot;JAVA_SHORT&quot;;&#10;                    case CHAR -&gt; valueLayout = &quot;JAVA_CHAR&quot;;&#10;                    default -&gt; valueLayout = &quot;JAVA_INT&quot;;&#10;                }&#10;                // absolute offset based on meta field offset&#10;                w.write(&quot;  public &quot; + javaTypeFor(f.ft) + &quot; get&quot; + prop + &quot;() { &quot;);&#10;                w.write(&quot;var __seg = __internalHandle.getSegment(); long __off = this.__baseOffset + &quot; + meta + &quot;.DESCRIPTOR.getField(&quot; + idxConst + &quot;).offset(); &quot;);&#10;                w.write(&quot;return __seg.get(java.lang.foreign.ValueLayout.&quot; + valueLayout + &quot;, __off); }\n&quot;);&#10;                w.write(&quot;  public void set&quot; + prop + &quot;(&quot; + javaTypeFor(f.ft) + &quot; v) { &quot;);&#10;                w.write(&quot;var __seg = __internalHandle.getSegment(); long __off = this.__baseOffset + &quot; + meta + &quot;.DESCRIPTOR.getField(&quot; + idxConst + &quot;).offset(); &quot;);&#10;                w.write(&quot;__seg.set(java.lang.foreign.ValueLayout.&quot; + valueLayout + &quot;, __off, v); }\n&quot;);&#10;            }&#10;            // Slice composite getters pass base offset to child handle&#10;            for (CompositeFieldInfo c : compositeInfos) {&#10;                String compSimple = c.typeFqn.substring(c.typeFqn.lastIndexOf('.') + 1);&#10;                String handleClass = compSimple + &quot;Handle&quot;;&#10;                String methodName = &quot;get&quot; + toCamelCase(c.originalName);&#10;                w.write(&quot;  public &quot; + handleClass + &quot; &quot; + methodName + &quot;() {\n&quot;);&#10;                w.write(&quot;    &quot; + handleClass + &quot; h = new &quot; + handleClass + &quot;(); h.__bind(this.__internalHandle); h.__setBaseOffset(this.__baseOffset + &quot; + c.baseOffset + &quot;L); return h;\n  }\n&quot;);&#10;            }&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    private void generateCentralRegistry() throws IOException {&#10;        String pkg = &quot;com.ethnicthv.ecs.generated&quot;;&#10;        String name = &quot;GeneratedComponents&quot;;&#10;        String fqn = pkg + &quot;.&quot; + name;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn);&#10;        try (Writer w = file.openWriter()) {&#10;            w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            w.write(&quot;public final class &quot; + name + &quot; {\n&quot;);&#10;            w.write(&quot;    private &quot; + name + &quot;() {}\n\n&quot;);&#10;            w.write(&quot;    public static void registerAll(com.ethnicthv.ecs.core.components.ComponentManager mgr) {\n&quot;);&#10;            for (String fqnComp : collectedComponents) {&#10;                String handleFqn = fqnComp + &quot;Handle&quot;;&#10;                w.write(&quot;        mgr.registerComponentWithHandle(\n&quot;);&#10;                w.write(&quot;            &quot; + fqnComp + &quot;.class,\n&quot;);&#10;                w.write(&quot;            &quot; + fqnComp + &quot;Meta.DESCRIPTOR,\n&quot;);&#10;                w.write(&quot;            &quot; + handleFqn + &quot;::new\n&quot;);&#10;                w.write(&quot;        );\n&quot;);&#10;            }&#10;            w.write(&quot;    }\n&quot;);&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Annotation reading &amp; utility&#10;    // ---------------------------------------------------------------------&#10;    private ComponentLayout readLayout(TypeElement type) {&#10;        for (AnnotationMirror am : type.getAnnotationMirrors()) {&#10;            Element el = am.getAnnotationType().asElement();&#10;            if (!(el instanceof TypeElement te)) continue;&#10;            if (!te.getQualifiedName().contentEquals(ANNO_LAYOUT)) continue;&#10;            LayoutType kind = LayoutType.SEQUENTIAL;&#10;            long sz = -1;&#10;            for (Map.Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; e : am.getElementValues().entrySet()) {&#10;                String name = e.getKey().getSimpleName().toString();&#10;                if (name.equals(&quot;value&quot;)) {&#10;                    kind = LayoutType.valueOf(e.getValue().getValue().toString());&#10;                } else if (name.equals(&quot;size&quot;)) {&#10;                    Number n = (Number) e.getValue().getValue();&#10;                    sz = n.longValue();&#10;                }&#10;            }&#10;            return new ComponentLayout(kind, sz);&#10;        }&#10;        return new ComponentLayout(LayoutType.SEQUENTIAL, -1); // default&#10;    }&#10;&#10;    private FieldAttrs readField(VariableElement ve) {&#10;        for (AnnotationMirror am : ve.getAnnotationMirrors()) {&#10;            Element el = am.getAnnotationType().asElement();&#10;            if (!(el instanceof TypeElement te)) continue;&#10;            if (!te.getQualifiedName().contentEquals(ANNO_FIELD)) continue;&#10;            int size = 0;&#10;            int offset = -1;&#10;            int alignment = 0;&#10;            for (Map.Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; e : am.getElementValues().entrySet()) {&#10;                String name = e.getKey().getSimpleName().toString();&#10;                Object av = e.getValue().getValue();&#10;                if (av instanceof Number n) {&#10;                    switch (name) {&#10;                        case &quot;size&quot; -&gt; size = n.intValue();&#10;                        case &quot;offset&quot; -&gt; offset = n.intValue();&#10;                        case &quot;alignment&quot; -&gt; alignment = n.intValue();&#10;                    }&#10;                }&#10;            }&#10;            return new FieldAttrs(size, offset, alignment);&#10;        }&#10;        return new FieldAttrs(0, -1, 0);&#10;    }&#10;&#10;    private FieldType tryMapPrimitive(String typeName) {&#10;        return switch (typeName) {&#10;            case &quot;byte&quot;, &quot;java.lang.Byte&quot; -&gt; FieldType.BYTE;&#10;            case &quot;short&quot;, &quot;java.lang.Short&quot; -&gt; FieldType.SHORT;&#10;            case &quot;int&quot;, &quot;java.lang.Integer&quot; -&gt; FieldType.INT;&#10;            case &quot;long&quot;, &quot;java.lang.Long&quot; -&gt; FieldType.LONG;&#10;            case &quot;float&quot;, &quot;java.lang.Float&quot; -&gt; FieldType.FLOAT;&#10;            case &quot;double&quot;, &quot;java.lang.Double&quot; -&gt; FieldType.DOUBLE;&#10;            case &quot;boolean&quot;, &quot;java.lang.Boolean&quot; -&gt; FieldType.BOOLEAN;&#10;            case &quot;char&quot;, &quot;java.lang.Character&quot; -&gt; FieldType.CHAR;&#10;            default -&gt; null;&#10;        };&#10;    }&#10;&#10;    private enum FieldType {&#10;        BYTE(1,1,&quot;BYTE&quot;), SHORT(2,2,&quot;SHORT&quot;), INT(4,4,&quot;INT&quot;), LONG(8,8,&quot;LONG&quot;), FLOAT(4,4,&quot;FLOAT&quot;), DOUBLE(8,8,&quot;DOUBLE&quot;), BOOLEAN(1,1,&quot;BOOLEAN&quot;), CHAR(2,2,&quot;CHAR&quot;);&#10;        final long size; final int naturalAlignment; final String enumName;&#10;        FieldType(long sz, int na, String en) { this.size = sz; this.naturalAlignment = na; this.enumName = en; }&#10;    }&#10;    private String javaTypeFor(FieldType ft) {&#10;        return switch (ft) {&#10;            case BYTE -&gt; &quot;byte&quot;;&#10;            case SHORT -&gt; &quot;short&quot;;&#10;            case INT -&gt; &quot;int&quot;;&#10;            case LONG -&gt; &quot;long&quot;;&#10;            case FLOAT -&gt; &quot;float&quot;;&#10;            case DOUBLE -&gt; &quot;double&quot;;&#10;            case BOOLEAN -&gt; &quot;boolean&quot;;&#10;            case CHAR -&gt; &quot;char&quot;;&#10;        };&#10;    }&#10;&#10;    private String toCamelCase(String name) {&#10;        StringBuilder sb = new StringBuilder();&#10;        boolean upperNext = true;&#10;        for (char c : name.toCharArray()) {&#10;            if (c == '_' || c == '-') {&#10;                upperNext = true;&#10;            } else if (upperNext) {&#10;                sb.append(Character.toUpperCase(c));&#10;                upperNext = false;&#10;            } else {&#10;                sb.append(c);&#10;            }&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    private long alignUp(long value, int alignment) {&#10;        return ((value + alignment - 1L) / alignment) * alignment;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Internal data structures&#10;    // ---------------------------------------------------------------------&#10;    private record ComponentLayout(LayoutType type, long sizeOverride) {}&#10;    private enum LayoutType { SEQUENTIAL, PADDING, EXPLICIT }&#10;    private record FieldAttrs(int size, int offset, int alignment) {}&#10;    private static final class GeneratedField {&#10;        final String name; final FieldType ft; final long offset; final long size; final int alignment;&#10;        GeneratedField(String n, FieldType ft, long off, long sz, int a) { this.name = n; this.ft = ft; this.offset = off; this.size = sz; this.alignment = a; }&#10;    }&#10;    // New structure to remember composite fields for slice handle generation&#10;    private static final class CompositeFieldInfo {&#10;        final String originalName; // e.g., position&#10;        final String typeFqn;      // e.g., com.foo.PositionComponent&#10;        final long baseOffset;     // offset where composite starts&#10;        CompositeFieldInfo(String originalName, String typeFqn, long baseOffset) {this.originalName = originalName; this.typeFqn = typeFqn; this.baseOffset = baseOffset; }&#10;    }&#10;    private record LocalDescriptor(List&lt;GeneratedField&gt; fields, long totalSize, int maxAlignment) {}&#10;    // Map component FQN -&gt; list of composite field infos (filled during layout)&#10;    private final Map&lt;String, List&lt;CompositeFieldInfo&gt;&gt; compositeFieldMap = new HashMap&lt;&gt;();&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.processor;&#10;&#10;import javax.annotation.processing.*;&#10;import javax.lang.model.SourceVersion;&#10;import javax.lang.model.element.*;&#10;import javax.lang.model.type.TypeMirror;&#10;import javax.lang.model.util.Elements;&#10;import javax.tools.JavaFileObject;&#10;import java.io.IOException;&#10;import java.io.Writer;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Annotation processor that generates per-component metaclasses with:&#10; * - integer field-index constants (IDX_&lt;NAME&gt;)&#10; * - a prebuilt ComponentDescriptor (DESCRIPTOR)&#10; * - a type-safe &lt;Component&gt;Access with getX/setX(ComponentHandle) API&#10; * Also generates a central registry com.ethnicthv.ecs.generated.GeneratedComponents&#10; * with registerAll(ComponentManager) for quick startup registration.&#10; */&#10;@SupportedAnnotationTypes({&#10;        &quot;com.ethnicthv.ecs.core.components.Component.Field&quot;,&#10;        &quot;com.ethnicthv.ecs.core.components.Component.Layout&quot;,&#10;})&#10;@SupportedSourceVersion(SourceVersion.RELEASE_25)&#10;public class ComponentProcessor extends BaseProcessor {&#10;    // ---------------------------------------------------------------------&#10;    // Constants&#10;    // ---------------------------------------------------------------------&#10;    private static final String ANNO_LAYOUT = &quot;com.ethnicthv.ecs.core.components.Component.Layout&quot;;&#10;    private static final String ANNO_FIELD = &quot;com.ethnicthv.ecs.core.components.Component.Field&quot;;&#10;    private static final String COMPONENT_IFACE = &quot;com.ethnicthv.ecs.core.components.Component&quot;;&#10;&#10;    private Elements elementUtils;&#10;    // Accumulate discovered component types to generate a central registry (FQNs)&#10;    private final Set&lt;String&gt; collectedComponents = new LinkedHashSet&lt;&gt;();&#10;    // In-memory descriptors for already-processed component types within a round&#10;    private final Map&lt;String, LocalDescriptor&gt; generatedDescriptors = new LinkedHashMap&lt;&gt;();&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Lifecycle&#10;    // ---------------------------------------------------------------------&#10;    @Override&#10;    public synchronized void init(ProcessingEnvironment processingEnv) {&#10;        super.init(processingEnv);&#10;        this.elementUtils = processingEnv.getElementUtils();&#10;        note(&quot;ComponentProcessor init&quot;);&#10;    }&#10;&#10;    @Override&#10;    public SourceVersion getSupportedSourceVersion() {&#10;        return SourceVersion.latestSupported();&#10;    }&#10;&#10;    @Override&#10;    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {&#10;        note(&quot;Processing round: annotations=%d over=%s&quot;, annotations.size(), roundEnv.processingOver());&#10;        generatedDescriptors.clear();&#10;        Set&lt;TypeElement&gt; candidates = collectCandidateComponentTypes(roundEnv);&#10;        note(&quot;Found %d candidate component types&quot;, candidates.size());&#10;        if (!candidates.isEmpty()) {&#10;            DependencyGraph graph = buildDependencyGraph(candidates);&#10;            List&lt;TypeElement&gt; ordered = topoSort(graph);&#10;            note(&quot;Topologically sorted component order (size=%d)&quot;, ordered.size());&#10;&#10;            TypeElement componentInterface = getTypeElement(COMPONENT_IFACE);&#10;            TypeMirror componentMirror = componentInterface != null ? componentInterface.asType() : null;&#10;            for (TypeElement compType : ordered) {&#10;                note(&quot;Processing component type (topo): %s&quot;, compType.getQualifiedName());&#10;                try {&#10;                    boolean generated = generateForComponent(compType);&#10;                    if (generated) {&#10;                        boolean isComponent = componentMirror != null &amp;&amp; processingEnv.getTypeUtils().isAssignable(compType.asType(), componentMirror);&#10;                        if (isComponent) collectedComponents.add(compType.getQualifiedName().toString());&#10;                    } else {&#10;                        note(&quot;Deferring generation for %s due to unresolved composite dependencies&quot;, compType.getQualifiedName());&#10;                    }&#10;                } catch (IOException ex) {&#10;                    error(&quot;Failed to generate meta/handle for %s: %s&quot;, compType.getQualifiedName(), ex.getMessage());&#10;                }&#10;            }&#10;        }&#10;        if (roundEnv.processingOver() &amp;&amp; !collectedComponents.isEmpty()) {&#10;            try { generateCentralRegistry(); } catch (IOException ex) { error(&quot;Failed to generate central registry: %s&quot;, ex.getMessage()); }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Candidate discovery&#10;    // ---------------------------------------------------------------------&#10;    private Set&lt;TypeElement&gt; collectCandidateComponentTypes(RoundEnvironment roundEnv) {&#10;        Set&lt;TypeElement&gt; result = new LinkedHashSet&lt;&gt;();&#10;        TypeElement layoutAnno = getTypeElement(ANNO_LAYOUT);&#10;        TypeElement fieldAnno = getTypeElement(ANNO_FIELD);&#10;&#10;        if (layoutAnno != null) {&#10;            for (Element e : roundEnv.getElementsAnnotatedWith(layoutAnno)) {&#10;                if (e.getKind().isClass()) result.add((TypeElement) e);&#10;            }&#10;        }&#10;        if (fieldAnno != null) {&#10;            for (Element e : roundEnv.getElementsAnnotatedWith(fieldAnno)) {&#10;                Element owner = e.getEnclosingElement();&#10;                if (owner != null &amp;&amp; owner.getKind().isClass()) result.add((TypeElement) owner);&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Dependency Graph Construction (Phase 1)&#10;    // ---------------------------------------------------------------------&#10;    private static final class DependencyGraph {&#10;        final Map&lt;String, TypeElement&gt; nodes = new LinkedHashMap&lt;&gt;(); // fqn -&gt; element&#10;        final Map&lt;String, Set&lt;String&gt;&gt; edges = new LinkedHashMap&lt;&gt;(); // component fqn -&gt; set of dependency fqns&#10;    }&#10;&#10;    private DependencyGraph buildDependencyGraph(Set&lt;TypeElement&gt; candidates) {&#10;        DependencyGraph graph = new DependencyGraph();&#10;        for (TypeElement te : candidates) {&#10;            String fqn = te.getQualifiedName().toString();&#10;            graph.nodes.put(fqn, te);&#10;            graph.edges.put(fqn, new LinkedHashSet&lt;&gt;());&#10;        }&#10;        for (TypeElement comp : candidates) {&#10;            String compFqn = comp.getQualifiedName().toString();&#10;            for (Element e : comp.getEnclosedElements()) {&#10;                if (e.getKind() != ElementKind.FIELD) continue;&#10;                if (!hasFieldAnnotation(e)) continue;&#10;                VariableElement ve = (VariableElement) e;&#10;                String fieldTypeFqn = ve.asType().toString();&#10;                if (isPrimitiveOrBoxed(fieldTypeFqn)) continue;&#10;                if (graph.nodes.containsKey(fieldTypeFqn)) {&#10;                    // Invert edge: dependency -&gt; component&#10;                    graph.edges.get(fieldTypeFqn).add(compFqn);&#10;                    note(&quot;Dependency edge (inverted): %s -&gt; %s&quot;, fieldTypeFqn, compFqn);&#10;                }&#10;            }&#10;        }&#10;        return graph;&#10;    }&#10;&#10;    private boolean isPrimitiveOrBoxed(String fqn) {&#10;        return switch (fqn) {&#10;            case &quot;byte&quot;, &quot;java.lang.Byte&quot;,&#10;                 &quot;short&quot;, &quot;java.lang.Short&quot;,&#10;                 &quot;int&quot;, &quot;java.lang.Integer&quot;,&#10;                 &quot;long&quot;, &quot;java.lang.Long&quot;,&#10;                 &quot;float&quot;, &quot;java.lang.Float&quot;,&#10;                 &quot;double&quot;, &quot;java.lang.Double&quot;,&#10;                 &quot;boolean&quot;, &quot;java.lang.Boolean&quot;,&#10;                 &quot;char&quot;, &quot;java.lang.Character&quot; -&gt; true;&#10;            default -&gt; false;&#10;        };&#10;    }&#10;&#10;    private List&lt;TypeElement&gt; topoSort(DependencyGraph graph) {&#10;        // Kahn's algorithm using edges: component -&gt; dependency&#10;        Map&lt;String, Integer&gt; indegree = new LinkedHashMap&lt;&gt;();&#10;        for (String node : graph.nodes.keySet()) indegree.put(node, 0);&#10;        for (Map.Entry&lt;String, Set&lt;String&gt;&gt; e : graph.edges.entrySet()) {&#10;            for (String dep : e.getValue()) indegree.put(dep, indegree.get(dep) + 1);&#10;        }&#10;        Deque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();&#10;        for (Map.Entry&lt;String, Integer&gt; entry : indegree.entrySet()) {&#10;            if (entry.getValue() == 0) queue.add(entry.getKey());&#10;        }&#10;        List&lt;String&gt; orderedNames = new ArrayList&lt;&gt;();&#10;        while (!queue.isEmpty()) {&#10;            String n = queue.removeFirst();&#10;            orderedNames.add(n);&#10;            for (String dep : graph.edges.getOrDefault(n, Collections.emptySet())) {&#10;                int remaining = indegree.compute(dep, (k, v) -&gt; v - 1);&#10;                if (remaining == 0) queue.add(dep);&#10;            }&#10;        }&#10;        if (orderedNames.size() != graph.nodes.size()) {&#10;            // Cycle detection: produce diagnostics for involved nodes&#10;            Set&lt;String&gt; cycleNodes = new LinkedHashSet&lt;&gt;();&#10;            for (Map.Entry&lt;String, Integer&gt; entry : indegree.entrySet()) if (entry.getValue() &gt; 0) cycleNodes.add(entry.getKey());&#10;            error(&quot;Cycle detected in component dependency graph: %s&quot;, cycleNodes);&#10;            // Fallback: return original insertion order to proceed (graceful degrade)&#10;            return new ArrayList&lt;&gt;(graph.nodes.values());&#10;        }&#10;        List&lt;TypeElement&gt; out = new ArrayList&lt;&gt;(orderedNames.size());&#10;        for (String name : orderedNames) out.add(graph.nodes.get(name));&#10;        return out;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Generation pipeline for one component&#10;    // ---------------------------------------------------------------------&#10;    private boolean generateForComponent(TypeElement compType) throws IOException {&#10;        String pkg = elementUtils.getPackageOf(compType).getQualifiedName().toString();&#10;        String simpleName = compType.getSimpleName().toString();&#10;        String compFqn = compType.getQualifiedName().toString();&#10;        ComponentLayout layout = readLayout(compType);&#10;        List&lt;VariableElement&gt; rawFields = collectAnnotatedFields(compType);&#10;        List&lt;GeneratedField&gt; genFields;&#10;        List&lt;CompositeFieldInfo&gt; compositeInfos = new ArrayList&lt;&gt;();&#10;        try {&#10;            genFields = layoutAndSizeFields(layout, rawFields, compType, compositeInfos);&#10;        } catch (UnresolvedCompositeException uce) {&#10;            note(&quot;Unresolved composite for %s: %s&quot;, compType.getQualifiedName(), uce.getMessage());&#10;            return false;&#10;        }&#10;        compositeFieldMap.put(compFqn, compositeInfos);&#10;        long totalSize = computeTotalSize(layout, genFields);&#10;        int maxAlignment = 1;&#10;        for (GeneratedField f : genFields) maxAlignment = Math.max(maxAlignment, f.alignment);&#10;        generatedDescriptors.put(compFqn, new LocalDescriptor(genFields, totalSize, maxAlignment));&#10;        generateMetaSource(pkg, simpleName, compType, genFields, totalSize, layout);&#10;        generateHandleSource(pkg, simpleName, genFields, compType, compositeInfos);&#10;        return true;&#10;    }&#10;&#10;    private List&lt;VariableElement&gt; collectAnnotatedFields(TypeElement compType) {&#10;        return compType.getEnclosedElements().stream()&#10;                .filter(e -&gt; e.getKind() == ElementKind.FIELD)&#10;                .map(VariableElement.class::cast)&#10;                .filter(this::hasFieldAnnotation)&#10;                .filter(f -&gt; !f.getModifiers().contains(Modifier.STATIC))&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    private boolean hasFieldAnnotation(Element e) {&#10;        for (AnnotationMirror am : e.getAnnotationMirrors()) {&#10;            Element el = am.getAnnotationType().asElement();&#10;            if (el instanceof TypeElement te &amp;&amp; te.getQualifiedName().contentEquals(ANNO_FIELD)) return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    // Exception used to defer generation when a composite dependency isn't ready yet&#10;    private static final class UnresolvedCompositeException extends RuntimeException {&#10;        UnresolvedCompositeException(String msg) { super(msg); }&#10;    }&#10;&#10;    private List&lt;GeneratedField&gt; layoutAndSizeFields(ComponentLayout layout, List&lt;VariableElement&gt; fields, TypeElement ownerType, List&lt;CompositeFieldInfo&gt; compositeOut) {&#10;        List&lt;VariableElement&gt; work = new ArrayList&lt;&gt;(fields);&#10;        if (layout.type == LayoutType.EXPLICIT) {&#10;            work.sort(Comparator.comparingInt(f -&gt; readField(f).offset));&#10;        }&#10;        List&lt;GeneratedField&gt; out = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0L;&#10;        int maxAlignment = 1;&#10;        for (VariableElement ve : work) {&#10;            FieldAttrs attrs = readField(ve);&#10;            String name = ve.getSimpleName().toString();&#10;            String typeFqn = ve.asType().toString();&#10;            FieldType primitive = tryMapPrimitive(typeFqn);&#10;            if (primitive != null) {&#10;                int alignment = attrs.alignment &gt; 0 ? attrs.alignment : primitive.naturalAlignment;&#10;                long size = attrs.size &gt; 0 ? attrs.size : primitive.size;&#10;                long offset;&#10;                if (layout.type == LayoutType.EXPLICIT &amp;&amp; attrs.offset &gt;= 0) {&#10;                    offset = attrs.offset;&#10;                } else if (layout.type == LayoutType.PADDING) {&#10;                    offset = alignUp(currentOffset, alignment);&#10;                } else {&#10;                    offset = currentOffset;&#10;                }&#10;                out.add(new GeneratedField(name, primitive, offset, size, alignment));&#10;                currentOffset = offset + size;&#10;                maxAlignment = Math.max(maxAlignment, alignment);&#10;                continue;&#10;            }&#10;            LocalDescriptor sub = generatedDescriptors.get(typeFqn);&#10;            if (sub == null) {&#10;                throw new UnresolvedCompositeException(&quot;Missing descriptor for composite type '&quot; + typeFqn + &quot;' used in &quot; + ownerType.getQualifiedName());&#10;            }&#10;            int compositeAlign = attrs.alignment &gt; 0 ? attrs.alignment : sub.maxAlignment();&#10;            long compositeSize = attrs.size &gt; 0 ? attrs.size : sub.totalSize();&#10;            long baseOffset;&#10;            if (layout.type == LayoutType.EXPLICIT &amp;&amp; attrs.offset &gt;= 0) {&#10;                baseOffset = attrs.offset;&#10;            } else if (layout.type == LayoutType.PADDING) {&#10;                baseOffset = alignUp(currentOffset, compositeAlign);&#10;            } else {&#10;                baseOffset = currentOffset;&#10;            }&#10;            compositeOut.add(new CompositeFieldInfo(name, typeFqn, baseOffset));&#10;            for (GeneratedField sf : sub.fields()) {&#10;                String flatName = name + &quot;_&quot; + sf.name;&#10;                long flatOffset = baseOffset + sf.offset;&#10;                out.add(new GeneratedField(flatName, sf.ft, flatOffset, sf.size, sf.alignment));&#10;            }&#10;            currentOffset = baseOffset + compositeSize;&#10;            maxAlignment = Math.max(maxAlignment, compositeAlign);&#10;        }&#10;        return out;&#10;    }&#10;&#10;    private long computeTotalSize(ComponentLayout layout, List&lt;GeneratedField&gt; fields) {&#10;        if (layout.sizeOverride &gt; 0) return layout.sizeOverride;&#10;        long currentOffset = 0L;&#10;        int maxAlignment = 1;&#10;        for (GeneratedField f : fields) {&#10;            currentOffset = Math.max(currentOffset, f.offset + f.size);&#10;            maxAlignment = Math.max(maxAlignment, f.alignment);&#10;        }&#10;        if (layout.type == LayoutType.PADDING &amp;&amp; !fields.isEmpty()) {&#10;            return alignUp(currentOffset, maxAlignment);&#10;        }&#10;        return currentOffset;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Individual source generation helpers&#10;    // ---------------------------------------------------------------------&#10;    private void generateMetaSource(String pkg, String simpleName, TypeElement compType,&#10;                                    List&lt;GeneratedField&gt; genFields, long totalSize, ComponentLayout layout) throws IOException {&#10;        String metaName = simpleName + &quot;Meta&quot;;&#10;        String fqn = pkg.isEmpty() ? metaName : pkg + &quot;.&quot; + metaName;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn, compType);&#10;        // Compute explicit ComponentKind from annotations&#10;        boolean hasManaged = BaseProcessor.hasAnnotation(compType, &quot;com.ethnicthv.ecs.core.components.Component.Managed&quot;);&#10;        boolean hasShared = BaseProcessor.hasAnnotation(compType, &quot;com.ethnicthv.ecs.core.components.Component.Shared&quot;);&#10;        String kindLiteral;&#10;        if (hasShared) {&#10;            kindLiteral = hasManaged&#10;                ? &quot;com.ethnicthv.ecs.core.components.ComponentDescriptor.ComponentKind.SHARED_MANAGED&quot;&#10;                : &quot;com.ethnicthv.ecs.core.components.ComponentDescriptor.ComponentKind.SHARED_UNMANAGED&quot;;&#10;        } else {&#10;            kindLiteral = hasManaged&#10;                ? &quot;com.ethnicthv.ecs.core.components.ComponentDescriptor.ComponentKind.INSTANCE_MANAGED&quot;&#10;                : &quot;com.ethnicthv.ecs.core.components.ComponentDescriptor.ComponentKind.INSTANCE_UNMANAGED&quot;;&#10;        }&#10;        try (Writer w = file.openWriter()) {&#10;            if (!pkg.isEmpty()) w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            w.write(&quot;public final class &quot; + metaName + &quot; {\n&quot;);&#10;&#10;            // Field index constants&#10;            for (int i = 0; i &lt; genFields.size(); i++) {&#10;                w.write(&quot;    public static final int IDX_&quot; + genFields.get(i).name.toUpperCase(Locale.ROOT) + &quot; = &quot; + i + &quot;;\n&quot;);&#10;            }&#10;            w.write(&quot;\n&quot;);&#10;&#10;            // Descriptor build with explicit kind&#10;            w.write(&quot;    public static final com.ethnicthv.ecs.core.components.ComponentDescriptor DESCRIPTOR =\n&quot;);&#10;            w.write(&quot;        new com.ethnicthv.ecs.core.components.ComponentDescriptor(\n&quot;);&#10;            w.write(&quot;            &quot; + compType.getQualifiedName() + &quot;.class,\n&quot;);&#10;            w.write(&quot;            &quot; + totalSize + &quot;L,\n&quot;);&#10;            w.write(&quot;            java.util.List.of(\n&quot;);&#10;            for (int i = 0; i &lt; genFields.size(); i++) {&#10;                GeneratedField f = genFields.get(i);&#10;                w.write(&quot;                new com.ethnicthv.ecs.core.components.ComponentDescriptor.FieldDescriptor(\&quot;&quot; + f.name + &quot;\&quot;, &quot;);&#10;                w.write(&quot;com.ethnicthv.ecs.core.components.ComponentDescriptor.FieldType.&quot; + f.ft.enumName + &quot;, &quot;);&#10;                w.write(f.offset + &quot;L, &quot; + f.size + &quot;L, &quot; + f.alignment + &quot;)&quot;);&#10;                if (i &lt; genFields.size() - 1) w.write(&quot;,&quot;);&#10;                w.write(&quot;\n&quot;);&#10;            }&#10;            w.write(&quot;            ),\n&quot;);&#10;            w.write(&quot;            com.ethnicthv.ecs.core.components.Component.LayoutType.&quot; + layout.type.name() + &quot;,\n&quot;);&#10;            w.write(&quot;            &quot; + kindLiteral + &quot;\n&quot;);&#10;            w.write(&quot;        );\n\n&quot;);&#10;&#10;            w.write(&quot;    public static com.ethnicthv.ecs.core.components.ComponentDescriptor descriptor() { return DESCRIPTOR; }\n\n&quot;);&#10;            w.write(&quot;    private &quot; + metaName + &quot;() {}\n&quot;);&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    private void generateHandleSource(String pkg, String simpleName, List&lt;GeneratedField&gt; genFields, TypeElement compType, List&lt;CompositeFieldInfo&gt; compositeInfos) throws IOException {&#10;        String handleName = simpleName + &quot;Handle&quot;;&#10;        String fqn = pkg.isEmpty() ? handleName : pkg + &quot;.&quot; + handleName;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn, compType);&#10;        boolean isInterface = compType.getKind() == ElementKind.INTERFACE;&#10;        try (Writer w = file.openWriter()) {&#10;            if (!pkg.isEmpty()) w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            if (isInterface) {&#10;                w.write(&quot;public final class &quot; + handleName + &quot; implements &quot; + compType.getQualifiedName() + &quot;, com.ethnicthv.ecs.core.components.IBindableHandle {\n&quot;);&#10;            } else {&#10;                w.write(&quot;public final class &quot; + handleName + &quot; implements com.ethnicthv.ecs.core.components.IBindableHandle {\n&quot;);&#10;            }&#10;            w.write(&quot;  private com.ethnicthv.ecs.core.components.ComponentHandle __internalHandle;\n&quot;);&#10;            w.write(&quot;  private long __baseOffset;\n&quot;);&#10;            w.write(&quot;  public void __bind(com.ethnicthv.ecs.core.components.ComponentHandle h) { this.__internalHandle = h; this.__baseOffset = 0L; }\n&quot;);&#10;            w.write(&quot;  void __setBaseOffset(long off) { this.__baseOffset = off; }\n&quot;);&#10;            w.write(&quot;  public com.ethnicthv.ecs.core.components.ComponentHandle __raw() { return __internalHandle; }\n\n&quot;);&#10;            String meta = simpleName + &quot;Meta&quot;;&#10;            for (GeneratedField f : genFields) {&#10;                String prop = toCamelCase(f.name);&#10;                String idxConst = meta + &quot;.IDX_&quot; + f.name.toUpperCase(Locale.ROOT);&#10;                String valueLayout;&#10;                switch (f.ft) {&#10;                    case FLOAT -&gt; valueLayout = &quot;JAVA_FLOAT&quot;;&#10;                    case INT -&gt; valueLayout = &quot;JAVA_INT&quot;;&#10;                    case LONG -&gt; valueLayout = &quot;JAVA_LONG&quot;;&#10;                    case DOUBLE -&gt; valueLayout = &quot;JAVA_DOUBLE&quot;;&#10;                    case BOOLEAN -&gt; valueLayout = &quot;JAVA_BOOLEAN&quot;;&#10;                    case BYTE -&gt; valueLayout = &quot;JAVA_BYTE&quot;;&#10;                    case SHORT -&gt; valueLayout = &quot;JAVA_SHORT&quot;;&#10;                    case CHAR -&gt; valueLayout = &quot;JAVA_CHAR&quot;;&#10;                    default -&gt; valueLayout = &quot;JAVA_INT&quot;;&#10;                }&#10;                // absolute offset based on meta field offset&#10;                w.write(&quot;  public &quot; + javaTypeFor(f.ft) + &quot; get&quot; + prop + &quot;() { &quot;);&#10;                w.write(&quot;var __seg = __internalHandle.getSegment(); long __off = this.__baseOffset + &quot; + meta + &quot;.DESCRIPTOR.getField(&quot; + idxConst + &quot;).offset(); &quot;);&#10;                w.write(&quot;return __seg.get(java.lang.foreign.ValueLayout.&quot; + valueLayout + &quot;, __off); }\n&quot;);&#10;                w.write(&quot;  public void set&quot; + prop + &quot;(&quot; + javaTypeFor(f.ft) + &quot; v) { &quot;);&#10;                w.write(&quot;var __seg = __internalHandle.getSegment(); long __off = this.__baseOffset + &quot; + meta + &quot;.DESCRIPTOR.getField(&quot; + idxConst + &quot;).offset(); &quot;);&#10;                w.write(&quot;__seg.set(java.lang.foreign.ValueLayout.&quot; + valueLayout + &quot;, __off, v); }\n&quot;);&#10;            }&#10;            // Slice composite getters pass base offset to child handle&#10;            for (CompositeFieldInfo c : compositeInfos) {&#10;                String compSimple = c.typeFqn.substring(c.typeFqn.lastIndexOf('.') + 1);&#10;                String handleClass = compSimple + &quot;Handle&quot;;&#10;                String methodName = &quot;get&quot; + toCamelCase(c.originalName);&#10;                w.write(&quot;  public &quot; + handleClass + &quot; &quot; + methodName + &quot;() {\n&quot;);&#10;                w.write(&quot;    &quot; + handleClass + &quot; h = new &quot; + handleClass + &quot;(); h.__bind(this.__internalHandle); h.__setBaseOffset(this.__baseOffset + &quot; + c.baseOffset + &quot;L); return h;\n  }\n&quot;);&#10;            }&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    private void generateCentralRegistry() throws IOException {&#10;        String pkg = &quot;com.ethnicthv.ecs.generated&quot;;&#10;        String name = &quot;GeneratedComponents&quot;;&#10;        String fqn = pkg + &quot;.&quot; + name;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn);&#10;        try (Writer w = file.openWriter()) {&#10;            w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            w.write(&quot;public final class &quot; + name + &quot; {\n&quot;);&#10;            w.write(&quot;    private &quot; + name + &quot;() {}\n\n&quot;);&#10;            w.write(&quot;    public static void registerAll(com.ethnicthv.ecs.core.components.ComponentManager mgr) {\n&quot;);&#10;            for (String fqnComp : collectedComponents) {&#10;                String handleFqn = fqnComp + &quot;Handle&quot;;&#10;                w.write(&quot;        mgr.registerComponentWithHandle(\n&quot;);&#10;                w.write(&quot;            &quot; + fqnComp + &quot;.class,\n&quot;);&#10;                w.write(&quot;            &quot; + fqnComp + &quot;Meta.DESCRIPTOR,\n&quot;);&#10;                w.write(&quot;            &quot; + handleFqn + &quot;::new\n&quot;);&#10;                w.write(&quot;        );\n&quot;);&#10;            }&#10;            w.write(&quot;    }\n&quot;);&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Annotation reading &amp; utility&#10;    // ---------------------------------------------------------------------&#10;    private ComponentLayout readLayout(TypeElement type) {&#10;        for (AnnotationMirror am : type.getAnnotationMirrors()) {&#10;            Element el = am.getAnnotationType().asElement();&#10;            if (!(el instanceof TypeElement te)) continue;&#10;            if (!te.getQualifiedName().contentEquals(ANNO_LAYOUT)) continue;&#10;            LayoutType kind = LayoutType.SEQUENTIAL;&#10;            long sz = -1;&#10;            for (Map.Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; e : am.getElementValues().entrySet()) {&#10;                String name = e.getKey().getSimpleName().toString();&#10;                if (name.equals(&quot;value&quot;)) {&#10;                    kind = LayoutType.valueOf(e.getValue().getValue().toString());&#10;                } else if (name.equals(&quot;size&quot;)) {&#10;                    Number n = (Number) e.getValue().getValue();&#10;                    sz = n.longValue();&#10;                }&#10;            }&#10;            return new ComponentLayout(kind, sz);&#10;        }&#10;        return new ComponentLayout(LayoutType.SEQUENTIAL, -1); // default&#10;    }&#10;&#10;    private FieldAttrs readField(VariableElement ve) {&#10;        for (AnnotationMirror am : ve.getAnnotationMirrors()) {&#10;            Element el = am.getAnnotationType().asElement();&#10;            if (!(el instanceof TypeElement te)) continue;&#10;            if (!te.getQualifiedName().contentEquals(ANNO_FIELD)) continue;&#10;            int size = 0;&#10;            int offset = -1;&#10;            int alignment = 0;&#10;            for (Map.Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; e : am.getElementValues().entrySet()) {&#10;                String name = e.getKey().getSimpleName().toString();&#10;                Object av = e.getValue().getValue();&#10;                if (av instanceof Number n) {&#10;                    switch (name) {&#10;                        case &quot;size&quot; -&gt; size = n.intValue();&#10;                        case &quot;offset&quot; -&gt; offset = n.intValue();&#10;                        case &quot;alignment&quot; -&gt; alignment = n.intValue();&#10;                    }&#10;                }&#10;            }&#10;            return new FieldAttrs(size, offset, alignment);&#10;        }&#10;        return new FieldAttrs(0, -1, 0);&#10;    }&#10;&#10;    private FieldType tryMapPrimitive(String typeName) {&#10;        return switch (typeName) {&#10;            case &quot;byte&quot;, &quot;java.lang.Byte&quot; -&gt; FieldType.BYTE;&#10;            case &quot;short&quot;, &quot;java.lang.Short&quot; -&gt; FieldType.SHORT;&#10;            case &quot;int&quot;, &quot;java.lang.Integer&quot; -&gt; FieldType.INT;&#10;            case &quot;long&quot;, &quot;java.lang.Long&quot; -&gt; FieldType.LONG;&#10;            case &quot;float&quot;, &quot;java.lang.Float&quot; -&gt; FieldType.FLOAT;&#10;            case &quot;double&quot;, &quot;java.lang.Double&quot; -&gt; FieldType.DOUBLE;&#10;            case &quot;boolean&quot;, &quot;java.lang.Boolean&quot; -&gt; FieldType.BOOLEAN;&#10;            case &quot;char&quot;, &quot;java.lang.Character&quot; -&gt; FieldType.CHAR;&#10;            default -&gt; null;&#10;        };&#10;    }&#10;&#10;    private enum FieldType {&#10;        BYTE(1,1,&quot;BYTE&quot;), SHORT(2,2,&quot;SHORT&quot;), INT(4,4,&quot;INT&quot;), LONG(8,8,&quot;LONG&quot;), FLOAT(4,4,&quot;FLOAT&quot;), DOUBLE(8,8,&quot;DOUBLE&quot;), BOOLEAN(1,1,&quot;BOOLEAN&quot;), CHAR(2,2,&quot;CHAR&quot;);&#10;        final long size; final int naturalAlignment; final String enumName;&#10;        FieldType(long sz, int na, String en) { this.size = sz; this.naturalAlignment = na; this.enumName = en; }&#10;    }&#10;    private String javaTypeFor(FieldType ft) {&#10;        return switch (ft) {&#10;            case BYTE -&gt; &quot;byte&quot;;&#10;            case SHORT -&gt; &quot;short&quot;;&#10;            case INT -&gt; &quot;int&quot;;&#10;            case LONG -&gt; &quot;long&quot;;&#10;            case FLOAT -&gt; &quot;float&quot;;&#10;            case DOUBLE -&gt; &quot;double&quot;;&#10;            case BOOLEAN -&gt; &quot;boolean&quot;;&#10;            case CHAR -&gt; &quot;char&quot;;&#10;        };&#10;    }&#10;&#10;    private String toCamelCase(String name) {&#10;        StringBuilder sb = new StringBuilder();&#10;        boolean upperNext = true;&#10;        for (char c : name.toCharArray()) {&#10;            if (c == '_' || c == '-') {&#10;                upperNext = true;&#10;            } else if (upperNext) {&#10;                sb.append(Character.toUpperCase(c));&#10;                upperNext = false;&#10;            } else {&#10;                sb.append(c);&#10;            }&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    private long alignUp(long value, int alignment) {&#10;        return ((value + alignment - 1L) / alignment) * alignment;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Internal data structures&#10;    // ---------------------------------------------------------------------&#10;    private record ComponentLayout(LayoutType type, long sizeOverride) {}&#10;    private enum LayoutType { SEQUENTIAL, PADDING, EXPLICIT }&#10;    private record FieldAttrs(int size, int offset, int alignment) {}&#10;    private static final class GeneratedField {&#10;        final String name; final FieldType ft; final long offset; final long size; final int alignment;&#10;        GeneratedField(String n, FieldType ft, long off, long sz, int a) { this.name = n; this.ft = ft; this.offset = off; this.size = sz; this.alignment = a; }&#10;    }&#10;    // New structure to remember composite fields for slice handle generation&#10;    private static final class CompositeFieldInfo {&#10;        final String originalName; // e.g., position&#10;        final String typeFqn;      // e.g., com.foo.PositionComponent&#10;        final long baseOffset;     // offset where composite starts&#10;        CompositeFieldInfo(String originalName, String typeFqn, long baseOffset) {this.originalName = originalName; this.typeFqn = typeFqn; this.baseOffset = baseOffset; }&#10;    }&#10;    private record LocalDescriptor(List&lt;GeneratedField&gt; fields, long totalSize, int maxAlignment) {}&#10;    // Map component FQN -&gt; list of composite field infos (filled during layout)&#10;    private final Map&lt;String, List&lt;CompositeFieldInfo&gt;&gt; compositeFieldMap = new HashMap&lt;&gt;();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ecs-processor/src/main/java/com/ethnicthv/ecs/processor/QueryProcessor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ecs-processor/src/main/java/com/ethnicthv/ecs/processor/QueryProcessor.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.processor;&#10;&#10;import javax.annotation.processing.*;&#10;import javax.lang.model.SourceVersion;&#10;import javax.lang.model.element.*;&#10;import javax.lang.model.util.Elements;&#10;import javax.tools.Diagnostic;&#10;import javax.tools.JavaFileObject;&#10;import java.io.IOException;&#10;import java.io.Writer;&#10;import java.util.*;&#10;&#10;@SupportedAnnotationTypes({&#10;    &quot;com.ethnicthv.ecs.core.system.annotation.Query&quot;&#10;})&#10;@SupportedSourceVersion(SourceVersion.RELEASE_25)&#10;public class QueryProcessor extends BaseProcessor {&#10;    // ---------------------------------------------------------------------&#10;    // Constants&#10;    // ---------------------------------------------------------------------&#10;    private static final String ANNO_QUERY = &quot;com.ethnicthv.ecs.core.system.annotation.Query&quot;;&#10;    private static final String ANNO_ID = &quot;com.ethnicthv.ecs.core.system.annotation.Id&quot;;&#10;    private static final String ANNO_COMPONENT = &quot;com.ethnicthv.ecs.core.system.annotation.Component&quot;;&#10;&#10;    private Elements elementUtils;&#10;&#10;    @Override&#10;    public synchronized void init(ProcessingEnvironment processingEnv) {&#10;        super.init(processingEnv);&#10;        this.elementUtils = processingEnv.getElementUtils();&#10;        note(&quot;QueryProcessor init&quot;);&#10;    }&#10;&#10;    @Override&#10;    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {&#10;        TypeElement queryAnno = elementUtils.getTypeElement(ANNO_QUERY);&#10;        if (queryAnno == null) return false;&#10;&#10;        Map&lt;TypeElement, List&lt;ExecutableElement&gt;&gt; byClass = new LinkedHashMap&lt;&gt;();&#10;        for (Element e : roundEnv.getElementsAnnotatedWith(queryAnno)) {&#10;            if (e.getKind() != ElementKind.METHOD) {&#10;                error(&quot;@Query can only be placed on methods: %s&quot;, e);&#10;                continue;&#10;            }&#10;            ExecutableElement method = (ExecutableElement) e;&#10;            TypeElement owner = (TypeElement) method.getEnclosingElement();&#10;            byClass.computeIfAbsent(owner, k -&gt; new ArrayList&lt;&gt;()).add(method);&#10;        }&#10;&#10;        for (Map.Entry&lt;TypeElement, List&lt;ExecutableElement&gt;&gt; entry : byClass.entrySet()) {&#10;            TypeElement owner = entry.getKey();&#10;            List&lt;ExecutableElement&gt; methods = entry.getValue();&#10;            try {&#10;                generateInjector(owner, methods);&#10;                for (ExecutableElement m : methods) generateRunner(owner, m);&#10;            } catch (IOException ex) {&#10;                error(&quot;Failed to generate for %s: %s&quot;, owner.getQualifiedName(), ex.getMessage());&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Code generation: Injector&#10;    // ---------------------------------------------------------------------&#10;    private void generateInjector(TypeElement owner, List&lt;ExecutableElement&gt; methods) throws IOException {&#10;        String pkg = elementUtils.getPackageOf(owner).getQualifiedName().toString();&#10;        String simple = owner.getSimpleName().toString();&#10;        String ownerQualified = owner.getQualifiedName().toString();&#10;        String name = simple + &quot;__QueryInjector&quot;;&#10;        String fqn = pkg.isEmpty() ? name : pkg + &quot;.&quot; + name;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn, owner);&#10;        try (Writer w = file.openWriter()) {&#10;            if (!pkg.isEmpty()) w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            w.write(&quot;public final class &quot; + name + &quot; {\n&quot;);&#10;            w.write(&quot;  private &quot; + name + &quot;(){}\n&quot;);&#10;            w.write(&quot;  public static void inject(Object system, com.ethnicthv.ecs.core.archetype.ArchetypeWorld world) {\n&quot;);&#10;            w.write(&quot;    &quot; + ownerQualified + &quot; self = (&quot; + ownerQualified + &quot;) system;\n&quot;);&#10;            for (ExecutableElement m : methods) {&#10;                AnnotationMirror q = BaseProcessor.getAnnotation(m, ANNO_QUERY);&#10;                String fieldInject = BaseProcessor.readString(q, &quot;fieldInject&quot;);&#10;                if (fieldInject == null || fieldInject.isEmpty()) {&#10;                    error(&quot;@Query on %s missing fieldInject&quot;, m);&#10;                    continue;&#10;                }&#10;                // Compile-time validation: ensure field exists and is typed as IGeneratedQuery&#10;                VariableElement targetField = null;&#10;                for (Element e : owner.getEnclosedElements()) {&#10;                    if (e.getKind() == ElementKind.FIELD &amp;&amp; e.getSimpleName().contentEquals(fieldInject)) {&#10;                        targetField = (VariableElement) e; break;&#10;                    }&#10;                }&#10;                if (targetField == null) {&#10;                    error(&quot;Field '%s' referenced by fieldInject on method %s not found in %s&quot;, fieldInject, m.getSimpleName(), owner.getQualifiedName());&#10;                    continue;&#10;                }&#10;                String fieldType = targetField.asType().toString();&#10;                String requiredType = &quot;com.ethnicthv.ecs.core.api.archetype.IGeneratedQuery&quot;;&#10;                if (!fieldType.equals(requiredType)) {&#10;                    error(&quot;Field '%s' must be of type %s (found %s) for @Query injection&quot;, fieldInject, requiredType, fieldType);&#10;                    continue;&#10;                }&#10;                String runner = simple + &quot;__&quot; + m.getSimpleName() + &quot;__QueryRunner&quot;;&#10;                w.write(&quot;    try {\n&quot;);&#10;                w.write(&quot;      java.lang.reflect.Field f = &quot; + ownerQualified + &quot;.class.getDeclaredField(\&quot;&quot; + fieldInject + &quot;\&quot;);\n&quot;);&#10;                w.write(&quot;      f.setAccessible(true);\n&quot;);&#10;                w.write(&quot;      if(!com.ethnicthv.ecs.core.api.archetype.IGeneratedQuery.class.isAssignableFrom(f.getType())) throw new IllegalStateException(\&quot;Field '&quot; + fieldInject + &quot;' must be assignable to IGeneratedQuery\&quot;);\n&quot;);&#10;                w.write(&quot;      f.set(self, new &quot; + runner + &quot;(world, self));\n&quot;);&#10;                w.write(&quot;    } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;            }&#10;            w.write(&quot;  }\n&quot;);&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Method analysis structures&#10;    // ---------------------------------------------------------------------&#10;    private static final class ParamAnalysis {&#10;        final List&lt;String&gt; componentClasses = new ArrayList&lt;&gt;();&#10;        final List&lt;String&gt; declaredTypes = new ArrayList&lt;&gt;();&#10;        final List&lt;Integer&gt; logicalToPhysical = new ArrayList&lt;&gt;();&#10;        final List&lt;String&gt; expectedHandleClasses = new ArrayList&lt;&gt;();&#10;        final List&lt;String&gt; directBinderNames = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Code generation: Runner per method&#10;    // ---------------------------------------------------------------------&#10;    private void generateRunner(TypeElement owner, ExecutableElement method) throws IOException {&#10;        String pkg = elementUtils.getPackageOf(owner).getQualifiedName().toString();&#10;        String simple = owner.getSimpleName().toString();&#10;        String ownerQualified = owner.getQualifiedName().toString();&#10;        String name = simple + &quot;__&quot; + method.getSimpleName() + &quot;__QueryRunner&quot;;&#10;        String fqn = pkg.isEmpty() ? name : pkg + &quot;.&quot; + name;&#10;        boolean isPrivate = method.getModifiers().contains(Modifier.PRIVATE);&#10;        String methodName = method.getSimpleName().toString();&#10;&#10;        // ID field detection&#10;        String idFieldName = findIdFieldName(owner);&#10;        boolean hasIdField = (idFieldName != null);&#10;&#10;        // ID parameter detection&#10;        int idParamIndex = findIdParamIndex(method);&#10;&#10;        // Parameter component / type analysis&#10;        ParamAnalysis pa = analyzeParameters(method, idParamIndex);&#10;&#10;        AnnotationMirror q = BaseProcessor.getAnnotation(method, ANNO_QUERY);&#10;        List&lt;String&gt; withClasses = BaseProcessor.readTypeArray(q, &quot;with&quot;);&#10;        List&lt;String&gt; withoutClasses = BaseProcessor.readTypeArray(q, &quot;without&quot;);&#10;        List&lt;String&gt; anyClasses = BaseProcessor.readTypeArray(q, &quot;any&quot;);&#10;        String modeConst = BaseProcessor.readEnumConst(q, &quot;mode&quot;);&#10;        boolean isParallel = &quot;PARALLEL&quot;.equals(modeConst);&#10;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn, owner);&#10;        try (Writer w = file.openWriter()) {&#10;            if (!pkg.isEmpty()) w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            w.write(&quot;public final class &quot; + name + &quot; implements com.ethnicthv.ecs.core.api.archetype.IQuery, com.ethnicthv.ecs.core.api.archetype.IQueryBuilder, com.ethnicthv.ecs.core.api.archetype.IGeneratedQuery {\n&quot;);&#10;            // Fields&#10;            w.write(&quot;  private final com.ethnicthv.ecs.core.archetype.ArchetypeWorld world;\n&quot;);&#10;            w.write(&quot;  private final &quot; + ownerQualified + &quot; system;\n&quot;);&#10;            if (isPrivate) w.write(&quot;  private final java.lang.invoke.MethodHandle invExact;\n&quot;);&#10;            w.write(&quot;  private Object __managedSharedFilter = null;\n&quot;);&#10;            w.write(&quot;  private java.util.List&lt;com.ethnicthv.ecs.core.archetype.ArchetypeQuery.UnmanagedFilter&gt; __unmanagedSharedFilters = null;\n&quot;);&#10;            w.write(&quot;  private static final boolean HAS_ID_FIELD = &quot; + (hasIdField ? &quot;true&quot; : &quot;false&quot;) + &quot;;\n&quot;);&#10;            w.write(&quot;  private final java.lang.reflect.Field ID_FIELD;\n&quot;);&#10;            w.write(&quot;  private static final boolean MODE_PARALLEL = &quot; + (isParallel ? &quot;true&quot; : &quot;false&quot;) + &quot;;\n&quot;);&#10;            // Param arrays&#10;            w.write(&quot;  private static final Class&lt;?&gt;[] PARAM_CLASSES = new Class&lt;?&gt;[]{&quot;);&#10;            for (int i = 0; i &lt; pa.componentClasses.size(); i++) w.write(pa.componentClasses.get(i) + &quot;.class&quot; + (i &lt; pa.componentClasses.size() - 1 ? &quot;, &quot; : &quot;&quot;));&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;  private static final Class&lt;?&gt;[] DECLARED_PARAM_TYPES = new Class&lt;?&gt;[]{&quot;);&#10;            for (int i = 0; i &lt; pa.declaredTypes.size(); i++) w.write(pa.declaredTypes.get(i) + &quot;.class&quot; + (i &lt; pa.declaredTypes.size() - 1 ? &quot;, &quot; : &quot;&quot;));&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;  private static final String[] HANDLE_CLASS_NAMES = new String[]{&quot;);&#10;            for (int i = 0; i &lt; pa.expectedHandleClasses.size(); i++) w.write(&quot;\&quot;&quot; + pa.expectedHandleClasses.get(i) + &quot;\&quot;&quot; + (i &lt; pa.expectedHandleClasses.size() - 1 ? &quot;, &quot; : &quot;&quot;));&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;  private static final int PARAM_COUNT = PARAM_CLASSES.length;\n&quot;);&#10;            // Filters arrays&#10;            writeClassArray(w, &quot;WITH_CLASSES&quot;, withClasses);&#10;            writeClassArray(w, &quot;WITHOUT_CLASSES&quot;, withoutClasses);&#10;            writeClassArray(w, &quot;ANY_CLASSES&quot;, anyClasses);&#10;            // IDs &amp; masks + strategy arrays&#10;            w.write(&quot;  private final int[] paramIds;\n&quot;);&#10;            w.write(&quot;  private final int[] withIds;\n&quot;);&#10;            w.write(&quot;  private final int[] withoutIds;\n&quot;);&#10;            w.write(&quot;  private final int[] anyIds;\n&quot;);&#10;            w.write(&quot;  private final com.ethnicthv.ecs.core.archetype.ComponentMask withMask;\n&quot;);&#10;            w.write(&quot;  private final com.ethnicthv.ecs.core.archetype.ComponentMask withoutMask;\n&quot;);&#10;            w.write(&quot;  private final com.ethnicthv.ecs.core.archetype.ComponentMask anyMask;\n&quot;);&#10;            w.write(&quot;  private final boolean[] PARAM_IS_MANAGED;\n&quot;);&#10;            w.write(&quot;  private final java.lang.invoke.MethodHandle[] BINDER_MH;\n&quot;);&#10;            w.write(&quot;  private final com.ethnicthv.ecs.core.components.ComponentDescriptor[] PARAM_DESCRIPTORS;\n&quot;);&#10;            w.write(&quot;  private static final boolean[] DIRECT_BIND = new boolean[]{&quot;);&#10;            for (int i = 0; i &lt; pa.directBinderNames.size(); i++) w.write((pa.directBinderNames.get(i) != null ? &quot;true&quot; : &quot;false&quot;) + (i &lt; pa.directBinderNames.size() - 1 ? &quot;, &quot; : &quot;&quot;));&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;  private static final String[] DIRECT_BIND_NAME = new String[]{&quot;);&#10;            for (int i = 0; i &lt; pa.directBinderNames.size(); i++) { String n = pa.directBinderNames.get(i); w.write(n == null ? &quot;null&quot; : (&quot;\&quot;&quot; + n + &quot;\&quot;&quot;)); if (i &lt; pa.directBinderNames.size() - 1) w.write(&quot;, &quot;); }&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;  private static final class ArchetypePlan { final int[] compIdx; final int[] managedIdx; ArchetypePlan(int[] a, int[] b){ this.compIdx=a; this.managedIdx=b; } }\n&quot;);&#10;            w.write(&quot;  private final java.util.concurrent.ConcurrentHashMap&lt;com.ethnicthv.ecs.core.archetype.Archetype, ArchetypePlan&gt; PLAN_CACHE = new java.util.concurrent.ConcurrentHashMap&lt;&gt;();\n&quot;);&#10;            w.write(&quot;  private enum ParamStrategy { MANAGED, UNMANAGED_RAW, UNMANAGED_TYPED }\n&quot;);&#10;            w.write(&quot;  private final ParamStrategy[] STRATEGY = new ParamStrategy[PARAM_COUNT];\n&quot;);&#10;            w.write(&quot;  private final java.lang.reflect.Constructor&lt;?&gt;[] TYPED_CTORS = new java.lang.reflect.Constructor&lt;?&gt;[PARAM_COUNT];\n&quot;);&#10;            w.write(&quot;  private final Object[] SEQ_TYPED = new Object[PARAM_COUNT];\n&quot;);&#10;            w.write(&quot;  private final ThreadLocal&lt;Object[]&gt; PAR_TYPED = ThreadLocal.withInitial(() -&gt; { Object[] a = new Object[PARAM_COUNT]; try { for (int i = 0; i &lt; PARAM_COUNT; i++) { if (STRATEGY[i] == ParamStrategy.UNMANAGED_TYPED) { a[i] = TYPED_CTORS[i].newInstance(); } } } catch (Throwable t) { throw new RuntimeException(t); } return a; });\n&quot;);&#10;            // Constructor&#10;            w.write(&quot;  public &quot; + name + &quot;(com.ethnicthv.ecs.core.archetype.ArchetypeWorld w, &quot; + ownerQualified + &quot; s){\n&quot;);&#10;            if (isPrivate) w.write(&quot;    this.world=w; this.system=s; this.invExact = createMH();\n&quot;); else w.write(&quot;    this.world=w; this.system=s;\n&quot;);&#10;            if (hasIdField) {&#10;                w.write(&quot;    try { java.lang.reflect.Field __idf = &quot; + ownerQualified + &quot;.class.getDeclaredField(\&quot;&quot; + idFieldName + &quot;\&quot;); __idf.setAccessible(true); this.ID_FIELD = __idf; } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;            } else w.write(&quot;    this.ID_FIELD = null;\n&quot;);&#10;            w.write(&quot;    this.paramIds = new int[PARAM_COUNT]; for (int i = 0; i &lt; PARAM_COUNT; i++) { Integer id = w.getComponentTypeId(PARAM_CLASSES[i]); if (id == null) throw new IllegalStateException(\&quot;Component not registered: \&quot; + PARAM_CLASSES[i]); this.paramIds[i] = id; }\n&quot;);&#10;            w.write(&quot;    java.util.ArrayList&lt;Integer&gt; wl = new java.util.ArrayList&lt;&gt;(); for (Class&lt;?&gt; c : WITH_CLASSES) { Integer id = w.getComponentTypeId(c); if (id != null) wl.add(id); } this.withIds = wl.stream().mapToInt(Integer::intValue).toArray();\n&quot;);&#10;            w.write(&quot;    java.util.ArrayList&lt;Integer&gt; wtl = new java.util.ArrayList&lt;&gt;(); for (Class&lt;?&gt; c : WITHOUT_CLASSES) { Integer id = w.getComponentTypeId(c); if (id != null) wtl.add(id); } this.withoutIds = wtl.stream().mapToInt(Integer::intValue).toArray();\n&quot;);&#10;            w.write(&quot;    java.util.ArrayList&lt;Integer&gt; al = new java.util.ArrayList&lt;&gt;(); for (Class&lt;?&gt; c : ANY_CLASSES) { Integer id = w.getComponentTypeId(c); if (id != null) al.add(id); } this.anyIds = al.stream().mapToInt(Integer::intValue).toArray();\n&quot;);&#10;            w.write(&quot;    com.ethnicthv.ecs.core.archetype.ComponentMask.Builder wb = com.ethnicthv.ecs.core.archetype.ComponentMask.builder(); for (int id : this.withIds) wb.with(id); for (int id : this.paramIds) wb.with(id); this.withMask = wb.build();\n&quot;);&#10;            w.write(&quot;    com.ethnicthv.ecs.core.archetype.ComponentMask.Builder woutb = com.ethnicthv.ecs.core.archetype.ComponentMask.builder(); for (int id : this.withoutIds) woutb.with(id); this.withoutMask = woutb.build();\n&quot;);&#10;            w.write(&quot;    com.ethnicthv.ecs.core.archetype.ComponentMask.Builder ab = com.ethnicthv.ecs.core.archetype.ComponentMask.builder(); for (int id : this.anyIds) ab.with(id); this.anyMask = ab.build();\n&quot;);&#10;            w.write(&quot;    this.PARAM_IS_MANAGED = new boolean[PARAM_COUNT]; this.BINDER_MH = new java.lang.invoke.MethodHandle[PARAM_COUNT]; this.PARAM_DESCRIPTORS = new com.ethnicthv.ecs.core.components.ComponentDescriptor[PARAM_COUNT];\n&quot;);&#10;            w.write(&quot;    final var __cmgr = w.getComponentManager(); final var __lookup = java.lang.invoke.MethodHandles.lookup();\n&quot;);&#10;            w.write(buildParamStrategyBlock());&#10;            w.write(&quot;    try { for (int i = 0; i &lt; PARAM_COUNT; i++) { if (STRATEGY[i] == ParamStrategy.UNMANAGED_TYPED) { TYPED_CTORS[i] = DECLARED_PARAM_TYPES[i].getDeclaredConstructor(); TYPED_CTORS[i].setAccessible(true); SEQ_TYPED[i] = TYPED_CTORS[i].newInstance(); } } } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;            // Defer config validation to run-time so system registration doesn't fail eagerly&#10;            // w.write(&quot;    validateConfig();\n&quot;);&#10;            w.write(&quot;  }\n&quot;);&#10;&#10;            if (isPrivate) w.write(buildPrivateMethodHandleCreator(ownerQualified, methodName, method.getParameters()));&#10;&#10;            w.write(buildValidateConfigBlock());&#10;            w.write(buildPlanBuilderBlock());&#10;&#10;            // IQueryBuilder implementations&#10;            w.write(&quot;  @Override public com.ethnicthv.ecs.core.api.archetype.IQueryBuilder withShared(Object managedValue) { this.__managedSharedFilter = managedValue; return this; }\n&quot;);&#10;            w.write(&quot;  @Override public com.ethnicthv.ecs.core.api.archetype.IQueryBuilder withShared(Class&lt;?&gt; unmanagedSharedType, long value) { if (this.__unmanagedSharedFilters == null) this.__unmanagedSharedFilters = new java.util.ArrayList&lt;&gt;(); this.__unmanagedSharedFilters.add(new com.ethnicthv.ecs.core.archetype.ArchetypeQuery.UnmanagedFilter(unmanagedSharedType, value)); return this; }\n&quot;);&#10;            w.write(&quot;  @Override public &lt;T&gt; com.ethnicthv.ecs.core.api.archetype.IQueryBuilder with(Class&lt;T&gt; c) { return this; }\n&quot;);&#10;            w.write(&quot;  @Override public &lt;T&gt; com.ethnicthv.ecs.core.api.archetype.IQueryBuilder without(Class&lt;T&gt; c) { return this; }\n&quot;);&#10;            w.write(&quot;  @Override public com.ethnicthv.ecs.core.api.archetype.IQueryBuilder any(Class&lt;?&gt;... cs) { return this; }\n&quot;);&#10;            w.write(&quot;  @Override public com.ethnicthv.ecs.core.api.archetype.IQuery build() { return this; }\n&quot;);&#10;&#10;            // Shared value key builder&#10;            w.write(buildSharedKeyBuilderBlock());&#10;&#10;            // Binding/prep/call sequences&#10;            String bindsSeq = buildBindSequence(pa.declaredTypes, pa.directBinderNames);&#10;            String prepSeq = buildPrepSequence(pa.declaredTypes, &quot;entityId&quot;);&#10;            String prepPar = buildPrepSequence(pa.declaredTypes, &quot;eid&quot;);&#10;            String callSeq = buildCallSequence(isPrivate, method, idParamIndex, pa.logicalToPhysical, &quot;entityId&quot;);&#10;            String callPar = buildCallSequence(isPrivate, method, idParamIndex, pa.logicalToPhysical, &quot;eid&quot;);&#10;&#10;            // Chunk runners&#10;            w.write(buildSequentialChunkRunner(hasIdField, bindsSeq, prepSeq, callSeq));&#10;            w.write(buildParallelChunkRunner(bindsSeq, prepPar, callPar));&#10;            // Group runners&#10;            w.write(&quot;  private void runOnGroup_Sequential(com.ethnicthv.ecs.core.archetype.ChunkGroup group, ArchetypePlan plan, com.ethnicthv.ecs.core.components.ComponentManager cm){ com.ethnicthv.ecs.core.archetype.ArchetypeChunk[] chunks = group.getChunksSnapshot(); int count = group.chunkCount(); for (int i = 0; i &lt; count; i++) runOnChunk_Sequential(chunks[i], plan, cm); }\n&quot;);&#10;            w.write(&quot;  private void runOnGroup_Parallel(com.ethnicthv.ecs.core.archetype.ChunkGroup group, ArchetypePlan plan, com.ethnicthv.ecs.core.components.ComponentManager cm){ com.ethnicthv.ecs.core.archetype.ArchetypeChunk[] chunks = group.getChunksSnapshot(); int count = group.chunkCount(); java.util.Arrays.stream(chunks, 0, count).parallel().forEach(chunk -&gt; runOnChunk_Parallel(chunk, plan, cm)); }\n&quot;);&#10;            // Drivers&#10;            w.write(&quot;  @Override public void runQuery(){ validateConfig(); if (MODE_PARALLEL) runParallel(); else runSequential(); this.__managedSharedFilter = null; if (this.__unmanagedSharedFilters != null) this.__unmanagedSharedFilters.clear(); }\n&quot;);&#10;            w.write(buildRunSequentialBlock());&#10;            w.write(buildRunParallelBlock());&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Analysis helpers&#10;    // ---------------------------------------------------------------------&#10;    private String findIdFieldName(TypeElement owner) {&#10;        String idFieldName = null;&#10;        for (Element e : owner.getEnclosedElements()) {&#10;            if (e.getKind() != ElementKind.FIELD) continue;&#10;            if (BaseProcessor.hasAnnotation(e, ANNO_ID)) {&#10;                if (idFieldName != null) { error(&quot;Only one @Id field is allowed per @Query method owner %s&quot;, owner.getQualifiedName()); break; }&#10;                String ft = e.asType().toString();&#10;                if (!&quot;int&quot;.equals(ft)) { error(&quot;@Id field must be of type int: %s.%s&quot;, owner.getQualifiedName(), e.getSimpleName()); break; }&#10;                idFieldName = e.getSimpleName().toString();&#10;            }&#10;        }&#10;        return idFieldName;&#10;    }&#10;&#10;    private int findIdParamIndex(ExecutableElement method) {&#10;        int idParamIndex = -1;&#10;        List&lt;? extends VariableElement&gt; methodParams = method.getParameters();&#10;        for (int i = 0; i &lt; methodParams.size(); i++) {&#10;            VariableElement p = methodParams.get(i);&#10;            if (BaseProcessor.getAnnotation(p, ANNO_ID) != null) {&#10;                if (idParamIndex != -1) { error(&quot;Only one @Id parameter is allowed on method %s&quot;, method); break; }&#10;                String dt = p.asType().toString();&#10;                if (!&quot;int&quot;.equals(dt) &amp;&amp; !&quot;java.lang.Integer&quot;.equals(dt)) { error(&quot;@Id parameter must be int or java.lang.Integer on method %s&quot;, method); break; }&#10;                idParamIndex = i;&#10;            }&#10;        }&#10;        return idParamIndex;&#10;    }&#10;&#10;    private ParamAnalysis analyzeParameters(ExecutableElement method, int idParamIndex) {&#10;        ParamAnalysis pa = new ParamAnalysis();&#10;        List&lt;? extends VariableElement&gt; params = method.getParameters();&#10;        for (int phys = 0; phys &lt; params.size(); phys++) {&#10;            if (phys == idParamIndex) continue;&#10;            VariableElement p = params.get(phys);&#10;            AnnotationMirror compAnno = BaseProcessor.getAnnotation(p, ANNO_COMPONENT);&#10;            String declaredType = p.asType().toString();&#10;            String compTypeFqn;&#10;            if (compAnno != null) {&#10;                compTypeFqn = BaseProcessor.readTypeClass(compAnno, &quot;type&quot;);&#10;                if (compTypeFqn == null || compTypeFqn.isEmpty()) { error(&quot;@Component on %s must specify type()&quot;, p); continue; }&#10;            } else {&#10;                if (&quot;com.ethnicthv.ecs.core.components.ComponentHandle&quot;.equals(declaredType)) { error(&quot;Parameter %s must be annotated with @Component(type=...) to specify component type&quot;, p); continue; }&#10;                if (declaredType.endsWith(&quot;Handle&quot;)) {&#10;                    String base = declaredType.substring(0, declaredType.length() - &quot;Handle&quot;.length());&#10;                    compTypeFqn = (elementUtils.getTypeElement(base) != null) ? base : declaredType;&#10;                } else compTypeFqn = declaredType;&#10;            }&#10;            pa.componentClasses.add(compTypeFqn);&#10;            pa.declaredTypes.add(declaredType);&#10;            pa.logicalToPhysical.add(phys);&#10;            int lastDot = compTypeFqn.lastIndexOf('.');&#10;            String compPkg = (lastDot &gt;= 0) ? compTypeFqn.substring(0, lastDot) : &quot;&quot;;&#10;            String compSimple = (lastDot &gt;= 0) ? compTypeFqn.substring(lastDot + 1) : compTypeFqn;&#10;            String handleFqn = (compPkg.isEmpty() ? compSimple + &quot;Handle&quot; : compPkg + &quot;.&quot; + compSimple + &quot;Handle&quot;);&#10;            pa.expectedHandleClasses.add(handleFqn);&#10;            String binderName = null;&#10;            if (!&quot;com.ethnicthv.ecs.core.components.ComponentHandle&quot;.equals(declaredType)) {&#10;                TypeElement declEl = elementUtils.getTypeElement(declaredType);&#10;                if (declEl != null) binderName = findPublicBinderMethodName(declEl);&#10;            }&#10;            pa.directBinderNames.add(binderName);&#10;        }&#10;        return pa;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Generation block builders (return code strings)&#10;    // ---------------------------------------------------------------------&#10;    private String buildParamStrategyBlock() {&#10;        return &quot;&quot;&quot;&#10;                for (int i = 0; i &lt; PARAM_COUNT; i++) {&#10;                  var __desc = __cmgr.getDescriptor(PARAM_CLASSES[i]);&#10;                  if (__desc == null) throw new IllegalStateException(&quot;Descriptor not found for component: &quot; + PARAM_CLASSES[i].getName());&#10;                  this.PARAM_IS_MANAGED[i] = __desc.isManaged();&#10;                  this.PARAM_DESCRIPTORS[i] = __desc;&#10;                  boolean declaredIsRawHandle = (DECLARED_PARAM_TYPES[i] == com.ethnicthv.ecs.core.components.ComponentHandle.class);&#10;                  boolean declaredIsGeneratedHandle = DECLARED_PARAM_TYPES[i].getName().equals(HANDLE_CLASS_NAMES[i]);&#10;                  boolean declaredEqualsComponentClass = (DECLARED_PARAM_TYPES[i] == PARAM_CLASSES[i]);&#10;                  if (this.PARAM_IS_MANAGED[i]) {&#10;                    this.STRATEGY[i] = ParamStrategy.MANAGED;&#10;                  } else {&#10;                    if (declaredIsRawHandle) {&#10;                      this.STRATEGY[i] = ParamStrategy.UNMANAGED_RAW;&#10;                    } else if (declaredIsGeneratedHandle || DIRECT_BIND[i]) {&#10;                      this.STRATEGY[i] = ParamStrategy.UNMANAGED_TYPED;&#10;                    } else if (declaredEqualsComponentClass) {&#10;                      // User mistakenly declared managed object for an unmanaged component; defer error to validateConfig()&#10;                      this.STRATEGY[i] = ParamStrategy.MANAGED;&#10;                    } else {&#10;                      throw new IllegalStateException(&quot;Parameter type &quot; + DECLARED_PARAM_TYPES[i].getName() + &quot; is invalid for unmanaged component &quot; + PARAM_CLASSES[i].getName() + &quot;. Use ComponentHandle or the generated Handle class.&quot;);&#10;                    }&#10;                  }&#10;                  if (!this.PARAM_IS_MANAGED[i] &amp;&amp; this.STRATEGY[i] == ParamStrategy.UNMANAGED_TYPED &amp;&amp; !DIRECT_BIND[i]) {&#10;                    try {&#10;                      var __prv = java.lang.invoke.MethodHandles.privateLookupIn(DECLARED_PARAM_TYPES[i], __lookup);&#10;                      java.lang.invoke.MethodHandle __bh = null;&#10;                      try { __bh = __prv.findVirtual(DECLARED_PARAM_TYPES[i], &quot;__bind&quot;, java.lang.invoke.MethodType.methodType(void.class, com.ethnicthv.ecs.core.components.ComponentHandle.class)); } catch (Throwable ignore) {}&#10;                      if (__bh == null) { try { __bh = __prv.findVirtual(DECLARED_PARAM_TYPES[i], &quot;bind&quot;, java.lang.invoke.MethodType.methodType(void.class, com.ethnicthv.ecs.core.components.ComponentHandle.class)); } catch (Throwable ignore) {} }&#10;                      if (__bh == null) { try { __bh = __prv.findVirtual(DECLARED_PARAM_TYPES[i], &quot;reset&quot;, java.lang.invoke.MethodType.methodType(void.class, com.ethnicthv.ecs.core.components.ComponentHandle.class)); } catch (Throwable ignore) {} }&#10;                      if (__bh == null) throw new IllegalStateException(&quot;Typed handle class &quot; + DECLARED_PARAM_TYPES[i].getName() + &quot; must declare __bind/ bind/ or reset method with (ComponentHandle)&quot;);&#10;                      this.BINDER_MH[i] = __bh;&#10;                    } catch (Throwable t) {&#10;                      throw new IllegalStateException(&quot;Failed to prepare typed handle for parameter &quot; + i + &quot; of type &quot; + DECLARED_PARAM_TYPES[i].getName(), t);&#10;                    }&#10;                  }&#10;                }&#10;&#10;                &quot;&quot;&quot;;&#10;    }&#10;&#10;    private String buildPrivateMethodHandleCreator(String ownerQualified, String methodName, List&lt;? extends VariableElement&gt; params) {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;  private java.lang.invoke.MethodHandle createMH(){ try { var lookup = java.lang.invoke.MethodHandles.lookup(); var prv = java.lang.invoke.MethodHandles.privateLookupIn(&quot;)&#10;          .append(ownerQualified).append(&quot;.class, lookup); var mt = java.lang.invoke.MethodType.methodType(void.class&quot;);&#10;        for (VariableElement p : params) {&#10;            String t = p.asType().toString();&#10;            sb.append(&quot;, &quot;).append(&quot;int&quot;.equals(t) ? &quot;int.class&quot; : t + &quot;.class&quot;);&#10;        }&#10;        sb.append(&quot;); return prv.findVirtual(&quot;).append(ownerQualified).append(&quot;.class, \&quot;&quot;)&#10;          .append(methodName).append(&quot;\&quot;, mt); } catch (Throwable t) { throw new RuntimeException(t); } }\n&quot;);&#10;        return sb.toString();&#10;    }&#10;&#10;    private String buildValidateConfigBlock() {&#10;        return &quot;&quot;&quot;&#10;  private void validateConfig(){&#10;    for (int i = 0; i &lt; paramIds.length; i++) {&#10;      boolean isManaged = PARAM_IS_MANAGED[i];&#10;      if (isManaged) {&#10;        if (DECLARED_PARAM_TYPES[i] != PARAM_CLASSES[i]) {&#10;          throw new IllegalStateException(&quot;Parameter type mismatch: component &quot; + PARAM_CLASSES[i].getName() + &quot; is @Managed, method parameter must be that component type&quot;);&#10;        }&#10;      } else {&#10;        if (DECLARED_PARAM_TYPES[i] == PARAM_CLASSES[i]) {&#10;          throw new IllegalStateException(&quot;Parameter &quot; + i + &quot; declared as managed object (&quot; + PARAM_CLASSES[i].getName() + &quot;) but component is unmanaged. Use ComponentHandle or the generated Handle class.&quot;);&#10;        }&#10;      }&#10;    }&#10;    if (HAS_ID_FIELD &amp;&amp; MODE_PARALLEL) {&#10;      throw new IllegalStateException(&quot;@Id field is not supported with PARALLEL Query mode; use SEQUENTIAL.&quot;);&#10;    }&#10;  }&#10;&quot;&quot;&quot;;&#10;    }&#10;&#10;    private String buildPlanBuilderBlock() {&#10;        return &quot;  private ArchetypePlan buildPlan(com.ethnicthv.ecs.core.archetype.Archetype archetype){ final int[] compIdx = new int[PARAM_COUNT]; final int[] managedIdx = new int[PARAM_COUNT]; boolean ok = true; for (int i = 0; i &lt; PARAM_COUNT; i++) { int tid = paramIds[i]; if (!PARAM_IS_MANAGED[i]) { compIdx[i] = archetype.indexOfComponentType(tid); if (compIdx[i] &lt; 0) { ok=false; break; } managedIdx[i] = -1; } else { managedIdx[i] = archetype.getManagedTypeIndex(tid); if (managedIdx[i] &lt; 0) { ok=false; break; } compIdx[i] = -1; } } return ok ? new ArchetypePlan(compIdx, managedIdx) : null; }\n&quot;;&#10;    }&#10;&#10;    private String buildSharedKeyBuilderBlock() {&#10;        return &quot;  private com.ethnicthv.ecs.core.archetype.SharedValueKey buildQueryKey(com.ethnicthv.ecs.core.archetype.Archetype archetype){ int[] managedIdx = null; long[] unmanagedVals = null; boolean any=false; if (this.__managedSharedFilter != null) { int ticket = world.findSharedIndex(this.__managedSharedFilter); if (ticket &lt; 0) return null; int managedCount = archetype.getSharedManagedTypeIds().length; if (managedCount == 0) return null; managedIdx = new int[managedCount]; java.util.Arrays.fill(managedIdx, -1); for (int typeId : archetype.getSharedManagedTypeIds()) { int pos = archetype.getSharedManagedIndex(typeId); if (pos &gt;= 0) { managedIdx[pos] = ticket; any = true; } } } if (this.__unmanagedSharedFilters != null &amp;&amp; !this.__unmanagedSharedFilters.isEmpty()) { int unmanagedCount = archetype.getSharedUnmanagedTypeIds().length; if (unmanagedCount == 0) return null; unmanagedVals = new long[unmanagedCount]; java.util.Arrays.fill(unmanagedVals, Long.MIN_VALUE); for (var f : this.__unmanagedSharedFilters) { Integer typeId = world.getComponentTypeId(f.type); if (typeId == null) return null; int pos = archetype.getSharedUnmanagedIndex(typeId); if (pos &lt; 0) return null; unmanagedVals[pos] = f.value; any = true; } } if (!any) return null; return new com.ethnicthv.ecs.core.archetype.SharedValueKey(managedIdx, unmanagedVals); }\n&quot;;&#10;    }&#10;&#10;    private String buildBindSequence(List&lt;String&gt; declaredTypes, List&lt;String&gt; directBinderNames) {&#10;        StringBuilder sb = new StringBuilder();&#10;        for (int i = 0; i &lt; declaredTypes.size(); i++) {&#10;            String decl = declaredTypes.get(i);&#10;            String direct = directBinderNames.get(i);&#10;            sb.append(&quot;            if (STRATEGY[&quot;).append(i).append(&quot;] == ParamStrategy.UNMANAGED_TYPED) { &quot;);&#10;            if (direct != null) {&#10;                sb.append(&quot;((&quot;).append(decl).append(&quot;) typed[&quot;).append(i).append(&quot;]).&quot;).append(direct).append(&quot;((com.ethnicthv.ecs.core.components.ComponentHandle) pooled[&quot;).append(i).append(&quot;]);\n&quot;);&#10;            } else {&#10;                sb.append(&quot;try { BINDER_MH[&quot;).append(i).append(&quot;]\n&quot;)&#10;                  .append(&quot;.invoke(typed[&quot;).append(i).append(&quot;], pooled[&quot;).append(i).append(&quot;]); } catch (Throwable __t) { throw new RuntimeException(__t); }\n&quot;);&#10;            }&#10;            sb.append(&quot;            }\n&quot;);&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    private String buildPrepSequence(List&lt;String&gt; declaredTypes, String entityVar) {&#10;        StringBuilder sb = new StringBuilder();&#10;        for (int i = 0; i &lt; declaredTypes.size(); i++) {&#10;            String dt = declaredTypes.get(i);&#10;            sb.append(&quot;            final Object __argObj_&quot;).append(i).append(&quot; = (STRATEGY[&quot;).append(i)&#10;              .append(&quot;] == ParamStrategy.MANAGED) ? world.getManagedComponent(&quot;).append(entityVar).append(&quot;, PARAM_CLASSES[&quot;).append(i)&#10;              .append(&quot;]) : (STRATEGY[&quot;).append(i).append(&quot;] == ParamStrategy.UNMANAGED_RAW) ? pooled[&quot;).append(i).append(&quot;] : typed[&quot;).append(i).append(&quot;];\n&quot;)&#10;              .append(&quot;            final &quot;).append(dt).append(&quot; a&quot;).append(i).append(&quot; = (&quot;).append(dt).append(&quot;) __argObj_&quot;).append(i).append(&quot;;\n&quot;);&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    private String buildCallSequence(boolean isPrivate, ExecutableElement method, int idParamIndex, List&lt;Integer&gt; logicalToPhysical, String entityVar) {&#10;        StringBuilder sb = new StringBuilder();&#10;        List&lt;? extends VariableElement&gt; params = method.getParameters();&#10;        if (isPrivate) {&#10;            sb.append(&quot;            try { invExact.invokeExact(system&quot;);&#10;            for (int i = 0; i &lt; params.size(); i++) {&#10;                String t = params.get(i).asType().toString();&#10;                if (i == idParamIndex) {&#10;                    sb.append(&quot;, &quot;).append(&quot;int&quot;.equals(t) ? entityVar : &quot;java.lang.Integer.valueOf(&quot; + entityVar + &quot;)&quot;);&#10;                } else {&#10;                    int li = -1; for (int k = 0; k &lt; logicalToPhysical.size(); k++) { if (logicalToPhysical.get(k) == i) { li = k; break; } }&#10;                    sb.append(&quot;, a&quot;).append(li);&#10;                }&#10;            }&#10;            sb.append(&quot;); } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;        } else {&#10;            sb.append(&quot;            system.&quot;).append(method.getSimpleName()).append(&quot;(&quot;);&#10;            for (int i = 0; i &lt; params.size(); i++) {&#10;                if (i &gt; 0) sb.append(&quot;, &quot;);&#10;                String t = params.get(i).asType().toString();&#10;                if (i == idParamIndex) sb.append(&quot;int&quot;.equals(t) ? entityVar : &quot;java.lang.Integer.valueOf(&quot; + entityVar + &quot;)&quot;);&#10;                else { int li = -1; for (int k = 0; k &lt; logicalToPhysical.size(); k++) { if (logicalToPhysical.get(k) == i) { li = k; break; } } sb.append(&quot;a&quot;).append(li); }&#10;            }&#10;            sb.append(&quot;);\n&quot;);&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    private String buildSequentialChunkRunner(boolean hasIdField, String bindsSeq, String prepSeq, String callSeq) {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;  private void runOnChunk_Sequential(com.ethnicthv.ecs.core.archetype.ArchetypeChunk chunk, ArchetypePlan plan, com.ethnicthv.ecs.core.components.ComponentManager cm){ final com.ethnicthv.ecs.core.components.ComponentHandle[] pooled = new com.ethnicthv.ecs.core.components.ComponentHandle[PARAM_COUNT]; for (int i = 0; i &lt; PARAM_COUNT; i++) { if (!PARAM_IS_MANAGED[i]) pooled[i] = cm.acquireHandle(); } final Object[] typed = SEQ_TYPED; try { int idx = chunk.nextOccupiedIndex(0); while (idx &gt;= 0) { int entityId = chunk.getEntityId(idx);\n&quot;);&#10;        if (hasIdField) sb.append(&quot;            try { ID_FIELD.setInt(system, entityId); } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;        sb.append(&quot;            for (int k = 0; k &lt; PARAM_COUNT; k++) { if (STRATEGY[k] != ParamStrategy.MANAGED) { var seg = chunk.getComponentData(plan.compIdx[k], idx); pooled[k].reset(seg, PARAM_DESCRIPTORS[k]); } }\n&quot;);&#10;        sb.append(bindsSeq);&#10;        sb.append(prepSeq);&#10;        sb.append(callSeq);&#10;        sb.append(&quot;            idx = chunk.nextOccupiedIndex(idx + 1); } } finally { for (int i = 0; i &lt; PARAM_COUNT; i++) { if (pooled[i] != null) cm.releaseHandle(pooled[i]); } } }\n&quot;);&#10;        return sb.toString();&#10;    }&#10;&#10;    private String buildParallelChunkRunner(String bindsSeq, String prepPar, String callPar) {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;  private void runOnChunk_Parallel(com.ethnicthv.ecs.core.archetype.ArchetypeChunk chunk, ArchetypePlan plan, com.ethnicthv.ecs.core.components.ComponentManager cm){ final com.ethnicthv.ecs.core.components.ComponentHandle[] pooled = new com.ethnicthv.ecs.core.components.ComponentHandle[PARAM_COUNT]; for (int i = 0; i &lt; PARAM_COUNT; i++) { if (!PARAM_IS_MANAGED[i]) pooled[i] = cm.acquireHandle(); } final Object[] typed = PAR_TYPED.get(); try { int idx = chunk.nextOccupiedIndex(0); while (idx &gt;= 0) { int eid = chunk.getEntityId(idx); for (int k = 0; k &lt; PARAM_COUNT; k++) { if (STRATEGY[k] != ParamStrategy.MANAGED) { var seg = chunk.getComponentData(plan.compIdx[k], idx); pooled[k].reset(seg, PARAM_DESCRIPTORS[k]); } }\n&quot;);&#10;        sb.append(bindsSeq);&#10;        sb.append(prepPar);&#10;        sb.append(callPar);&#10;        sb.append(&quot;            idx = chunk.nextOccupiedIndex(idx + 1); } } finally { for (int i = 0; i &lt; PARAM_COUNT; i++) { if (pooled[i] != null) cm.releaseHandle(pooled[i]); } } }\n&quot;);&#10;        return sb.toString();&#10;    }&#10;&#10;    private String buildRunSequentialBlock() {&#10;        return &quot;  private void runSequential(){ final var cm = world.getComponentManager(); final boolean hasFilter = (this.__managedSharedFilter != null || (this.__unmanagedSharedFilters != null &amp;&amp; !this.__unmanagedSharedFilters.isEmpty())); for (com.ethnicthv.ecs.core.archetype.Archetype archetype : world.getAllArchetypes()) { com.ethnicthv.ecs.core.archetype.ComponentMask am = archetype.getMask(); if (!am.containsAll(withMask)) continue; if (!am.containsNone(withoutMask)) continue; if (anyIds.length &gt; 0 &amp;&amp; !am.intersects(anyMask)) continue; ArchetypePlan plan = PLAN_CACHE.computeIfAbsent(archetype, a -&gt; buildPlan(a)); if (plan == null) continue; if (hasFilter) { com.ethnicthv.ecs.core.archetype.SharedValueKey qk = buildQueryKey(archetype); if (qk == null) continue; com.ethnicthv.ecs.core.archetype.ChunkGroup g = archetype.getChunkGroup(qk); if (g == null) continue; runOnGroup_Sequential(g, plan, cm); } else { for (com.ethnicthv.ecs.core.archetype.ChunkGroup g : archetype.getAllChunkGroups()) runOnGroup_Sequential(g, plan, cm); } } }\n&quot;;&#10;    }&#10;&#10;    private String buildRunParallelBlock() {&#10;        return &quot;  private void runParallel(){ final var cm = world.getComponentManager(); final boolean hasFilter = (this.__managedSharedFilter != null || (this.__unmanagedSharedFilters != null &amp;&amp; !this.__unmanagedSharedFilters.isEmpty())); java.util.List&lt;Runnable&gt; tasks = new java.util.ArrayList&lt;&gt;(); for (com.ethnicthv.ecs.core.archetype.Archetype archetype : world.getAllArchetypes()) { com.ethnicthv.ecs.core.archetype.ComponentMask am = archetype.getMask(); if (!am.containsAll(withMask)) continue; if (!am.containsNone(withoutMask)) continue; if (anyIds.length &gt; 0 &amp;&amp; !am.intersects(anyMask)) continue; ArchetypePlan plan = PLAN_CACHE.computeIfAbsent(archetype, a -&gt; buildPlan(a)); if (plan == null) continue; if (hasFilter) { com.ethnicthv.ecs.core.archetype.SharedValueKey qk = buildQueryKey(archetype); if (qk == null) continue; com.ethnicthv.ecs.core.archetype.ChunkGroup g = archetype.getChunkGroup(qk); if (g == null) continue; com.ethnicthv.ecs.core.archetype.ArchetypeChunk[] chunks = g.getChunksSnapshot(); int count = g.chunkCount(); for (int i = 0; i &lt; count; i++) { final com.ethnicthv.ecs.core.archetype.ArchetypeChunk c = chunks[i]; final ArchetypePlan p = plan; tasks.add(() -&gt; runOnChunk_Parallel(c, p, cm)); } } else { for (com.ethnicthv.ecs.core.archetype.ChunkGroup g : archetype.getAllChunkGroups()) { com.ethnicthv.ecs.core.archetype.ArchetypeChunk[] chunks = g.getChunksSnapshot(); int count = g.chunkCount(); for (int i = 0; i &lt; count; i++) { final com.ethnicthv.ecs.core.archetype.ArchetypeChunk c = chunks[i]; final ArchetypePlan p = plan; tasks.add(() -&gt; runOnChunk_Parallel(c, p, cm)); } } } } tasks.parallelStream().forEach(Runnable::run); }\n&quot;;&#10;    }&#10;&#10;    private void writeClassArray(Writer w, String label, List&lt;String&gt; classes) throws IOException {&#10;        w.write(&quot;  private static final Class&lt;?&gt;[] &quot; + label + &quot; = new Class&lt;?&gt;[]{&quot;);&#10;        for (int i = 0; i &lt; classes.size(); i++) w.write(classes.get(i) + &quot;.class&quot; + (i &lt; classes.size() - 1 ? &quot;,&quot; : &quot;&quot;));&#10;        w.write(&quot;};\n&quot;);&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Low-level utilities&#10;    // ---------------------------------------------------------------------&#10;    private String findPublicBinderMethodName(TypeElement typeEl) {&#10;        for (Element e : typeEl.getEnclosedElements()) {&#10;            if (e.getKind() == ElementKind.METHOD) {&#10;                ExecutableElement m = (ExecutableElement) e;&#10;                String n = m.getSimpleName().toString();&#10;                if (!n.equals(&quot;__bind&quot;) &amp;&amp; !n.equals(&quot;bind&quot;) &amp;&amp; !n.equals(&quot;reset&quot;)) continue;&#10;                if (!m.getModifiers().contains(Modifier.PUBLIC)) continue;&#10;                List&lt;? extends VariableElement&gt; params = m.getParameters();&#10;                if (params.size() != 1) continue;&#10;                String p0 = params.getFirst().asType().toString();&#10;                if (&quot;com.ethnicthv.ecs.core.components.ComponentHandle&quot;.equals(p0)) return n;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.processor;&#10;&#10;import javax.annotation.processing.*;&#10;import javax.lang.model.SourceVersion;&#10;import javax.lang.model.element.*;&#10;import javax.lang.model.util.Elements;&#10;import javax.tools.Diagnostic;&#10;import javax.tools.JavaFileObject;&#10;import java.io.IOException;&#10;import java.io.Writer;&#10;import java.util.*;&#10;&#10;@SupportedAnnotationTypes({&#10;    &quot;com.ethnicthv.ecs.core.system.annotation.Query&quot;&#10;})&#10;@SupportedSourceVersion(SourceVersion.RELEASE_25)&#10;public class QueryProcessor extends BaseProcessor {&#10;    // ---------------------------------------------------------------------&#10;    // Constants&#10;    // ---------------------------------------------------------------------&#10;    private static final String ANNO_QUERY = &quot;com.ethnicthv.ecs.core.system.annotation.Query&quot;;&#10;    private static final String ANNO_ID = &quot;com.ethnicthv.ecs.core.system.annotation.Id&quot;;&#10;    private static final String ANNO_COMPONENT = &quot;com.ethnicthv.ecs.core.system.annotation.Component&quot;;&#10;&#10;    private Elements elementUtils;&#10;&#10;    @Override&#10;    public synchronized void init(ProcessingEnvironment processingEnv) {&#10;        super.init(processingEnv);&#10;        this.elementUtils = processingEnv.getElementUtils();&#10;        note(&quot;QueryProcessor init&quot;);&#10;    }&#10;&#10;    @Override&#10;    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {&#10;        TypeElement queryAnno = elementUtils.getTypeElement(ANNO_QUERY);&#10;        if (queryAnno == null) return false;&#10;&#10;        Map&lt;TypeElement, List&lt;ExecutableElement&gt;&gt; byClass = new LinkedHashMap&lt;&gt;();&#10;        for (Element e : roundEnv.getElementsAnnotatedWith(queryAnno)) {&#10;            if (e.getKind() != ElementKind.METHOD) {&#10;                error(&quot;@Query can only be placed on methods: %s&quot;, e);&#10;                continue;&#10;            }&#10;            ExecutableElement method = (ExecutableElement) e;&#10;            TypeElement owner = (TypeElement) method.getEnclosingElement();&#10;            byClass.computeIfAbsent(owner, k -&gt; new ArrayList&lt;&gt;()).add(method);&#10;        }&#10;&#10;        for (Map.Entry&lt;TypeElement, List&lt;ExecutableElement&gt;&gt; entry : byClass.entrySet()) {&#10;            TypeElement owner = entry.getKey();&#10;            List&lt;ExecutableElement&gt; methods = entry.getValue();&#10;            try {&#10;                generateInjector(owner, methods);&#10;                for (ExecutableElement m : methods) generateRunner(owner, m);&#10;            } catch (IOException ex) {&#10;                error(&quot;Failed to generate for %s: %s&quot;, owner.getQualifiedName(), ex.getMessage());&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Code generation: Injector&#10;    // ---------------------------------------------------------------------&#10;    private void generateInjector(TypeElement owner, List&lt;ExecutableElement&gt; methods) throws IOException {&#10;        String pkg = elementUtils.getPackageOf(owner).getQualifiedName().toString();&#10;        String simple = owner.getSimpleName().toString();&#10;        String ownerQualified = owner.getQualifiedName().toString();&#10;        String name = simple + &quot;__QueryInjector&quot;;&#10;        String fqn = pkg.isEmpty() ? name : pkg + &quot;.&quot; + name;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn, owner);&#10;        try (Writer w = file.openWriter()) {&#10;            if (!pkg.isEmpty()) w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            w.write(&quot;public final class &quot; + name + &quot; {\n&quot;);&#10;            w.write(&quot;  private &quot; + name + &quot;(){}\n&quot;);&#10;            w.write(&quot;  public static void inject(Object system, com.ethnicthv.ecs.core.archetype.ArchetypeWorld world) {\n&quot;);&#10;            w.write(&quot;    &quot; + ownerQualified + &quot; self = (&quot; + ownerQualified + &quot;) system;\n&quot;);&#10;            for (ExecutableElement m : methods) {&#10;                AnnotationMirror q = BaseProcessor.getAnnotation(m, ANNO_QUERY);&#10;                String fieldInject = BaseProcessor.readString(q, &quot;fieldInject&quot;);&#10;                if (fieldInject == null || fieldInject.isEmpty()) {&#10;                    error(&quot;@Query on %s missing fieldInject&quot;, m);&#10;                    continue;&#10;                }&#10;                // Compile-time validation: ensure field exists and is typed as IGeneratedQuery&#10;                VariableElement targetField = null;&#10;                for (Element e : owner.getEnclosedElements()) {&#10;                    if (e.getKind() == ElementKind.FIELD &amp;&amp; e.getSimpleName().contentEquals(fieldInject)) {&#10;                        targetField = (VariableElement) e; break;&#10;                    }&#10;                }&#10;                if (targetField == null) {&#10;                    error(&quot;Field '%s' referenced by fieldInject on method %s not found in %s&quot;, fieldInject, m.getSimpleName(), owner.getQualifiedName());&#10;                    continue;&#10;                }&#10;                String fieldType = targetField.asType().toString();&#10;                String requiredType = &quot;com.ethnicthv.ecs.core.api.archetype.IGeneratedQuery&quot;;&#10;                if (!fieldType.equals(requiredType)) {&#10;                    error(&quot;Field '%s' must be of type %s (found %s) for @Query injection&quot;, fieldInject, requiredType, fieldType);&#10;                    continue;&#10;                }&#10;                String runner = simple + &quot;__&quot; + m.getSimpleName() + &quot;__QueryRunner&quot;;&#10;                w.write(&quot;    try {\n&quot;);&#10;                w.write(&quot;      java.lang.reflect.Field f = &quot; + ownerQualified + &quot;.class.getDeclaredField(\&quot;&quot; + fieldInject + &quot;\&quot;);\n&quot;);&#10;                w.write(&quot;      f.setAccessible(true);\n&quot;);&#10;                w.write(&quot;      if(!com.ethnicthv.ecs.core.api.archetype.IGeneratedQuery.class.isAssignableFrom(f.getType())) throw new IllegalStateException(\&quot;Field '&quot; + fieldInject + &quot;' must be assignable to IGeneratedQuery\&quot;);\n&quot;);&#10;                w.write(&quot;      f.set(self, new &quot; + runner + &quot;(world, self));\n&quot;);&#10;                w.write(&quot;    } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;            }&#10;            w.write(&quot;  }\n&quot;);&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Method analysis structures&#10;    // ---------------------------------------------------------------------&#10;    private static final class ParamAnalysis {&#10;        final List&lt;String&gt; componentClasses = new ArrayList&lt;&gt;();&#10;        final List&lt;String&gt; declaredTypes = new ArrayList&lt;&gt;();&#10;        final List&lt;Integer&gt; logicalToPhysical = new ArrayList&lt;&gt;();&#10;        final List&lt;String&gt; expectedHandleClasses = new ArrayList&lt;&gt;();&#10;        final List&lt;String&gt; directBinderNames = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Code generation: Runner per method&#10;    // ---------------------------------------------------------------------&#10;    private void generateRunner(TypeElement owner, ExecutableElement method) throws IOException {&#10;        String pkg = elementUtils.getPackageOf(owner).getQualifiedName().toString();&#10;        String simple = owner.getSimpleName().toString();&#10;        String ownerQualified = owner.getQualifiedName().toString();&#10;        String name = simple + &quot;__&quot; + method.getSimpleName() + &quot;__QueryRunner&quot;;&#10;        String fqn = pkg.isEmpty() ? name : pkg + &quot;.&quot; + name;&#10;        boolean isPrivate = method.getModifiers().contains(Modifier.PRIVATE);&#10;        String methodName = method.getSimpleName().toString();&#10;&#10;        // ID field detection&#10;        String idFieldName = findIdFieldName(owner);&#10;        boolean hasIdField = (idFieldName != null);&#10;&#10;        // ID parameter detection&#10;        int idParamIndex = findIdParamIndex(method);&#10;&#10;        // Parameter component / type analysis&#10;        ParamAnalysis pa = analyzeParameters(method, idParamIndex);&#10;&#10;        AnnotationMirror q = BaseProcessor.getAnnotation(method, ANNO_QUERY);&#10;        List&lt;String&gt; withClasses = BaseProcessor.readTypeArray(q, &quot;with&quot;);&#10;        List&lt;String&gt; withoutClasses = BaseProcessor.readTypeArray(q, &quot;without&quot;);&#10;        List&lt;String&gt; anyClasses = BaseProcessor.readTypeArray(q, &quot;any&quot;);&#10;        String modeConst = BaseProcessor.readEnumConst(q, &quot;mode&quot;);&#10;        boolean isParallel = &quot;PARALLEL&quot;.equals(modeConst);&#10;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn, owner);&#10;        try (Writer w = file.openWriter()) {&#10;            if (!pkg.isEmpty()) w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            w.write(&quot;public final class &quot; + name + &quot; implements com.ethnicthv.ecs.core.api.archetype.IQuery, com.ethnicthv.ecs.core.api.archetype.IQueryBuilder, com.ethnicthv.ecs.core.api.archetype.IGeneratedQuery {\n&quot;);&#10;            // Fields&#10;            w.write(&quot;  private final com.ethnicthv.ecs.core.archetype.ArchetypeWorld world;\n&quot;);&#10;            w.write(&quot;  private final &quot; + ownerQualified + &quot; system;\n&quot;);&#10;            if (isPrivate) w.write(&quot;  private final java.lang.invoke.MethodHandle invExact;\n&quot;);&#10;            w.write(&quot;  private Object __managedSharedFilter = null;\n&quot;);&#10;            w.write(&quot;  private java.util.List&lt;com.ethnicthv.ecs.core.archetype.ArchetypeQuery.UnmanagedFilter&gt; __unmanagedSharedFilters = null;\n&quot;);&#10;            w.write(&quot;  private static final boolean HAS_ID_FIELD = &quot; + (hasIdField ? &quot;true&quot; : &quot;false&quot;) + &quot;;\n&quot;);&#10;            w.write(&quot;  private final java.lang.reflect.Field ID_FIELD;\n&quot;);&#10;            w.write(&quot;  private static final boolean MODE_PARALLEL = &quot; + (isParallel ? &quot;true&quot; : &quot;false&quot;) + &quot;;\n&quot;);&#10;            // Param arrays&#10;            w.write(&quot;  private static final Class&lt;?&gt;[] PARAM_CLASSES = new Class&lt;?&gt;[]{&quot;);&#10;            for (int i = 0; i &lt; pa.componentClasses.size(); i++) w.write(pa.componentClasses.get(i) + &quot;.class&quot; + (i &lt; pa.componentClasses.size() - 1 ? &quot;, &quot; : &quot;&quot;));&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;  private static final Class&lt;?&gt;[] DECLARED_PARAM_TYPES = new Class&lt;?&gt;[]{&quot;);&#10;            for (int i = 0; i &lt; pa.declaredTypes.size(); i++) w.write(pa.declaredTypes.get(i) + &quot;.class&quot; + (i &lt; pa.declaredTypes.size() - 1 ? &quot;, &quot; : &quot;&quot;));&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;  private static final String[] HANDLE_CLASS_NAMES = new String[]{&quot;);&#10;            for (int i = 0; i &lt; pa.expectedHandleClasses.size(); i++) w.write(&quot;\&quot;&quot; + pa.expectedHandleClasses.get(i) + &quot;\&quot;&quot; + (i &lt; pa.expectedHandleClasses.size() - 1 ? &quot;, &quot; : &quot;&quot;));&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;  private static final int PARAM_COUNT = PARAM_CLASSES.length;\n&quot;);&#10;            // Filters arrays&#10;            writeClassArray(w, &quot;WITH_CLASSES&quot;, withClasses);&#10;            writeClassArray(w, &quot;WITHOUT_CLASSES&quot;, withoutClasses);&#10;            writeClassArray(w, &quot;ANY_CLASSES&quot;, anyClasses);&#10;            // IDs &amp; masks + strategy arrays&#10;            w.write(&quot;  private final int[] paramIds;\n&quot;);&#10;            w.write(&quot;  private final int[] withIds;\n&quot;);&#10;            w.write(&quot;  private final int[] withoutIds;\n&quot;);&#10;            w.write(&quot;  private final int[] anyIds;\n&quot;);&#10;            w.write(&quot;  private final com.ethnicthv.ecs.core.archetype.ComponentMask withMask;\n&quot;);&#10;            w.write(&quot;  private final com.ethnicthv.ecs.core.archetype.ComponentMask withoutMask;\n&quot;);&#10;            w.write(&quot;  private final com.ethnicthv.ecs.core.archetype.ComponentMask anyMask;\n&quot;);&#10;            w.write(&quot;  private final boolean[] PARAM_IS_MANAGED;\n&quot;);&#10;            w.write(&quot;  private final java.lang.invoke.MethodHandle[] BINDER_MH;\n&quot;);&#10;            w.write(&quot;  private final com.ethnicthv.ecs.core.components.ComponentDescriptor[] PARAM_DESCRIPTORS;\n&quot;);&#10;            w.write(&quot;  private static final boolean[] DIRECT_BIND = new boolean[]{&quot;);&#10;            for (int i = 0; i &lt; pa.directBinderNames.size(); i++) w.write((pa.directBinderNames.get(i) != null ? &quot;true&quot; : &quot;false&quot;) + (i &lt; pa.directBinderNames.size() - 1 ? &quot;, &quot; : &quot;&quot;));&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;  private static final String[] DIRECT_BIND_NAME = new String[]{&quot;);&#10;            for (int i = 0; i &lt; pa.directBinderNames.size(); i++) { String n = pa.directBinderNames.get(i); w.write(n == null ? &quot;null&quot; : (&quot;\&quot;&quot; + n + &quot;\&quot;&quot;)); if (i &lt; pa.directBinderNames.size() - 1) w.write(&quot;, &quot;); }&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;  private static final class ArchetypePlan { final int[] compIdx; final int[] managedIdx; ArchetypePlan(int[] a, int[] b){ this.compIdx=a; this.managedIdx=b; } }\n&quot;);&#10;            w.write(&quot;  private final java.util.concurrent.ConcurrentHashMap&lt;com.ethnicthv.ecs.core.archetype.Archetype, ArchetypePlan&gt; PLAN_CACHE = new java.util.concurrent.ConcurrentHashMap&lt;&gt;();\n&quot;);&#10;            w.write(&quot;  private enum ParamStrategy { MANAGED, UNMANAGED_RAW, UNMANAGED_TYPED }\n&quot;);&#10;            w.write(&quot;  private final ParamStrategy[] STRATEGY = new ParamStrategy[PARAM_COUNT];\n&quot;);&#10;            w.write(&quot;  private final java.lang.reflect.Constructor&lt;?&gt;[] TYPED_CTORS = new java.lang.reflect.Constructor&lt;?&gt;[PARAM_COUNT];\n&quot;);&#10;            w.write(&quot;  private final Object[] SEQ_TYPED = new Object[PARAM_COUNT];\n&quot;);&#10;            w.write(&quot;  private final ThreadLocal&lt;Object[]&gt; PAR_TYPED = ThreadLocal.withInitial(() -&gt; { Object[] a = new Object[PARAM_COUNT]; try { for (int i = 0; i &lt; PARAM_COUNT; i++) { if (STRATEGY[i] == ParamStrategy.UNMANAGED_TYPED) { a[i] = TYPED_CTORS[i].newInstance(); } } } catch (Throwable t) { throw new RuntimeException(t); } return a; });\n&quot;);&#10;            // Constructor&#10;            w.write(&quot;  public &quot; + name + &quot;(com.ethnicthv.ecs.core.archetype.ArchetypeWorld w, &quot; + ownerQualified + &quot; s){\n&quot;);&#10;            if (isPrivate) w.write(&quot;    this.world=w; this.system=s; this.invExact = createMH();\n&quot;); else w.write(&quot;    this.world=w; this.system=s;\n&quot;);&#10;            if (hasIdField) {&#10;                w.write(&quot;    try { java.lang.reflect.Field __idf = &quot; + ownerQualified + &quot;.class.getDeclaredField(\&quot;&quot; + idFieldName + &quot;\&quot;); __idf.setAccessible(true); this.ID_FIELD = __idf; } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;            } else w.write(&quot;    this.ID_FIELD = null;\n&quot;);&#10;            w.write(&quot;    this.paramIds = new int[PARAM_COUNT]; for (int i = 0; i &lt; PARAM_COUNT; i++) { Integer id = w.getComponentTypeId(PARAM_CLASSES[i]); if (id == null) throw new IllegalStateException(\&quot;Component not registered: \&quot; + PARAM_CLASSES[i]); this.paramIds[i] = id; }\n&quot;);&#10;            w.write(&quot;    java.util.ArrayList&lt;Integer&gt; wl = new java.util.ArrayList&lt;&gt;(); for (Class&lt;?&gt; c : WITH_CLASSES) { Integer id = w.getComponentTypeId(c); if (id != null) wl.add(id); } this.withIds = wl.stream().mapToInt(Integer::intValue).toArray();\n&quot;);&#10;            w.write(&quot;    java.util.ArrayList&lt;Integer&gt; wtl = new java.util.ArrayList&lt;&gt;(); for (Class&lt;?&gt; c : WITHOUT_CLASSES) { Integer id = w.getComponentTypeId(c); if (id != null) wtl.add(id); } this.withoutIds = wtl.stream().mapToInt(Integer::intValue).toArray();\n&quot;);&#10;            w.write(&quot;    java.util.ArrayList&lt;Integer&gt; al = new java.util.ArrayList&lt;&gt;(); for (Class&lt;?&gt; c : ANY_CLASSES) { Integer id = w.getComponentTypeId(c); if (id != null) al.add(id); } this.anyIds = al.stream().mapToInt(Integer::intValue).toArray();\n&quot;);&#10;            w.write(&quot;    com.ethnicthv.ecs.core.archetype.ComponentMask.Builder wb = com.ethnicthv.ecs.core.archetype.ComponentMask.builder(); for (int id : this.withIds) wb.with(id); for (int id : this.paramIds) wb.with(id); this.withMask = wb.build();\n&quot;);&#10;            w.write(&quot;    com.ethnicthv.ecs.core.archetype.ComponentMask.Builder woutb = com.ethnicthv.ecs.core.archetype.ComponentMask.builder(); for (int id : this.withoutIds) woutb.with(id); this.withoutMask = woutb.build();\n&quot;);&#10;            w.write(&quot;    com.ethnicthv.ecs.core.archetype.ComponentMask.Builder ab = com.ethnicthv.ecs.core.archetype.ComponentMask.builder(); for (int id : this.anyIds) ab.with(id); this.anyMask = ab.build();\n&quot;);&#10;            w.write(&quot;    this.PARAM_IS_MANAGED = new boolean[PARAM_COUNT]; this.BINDER_MH = new java.lang.invoke.MethodHandle[PARAM_COUNT]; this.PARAM_DESCRIPTORS = new com.ethnicthv.ecs.core.components.ComponentDescriptor[PARAM_COUNT];\n&quot;);&#10;            w.write(&quot;    final var __cmgr = w.getComponentManager(); final var __lookup = java.lang.invoke.MethodHandles.lookup();\n&quot;);&#10;            w.write(buildParamStrategyBlock());&#10;            w.write(&quot;    try { for (int i = 0; i &lt; PARAM_COUNT; i++) { if (STRATEGY[i] == ParamStrategy.UNMANAGED_TYPED) { TYPED_CTORS[i] = DECLARED_PARAM_TYPES[i].getDeclaredConstructor(); TYPED_CTORS[i].setAccessible(true); SEQ_TYPED[i] = TYPED_CTORS[i].newInstance(); } } } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;            // Defer config validation to run-time so system registration doesn't fail eagerly&#10;            // w.write(&quot;    validateConfig();\n&quot;);&#10;            w.write(&quot;  }\n&quot;);&#10;&#10;            if (isPrivate) w.write(buildPrivateMethodHandleCreator(ownerQualified, methodName, method.getParameters()));&#10;&#10;            w.write(buildValidateConfigBlock());&#10;            w.write(buildPlanBuilderBlock());&#10;&#10;            // IQueryBuilder implementations&#10;            w.write(&quot;  @Override public com.ethnicthv.ecs.core.api.archetype.IQueryBuilder withShared(Object managedValue) { this.__managedSharedFilter = managedValue; return this; }\n&quot;);&#10;            w.write(&quot;  @Override public com.ethnicthv.ecs.core.api.archetype.IQueryBuilder withShared(Class&lt;?&gt; unmanagedSharedType, long value) { if (this.__unmanagedSharedFilters == null) this.__unmanagedSharedFilters = new java.util.ArrayList&lt;&gt;(); this.__unmanagedSharedFilters.add(new com.ethnicthv.ecs.core.archetype.ArchetypeQuery.UnmanagedFilter(unmanagedSharedType, value)); return this; }\n&quot;);&#10;            w.write(&quot;  @Override public &lt;T&gt; com.ethnicthv.ecs.core.api.archetype.IQueryBuilder with(Class&lt;T&gt; c) { return this; }\n&quot;);&#10;            w.write(&quot;  @Override public &lt;T&gt; com.ethnicthv.ecs.core.api.archetype.IQueryBuilder without(Class&lt;T&gt; c) { return this; }\n&quot;);&#10;            w.write(&quot;  @Override public com.ethnicthv.ecs.core.api.archetype.IQueryBuilder any(Class&lt;?&gt;... cs) { return this; }\n&quot;);&#10;            w.write(&quot;  @Override public com.ethnicthv.ecs.core.api.archetype.IQuery build() { return this; }\n&quot;);&#10;&#10;            // Shared value key builder&#10;            w.write(buildSharedKeyBuilderBlock());&#10;&#10;            // Binding/prep/call sequences&#10;            String bindsSeq = buildBindSequence(pa.declaredTypes, pa.directBinderNames);&#10;            String prepSeq = buildPrepSequence(pa.declaredTypes, &quot;entityId&quot;);&#10;            String prepPar = buildPrepSequence(pa.declaredTypes, &quot;eid&quot;);&#10;            String callSeq = buildCallSequence(isPrivate, method, idParamIndex, pa.logicalToPhysical, &quot;entityId&quot;);&#10;            String callPar = buildCallSequence(isPrivate, method, idParamIndex, pa.logicalToPhysical, &quot;eid&quot;);&#10;&#10;            // Chunk runners&#10;            w.write(buildSequentialChunkRunner(hasIdField, bindsSeq, prepSeq, callSeq));&#10;            w.write(buildParallelChunkRunner(bindsSeq, prepPar, callPar));&#10;            // Group runners&#10;            w.write(&quot;  private void runOnGroup_Sequential(com.ethnicthv.ecs.core.archetype.ChunkGroup group, ArchetypePlan plan, com.ethnicthv.ecs.core.components.ComponentManager cm){ com.ethnicthv.ecs.core.archetype.ArchetypeChunk[] chunks = group.getChunksSnapshot(); int count = group.chunkCount(); for (int i = 0; i &lt; count; i++) runOnChunk_Sequential(chunks[i], plan, cm); }\n&quot;);&#10;            w.write(&quot;  private void runOnGroup_Parallel(com.ethnicthv.ecs.core.archetype.ChunkGroup group, ArchetypePlan plan, com.ethnicthv.ecs.core.components.ComponentManager cm){ com.ethnicthv.ecs.core.archetype.ArchetypeChunk[] chunks = group.getChunksSnapshot(); int count = group.chunkCount(); java.util.Arrays.stream(chunks, 0, count).parallel().forEach(chunk -&gt; runOnChunk_Parallel(chunk, plan, cm)); }\n&quot;);&#10;            // Drivers&#10;            w.write(&quot;  @Override public void runQuery(){ validateConfig(); if (MODE_PARALLEL) runParallel(); else runSequential(); this.__managedSharedFilter = null; if (this.__unmanagedSharedFilters != null) this.__unmanagedSharedFilters.clear(); }\n&quot;);&#10;            w.write(buildRunSequentialBlock());&#10;            w.write(buildRunParallelBlock());&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Analysis helpers&#10;    // ---------------------------------------------------------------------&#10;    private String findIdFieldName(TypeElement owner) {&#10;        String idFieldName = null;&#10;        for (Element e : owner.getEnclosedElements()) {&#10;            if (e.getKind() != ElementKind.FIELD) continue;&#10;            if (BaseProcessor.hasAnnotation(e, ANNO_ID)) {&#10;                if (idFieldName != null) { error(&quot;Only one @Id field is allowed per @Query method owner %s&quot;, owner.getQualifiedName()); break; }&#10;                String ft = e.asType().toString();&#10;                if (!&quot;int&quot;.equals(ft)) { error(&quot;@Id field must be of type int: %s.%s&quot;, owner.getQualifiedName(), e.getSimpleName()); break; }&#10;                idFieldName = e.getSimpleName().toString();&#10;            }&#10;        }&#10;        return idFieldName;&#10;    }&#10;&#10;    private int findIdParamIndex(ExecutableElement method) {&#10;        int idParamIndex = -1;&#10;        List&lt;? extends VariableElement&gt; methodParams = method.getParameters();&#10;        for (int i = 0; i &lt; methodParams.size(); i++) {&#10;            VariableElement p = methodParams.get(i);&#10;            if (BaseProcessor.getAnnotation(p, ANNO_ID) != null) {&#10;                if (idParamIndex != -1) { error(&quot;Only one @Id parameter is allowed on method %s&quot;, method); break; }&#10;                String dt = p.asType().toString();&#10;                if (!&quot;int&quot;.equals(dt) &amp;&amp; !&quot;java.lang.Integer&quot;.equals(dt)) { error(&quot;@Id parameter must be int or java.lang.Integer on method %s&quot;, method); break; }&#10;                idParamIndex = i;&#10;            }&#10;        }&#10;        return idParamIndex;&#10;    }&#10;&#10;    private ParamAnalysis analyzeParameters(ExecutableElement method, int idParamIndex) {&#10;        ParamAnalysis pa = new ParamAnalysis();&#10;        List&lt;? extends VariableElement&gt; params = method.getParameters();&#10;        for (int phys = 0; phys &lt; params.size(); phys++) {&#10;            if (phys == idParamIndex) continue;&#10;            VariableElement p = params.get(phys);&#10;            AnnotationMirror compAnno = BaseProcessor.getAnnotation(p, ANNO_COMPONENT);&#10;            String declaredType = p.asType().toString();&#10;            String compTypeFqn;&#10;            if (compAnno != null) {&#10;                compTypeFqn = BaseProcessor.readTypeClass(compAnno, &quot;type&quot;);&#10;                if (compTypeFqn == null || compTypeFqn.isEmpty()) { error(&quot;@Component on %s must specify type()&quot;, p); continue; }&#10;            } else {&#10;                if (&quot;com.ethnicthv.ecs.core.components.ComponentHandle&quot;.equals(declaredType)) { error(&quot;Parameter %s must be annotated with @Component(type=...) to specify component type&quot;, p); continue; }&#10;                if (declaredType.endsWith(&quot;Handle&quot;)) {&#10;                    String base = declaredType.substring(0, declaredType.length() - &quot;Handle&quot;.length());&#10;                    compTypeFqn = (elementUtils.getTypeElement(base) != null) ? base : declaredType;&#10;                } else compTypeFqn = declaredType;&#10;            }&#10;            pa.componentClasses.add(compTypeFqn);&#10;            pa.declaredTypes.add(declaredType);&#10;            pa.logicalToPhysical.add(phys);&#10;            int lastDot = compTypeFqn.lastIndexOf('.');&#10;            String compPkg = (lastDot &gt;= 0) ? compTypeFqn.substring(0, lastDot) : &quot;&quot;;&#10;            String compSimple = (lastDot &gt;= 0) ? compTypeFqn.substring(lastDot + 1) : compTypeFqn;&#10;            String handleFqn = (compPkg.isEmpty() ? compSimple + &quot;Handle&quot; : compPkg + &quot;.&quot; + compSimple + &quot;Handle&quot;);&#10;            pa.expectedHandleClasses.add(handleFqn);&#10;            String binderName = null;&#10;            if (!&quot;com.ethnicthv.ecs.core.components.ComponentHandle&quot;.equals(declaredType)) {&#10;                TypeElement declEl = elementUtils.getTypeElement(declaredType);&#10;                if (declEl != null) binderName = findPublicBinderMethodName(declEl);&#10;            }&#10;            pa.directBinderNames.add(binderName);&#10;        }&#10;        return pa;&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Generation block builders (return code strings)&#10;    // ---------------------------------------------------------------------&#10;    private String buildParamStrategyBlock() {&#10;        return &quot;&quot;&quot;&#10;                for (int i = 0; i &lt; PARAM_COUNT; i++) {&#10;                  var __desc = __cmgr.getDescriptor(PARAM_CLASSES[i]);&#10;                  if (__desc == null) throw new IllegalStateException(&quot;Descriptor not found for component: &quot; + PARAM_CLASSES[i].getName());&#10;                  this.PARAM_IS_MANAGED[i] = __desc.isManaged();&#10;                  this.PARAM_DESCRIPTORS[i] = __desc;&#10;                  boolean declaredIsRawHandle = (DECLARED_PARAM_TYPES[i] == com.ethnicthv.ecs.core.components.ComponentHandle.class);&#10;                  boolean declaredIsGeneratedHandle = DECLARED_PARAM_TYPES[i].getName().equals(HANDLE_CLASS_NAMES[i]);&#10;                  boolean declaredEqualsComponentClass = (DECLARED_PARAM_TYPES[i] == PARAM_CLASSES[i]);&#10;                  if (this.PARAM_IS_MANAGED[i]) {&#10;                    this.STRATEGY[i] = ParamStrategy.MANAGED;&#10;                  } else {&#10;                    if (declaredIsRawHandle) {&#10;                      this.STRATEGY[i] = ParamStrategy.UNMANAGED_RAW;&#10;                    } else if (declaredIsGeneratedHandle || DIRECT_BIND[i]) {&#10;                      this.STRATEGY[i] = ParamStrategy.UNMANAGED_TYPED;&#10;                    } else if (declaredEqualsComponentClass) {&#10;                      // User mistakenly declared managed object for an unmanaged component; defer error to validateConfig()&#10;                      this.STRATEGY[i] = ParamStrategy.MANAGED;&#10;                    } else {&#10;                      throw new IllegalStateException(&quot;Parameter type &quot; + DECLARED_PARAM_TYPES[i].getName() + &quot; is invalid for unmanaged component &quot; + PARAM_CLASSES[i].getName() + &quot;. Use ComponentHandle or the generated Handle class.&quot;);&#10;                    }&#10;                  }&#10;                  if (!this.PARAM_IS_MANAGED[i] &amp;&amp; this.STRATEGY[i] == ParamStrategy.UNMANAGED_TYPED &amp;&amp; !DIRECT_BIND[i]) {&#10;                    try {&#10;                      var __prv = java.lang.invoke.MethodHandles.privateLookupIn(DECLARED_PARAM_TYPES[i], __lookup);&#10;                      java.lang.invoke.MethodHandle __bh = null;&#10;                      try { __bh = __prv.findVirtual(DECLARED_PARAM_TYPES[i], &quot;__bind&quot;, java.lang.invoke.MethodType.methodType(void.class, com.ethnicthv.ecs.core.components.ComponentHandle.class)); } catch (Throwable ignore) {}&#10;                      if (__bh == null) { try { __bh = __prv.findVirtual(DECLARED_PARAM_TYPES[i], &quot;bind&quot;, java.lang.invoke.MethodType.methodType(void.class, com.ethnicthv.ecs.core.components.ComponentHandle.class)); } catch (Throwable ignore) {} }&#10;                      if (__bh == null) { try { __bh = __prv.findVirtual(DECLARED_PARAM_TYPES[i], &quot;reset&quot;, java.lang.invoke.MethodType.methodType(void.class, com.ethnicthv.ecs.core.components.ComponentHandle.class)); } catch (Throwable ignore) {} }&#10;                      if (__bh == null) throw new IllegalStateException(&quot;Typed handle class &quot; + DECLARED_PARAM_TYPES[i].getName() + &quot; must declare __bind/ bind/ or reset method with (ComponentHandle)&quot;);&#10;                      this.BINDER_MH[i] = __bh;&#10;                    } catch (Throwable t) {&#10;                      throw new IllegalStateException(&quot;Failed to prepare typed handle for parameter &quot; + i + &quot; of type &quot; + DECLARED_PARAM_TYPES[i].getName(), t);&#10;                    }&#10;                  }&#10;                }&#10;&#10;                &quot;&quot;&quot;;&#10;    }&#10;&#10;    private String buildPrivateMethodHandleCreator(String ownerQualified, String methodName, List&lt;? extends VariableElement&gt; params) {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;  private java.lang.invoke.MethodHandle createMH(){ try { var lookup = java.lang.invoke.MethodHandles.lookup(); var prv = java.lang.invoke.MethodHandles.privateLookupIn(&quot;)&#10;          .append(ownerQualified).append(&quot;.class, lookup); var mt = java.lang.invoke.MethodType.methodType(void.class&quot;);&#10;        for (VariableElement p : params) {&#10;            String t = p.asType().toString();&#10;            sb.append(&quot;, &quot;).append(&quot;int&quot;.equals(t) ? &quot;int.class&quot; : t + &quot;.class&quot;);&#10;        }&#10;        sb.append(&quot;); return prv.findVirtual(&quot;).append(ownerQualified).append(&quot;.class, \&quot;&quot;)&#10;          .append(methodName).append(&quot;\&quot;, mt); } catch (Throwable t) { throw new RuntimeException(t); } }\n&quot;);&#10;        return sb.toString();&#10;    }&#10;&#10;    private String buildValidateConfigBlock() {&#10;        return &quot;&quot;&quot;&#10;  private void validateConfig(){&#10;    for (int i = 0; i &lt; paramIds.length; i++) {&#10;      boolean isManaged = PARAM_IS_MANAGED[i];&#10;      if (isManaged) {&#10;        if (DECLARED_PARAM_TYPES[i] != PARAM_CLASSES[i]) {&#10;          throw new IllegalStateException(&quot;Parameter type mismatch: component &quot; + PARAM_CLASSES[i].getName() + &quot; is @Managed, method parameter must be that component type&quot;);&#10;        }&#10;      } else {&#10;        if (DECLARED_PARAM_TYPES[i] == PARAM_CLASSES[i]) {&#10;          throw new IllegalStateException(&quot;Parameter &quot; + i + &quot; declared as managed object (&quot; + PARAM_CLASSES[i].getName() + &quot;) but component is unmanaged. Use ComponentHandle or the generated Handle class.&quot;);&#10;        }&#10;      }&#10;    }&#10;    if (HAS_ID_FIELD &amp;&amp; MODE_PARALLEL) {&#10;      throw new IllegalStateException(&quot;@Id field is not supported with PARALLEL Query mode; use SEQUENTIAL.&quot;);&#10;    }&#10;  }&#10;&quot;&quot;&quot;;&#10;    }&#10;&#10;    private String buildPlanBuilderBlock() {&#10;        return &quot;  private ArchetypePlan buildPlan(com.ethnicthv.ecs.core.archetype.Archetype archetype){ final int[] compIdx = new int[PARAM_COUNT]; final int[] managedIdx = new int[PARAM_COUNT]; boolean ok = true; for (int i = 0; i &lt; PARAM_COUNT; i++) { int tid = paramIds[i]; if (!PARAM_IS_MANAGED[i]) { compIdx[i] = archetype.indexOfComponentType(tid); if (compIdx[i] &lt; 0) { ok=false; break; } managedIdx[i] = -1; } else { managedIdx[i] = archetype.getManagedTypeIndex(tid); if (managedIdx[i] &lt; 0) { ok=false; break; } compIdx[i] = -1; } } return ok ? new ArchetypePlan(compIdx, managedIdx) : null; }\n&quot;;&#10;    }&#10;&#10;    private String buildSharedKeyBuilderBlock() {&#10;        return &quot;  private com.ethnicthv.ecs.core.archetype.SharedValueKey buildQueryKey(com.ethnicthv.ecs.core.archetype.Archetype archetype){ int[] managedIdx = null; long[] unmanagedVals = null; boolean any=false; if (this.__managedSharedFilter != null) { int ticket = world.findSharedIndex(this.__managedSharedFilter); if (ticket &lt; 0) return null; int managedCount = archetype.getSharedManagedTypeIds().length; if (managedCount == 0) return null; managedIdx = new int[managedCount]; java.util.Arrays.fill(managedIdx, -1); for (int typeId : archetype.getSharedManagedTypeIds()) { int pos = archetype.getSharedManagedIndex(typeId); if (pos &gt;= 0) { managedIdx[pos] = ticket; any = true; } } } if (this.__unmanagedSharedFilters != null &amp;&amp; !this.__unmanagedSharedFilters.isEmpty()) { int unmanagedCount = archetype.getSharedUnmanagedTypeIds().length; if (unmanagedCount == 0) return null; unmanagedVals = new long[unmanagedCount]; java.util.Arrays.fill(unmanagedVals, Long.MIN_VALUE); for (var f : this.__unmanagedSharedFilters) { Integer typeId = world.getComponentTypeId(f.type); if (typeId == null) return null; int pos = archetype.getSharedUnmanagedIndex(typeId); if (pos &lt; 0) return null; unmanagedVals[pos] = f.value; any = true; } } if (!any) return null; return new com.ethnicthv.ecs.core.archetype.SharedValueKey(managedIdx, unmanagedVals); }\n&quot;;&#10;    }&#10;&#10;    private String buildBindSequence(List&lt;String&gt; declaredTypes, List&lt;String&gt; directBinderNames) {&#10;        StringBuilder sb = new StringBuilder();&#10;        for (int i = 0; i &lt; declaredTypes.size(); i++) {&#10;            String decl = declaredTypes.get(i);&#10;            String direct = directBinderNames.get(i);&#10;            sb.append(&quot;            if (STRATEGY[&quot;).append(i).append(&quot;] == ParamStrategy.UNMANAGED_TYPED) { &quot;);&#10;            if (direct != null) {&#10;                sb.append(&quot;((&quot;).append(decl).append(&quot;) typed[&quot;).append(i).append(&quot;]).&quot;).append(direct).append(&quot;((com.ethnicthv.ecs.core.components.ComponentHandle) pooled[&quot;).append(i).append(&quot;]);\n&quot;);&#10;            } else {&#10;                sb.append(&quot;try { BINDER_MH[&quot;).append(i).append(&quot;]\n&quot;)&#10;                  .append(&quot;.invoke(typed[&quot;).append(i).append(&quot;], pooled[&quot;).append(i).append(&quot;]); } catch (Throwable __t) { throw new RuntimeException(__t); }\n&quot;);&#10;            }&#10;            sb.append(&quot;            }\n&quot;);&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    private String buildPrepSequence(List&lt;String&gt; declaredTypes, String entityVar) {&#10;        StringBuilder sb = new StringBuilder();&#10;        for (int i = 0; i &lt; declaredTypes.size(); i++) {&#10;            String dt = declaredTypes.get(i);&#10;            sb.append(&quot;            final Object __argObj_&quot;).append(i).append(&quot; = (STRATEGY[&quot;).append(i)&#10;              .append(&quot;] == ParamStrategy.MANAGED) ? world.getManagedComponent(&quot;).append(entityVar).append(&quot;, PARAM_CLASSES[&quot;).append(i)&#10;              .append(&quot;]) : (STRATEGY[&quot;).append(i).append(&quot;] == ParamStrategy.UNMANAGED_RAW) ? pooled[&quot;).append(i).append(&quot;] : typed[&quot;).append(i).append(&quot;];\n&quot;)&#10;              .append(&quot;            final &quot;).append(dt).append(&quot; a&quot;).append(i).append(&quot; = (&quot;).append(dt).append(&quot;) __argObj_&quot;).append(i).append(&quot;;\n&quot;);&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    private String buildCallSequence(boolean isPrivate, ExecutableElement method, int idParamIndex, List&lt;Integer&gt; logicalToPhysical, String entityVar) {&#10;        StringBuilder sb = new StringBuilder();&#10;        List&lt;? extends VariableElement&gt; params = method.getParameters();&#10;        if (isPrivate) {&#10;            sb.append(&quot;            try { invExact.invokeExact(system&quot;);&#10;            for (int i = 0; i &lt; params.size(); i++) {&#10;                String t = params.get(i).asType().toString();&#10;                if (i == idParamIndex) {&#10;                    sb.append(&quot;, &quot;).append(&quot;int&quot;.equals(t) ? entityVar : &quot;java.lang.Integer.valueOf(&quot; + entityVar + &quot;)&quot;);&#10;                } else {&#10;                    int li = -1; for (int k = 0; k &lt; logicalToPhysical.size(); k++) { if (logicalToPhysical.get(k) == i) { li = k; break; } }&#10;                    sb.append(&quot;, a&quot;).append(li);&#10;                }&#10;            }&#10;            sb.append(&quot;); } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;        } else {&#10;            sb.append(&quot;            system.&quot;).append(method.getSimpleName()).append(&quot;(&quot;);&#10;            for (int i = 0; i &lt; params.size(); i++) {&#10;                if (i &gt; 0) sb.append(&quot;, &quot;);&#10;                String t = params.get(i).asType().toString();&#10;                if (i == idParamIndex) sb.append(&quot;int&quot;.equals(t) ? entityVar : &quot;java.lang.Integer.valueOf(&quot; + entityVar + &quot;)&quot;);&#10;                else { int li = -1; for (int k = 0; k &lt; logicalToPhysical.size(); k++) { if (logicalToPhysical.get(k) == i) { li = k; break; } } sb.append(&quot;a&quot;).append(li); }&#10;            }&#10;            sb.append(&quot;);\n&quot;);&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    private String buildSequentialChunkRunner(boolean hasIdField, String bindsSeq, String prepSeq, String callSeq) {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;  private void runOnChunk_Sequential(com.ethnicthv.ecs.core.archetype.ArchetypeChunk chunk, ArchetypePlan plan, com.ethnicthv.ecs.core.components.ComponentManager cm){ final com.ethnicthv.ecs.core.components.ComponentHandle[] pooled = new com.ethnicthv.ecs.core.components.ComponentHandle[PARAM_COUNT]; for (int i = 0; i &lt; PARAM_COUNT; i++) { if (!PARAM_IS_MANAGED[i]) pooled[i] = cm.acquireHandle(); } final Object[] typed = SEQ_TYPED; try { int idx = chunk.nextOccupiedIndex(0); while (idx &gt;= 0) { int entityId = chunk.getEntityId(idx);\n&quot;);&#10;        if (hasIdField) sb.append(&quot;            try { ID_FIELD.setInt(system, entityId); } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;        sb.append(&quot;            for (int k = 0; k &lt; PARAM_COUNT; k++) { if (STRATEGY[k] != ParamStrategy.MANAGED) { var seg = chunk.getComponentData(plan.compIdx[k], idx); pooled[k].reset(seg, PARAM_DESCRIPTORS[k]); } }\n&quot;);&#10;        sb.append(bindsSeq);&#10;        sb.append(prepSeq);&#10;        sb.append(callSeq);&#10;        sb.append(&quot;            idx = chunk.nextOccupiedIndex(idx + 1); } } finally { for (int i = 0; i &lt; PARAM_COUNT; i++) { if (pooled[i] != null) cm.releaseHandle(pooled[i]); } } }\n&quot;);&#10;        return sb.toString();&#10;    }&#10;&#10;    private String buildParallelChunkRunner(String bindsSeq, String prepPar, String callPar) {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;  private void runOnChunk_Parallel(com.ethnicthv.ecs.core.archetype.ArchetypeChunk chunk, ArchetypePlan plan, com.ethnicthv.ecs.core.components.ComponentManager cm){ final com.ethnicthv.ecs.core.components.ComponentHandle[] pooled = new com.ethnicthv.ecs.core.components.ComponentHandle[PARAM_COUNT]; for (int i = 0; i &lt; PARAM_COUNT; i++) { if (!PARAM_IS_MANAGED[i]) pooled[i] = cm.acquireHandle(); } final Object[] typed = PAR_TYPED.get(); try { int idx = chunk.nextOccupiedIndex(0); while (idx &gt;= 0) { int eid = chunk.getEntityId(idx); for (int k = 0; k &lt; PARAM_COUNT; k++) { if (STRATEGY[k] != ParamStrategy.MANAGED) { var seg = chunk.getComponentData(plan.compIdx[k], idx); pooled[k].reset(seg, PARAM_DESCRIPTORS[k]); } }\n&quot;);&#10;        sb.append(bindsSeq);&#10;        sb.append(prepPar);&#10;        sb.append(callPar);&#10;        sb.append(&quot;            idx = chunk.nextOccupiedIndex(idx + 1); } } finally { for (int i = 0; i &lt; PARAM_COUNT; i++) { if (pooled[i] != null) cm.releaseHandle(pooled[i]); } } }\n&quot;);&#10;        return sb.toString();&#10;    }&#10;&#10;    private String buildRunSequentialBlock() {&#10;        return &quot;  private void runSequential(){ final var cm = world.getComponentManager(); final boolean hasFilter = (this.__managedSharedFilter != null || (this.__unmanagedSharedFilters != null &amp;&amp; !this.__unmanagedSharedFilters.isEmpty())); for (com.ethnicthv.ecs.core.archetype.Archetype archetype : world.getAllArchetypes()) { com.ethnicthv.ecs.core.archetype.ComponentMask am = archetype.getMask(); if (!am.containsAll(withMask)) continue; if (!am.containsNone(withoutMask)) continue; if (anyIds.length &gt; 0 &amp;&amp; !am.intersects(anyMask)) continue; ArchetypePlan plan = PLAN_CACHE.computeIfAbsent(archetype, a -&gt; buildPlan(a)); if (plan == null) continue; if (hasFilter) { com.ethnicthv.ecs.core.archetype.SharedValueKey qk = buildQueryKey(archetype); if (qk == null) continue; com.ethnicthv.ecs.core.archetype.ChunkGroup g = archetype.getChunkGroup(qk); if (g == null) continue; runOnGroup_Sequential(g, plan, cm); } else { for (com.ethnicthv.ecs.core.archetype.ChunkGroup g : archetype.getAllChunkGroups()) runOnGroup_Sequential(g, plan, cm); } } }\n&quot;;&#10;    }&#10;&#10;    private String buildRunParallelBlock() {&#10;        return &quot;  private void runParallel(){ final var cm = world.getComponentManager(); final boolean hasFilter = (this.__managedSharedFilter != null || (this.__unmanagedSharedFilters != null &amp;&amp; !this.__unmanagedSharedFilters.isEmpty())); java.util.List&lt;Runnable&gt; tasks = new java.util.ArrayList&lt;&gt;(); for (com.ethnicthv.ecs.core.archetype.Archetype archetype : world.getAllArchetypes()) { com.ethnicthv.ecs.core.archetype.ComponentMask am = archetype.getMask(); if (!am.containsAll(withMask)) continue; if (!am.containsNone(withoutMask)) continue; if (anyIds.length &gt; 0 &amp;&amp; !am.intersects(anyMask)) continue; ArchetypePlan plan = PLAN_CACHE.computeIfAbsent(archetype, a -&gt; buildPlan(a)); if (plan == null) continue; if (hasFilter) { com.ethnicthv.ecs.core.archetype.SharedValueKey qk = buildQueryKey(archetype); if (qk == null) continue; com.ethnicthv.ecs.core.archetype.ChunkGroup g = archetype.getChunkGroup(qk); if (g == null) continue; com.ethnicthv.ecs.core.archetype.ArchetypeChunk[] chunks = g.getChunksSnapshot(); int count = g.chunkCount(); for (int i = 0; i &lt; count; i++) { final com.ethnicthv.ecs.core.archetype.ArchetypeChunk c = chunks[i]; final ArchetypePlan p = plan; tasks.add(() -&gt; runOnChunk_Parallel(c, p, cm)); } } else { for (com.ethnicthv.ecs.core.archetype.ChunkGroup g : archetype.getAllChunkGroups()) { com.ethnicthv.ecs.core.archetype.ArchetypeChunk[] chunks = g.getChunksSnapshot(); int count = g.chunkCount(); for (int i = 0; i &lt; count; i++) { final com.ethnicthv.ecs.core.archetype.ArchetypeChunk c = chunks[i]; final ArchetypePlan p = plan; tasks.add(() -&gt; runOnChunk_Parallel(c, p, cm)); } } } } tasks.parallelStream().forEach(Runnable::run); }\n&quot;;&#10;    }&#10;&#10;    private void writeClassArray(Writer w, String label, List&lt;String&gt; classes) throws IOException {&#10;        w.write(&quot;  private static final Class&lt;?&gt;[] &quot; + label + &quot; = new Class&lt;?&gt;[]{&quot;);&#10;        for (int i = 0; i &lt; classes.size(); i++) w.write(classes.get(i) + &quot;.class&quot; + (i &lt; classes.size() - 1 ? &quot;,&quot; : &quot;&quot;));&#10;        w.write(&quot;};\n&quot;);&#10;    }&#10;&#10;    // ---------------------------------------------------------------------&#10;    // Low-level utilities&#10;    // ---------------------------------------------------------------------&#10;    private String findPublicBinderMethodName(TypeElement typeEl) {&#10;        for (Element e : typeEl.getEnclosedElements()) {&#10;            if (e.getKind() == ElementKind.METHOD) {&#10;                ExecutableElement m = (ExecutableElement) e;&#10;                String n = m.getSimpleName().toString();&#10;                if (!n.equals(&quot;__bind&quot;) &amp;&amp; !n.equals(&quot;bind&quot;) &amp;&amp; !n.equals(&quot;reset&quot;)) continue;&#10;                if (!m.getModifiers().contains(Modifier.PUBLIC)) continue;&#10;                List&lt;? extends VariableElement&gt; params = m.getParameters();&#10;                if (params.size() != 1) continue;&#10;                String p0 = params.getFirst().asType().toString();&#10;                if (&quot;com.ethnicthv.ecs.core.components.ComponentHandle&quot;.equals(p0)) return n;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeChunk.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeChunk.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk {&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                size.incrementAndGet();&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                size.decrementAndGet();&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk {&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                size.incrementAndGet();&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                size.decrementAndGet();&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] componentIds = m.toComponentIdArray();&#10;            ComponentDescriptor[] descriptors = new ComponentDescriptor[componentIds.length];&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                var meta = metadataProvider.apply(componentIds[i]);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + componentIds[i]);&#10;                }&#10;                descriptors[i] = componentManager.getDescriptor(meta.type());&#10;            }&#10;            return new Archetype(m, componentIds, descriptors, arena);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] componentIds = m.toComponentIdArray();&#10;            ComponentDescriptor[] descriptors = new ComponentDescriptor[componentIds.length];&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                var meta = metadataProvider.apply(componentIds[i]);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + componentIds[i]);&#10;                }&#10;                descriptors[i] = componentManager.getDescriptor(meta.type());&#10;            }&#10;            return new Archetype(m, componentIds, descriptors, arena);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeQuery.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeQuery.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentHandle;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (ArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                consumer.accept(entityId, location, chunk, archetype);&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities, providing pooled ComponentHandles for the requested component classes.&#10;     * The consumer receives an array of bound ComponentHandle (same order as componentClasses). The handles are released&#10;     * back to the manager after the consumer returns. This is intended for synchronous, short-lived access inside the consumer.&#10;     */&#10;    public void forEachEntityWith(EntityWithHandlesConsumer consumer, Class&lt;?&gt;... componentClasses) {&#10;        // Resolve component type IDs for requested classes&#10;        int[] reqTypeIds = new int[componentClasses.length];&#10;        for (int i = 0; i &lt; componentClasses.length; i++) {&#10;            Integer tid = world.getComponentTypeId(componentClasses[i]);&#10;            if (tid == null) {&#10;                // If a requested component class is not registered, no entity will match; return early&#10;                return;&#10;            }&#10;            reqTypeIds[i] = tid;&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            int[] compIndices = new int[reqTypeIds.length];&#10;            for (int i = 0; i &lt; reqTypeIds.length; i++) {&#10;                int idx = archetype.indexOfComponentType(reqTypeIds[i]);&#10;                if (idx &lt; 0) {&#10;                    // archetype missing at least one required component; skip it&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;&#10;            // Iterate entities in archetype&#10;            final int[] useIdx = compIndices; // capture&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; useIdx.length; k++) {&#10;                        int compIdx = useIdx[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, location, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeConsumer {&#10;        void accept(Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ChunkConsumer {&#10;        void accept(ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityConsumer {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityWithHandlesConsumer {&#10;        void accept(int entityId, ComponentHandle[] handles, ArchetypeChunk.ChunkLocation location, Archetype archetype);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentHandle;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (ArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                consumer.accept(entityId, location, chunk, archetype);&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities, providing pooled ComponentHandles for the requested component classes.&#10;     * The consumer receives an array of bound ComponentHandle (same order as componentClasses). The handles are released&#10;     * back to the manager after the consumer returns. This is intended for synchronous, short-lived access inside the consumer.&#10;     */&#10;    public void forEachEntityWith(EntityWithHandlesConsumer consumer, Class&lt;?&gt;... componentClasses) {&#10;        // Resolve component type IDs for requested classes&#10;        int[] reqTypeIds = new int[componentClasses.length];&#10;        for (int i = 0; i &lt; componentClasses.length; i++) {&#10;            Integer tid = world.getComponentTypeId(componentClasses[i]);&#10;            if (tid == null) {&#10;                // If a requested component class is not registered, no entity will match; return early&#10;                return;&#10;            }&#10;            reqTypeIds[i] = tid;&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            int[] compIndices = new int[reqTypeIds.length];&#10;            for (int i = 0; i &lt; reqTypeIds.length; i++) {&#10;                int idx = archetype.indexOfComponentType(reqTypeIds[i]);&#10;                if (idx &lt; 0) {&#10;                    // archetype missing at least one required component; skip it&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;&#10;            // Iterate entities in archetype&#10;            final int[] useIdx = compIndices; // capture&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; useIdx.length; k++) {&#10;                        int compIdx = useIdx[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, location, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeConsumer {&#10;        void accept(Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ChunkConsumer {&#10;        void accept(ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityConsumer {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityWithHandlesConsumer {&#10;        void accept(int entityId, ComponentHandle[] handles, ArchetypeChunk.ChunkLocation location, Archetype archetype);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeWorld.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeWorld.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ComponentManager componentManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    private final AtomicInteger nextComponentTypeId = new AtomicInteger(0);&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentMetadata = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentTypeIds.computeIfAbsent(componentClass, cls -&gt; {&#10;            int tid = componentManager.registerComponent(cls);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(cls);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, cls, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id atomically&#10;            nextComponentTypeId.updateAndGet(prev -&gt; Math.max(prev, tid + 1));&#10;            return tid;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query for entities matching component requirements&#10;     */&#10;    public ArchetypeQuery query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Delegate archetype construction to ArchetypeManager&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;&#10;        // Copy existing component data (only components present in both)&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;        int[] componentIds = newMask.toComponentIdArray();&#10;        for (int componentTypeId : componentIds) {&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ComponentManager componentManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    private final AtomicInteger nextComponentTypeId = new AtomicInteger(0);&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentMetadata = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentTypeIds.computeIfAbsent(componentClass, cls -&gt; {&#10;            int tid = componentManager.registerComponent(cls);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(cls);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, cls, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id atomically&#10;            nextComponentTypeId.updateAndGet(prev -&gt; Math.max(prev, tid + 1));&#10;            return tid;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query for entities matching component requirements&#10;     */&#10;    public ArchetypeQuery query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Delegate archetype construction to ArchetypeManager&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;&#10;        // Copy existing component data (only components present in both)&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;        int[] componentIds = newMask.toComponentIdArray();&#10;        for (int componentTypeId : componentIds) {&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ComponentMask.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ComponentMask.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import java.util.BitSet;&#10;&#10;/**&#10; * Represents a unique signature of components that an entity possesses.&#10; * Used to identify and group entities with the same component composition.&#10; */&#10;public final class ComponentMask {&#10;    private final BitSet mask;&#10;    private final int hashCode;&#10;&#10;    public ComponentMask() {&#10;        this.mask = new BitSet();&#10;        this.hashCode = 0;&#10;    }&#10;&#10;    private ComponentMask(BitSet mask) {&#10;        this.mask = (BitSet) mask.clone();&#10;        this.hashCode = mask.hashCode();&#10;    }&#10;&#10;    /**&#10;     * Set a component bit in the mask&#10;     */&#10;    public ComponentMask set(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.set(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Clear a component bit from the mask&#10;     */&#10;    public ComponentMask clear(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.clear(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Check if a component is present in the mask&#10;     */&#10;    public boolean has(int componentId) {&#10;        return mask.get(componentId);&#10;    }&#10;&#10;    /**&#10;     * Check if this mask contains all components from another mask&#10;     */&#10;    public boolean contains(ComponentMask other) {&#10;        BitSet intersection = (BitSet) mask.clone();&#10;        intersection.and(other.mask);&#10;        return intersection.equals(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask is a superset of other (WITH semantics).&#10;     */&#10;    public boolean containsAll(ComponentMask other) {&#10;        // other - this == empty ?&#10;        BitSet diff = (BitSet) other.mask.clone();&#10;        diff.andNot(this.mask);&#10;        return diff.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask shares at least one bit with other (ANY semantics).&#10;     */&#10;    public boolean intersects(ComponentMask other) {&#10;        return this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask has no bits in common with other (WITHOUT semantics).&#10;     */&#10;    public boolean containsNone(ComponentMask other) {&#10;        return !this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Get the number of components in this mask&#10;     */&#10;    public int cardinality() {&#10;        return mask.cardinality();&#10;    }&#10;&#10;    /**&#10;     * Return all set component IDs in ascending order.&#10;     */&#10;    public int[] toComponentIdArray() {&#10;        int count = mask.cardinality();&#10;        int[] ids = new int[count];&#10;        int idx = 0;&#10;        for (int bit = mask.nextSetBit(0); bit &gt;= 0; bit = mask.nextSetBit(bit + 1)) {&#10;            ids[idx++] = bit;&#10;        }&#10;        return ids;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        ComponentMask that = (ComponentMask) o;&#10;        return mask.equals(that.mask);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return hashCode;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;ComponentMask{&quot; + mask + '}';&#10;    }&#10;&#10;    /**&#10;     * Create a builder for fluent API&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    public static class Builder {&#10;        private final BitSet mask = new BitSet();&#10;&#10;        public Builder with(int componentId) {&#10;            mask.set(componentId);&#10;            return this;&#10;        }&#10;&#10;        public ComponentMask build() {&#10;            return new ComponentMask(mask);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import java.util.BitSet;&#10;&#10;/**&#10; * Represents a unique signature of components that an entity possesses.&#10; * Used to identify and group entities with the same component composition.&#10; */&#10;public final class ComponentMask {&#10;    private final BitSet mask;&#10;    private final int hashCode;&#10;&#10;    public ComponentMask() {&#10;        this.mask = new BitSet();&#10;        this.hashCode = 0;&#10;    }&#10;&#10;    private ComponentMask(BitSet mask) {&#10;        this.mask = (BitSet) mask.clone();&#10;        this.hashCode = mask.hashCode();&#10;    }&#10;&#10;    /**&#10;     * Set a component bit in the mask&#10;     */&#10;    public ComponentMask set(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.set(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Clear a component bit from the mask&#10;     */&#10;    public ComponentMask clear(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.clear(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Check if a component is present in the mask&#10;     */&#10;    public boolean has(int componentId) {&#10;        return mask.get(componentId);&#10;    }&#10;&#10;    /**&#10;     * Check if this mask contains all components from another mask&#10;     */&#10;    public boolean contains(ComponentMask other) {&#10;        BitSet intersection = (BitSet) mask.clone();&#10;        intersection.and(other.mask);&#10;        return intersection.equals(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask is a superset of other (WITH semantics).&#10;     */&#10;    public boolean containsAll(ComponentMask other) {&#10;        // other - this == empty ?&#10;        BitSet diff = (BitSet) other.mask.clone();&#10;        diff.andNot(this.mask);&#10;        return diff.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask shares at least one bit with other (ANY semantics).&#10;     */&#10;    public boolean intersects(ComponentMask other) {&#10;        return this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask has no bits in common with other (WITHOUT semantics).&#10;     */&#10;    public boolean containsNone(ComponentMask other) {&#10;        return !this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Get the number of components in this mask&#10;     */&#10;    public int cardinality() {&#10;        return mask.cardinality();&#10;    }&#10;&#10;    /**&#10;     * Return all set component IDs in ascending order.&#10;     */&#10;    public int[] toComponentIdArray() {&#10;        int count = mask.cardinality();&#10;        int[] ids = new int[count];&#10;        int idx = 0;&#10;        for (int bit = mask.nextSetBit(0); bit &gt;= 0; bit = mask.nextSetBit(bit + 1)) {&#10;            ids[idx++] = bit;&#10;        }&#10;        return ids;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        ComponentMask that = (ComponentMask) o;&#10;        return mask.equals(that.mask);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return hashCode;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;ComponentMask{&quot; + mask + '}';&#10;    }&#10;&#10;    /**&#10;     * Create a builder for fluent API&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    public static class Builder {&#10;        private final BitSet mask = new BitSet();&#10;&#10;        public Builder with(int componentId) {&#10;            mask.set(componentId);&#10;            return this;&#10;        }&#10;&#10;        public ComponentMask build() {&#10;            return new ComponentMask(mask);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/system/ArchetypeMovementSystem.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/system/ArchetypeMovementSystem.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype.system;&#10;&#10;import com.ethnicthv.ecs.archetype.Archetype;&#10;import com.ethnicthv.ecs.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.components.PositionComponent;&#10;import com.ethnicthv.ecs.components.VelocityComponent;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Movement system optimized for Archetype-based ECS.&#10; * Processes entities in cache-friendly chunks.&#10; */&#10;public final class ArchetypeMovementSystem {&#10;    private final ArchetypeWorld world;&#10;    private final int positionTypeId;&#10;    private final int velocityTypeId;&#10;&#10;    public ArchetypeMovementSystem(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.positionTypeId = world.getComponentTypeId(PositionComponent.class);&#10;        this.velocityTypeId = world.getComponentTypeId(VelocityComponent.class);&#10;    }&#10;&#10;    /**&#10;     * Update all entities that have both Position and Velocity&#10;     */&#10;    public void update(float deltaTime) {&#10;        world.query()&#10;            .with(PositionComponent.class)&#10;            .with(VelocityComponent.class)&#10;            .forEachChunk((chunk, archetype) -&gt; {&#10;                updateChunk(chunk, archetype, deltaTime);&#10;            });&#10;    }&#10;&#10;    private void updateChunk(ArchetypeChunk chunk, Archetype archetype, float deltaTime) {&#10;        int size = chunk.size();&#10;&#10;        // Get component indices in this archetype&#10;        int posIndex = getComponentIndex(archetype, positionTypeId);&#10;        int velIndex = getComponentIndex(archetype, velocityTypeId);&#10;&#10;        // Process each entity in the chunk&#10;        for (int i = 0; i &lt; size; i++) {&#10;            MemorySegment posData = chunk.getComponentData(posIndex, i);&#10;            MemorySegment velData = chunk.getComponentData(velIndex, i);&#10;&#10;            if (posData != null &amp;&amp; velData != null) {&#10;                // Read velocity&#10;                float vx = velData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float vy = velData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Read position&#10;                float x = posData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float y = posData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Update position&#10;                x += vx * deltaTime;&#10;                y += vy * deltaTime;&#10;&#10;                // Write back&#10;                posData.set(ValueLayout.JAVA_FLOAT, 0, x);&#10;                posData.set(ValueLayout.JAVA_FLOAT, 4, y);&#10;            }&#10;        }&#10;    }&#10;&#10;    private int getComponentIndex(Archetype archetype, int componentTypeId) {&#10;        int index = 0;&#10;        ComponentMask mask = archetype.getMask();&#10;        for (int i = 0; i &lt; componentTypeId; i++) {&#10;            if (mask.has(i)) {&#10;                index++;&#10;            }&#10;        }&#10;        return index;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype.system;&#10;&#10;import com.ethnicthv.ecs.archetype.Archetype;&#10;import com.ethnicthv.ecs.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.components.PositionComponent;&#10;import com.ethnicthv.ecs.components.VelocityComponent;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Movement system optimized for Archetype-based ECS.&#10; * Processes entities in cache-friendly chunks.&#10; */&#10;public final class ArchetypeMovementSystem {&#10;    private final ArchetypeWorld world;&#10;    private final int positionTypeId;&#10;    private final int velocityTypeId;&#10;&#10;    public ArchetypeMovementSystem(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.positionTypeId = world.getComponentTypeId(PositionComponent.class);&#10;        this.velocityTypeId = world.getComponentTypeId(VelocityComponent.class);&#10;    }&#10;&#10;    /**&#10;     * Update all entities that have both Position and Velocity&#10;     */&#10;    public void update(float deltaTime) {&#10;        world.query()&#10;            .with(PositionComponent.class)&#10;            .with(VelocityComponent.class)&#10;            .forEachChunk((chunk, archetype) -&gt; {&#10;                updateChunk(chunk, archetype, deltaTime);&#10;            });&#10;    }&#10;&#10;    private void updateChunk(ArchetypeChunk chunk, Archetype archetype, float deltaTime) {&#10;        int size = chunk.size();&#10;&#10;        // Get component indices in this archetype&#10;        int posIndex = getComponentIndex(archetype, positionTypeId);&#10;        int velIndex = getComponentIndex(archetype, velocityTypeId);&#10;&#10;        // Process each entity in the chunk&#10;        for (int i = 0; i &lt; size; i++) {&#10;            MemorySegment posData = chunk.getComponentData(posIndex, i);&#10;            MemorySegment velData = chunk.getComponentData(velIndex, i);&#10;&#10;            if (posData != null &amp;&amp; velData != null) {&#10;                // Read velocity&#10;                float vx = velData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float vy = velData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Read position&#10;                float x = posData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float y = posData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Update position&#10;                x += vx * deltaTime;&#10;                y += vy * deltaTime;&#10;&#10;                // Write back&#10;                posData.set(ValueLayout.JAVA_FLOAT, 0, x);&#10;                posData.set(ValueLayout.JAVA_FLOAT, 4, y);&#10;            }&#10;        }&#10;    }&#10;&#10;    private int getComponentIndex(Archetype archetype, int componentTypeId) {&#10;        int index = 0;&#10;        ComponentMask mask = archetype.getMask();&#10;        for (int i = 0; i &lt; componentTypeId; i++) {&#10;            if (mask.has(i)) {&#10;                index++;&#10;            }&#10;        }&#10;        return index;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentHandle.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentHandle.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a field value by name&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a field value by name&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    private final Map&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new HashMap&lt;&gt;();&#10;    private int nextTypeId = 0;&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        if (componentTypeIds.containsKey(componentClass)) {&#10;            return componentTypeIds.get(componentClass);&#10;        }&#10;&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Build descriptor through reflection&#10;        ComponentDescriptor descriptor = buildDescriptor(componentClass);&#10;        descriptors.put(componentClass, descriptor);&#10;&#10;        int typeId = nextTypeId++;&#10;        componentTypeIds.put(componentClass, typeId);&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    private final Map&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new HashMap&lt;&gt;();&#10;    private int nextTypeId = 0;&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        if (componentTypeIds.containsKey(componentClass)) {&#10;            return componentTypeIds.get(componentClass);&#10;        }&#10;&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Build descriptor through reflection&#10;        ComponentDescriptor descriptor = buildDescriptor(componentClass);&#10;        descriptors.put(componentClass, descriptor);&#10;&#10;        int typeId = nextTypeId++;&#10;        componentTypeIds.put(componentClass, typeId);&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/api/IWorld.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/api/IWorld.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.api;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;&#10;/**&#10; * Public API for the ECS world, providing safe access to entity and component management.&#10; * &lt;p&gt;&#10; * This interface exposes the core functionality of the Archetype-based ECS system&#10; * without revealing internal implementation details.&#10; */&#10;public interface IWorld extends AutoCloseable {&#10;    /**&#10;     * Register a component type in the world.&#10;     *&#10;     * @param componentClass The component class to register.&#10;     * @return The unique type ID assigned to this component.&#10;     */&#10;    &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass);&#10;&#10;    /**&#10;     * Create a new entity with no components.&#10;     *&#10;     * @return The unique ID of the newly created entity.&#10;     */&#10;    int createEntity();&#10;&#10;    /**&#10;     * Create a new entity with the specified component types.&#10;     * Components are initialized with default (zeroed) values.&#10;     *&#10;     * @param componentClasses The component classes to add to the entity.&#10;     * @return The unique ID of the newly created entity.&#10;     */&#10;    int createEntity(Class&lt;?&gt;... componentClasses);&#10;&#10;    /**&#10;     * Check if an entity has a specific component.&#10;     *&#10;     * @param entityId The entity ID.&#10;     * @param componentClass The component class to check for.&#10;     * @return True if the entity has the component, false otherwise.&#10;     */&#10;    &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass);&#10;&#10;    /**&#10;     * Destroy an entity and remove it from the world.&#10;     *&#10;     * @param entityId The ID of the entity to destroy.&#10;     */&#10;    void destroyEntity(int entityId);&#10;&#10;    /**&#10;     * Create a query builder for filtering entities based on component requirements.&#10;     *&#10;     * @return A new query builder instance.&#10;     */&#10;    IQueryBuilder query();&#10;&#10;    /**&#10;     * Get the total number of entities currently in the world.&#10;     *&#10;     * @return The entity count.&#10;     */&#10;    int getEntityCount();&#10;&#10;    /**&#10;     * Get the component type ID for a registered component class.&#10;     *&#10;     * @param componentClass The component class.&#10;     * @return The type ID, or null if not registered.&#10;     */&#10;    Integer getComponentTypeId(Class&lt;?&gt; componentClass);&#10;&#10;    /**&#10;     * Close the world and release all associated resources.&#10;     */&#10;    @Override&#10;    void close();&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.api;&#13;&#10;&#13;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#13;&#10;&#13;&#10;/**&#13;&#10; * Public API for the ECS world, providing safe access to entity and component management.&#13;&#10; * &lt;p&gt;&#13;&#10; * This interface exposes the core functionality of the Archetype-based ECS system&#13;&#10; * without revealing internal implementation details.&#13;&#10; */&#13;&#10;public interface IWorld extends AutoCloseable {&#13;&#10;    /**&#13;&#10;     * Register a component type in the world.&#13;&#10;     *&#13;&#10;     * @param componentClass The component class to register.&#13;&#10;     * @return The unique type ID assigned to this component.&#13;&#10;     */&#13;&#10;    &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create a new entity with no components.&#13;&#10;     *&#13;&#10;     * @return The unique ID of the newly created entity.&#13;&#10;     */&#13;&#10;    int createEntity();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create a new entity with the specified component types.&#13;&#10;     * Components are initialized with default (zeroed) values.&#13;&#10;     *&#13;&#10;     * @param componentClasses The component classes to add to the entity.&#13;&#10;     * @return The unique ID of the newly created entity.&#13;&#10;     */&#13;&#10;    int createEntity(Class&lt;?&gt;... componentClasses);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Check if an entity has a specific component.&#13;&#10;     *&#13;&#10;     * @param entityId The entity ID.&#13;&#10;     * @param componentClass The component class to check for.&#13;&#10;     * @return True if the entity has the component, false otherwise.&#13;&#10;     */&#13;&#10;    &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Destroy an entity and remove it from the world.&#13;&#10;     *&#13;&#10;     * @param entityId The ID of the entity to destroy.&#13;&#10;     */&#13;&#10;    void destroyEntity(int entityId);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create a query builder for filtering entities based on component requirements.&#13;&#10;     *&#13;&#10;     * @return A new query builder instance.&#13;&#10;     */&#13;&#10;    IQueryBuilder query();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get the total number of entities currently in the world.&#13;&#10;     *&#13;&#10;     * @return The entity count.&#13;&#10;     */&#13;&#10;    int getEntityCount();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get the component type ID for a registered component class.&#13;&#10;     *&#13;&#10;     * @param componentClass The component class.&#13;&#10;     * @return The type ID, or null if not registered.&#13;&#10;     */&#13;&#10;    Integer getComponentTypeId(Class&lt;?&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Close the world and release all associated resources.&#13;&#10;     */&#13;&#10;    @Override&#13;&#10;    void close();&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/api/archetype/IQueryBuilder.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/api/archetype/IQueryBuilder.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.api.archetype;&#10;&#10;/**&#10; * Mutable builder interface for constructing archetype queries.&#10; * &lt;p&gt;&#10; * This interface follows the Builder pattern and allows fluent configuration&#10; * of query criteria. Once configuration is complete, call {@link #build()}&#10; * to create an immutable {@link IQuery} instance.&#10; * &lt;p&gt;&#10; * Example usage:&#10; * &lt;pre&gt;{@code&#10; * IQuery query = world.query()&#10; *     .with(Position.class)&#10; *     .with(Velocity.class)&#10; *     .without(Stunned.class)&#10; *     .build();&#10; * }&lt;/pre&gt;&#10; *&#10; * @see IQuery&#10; */&#10;public interface IQueryBuilder {&#10;&#10;    /**&#10;     * Add a required component to the query.&#10;     * &lt;p&gt;&#10;     * Entities must have this component to match the query.&#10;     *&#10;     * @param componentClass the component class to require&#10;     * @param &lt;T&gt; the component type&#10;     * @return this builder for chaining&#10;     */&#10;    &lt;T&gt; IQueryBuilder with(Class&lt;T&gt; componentClass);&#10;&#10;    /**&#10;     * Add an excluded component to the query.&#10;     * &lt;p&gt;&#10;     * Entities must NOT have this component to match the query.&#10;     *&#10;     * @param componentClass the component class to exclude&#10;     * @param &lt;T&gt; the component type&#10;     * @return this builder for chaining&#10;     */&#10;    &lt;T&gt; IQueryBuilder without(Class&lt;T&gt; componentClass);&#10;&#10;    /**&#10;     * Add optional components to the query.&#10;     * &lt;p&gt;&#10;     * Entities must have at least ONE of these components to match the query.&#10;     *&#10;     * @param componentClasses the component classes (at least one required)&#10;     * @return this builder for chaining&#10;     */&#10;    IQueryBuilder any(Class&lt;?&gt;... componentClasses);&#10;&#10;    /**&#10;     * Filter by a managed shared component value. Only chunks in groups with this shared value will be considered.&#10;     */&#10;    IQueryBuilder withShared(Object managedValue);&#10;&#10;    /**&#10;     * Filter by an unmanaged shared component value (type + 64-bit value).&#10;     */&#10;    IQueryBuilder withShared(Class&lt;?&gt; unmanagedSharedType, long value);&#10;&#10;    /**&#10;     * Build an immutable query from this builder's configuration.&#10;     * &lt;p&gt;&#10;     * The returned {@link IQuery} is thread-safe and immutable.&#10;     * This builder can continue to be used after calling build().&#10;     *&#10;     * @return an immutable query instance&#10;     */&#10;    IQuery build();&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.api.archetype;&#13;&#10;&#13;&#10;/**&#13;&#10; * Mutable builder interface for constructing archetype queries.&#13;&#10; * &lt;p&gt;&#13;&#10; * This interface follows the Builder pattern and allows fluent configuration&#13;&#10; * of query criteria. Once configuration is complete, call {@link #build()}&#13;&#10; * to create an immutable {@link IQuery} instance.&#13;&#10; * &lt;p&gt;&#13;&#10; * Example usage:&#13;&#10; * &lt;pre&gt;{@code&#13;&#10; * IQuery query = world.query()&#13;&#10; *     .with(Position.class)&#13;&#10; *     .with(Velocity.class)&#13;&#10; *     .without(Stunned.class)&#13;&#10; *     .build();&#13;&#10; * }&lt;/pre&gt;&#13;&#10; *&#13;&#10; * @see IQuery&#13;&#10; */&#13;&#10;public interface IQueryBuilder {&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Add a required component to the query.&#13;&#10;     * &lt;p&gt;&#13;&#10;     * Entities must have this component to match the query.&#13;&#10;     *&#13;&#10;     * @param componentClass the component class to require&#13;&#10;     * @param &lt;T&gt; the component type&#13;&#10;     * @return this builder for chaining&#13;&#10;     */&#13;&#10;    &lt;T&gt; IQueryBuilder with(Class&lt;T&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Add an excluded component to the query.&#13;&#10;     * &lt;p&gt;&#13;&#10;     * Entities must NOT have this component to match the query.&#13;&#10;     *&#13;&#10;     * @param componentClass the component class to exclude&#13;&#10;     * @param &lt;T&gt; the component type&#13;&#10;     * @return this builder for chaining&#13;&#10;     */&#13;&#10;    &lt;T&gt; IQueryBuilder without(Class&lt;T&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Add optional components to the query.&#13;&#10;     * &lt;p&gt;&#13;&#10;     * Entities must have at least ONE of these components to match the query.&#13;&#10;     *&#13;&#10;     * @param componentClasses the component classes (at least one required)&#13;&#10;     * @return this builder for chaining&#13;&#10;     */&#13;&#10;    IQueryBuilder any(Class&lt;?&gt;... componentClasses);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Filter by a managed shared component value. Only chunks in groups with this shared value will be considered.&#13;&#10;     */&#13;&#10;    IQueryBuilder withShared(Object managedValue);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Filter by an unmanaged shared component value (type + 64-bit value).&#13;&#10;     */&#13;&#10;    IQueryBuilder withShared(Class&lt;?&gt; unmanagedSharedType, long value);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Build an immutable query from this builder's configuration.&#13;&#10;     * &lt;p&gt;&#13;&#10;     * The returned {@link IQuery} is thread-safe and immutable.&#13;&#10;     * This builder can continue to be used after calling build().&#13;&#10;     *&#13;&#10;     * @return an immutable query instance&#13;&#10;     */&#13;&#10;    IQuery build();&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/Archetype.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/Archetype.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.ArrayList;&#10;import java.util.Collection;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Archetype groups entities that share the same set of components.&#10; * It stores component descriptors and manages a list of chunks.&#10; */&#10;public final class Archetype implements IArchetype {&#10;&#10;    private final int[] componentIds;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] componentElementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final ComponentMask mask; // cached mask&#10;    private final Arena arena; // arena for new chunk allocations&#10;&#10;    private final int[] allComponentTypeIds;&#10;    private final int[] managedTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; managedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; componentIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // New: per-shared-value grouping of chunks&#10;    private final ConcurrentHashMap&lt;SharedValueKey, ChunkGroup&gt; chunkGroups = new ConcurrentHashMap&lt;&gt;();&#10;    // New: shared component type ids (unmanaged and managed) and their index maps&#10;    private final int[] sharedManagedTypeIds;&#10;    private final int[] sharedUnmanagedTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; sharedManagedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; sharedUnmanagedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // constants preserved&#10;    private static final int CHUNK_SIZE = 16 * 1024;&#10;    private static final int DEFAULT_ENTITIES_PER_CHUNK = 64;&#10;&#10;    public Archetype(ComponentMask mask, int[] componentIds, ComponentDescriptor[] descriptors, Arena arena) {&#10;        if (componentIds.length != descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;componentIds/descriptors length mismatch&quot;);&#10;        }&#10;        this.componentIds = componentIds;&#10;        this.descriptors = descriptors;&#10;        this.componentElementSizes = new long[descriptors.length];&#10;        this.mask = mask;&#10;        this.arena = arena;&#10;        this.allComponentTypeIds = null;&#10;        this.managedTypeIds = new int[0];&#10;        this.sharedManagedTypeIds = new int[0];&#10;        this.sharedUnmanagedTypeIds = new int[0];&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long s = descriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        if (totalPerEntity &lt;= 0) {&#10;            this.entitiesPerChunk = DEFAULT_ENTITIES_PER_CHUNK;&#10;        } else {&#10;            this.entitiesPerChunk = Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        }&#10;        // Create default group to preserve previous behavior (one initial chunk)&#10;        getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;    }&#10;&#10;    // Managed-aware constructor: unmanaged descriptors + separate managed type ids&#10;    public Archetype(ComponentMask mask, int[] allComponentTypeIds, ComponentDescriptor[] unmanagedDescriptors, int[] managedTypeIds, Arena arena) {&#10;        this.mask = mask;&#10;        this.allComponentTypeIds = allComponentTypeIds;&#10;        this.managedTypeIds = managedTypeIds != null ? managedTypeIds.clone() : new int[0];&#10;        this.componentIds = new int[unmanagedDescriptors.length];&#10;        this.descriptors = unmanagedDescriptors;&#10;        this.componentElementSizes = new long[unmanagedDescriptors.length];&#10;        this.arena = arena;&#10;        this.sharedManagedTypeIds = new int[0];&#10;        this.sharedUnmanagedTypeIds = new int[0];&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; unmanagedDescriptors.length; i++) {&#10;            long s = unmanagedDescriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        this.entitiesPerChunk = (totalPerEntity &lt;= 0) ? DEFAULT_ENTITIES_PER_CHUNK : Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        // Create default group to preserve previous behavior&#10;        getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;    }&#10;&#10;    // New: Fully managed/shared aware constructor&#10;    public Archetype(ComponentMask mask,&#10;                     int[] allComponentTypeIds,&#10;                     ComponentDescriptor[] unmanagedInstanceDescriptors,&#10;                     int[] managedInstanceTypeIds,&#10;                     int[] unmanagedSharedTypeIds,&#10;                     int[] managedSharedTypeIds,&#10;                     Arena arena) {&#10;        this.mask = mask;&#10;        this.allComponentTypeIds = allComponentTypeIds;&#10;        this.managedTypeIds = managedInstanceTypeIds != null ? managedInstanceTypeIds.clone() : new int[0];&#10;        this.sharedUnmanagedTypeIds = unmanagedSharedTypeIds != null ? unmanagedSharedTypeIds.clone() : new int[0];&#10;        this.sharedManagedTypeIds = managedSharedTypeIds != null ? managedSharedTypeIds.clone() : new int[0];&#10;        this.componentIds = new int[unmanagedInstanceDescriptors.length];&#10;        this.descriptors = unmanagedInstanceDescriptors;&#10;        this.componentElementSizes = new long[unmanagedInstanceDescriptors.length];&#10;        this.arena = arena;&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; unmanagedInstanceDescriptors.length; i++) {&#10;            long s = unmanagedInstanceDescriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        this.entitiesPerChunk = (totalPerEntity &lt;= 0) ? DEFAULT_ENTITIES_PER_CHUNK : Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;&#10;        // Build index maps for shared type ids&#10;        for (int i = 0; i &lt; this.sharedManagedTypeIds.length; i++) {&#10;            sharedManagedIndexMap.put(this.sharedManagedTypeIds[i], i);&#10;        }&#10;        for (int i = 0; i &lt; this.sharedUnmanagedTypeIds.length; i++) {&#10;            sharedUnmanagedIndexMap.put(this.sharedUnmanagedTypeIds[i], i);&#10;        }&#10;        // Create default group to preserve previous behavior&#10;        getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;    }&#10;&#10;    // Internal helper to set unmanaged type ids after construction (used by ArchetypeManager)&#10;    void setUnmanagedTypeIds(int[] unmanagedTypeIds) {&#10;        if (unmanagedTypeIds == null || unmanagedTypeIds.length != this.descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;unmanagedTypeIds length mismatch&quot;);&#10;        }&#10;        System.arraycopy(unmanagedTypeIds, 0, this.componentIds, 0, unmanagedTypeIds.length);&#10;    }&#10;&#10;    /**&#10;     * Get component mask (cached)&#10;     */&#10;    public ComponentMask getMask() { return mask; }&#10;&#10;    public int[] getComponentIds() { return componentIds; }&#10;&#10;    @Override&#10;    public int[] getComponentTypeIds() {&#10;        return allComponentTypeIds != null ? allComponentTypeIds : getComponentIds();&#10;    }&#10;&#10;    public ComponentDescriptor[] getDescriptors() { return descriptors; }&#10;&#10;    public int getEntitiesPerChunk() { return entitiesPerChunk; }&#10;&#10;    public long[] getElementSizes() { return componentElementSizes; }&#10;&#10;    /**&#10;     * Return a snapshot list of chunks. Order is physical array order.&#10;     */&#10;    @Override&#10;    public List&lt;IArchetypeChunk&gt; getChunks() {&#10;        // Backward compatible: if no shared grouping used, return chunks from a default group if present&#10;        ChunkGroup defaultGroup = chunkGroups.getOrDefault(new SharedValueKey(null, null), null);&#10;        if (defaultGroup == null) return List.of();&#10;        List&lt;ArchetypeChunk&gt; list = defaultGroup.getChunks();&#10;        return new ArrayList&lt;&gt;(list);&#10;    }&#10;&#10;    /**&#10;     * Get a direct reference to the current chunks array.&#10;     * &lt;p&gt;&#10;     * This method provides thread-safe access to the chunks array for parallel iteration.&#10;     * Since the 'chunks' field is declared as volatile, reading it guarantees visibility&#10;     * of the most recent array reference. The array itself may be replaced during resize&#10;     * operations, but the reference returned here is stable for the duration of its use.&#10;     * &lt;p&gt;&#10;     * This is primarily intended for parallel processing where multiple threads need to&#10;     * iterate over chunks concurrently without creating defensive copies.&#10;     *&#10;     * @return A reference to the current chunks array. The caller should also read&#10;     *         {@link #chunkCount()} to determine how many valid entries exist.&#10;     */&#10;    public ArchetypeChunk[] getChunksSnapshot() {&#10;        ChunkGroup defaultGroup = chunkGroups.getOrDefault(new SharedValueKey(null, null), null);&#10;        return defaultGroup != null ? defaultGroup.getChunksSnapshot() : new ArchetypeChunk[0];&#10;    }&#10;&#10;    public ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        // Place into default group when no shared key is defined&#10;        ChunkGroup group = getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;        return group.addEntity(entityId);&#10;    }&#10;&#10;    public void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        // Assume default group for backward compatibility&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        if (defaultGroup != null) defaultGroup.removeEntity(location);&#10;    }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        if (defaultGroup == null) throw new IndexOutOfBoundsException();&#10;        return defaultGroup.getChunk(chunkIndex);&#10;    }&#10;&#10;    public int chunkCount() {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        return defaultGroup != null ? defaultGroup.chunkCount() : 0;&#10;    }&#10;&#10;    @Override&#10;    public int getChunkCount() { return chunkCount(); }&#10;&#10;    @Override&#10;    public int getEntityCount() {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        return defaultGroup != null ? defaultGroup.getEntityCount() : 0;&#10;    }&#10;&#10;    /**&#10;     * Iterate over all entities in this archetype.&#10;     * Weakly consistent: concurrent adds/removes may or may not be observed by this traversal,&#10;     * and an entity may be skipped or visited once depending on timing. The traversal never throws&#10;     * due to concurrent modification and aims to be cache-friendly.&#10;     */&#10;    public void forEach(ArchetypeIterator iterator) {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        if (defaultGroup == null) return;&#10;        defaultGroup.forEach(iterator);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public MemorySegment getComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex) {&#10;        ArchetypeChunk[] snap = this.getChunksSnapshot();&#10;        return (location.chunkIndex &gt;= 0 &amp;&amp; location.chunkIndex &lt; snap.length)&#10;            ? snap[location.chunkIndex].getComponentData(componentIndex, location.indexInChunk)&#10;            : null;&#10;    }&#10;&#10;    /**&#10;     * Set component data for an entity&#10;     */&#10;    public void setComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex, MemorySegment data) {&#10;        ArchetypeChunk[] snap = this.getChunksSnapshot();&#10;        if (location.chunkIndex &gt;= 0 &amp;&amp; location.chunkIndex &lt; snap.length) {&#10;            snap[location.chunkIndex].setComponentData(componentIndex, location.indexInChunk, data);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the index of a component type ID within this archetype's component arrays, or -1 if absent.&#10;     * Uses a thread-safe lazy cache to compute the mapping at most once per component type id.&#10;     */&#10;    public int indexOfComponentType(int componentTypeId) {&#10;        return componentIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                if (componentIds[i] == tid) {&#10;                    return i;&#10;                }&#10;            }&#10;            return -1; // not present in this archetype or is managed-only&#10;        });&#10;    }&#10;&#10;    // Managed helpers&#10;    public int getManagedTypeIndex(int componentTypeId) {&#10;        if (managedTypeIds.length == 0) return -1;&#10;        return managedIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; managedTypeIds.length; i++) if (managedTypeIds[i] == tid) return i;&#10;            return -1;&#10;        });&#10;    }&#10;&#10;    public int[] getManagedTypeIds() { return managedTypeIds; }&#10;&#10;    // New APIs for chunk group by shared values&#10;    public ChunkGroup getOrCreateChunkGroup(SharedValueKey key) {&#10;        return chunkGroups.computeIfAbsent(key, k -&gt; new ChunkGroup(descriptors, componentElementSizes, entitiesPerChunk, arena, managedTypeIds.length));&#10;    }&#10;&#10;    public ChunkGroup getChunkGroup(SharedValueKey key) {&#10;        return chunkGroups.get(key);&#10;    }&#10;&#10;    public int[] getSharedManagedTypeIds() { return sharedManagedTypeIds; }&#10;    public int[] getSharedUnmanagedTypeIds() { return sharedUnmanagedTypeIds; }&#10;&#10;    public int getSharedManagedIndex(int componentTypeId) {&#10;        Integer idx = sharedManagedIndexMap.get(componentTypeId);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public int getSharedUnmanagedIndex(int componentTypeId) {&#10;        Integer idx = sharedUnmanagedIndexMap.get(componentTypeId);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public java.util.Collection&lt;ChunkGroup&gt; getAllChunkGroups() {&#10;        return chunkGroups.values();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.ArrayList;&#10;import java.util.Collection;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Archetype groups entities that share the same set of components.&#10; * It stores component descriptors and manages a list of chunks.&#10; */&#10;public final class Archetype implements IArchetype {&#10;&#10;    private final int[] componentIds;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] componentElementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final ComponentMask mask; // cached mask&#10;    private final Arena arena; // arena for new chunk allocations&#10;&#10;    private final int[] allComponentTypeIds;&#10;    private final int[] managedTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; managedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; componentIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // New: per-shared-value grouping of chunks&#10;    private final ConcurrentHashMap&lt;SharedValueKey, ChunkGroup&gt; chunkGroups = new ConcurrentHashMap&lt;&gt;();&#10;    // New: shared component type ids (unmanaged and managed) and their index maps&#10;    private final int[] sharedManagedTypeIds;&#10;    private final int[] sharedUnmanagedTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; sharedManagedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; sharedUnmanagedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // constants preserved&#10;    private static final int CHUNK_SIZE = 16 * 1024;&#10;    private static final int DEFAULT_ENTITIES_PER_CHUNK = 64;&#10;&#10;    public Archetype(ComponentMask mask, int[] componentIds, ComponentDescriptor[] descriptors, Arena arena) {&#10;        if (componentIds.length != descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;componentIds/descriptors length mismatch&quot;);&#10;        }&#10;        this.componentIds = componentIds;&#10;        this.descriptors = descriptors;&#10;        this.componentElementSizes = new long[descriptors.length];&#10;        this.mask = mask;&#10;        this.arena = arena;&#10;        this.allComponentTypeIds = null;&#10;        this.managedTypeIds = new int[0];&#10;        this.sharedManagedTypeIds = new int[0];&#10;        this.sharedUnmanagedTypeIds = new int[0];&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long s = descriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        if (totalPerEntity &lt;= 0) {&#10;            this.entitiesPerChunk = DEFAULT_ENTITIES_PER_CHUNK;&#10;        } else {&#10;            this.entitiesPerChunk = Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        }&#10;        // Create default group to preserve previous behavior (one initial chunk)&#10;        getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;    }&#10;&#10;    // Managed-aware constructor: unmanaged descriptors + separate managed type ids&#10;    public Archetype(ComponentMask mask, int[] allComponentTypeIds, ComponentDescriptor[] unmanagedDescriptors, int[] managedTypeIds, Arena arena) {&#10;        this.mask = mask;&#10;        this.allComponentTypeIds = allComponentTypeIds;&#10;        this.managedTypeIds = managedTypeIds != null ? managedTypeIds.clone() : new int[0];&#10;        this.componentIds = new int[unmanagedDescriptors.length];&#10;        this.descriptors = unmanagedDescriptors;&#10;        this.componentElementSizes = new long[unmanagedDescriptors.length];&#10;        this.arena = arena;&#10;        this.sharedManagedTypeIds = new int[0];&#10;        this.sharedUnmanagedTypeIds = new int[0];&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; unmanagedDescriptors.length; i++) {&#10;            long s = unmanagedDescriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        this.entitiesPerChunk = (totalPerEntity &lt;= 0) ? DEFAULT_ENTITIES_PER_CHUNK : Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        // Create default group to preserve previous behavior&#10;        getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;    }&#10;&#10;    // New: Fully managed/shared aware constructor&#10;    public Archetype(ComponentMask mask,&#10;                     int[] allComponentTypeIds,&#10;                     ComponentDescriptor[] unmanagedInstanceDescriptors,&#10;                     int[] managedInstanceTypeIds,&#10;                     int[] unmanagedSharedTypeIds,&#10;                     int[] managedSharedTypeIds,&#10;                     Arena arena) {&#10;        this.mask = mask;&#10;        this.allComponentTypeIds = allComponentTypeIds;&#10;        this.managedTypeIds = managedInstanceTypeIds != null ? managedInstanceTypeIds.clone() : new int[0];&#10;        this.sharedUnmanagedTypeIds = unmanagedSharedTypeIds != null ? unmanagedSharedTypeIds.clone() : new int[0];&#10;        this.sharedManagedTypeIds = managedSharedTypeIds != null ? managedSharedTypeIds.clone() : new int[0];&#10;        this.componentIds = new int[unmanagedInstanceDescriptors.length];&#10;        this.descriptors = unmanagedInstanceDescriptors;&#10;        this.componentElementSizes = new long[unmanagedInstanceDescriptors.length];&#10;        this.arena = arena;&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; unmanagedInstanceDescriptors.length; i++) {&#10;            long s = unmanagedInstanceDescriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        this.entitiesPerChunk = (totalPerEntity &lt;= 0) ? DEFAULT_ENTITIES_PER_CHUNK : Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;&#10;        // Build index maps for shared type ids&#10;        for (int i = 0; i &lt; this.sharedManagedTypeIds.length; i++) {&#10;            sharedManagedIndexMap.put(this.sharedManagedTypeIds[i], i);&#10;        }&#10;        for (int i = 0; i &lt; this.sharedUnmanagedTypeIds.length; i++) {&#10;            sharedUnmanagedIndexMap.put(this.sharedUnmanagedTypeIds[i], i);&#10;        }&#10;        // Create default group to preserve previous behavior&#10;        getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;    }&#10;&#10;    // Internal helper to set unmanaged type ids after construction (used by ArchetypeManager)&#10;    void setUnmanagedTypeIds(int[] unmanagedTypeIds) {&#10;        if (unmanagedTypeIds == null || unmanagedTypeIds.length != this.descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;unmanagedTypeIds length mismatch&quot;);&#10;        }&#10;        System.arraycopy(unmanagedTypeIds, 0, this.componentIds, 0, unmanagedTypeIds.length);&#10;    }&#10;&#10;    /**&#10;     * Get component mask (cached)&#10;     */&#10;    public ComponentMask getMask() { return mask; }&#10;&#10;    public int[] getComponentIds() { return componentIds; }&#10;&#10;    @Override&#10;    public int[] getComponentTypeIds() {&#10;        return allComponentTypeIds != null ? allComponentTypeIds : getComponentIds();&#10;    }&#10;&#10;    public ComponentDescriptor[] getDescriptors() { return descriptors; }&#10;&#10;    public int getEntitiesPerChunk() { return entitiesPerChunk; }&#10;&#10;    public long[] getElementSizes() { return componentElementSizes; }&#10;&#10;    /**&#10;     * Return a snapshot list of chunks. Order is physical array order.&#10;     */&#10;    @Override&#10;    public List&lt;IArchetypeChunk&gt; getChunks() {&#10;        // Backward compatible: if no shared grouping used, return chunks from a default group if present&#10;        ChunkGroup defaultGroup = chunkGroups.getOrDefault(new SharedValueKey(null, null), null);&#10;        if (defaultGroup == null) return List.of();&#10;        List&lt;ArchetypeChunk&gt; list = defaultGroup.getChunks();&#10;        return new ArrayList&lt;&gt;(list);&#10;    }&#10;&#10;    /**&#10;     * Get a direct reference to the current chunks array.&#10;     * &lt;p&gt;&#10;     * This method provides thread-safe access to the chunks array for parallel iteration.&#10;     * Since the 'chunks' field is declared as volatile, reading it guarantees visibility&#10;     * of the most recent array reference. The array itself may be replaced during resize&#10;     * operations, but the reference returned here is stable for the duration of its use.&#10;     * &lt;p&gt;&#10;     * This is primarily intended for parallel processing where multiple threads need to&#10;     * iterate over chunks concurrently without creating defensive copies.&#10;     *&#10;     * @return A reference to the current chunks array. The caller should also read&#10;     *         {@link #chunkCount()} to determine how many valid entries exist.&#10;     */&#10;    public ArchetypeChunk[] getChunksSnapshot() {&#10;        ChunkGroup defaultGroup = chunkGroups.getOrDefault(new SharedValueKey(null, null), null);&#10;        return defaultGroup != null ? defaultGroup.getChunksSnapshot() : new ArchetypeChunk[0];&#10;    }&#10;&#10;    public ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        // Place into default group when no shared key is defined&#10;        ChunkGroup group = getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;        return group.addEntity(entityId);&#10;    }&#10;&#10;    public void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        // Assume default group for backward compatibility&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        if (defaultGroup != null) defaultGroup.removeEntity(location);&#10;    }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        if (defaultGroup == null) throw new IndexOutOfBoundsException();&#10;        return defaultGroup.getChunk(chunkIndex);&#10;    }&#10;&#10;    public int chunkCount() {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        return defaultGroup != null ? defaultGroup.chunkCount() : 0;&#10;    }&#10;&#10;    @Override&#10;    public int getChunkCount() { return chunkCount(); }&#10;&#10;    @Override&#10;    public int getEntityCount() {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        return defaultGroup != null ? defaultGroup.getEntityCount() : 0;&#10;    }&#10;&#10;    /**&#10;     * Iterate over all entities in this archetype.&#10;     * Weakly consistent: concurrent adds/removes may or may not be observed by this traversal,&#10;     * and an entity may be skipped or visited once depending on timing. The traversal never throws&#10;     * due to concurrent modification and aims to be cache-friendly.&#10;     */&#10;    public void forEach(ArchetypeIterator iterator) {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        if (defaultGroup == null) return;&#10;        defaultGroup.forEach(iterator);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public MemorySegment getComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex) {&#10;        ArchetypeChunk[] snap = this.getChunksSnapshot();&#10;        return (location.chunkIndex &gt;= 0 &amp;&amp; location.chunkIndex &lt; snap.length)&#10;            ? snap[location.chunkIndex].getComponentData(componentIndex, location.indexInChunk)&#10;            : null;&#10;    }&#10;&#10;    /**&#10;     * Set component data for an entity&#10;     */&#10;    public void setComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex, MemorySegment data) {&#10;        ArchetypeChunk[] snap = this.getChunksSnapshot();&#10;        if (location.chunkIndex &gt;= 0 &amp;&amp; location.chunkIndex &lt; snap.length) {&#10;            snap[location.chunkIndex].setComponentData(componentIndex, location.indexInChunk, data);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the index of a component type ID within this archetype's component arrays, or -1 if absent.&#10;     * Uses a thread-safe lazy cache to compute the mapping at most once per component type id.&#10;     */&#10;    public int indexOfComponentType(int componentTypeId) {&#10;        return componentIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                if (componentIds[i] == tid) {&#10;                    return i;&#10;                }&#10;            }&#10;            return -1; // not present in this archetype or is managed-only&#10;        });&#10;    }&#10;&#10;    // Managed helpers&#10;    public int getManagedTypeIndex(int componentTypeId) {&#10;        if (managedTypeIds.length == 0) return -1;&#10;        return managedIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; managedTypeIds.length; i++) if (managedTypeIds[i] == tid) return i;&#10;            return -1;&#10;        });&#10;    }&#10;&#10;    public int[] getManagedTypeIds() { return managedTypeIds; }&#10;&#10;    // New APIs for chunk group by shared values&#10;    public ChunkGroup getOrCreateChunkGroup(SharedValueKey key) {&#10;        return chunkGroups.computeIfAbsent(key, k -&gt; new ChunkGroup(descriptors, componentElementSizes, entitiesPerChunk, arena, managedTypeIds.length));&#10;    }&#10;&#10;    public ChunkGroup getChunkGroup(SharedValueKey key) {&#10;        return chunkGroups.get(key);&#10;    }&#10;&#10;    public int[] getSharedManagedTypeIds() { return sharedManagedTypeIds; }&#10;    public int[] getSharedUnmanagedTypeIds() { return sharedUnmanagedTypeIds; }&#10;&#10;    public int getSharedManagedIndex(int componentTypeId) {&#10;        Integer idx = sharedManagedIndexMap.get(componentTypeId);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public int getSharedUnmanagedIndex(int componentTypeId) {&#10;        Integer idx = sharedUnmanagedIndexMap.get(componentTypeId);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public java.util.Collection&lt;ChunkGroup&gt; getAllChunkGroups() {&#10;        return chunkGroups.values();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeChunk.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeChunk.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.exception.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;import java.util.Arrays;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk implements IArchetypeChunk {&#10;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    // New: per-managed-type ticket arrays; may be empty if no managed types&#10;    private final int[][] managedComponentIndexArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    // Backwards-compatible constructor (no managed types)&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this(descriptors, elementSizes, capacity, arena, 0);&#10;    }&#10;&#10;    // New constructor supporting managed types&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena, int managedTypeCount) {&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // Initialize managed ticket arrays (filled with -1 indicating empty)&#10;        if (managedTypeCount &gt; 0) {&#10;            this.managedComponentIndexArrays = new int[managedTypeCount][];&#10;            for (int i = 0; i &lt; managedTypeCount; i++) {&#10;                int[] arr = new int[capacity];&#10;                Arrays.fill(arr, -1);&#10;                this.managedComponentIndexArrays[i] = arr;&#10;            }&#10;        } else {&#10;            this.managedComponentIndexArrays = new int[0][];&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                int newSize = size.incrementAndGet();&#10;                if (newSize &gt; capacity) {&#10;                    // Defensive: should never happen; roll back and fail fast&#10;                    size.decrementAndGet();&#10;                    clearBit(head);&#10;                    entityIds.set(head, -1);&#10;                    // push slot back to free list&#10;                    while (true) {&#10;                        int h = freeHead.get();&#10;                        nextFree[head] = h;&#10;                        if (freeHead.compareAndSet(h, head)) break;&#10;                    }&#10;                    throw new IllegalStateException(&quot;ArchetypeChunk size overflow: &quot; + newSize + &quot; &gt; capacity=&quot; + capacity);&#10;                }&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        int newSize = size.decrementAndGet();&#10;        if (newSize &lt; 0) {&#10;            // Defensive: should never happen; restore and fail fast&#10;            size.incrementAndGet();&#10;            entityIds.set(index, -1);&#10;            throw new IllegalStateException(&quot;ArchetypeChunk size underflow: &quot; + newSize);&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;        // Reset managed tickets to -1 for this slot&#10;        for (int i = 0; i &lt; managedComponentIndexArrays.length; i++) {&#10;            managedComponentIndexArrays[i][idx] = -1;&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    @Override&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    @Override&#10;    public int getCapacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    @Override&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    @Override&#10;    public int getEntityCount() {&#10;        return size();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;&#10;    // ===== Managed component ticket accessors =====&#10;&#10;    public int[] getManagedIndexArray(int managedTypeIndex) {&#10;        return managedComponentIndexArrays[managedTypeIndex];&#10;    }&#10;&#10;    public int getManagedTicket(int managedTypeIndex, int elementIndex) {&#10;        if (managedTypeIndex &lt; 0 || managedTypeIndex &gt;= managedComponentIndexArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;managedTypeIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        return managedComponentIndexArrays[managedTypeIndex][elementIndex];&#10;    }&#10;&#10;    public void setManagedTicket(int managedTypeIndex, int elementIndex, int ticket) {&#10;        if (managedTypeIndex &lt; 0 || managedTypeIndex &gt;= managedComponentIndexArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;managedTypeIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        managedComponentIndexArrays[managedTypeIndex][elementIndex] = ticket;&#10;    }&#10;&#10;    public MemorySegment getComponentArray(int componentIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        return componentArrays[componentIndex];&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#13;&#10;&#13;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#13;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#13;&#10;import com.ethnicthv.ecs.core.exception.ECSMemoryAllocationException;&#13;&#10;&#13;&#10;import java.lang.foreign.Arena;&#13;&#10;import java.lang.foreign.MemorySegment;&#13;&#10;import java.util.concurrent.atomic.AtomicInteger;&#13;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#13;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#13;&#10;import java.util.Arrays;&#13;&#10;&#13;&#10;/**&#13;&#10; * Single chunk storing SoA arrays for each component.&#13;&#10; */&#13;&#10;public final class ArchetypeChunk implements IArchetypeChunk {&#13;&#10;&#13;&#10;    private final long[] elementSizes;&#13;&#10;    private final MemorySegment[] componentArrays;&#13;&#10;    // New: per-managed-type ticket arrays; may be empty if no managed types&#13;&#10;    private final int[][] managedComponentIndexArrays;&#13;&#10;    private final int capacity;&#13;&#10;    // Lock-free free list: Treiber stack of free indices&#13;&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#13;&#10;    private final int[] nextFree; // next pointer for each slot&#13;&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#13;&#10;    private final Arena arena;&#13;&#10;    private final AtomicInteger size; // number of occupied slots&#13;&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#13;&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#13;&#10;    private static final int BITS_PER_WORD = 64;&#13;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#13;&#10;&#13;&#10;    public static final class ChunkLocation {&#13;&#10;        public final int chunkIndex;&#13;&#10;        public final int indexInChunk;&#13;&#10;&#13;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#13;&#10;            this.chunkIndex = chunkIndex;&#13;&#10;            this.indexInChunk = indexInChunk;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Backwards-compatible constructor (no managed types)&#13;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#13;&#10;        this(descriptors, elementSizes, capacity, arena, 0);&#13;&#10;    }&#13;&#10;&#13;&#10;    // New constructor supporting managed types&#13;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena, int managedTypeCount) {&#13;&#10;        this.elementSizes = elementSizes;&#13;&#10;        this.capacity = capacity;&#13;&#10;        this.arena = arena;&#13;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#13;&#10;        this.size = new AtomicInteger(0);&#13;&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#13;&#10;        this.nextFree = new int[capacity];&#13;&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#13;&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#13;&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#13;&#10;            nextFree[i] = i + 1;&#13;&#10;            entityIds.set(i, -1);&#13;&#10;        }&#13;&#10;        if (capacity &gt; 0) {&#13;&#10;            nextFree[capacity - 1] = -1;&#13;&#10;            entityIds.set(capacity - 1, -1);&#13;&#10;        }&#13;&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#13;&#10;&#13;&#10;        // Allocate per-component arrays and zero-initialize them&#13;&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#13;&#10;            long bytes = elementSizes[i] * (long) capacity;&#13;&#10;            if (bytes &lt;= 0) {&#13;&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#13;&#10;            }&#13;&#10;            try {&#13;&#10;                this.componentArrays[i] = arena.allocate(bytes);&#13;&#10;                // zero entire component array to ensure new slots start clean&#13;&#10;                this.componentArrays[i].fill((byte) 0);&#13;&#10;            } catch (OutOfMemoryError oom) {&#13;&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        // Initialize managed ticket arrays (filled with -1 indicating empty)&#13;&#10;        if (managedTypeCount &gt; 0) {&#13;&#10;            this.managedComponentIndexArrays = new int[managedTypeCount][];&#13;&#10;            for (int i = 0; i &lt; managedTypeCount; i++) {&#13;&#10;                int[] arr = new int[capacity];&#13;&#10;                Arrays.fill(arr, -1);&#13;&#10;                this.managedComponentIndexArrays[i] = arr;&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            this.managedComponentIndexArrays = new int[0][];&#13;&#10;        }&#13;&#10;&#13;&#10;        // keep entityIds initialized to -1&#13;&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#13;&#10;    }&#13;&#10;&#13;&#10;    public Arena getArena() {&#13;&#10;        return arena;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Allocate a free slot and associate with entityId.&#13;&#10;     * Returns index or -1 if full.&#13;&#10;     */&#13;&#10;    public int allocateSlot(int entityId) {&#13;&#10;        while (true) {&#13;&#10;            int head = freeHead.get();&#13;&#10;            if (head == -1) return -1; // full&#13;&#10;            int next = nextFree[head];&#13;&#10;            if (freeHead.compareAndSet(head, next)) {&#13;&#10;                // zero out the slot data before making it visible to iterators or readers&#13;&#10;                zeroSlot(head);&#13;&#10;                // publish entity id for the claimed slot&#13;&#10;                entityIds.set(head, entityId);&#13;&#10;                // mark occupancy bit so iterators can observe&#13;&#10;                setBit(head);&#13;&#10;                int newSize = size.incrementAndGet();&#13;&#10;                if (newSize &gt; capacity) {&#13;&#10;                    // Defensive: should never happen; roll back and fail fast&#13;&#10;                    size.decrementAndGet();&#13;&#10;                    clearBit(head);&#13;&#10;                    entityIds.set(head, -1);&#13;&#10;                    // push slot back to free list&#13;&#10;                    while (true) {&#13;&#10;                        int h = freeHead.get();&#13;&#10;                        nextFree[head] = h;&#13;&#10;                        if (freeHead.compareAndSet(h, head)) break;&#13;&#10;                    }&#13;&#10;                    throw new IllegalStateException(&quot;ArchetypeChunk size overflow: &quot; + newSize + &quot; &gt; capacity=&quot; + capacity);&#13;&#10;                }&#13;&#10;                return head;&#13;&#10;            }&#13;&#10;            // CAS failed: retry&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public void freeSlot(int index) {&#13;&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#13;&#10;        // mark entity id as free first (helps readers)&#13;&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#13;&#10;            // already free; ignore double free&#13;&#10;            return;&#13;&#10;        }&#13;&#10;        int newSize = size.decrementAndGet();&#13;&#10;        if (newSize &lt; 0) {&#13;&#10;            // Defensive: should never happen; restore and fail fast&#13;&#10;            size.incrementAndGet();&#13;&#10;            entityIds.set(index, -1);&#13;&#10;            throw new IllegalStateException(&quot;ArchetypeChunk size underflow: &quot; + newSize);&#13;&#10;        }&#13;&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#13;&#10;        clearBit(index);&#13;&#10;        // push index onto free list&#13;&#10;        while (true) {&#13;&#10;            int head = freeHead.get();&#13;&#10;            nextFree[index] = head;&#13;&#10;            if (freeHead.compareAndSet(head, index)) {&#13;&#10;                return;&#13;&#10;            }&#13;&#10;            // retry on contention&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void zeroSlot(int idx) {&#13;&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#13;&#10;            long elemSize = elementSizes[c];&#13;&#10;            long offset = elemSize * (long) idx;&#13;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#13;&#10;        }&#13;&#10;        // Reset managed tickets to -1 for this slot&#13;&#10;        for (int i = 0; i &lt; managedComponentIndexArrays.length; i++) {&#13;&#10;            managedComponentIndexArrays[i][idx] = -1;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isEmpty() {&#13;&#10;        return size.get() == 0;&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public int getEntityId(int index) {&#13;&#10;        return entityIds.get(index);&#13;&#10;    }&#13;&#10;&#13;&#10;    public int capacity() {&#13;&#10;        return capacity;&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public int getCapacity() {&#13;&#10;        return capacity;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Current number of occupied slots in this chunk&#13;&#10;     */&#13;&#10;    @Override&#13;&#10;    public int size() {&#13;&#10;        return size.get();&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public int getEntityCount() {&#13;&#10;        return size();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#13;&#10;     * The returned slice is a view into the backing component array (zero-copy).&#13;&#10;     */&#13;&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#13;&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#13;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Copy provided segment into the element slot for componentIndex.&#13;&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#13;&#10;     */&#13;&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#13;&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#13;&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#13;&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean hasFree() {&#13;&#10;        return freeHead.get() != -1;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#13;&#10;     */&#13;&#10;    public boolean tryMarkQueued() {&#13;&#10;        return queued.compareAndSet(0, 1);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#13;&#10;     */&#13;&#10;    public void markDequeued() {&#13;&#10;        queued.set(0);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void setBit(int idx) {&#13;&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#13;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#13;&#10;        while (true) {&#13;&#10;            long cur = occupancy.get(word);&#13;&#10;            long nxt = cur | mask;&#13;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void clearBit(int idx) {&#13;&#10;        int word = idx &gt;&gt;&gt; 6;&#13;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#13;&#10;        while (true) {&#13;&#10;            long cur = occupancy.get(word);&#13;&#10;            long nxt = cur &amp; ~mask;&#13;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#13;&#10;     */&#13;&#10;    public int nextOccupiedIndex(int fromIndex) {&#13;&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#13;&#10;        if (fromIndex &gt;= capacity) return -1;&#13;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#13;&#10;        int bit = fromIndex &amp; 63;&#13;&#10;        int words = occupancy.length();&#13;&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#13;&#10;        // mask off bits before 'bit'&#13;&#10;        w &amp;= (-1L &lt;&lt; bit);&#13;&#10;        while (true) {&#13;&#10;            if (w != 0) {&#13;&#10;                int offset = Long.numberOfTrailingZeros(w);&#13;&#10;                int idx = (word &lt;&lt; 6) + offset;&#13;&#10;                if (idx &lt; capacity) return idx;&#13;&#10;                return -1;&#13;&#10;            }&#13;&#10;            word++;&#13;&#10;            if (word &gt;= words) return -1;&#13;&#10;            w = occupancy.get(word);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // ===== Managed component ticket accessors =====&#13;&#10;&#13;&#10;    public int[] getManagedIndexArray(int managedTypeIndex) {&#13;&#10;        return managedComponentIndexArrays[managedTypeIndex];&#13;&#10;    }&#13;&#10;&#13;&#10;    public int getManagedTicket(int managedTypeIndex, int elementIndex) {&#13;&#10;        if (managedTypeIndex &lt; 0 || managedTypeIndex &gt;= managedComponentIndexArrays.length) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;managedTypeIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        return managedComponentIndexArrays[managedTypeIndex][elementIndex];&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setManagedTicket(int managedTypeIndex, int elementIndex, int ticket) {&#13;&#10;        if (managedTypeIndex &lt; 0 || managedTypeIndex &gt;= managedComponentIndexArrays.length) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;managedTypeIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        managedComponentIndexArrays[managedTypeIndex][elementIndex] = ticket;&#13;&#10;    }&#13;&#10;&#13;&#10;    public MemorySegment getComponentArray(int componentIndex) {&#13;&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        return componentArrays[componentIndex];&#13;&#10;    }&#13;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] allTypeIds = m.toComponentIdArray();&#10;&#10;            List&lt;ComponentDescriptor&gt; unmanagedInstanceDescs = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; unmanagedInstanceIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; managedInstanceIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; unmanagedSharedIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; managedSharedIds = new ArrayList&lt;&gt;();&#10;&#10;            for (int typeId : allTypeIds) {&#10;                var meta = metadataProvider.apply(typeId);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + typeId);&#10;                }&#10;                ComponentDescriptor desc = componentManager.getDescriptor(meta.type());&#10;                if (desc == null) {&#10;                    throw new IllegalStateException(&quot;Descriptor missing for component &quot; + meta.type().getName());&#10;                }&#10;                ComponentDescriptor.ComponentKind kind = desc.getKind();&#10;                switch (kind) {&#10;                    case INSTANCE_UNMANAGED -&gt; {&#10;                        unmanagedInstanceIds.add(typeId);&#10;                        unmanagedInstanceDescs.add(desc);&#10;                    }&#10;                    case INSTANCE_MANAGED -&gt; managedInstanceIds.add(typeId);&#10;                    case SHARED_UNMANAGED -&gt; unmanagedSharedIds.add(typeId);&#10;                    case SHARED_MANAGED -&gt; managedSharedIds.add(typeId);&#10;                }&#10;            }&#10;&#10;            ComponentDescriptor[] unmanagedInstanceArray = unmanagedInstanceDescs.toArray(new ComponentDescriptor[0]);&#10;            int[] managedInstanceIdsArray = managedInstanceIds.stream().mapToInt(Integer::intValue).toArray();&#10;            int[] unmanagedSharedIdsArray = unmanagedSharedIds.stream().mapToInt(Integer::intValue).toArray();&#10;            int[] managedSharedIdsArray = managedSharedIds.stream().mapToInt(Integer::intValue).toArray();&#10;&#10;            Archetype archetype = new Archetype(m, allTypeIds, unmanagedInstanceArray, managedInstanceIdsArray, unmanagedSharedIdsArray, managedSharedIdsArray, arena);&#10;            // Provide the mapping for unmanaged instance type ids order used in this archetype&#10;            int[] unmanagedInstanceIdsArray = unmanagedInstanceIds.stream().mapToInt(Integer::intValue).toArray();&#10;            archetype.setUnmanagedTypeIds(unmanagedInstanceIdsArray);&#10;            return archetype;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] allTypeIds = m.toComponentIdArray();&#10;&#10;            List&lt;ComponentDescriptor&gt; unmanagedInstanceDescs = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; unmanagedInstanceIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; managedInstanceIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; unmanagedSharedIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; managedSharedIds = new ArrayList&lt;&gt;();&#10;&#10;            for (int typeId : allTypeIds) {&#10;                var meta = metadataProvider.apply(typeId);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + typeId);&#10;                }&#10;                ComponentDescriptor desc = componentManager.getDescriptor(meta.type());&#10;                if (desc == null) {&#10;                    throw new IllegalStateException(&quot;Descriptor missing for component &quot; + meta.type().getName());&#10;                }&#10;                ComponentDescriptor.ComponentKind kind = desc.getKind();&#10;                switch (kind) {&#10;                    case INSTANCE_UNMANAGED -&gt; {&#10;                        unmanagedInstanceIds.add(typeId);&#10;                        unmanagedInstanceDescs.add(desc);&#10;                    }&#10;                    case INSTANCE_MANAGED -&gt; managedInstanceIds.add(typeId);&#10;                    case SHARED_UNMANAGED -&gt; unmanagedSharedIds.add(typeId);&#10;                    case SHARED_MANAGED -&gt; managedSharedIds.add(typeId);&#10;                }&#10;            }&#10;&#10;            ComponentDescriptor[] unmanagedInstanceArray = unmanagedInstanceDescs.toArray(new ComponentDescriptor[0]);&#10;            int[] managedInstanceIdsArray = managedInstanceIds.stream().mapToInt(Integer::intValue).toArray();&#10;            int[] unmanagedSharedIdsArray = unmanagedSharedIds.stream().mapToInt(Integer::intValue).toArray();&#10;            int[] managedSharedIdsArray = managedSharedIds.stream().mapToInt(Integer::intValue).toArray();&#10;&#10;            Archetype archetype = new Archetype(m, allTypeIds, unmanagedInstanceArray, managedInstanceIdsArray, unmanagedSharedIdsArray, managedSharedIdsArray, arena);&#10;            // Provide the mapping for unmanaged instance type ids order used in this archetype&#10;            int[] unmanagedInstanceIdsArray = unmanagedInstanceIds.stream().mapToInt(Integer::intValue).toArray();&#10;            archetype.setUnmanagedTypeIds(unmanagedInstanceIdsArray);&#10;            return archetype;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeQuery.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeQuery.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQuery;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentHandle;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Arrays;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * This class implements both {@link IQueryBuilder} (for configuration) and&#10; * {@link IQuery} (for execution). Once {@link #build()} is called, it returns&#10; * an immutable snapshot of the query configuration.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery implements IQueryBuilder, IQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    private final List&lt;Class&lt;?&gt;&gt; compList = new ArrayList&lt;&gt;();&#10;    private final List&lt;Integer&gt; compIdxList = new ArrayList&lt;&gt;();&#10;&#10;    // New: shared filters (at most one managed value and many unmanaged pairs)&#10;    private Object managedSharedFilter = null;&#10;    private final List&lt;UnmanagedFilter&gt; unmanagedSharedFilters = new ArrayList&lt;&gt;();&#10;&#10;    // Expose for generated code to reference as a type&#10;    public static final class UnmanagedFilter {&#10;        public final Class&lt;?&gt; type;&#10;        public final long value;&#10;        public UnmanagedFilter(Class&lt;?&gt; type, long value) { this.type = type; this.value = value; }&#10;    }&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) { this.world = world; }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        compList.add(componentClass);&#10;        compIdxList.add(componentTypeId);&#10;&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    @Override&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    @Override&#10;    public IQueryBuilder withShared(Object managedValue) {&#10;        this.managedSharedFilter = managedValue;&#10;        return this;&#10;    }&#10;&#10;    @Override&#10;    public IQueryBuilder withShared(Class&lt;?&gt; unmanagedSharedType, long value) {&#10;        unmanagedSharedFilters.add(new UnmanagedFilter(unmanagedSharedType, value));&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Build an immutable query from this builder's configuration.&#10;     * &lt;p&gt;&#10;     * This method creates a snapshot of the current query configuration.&#10;     * The returned {@link IQuery} is immutable and thread-safe.&#10;     * &lt;p&gt;&#10;     * Note: Since ArchetypeQuery implements both IQueryBuilder and IQuery,&#10;     * this method simply returns itself. However, callers should treat the&#10;     * returned reference as immutable and not call builder methods on it.&#10;     *&#10;     * @return an immutable query instance&#10;     */&#10;    @Override&#10;    public IQuery build() {&#10;        // For now, we return this instance&#10;        // In a more sophisticated implementation, we could create&#10;        // a truly immutable wrapper or snapshot&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    @Override&#10;    public void forEach(IQuery.ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            // Build query key if any shared filters provided&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue; // skip archetype entirely&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    @Override&#10;    public void forEachChunk(IQuery.ChunkConsumer consumer) {&#10;        // Use group-level filtering if possible&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;            if (!archetypeMask.containsAll(with)) continue;&#10;            if (!archetypeMask.containsNone(without)) continue;&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue;&#10;                ArchetypeChunk[] chunks = group.getChunksSnapshot();&#10;                int count = group.chunkCount();&#10;                for (int i = 0; i &lt; count; i++) consumer.accept(chunks[i], archetype);&#10;            } else {&#10;                for (IArchetypeChunk chunk : archetype.getChunks()) consumer.accept(chunk, archetype);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    @Override&#10;    public void forEachEntity(IQuery.EntityConsumer consumer) {&#10;        ComponentManager mgr = world.getComponentManager();&#10;        Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;        for (int i = 0; i &lt; compList.size(); i++) componentClasses[i] = compList.get(i);&#10;&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;            if (!archetypeMask.containsAll(with)) continue;&#10;            if (!archetypeMask.containsNone(without)) continue;&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            // Precompute component indices for this archetype&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            boolean ok = true;&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) { ok = false; break; }&#10;                compIndices[i] = idx;&#10;            }&#10;            if (!ok) continue;&#10;&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue;&#10;                ArchetypeChunk[] chunks = group.getChunksSnapshot();&#10;                int count = group.chunkCount();&#10;                for (int ci = 0; ci &lt; count; ci++) {&#10;                    ArchetypeChunk chunk = chunks[ci];&#10;                    iterateChunkEntities(chunk, mgr, componentClasses, compIndices, consumer, archetype);&#10;                }&#10;            } else {&#10;                for (IArchetypeChunk chunk : archetype.getChunks()) {&#10;                    iterateChunkEntities((ArchetypeChunk) chunk, mgr, componentClasses, compIndices, consumer, archetype);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void iterateChunkEntities(ArchetypeChunk chunk, ComponentManager mgr, Class&lt;?&gt;[] componentClasses, int[] compIndices, IQuery.EntityConsumer consumer, Archetype archetype) {&#10;        ComponentHandle[] pooled = new ComponentHandle[compIndices.length];&#10;        for (int k = 0; k &lt; compIndices.length; k++) pooled[k] = mgr.acquireHandle();&#10;        try {&#10;            int idx = chunk.nextOccupiedIndex(0);&#10;            while (idx &gt;= 0) {&#10;                int entityId = chunk.getEntityId(idx);&#10;                for (int k = 0; k &lt; compIndices.length; k++) {&#10;                    var seg = chunk.getComponentData(compIndices[k], idx);&#10;                    pooled[k].reset(seg, mgr.getDescriptor(componentClasses[k]));&#10;                }&#10;                consumer.accept(entityId, pooled, archetype);&#10;                idx = chunk.nextOccupiedIndex(idx + 1);&#10;            }&#10;        } finally {&#10;            for (int k = 0; k &lt; compIndices.length; k++) if (pooled[k] != null) mgr.releaseHandle(pooled[k]);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    @Override&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    /**&#10;     * Execute the query and process matching entities in parallel across multiple CPU cores.&#10;     * &lt;p&gt;&#10;     * This method leverages Java's parallel streams to distribute entity processing across&#10;     * available CPU cores. The processing is done at the chunk level - each chunk is processed&#10;     * by a single thread, but different chunks may be processed concurrently.&#10;     * &lt;p&gt;&#10;     * &lt;strong&gt;THREAD SAFETY REQUIREMENTS:&lt;/strong&gt;&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;The provided {@code EntityConsumer} MUST be thread-safe&lt;/li&gt;&#10;     *   &lt;li&gt;Any shared state accessed or modified by the consumer must be properly synchronized&lt;/li&gt;&#10;     *   &lt;li&gt;The consumer may be called concurrently from multiple threads&lt;/li&gt;&#10;     *   &lt;li&gt;There are no ordering guarantees - entities may be processed in any order&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     * &lt;p&gt;&#10;     * Performance considerations:&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;Best suited for CPU-intensive operations on large entity sets&lt;/li&gt;&#10;     *   &lt;li&gt;Overhead of parallelization may not be worth it for very small entity counts&lt;/li&gt;&#10;     *   &lt;li&gt;The actual parallelism depends on the ForkJoinPool common pool size&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     *&#10;     * @param consumer A thread-safe callback that processes each matching entity.&#10;     *                 Called with (entityId, handles, archetype) for each entity.&#10;     * @throws NullPointerException if consumer is null&#10;     *&#10;     * @see #forEachEntity(EntityConsumer) for sequential processing&#10;     */&#10;    @Override&#10;    public void forEachParallel(IQuery.EntityConsumer consumer) {&#10;        if (consumer == null) throw new NullPointerException(&quot;EntityConsumer must not be null&quot;);&#10;        ComponentManager mgr = world.getComponentManager();&#10;        Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;        for (int i = 0; i &lt; compList.size(); i++) componentClasses[i] = compList.get(i);&#10;&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;            if (!archetypeMask.containsAll(with)) continue;&#10;            if (!archetypeMask.containsNone(without)) continue;&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            boolean ok = true;&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) { ok = false; break; }&#10;                compIndices[i] = idx;&#10;            }&#10;            if (!ok) continue;&#10;&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue;&#10;                ArchetypeChunk[] chunks = group.getChunksSnapshot();&#10;                int count = group.chunkCount();&#10;                Arrays.stream(chunks, 0, count).parallel().forEach(chunk -&gt;&#10;                    iterateChunkEntities(chunk, mgr, componentClasses, compIndices, consumer, archetype)&#10;                );&#10;            } else {&#10;                ArchetypeChunk[] chunks = archetype.getChunksSnapshot();&#10;                int count = archetype.chunkCount();&#10;                Arrays.stream(chunks, 0, count).parallel().forEach(chunk -&gt;&#10;                    iterateChunkEntities(chunk, mgr, componentClasses, compIndices, consumer, archetype)&#10;                );&#10;            }&#10;        }&#10;    }&#10;&#10;    private SharedValueKey buildQueryKey(Archetype archetype) {&#10;        int[] managedIdx = null;&#10;        long[] unmanagedVals = null;&#10;        boolean any = false;&#10;&#10;        if (managedSharedFilter != null) {&#10;            int ticket = world.findSharedIndex(managedSharedFilter);&#10;            if (ticket &lt; 0) return null;&#10;            int managedCount = archetype.getSharedManagedTypeIds().length;&#10;            if (managedCount == 0) return null;&#10;            managedIdx = new int[managedCount];&#10;            Arrays.fill(managedIdx, -1);&#10;            for (int typeId : archetype.getSharedManagedTypeIds()) {&#10;                int pos = archetype.getSharedManagedIndex(typeId);&#10;                if (pos &gt;= 0) { managedIdx[pos] = ticket; any = true; }&#10;            }&#10;        }&#10;        if (!unmanagedSharedFilters.isEmpty()) {&#10;            int unmanagedCount = archetype.getSharedUnmanagedTypeIds().length;&#10;            if (unmanagedCount == 0) return null;&#10;            unmanagedVals = new long[unmanagedCount];&#10;            Arrays.fill(unmanagedVals, Long.MIN_VALUE);&#10;            for (UnmanagedFilter f : unmanagedSharedFilters) {&#10;                Integer typeId = world.getComponentTypeId(f.type);&#10;                if (typeId == null) return null;&#10;                int pos = archetype.getSharedUnmanagedIndex(typeId);&#10;                if (pos &lt; 0) return null;&#10;                unmanagedVals[pos] = f.value; any = true;&#10;            }&#10;        }&#10;        if (!any) return null;&#10;        return new SharedValueKey(managedIdx, unmanagedVals);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQuery;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentHandle;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Arrays;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * This class implements both {@link IQueryBuilder} (for configuration) and&#10; * {@link IQuery} (for execution). Once {@link #build()} is called, it returns&#10; * an immutable snapshot of the query configuration.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery implements IQueryBuilder, IQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    private final List&lt;Class&lt;?&gt;&gt; compList = new ArrayList&lt;&gt;();&#10;    private final List&lt;Integer&gt; compIdxList = new ArrayList&lt;&gt;();&#10;&#10;    // New: shared filters (at most one managed value and many unmanaged pairs)&#10;    private Object managedSharedFilter = null;&#10;    private final List&lt;UnmanagedFilter&gt; unmanagedSharedFilters = new ArrayList&lt;&gt;();&#10;&#10;    // Expose for generated code to reference as a type&#10;    public static final class UnmanagedFilter {&#10;        public final Class&lt;?&gt; type;&#10;        public final long value;&#10;        public UnmanagedFilter(Class&lt;?&gt; type, long value) { this.type = type; this.value = value; }&#10;    }&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) { this.world = world; }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        compList.add(componentClass);&#10;        compIdxList.add(componentTypeId);&#10;&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    @Override&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    @Override&#10;    public IQueryBuilder withShared(Object managedValue) {&#10;        this.managedSharedFilter = managedValue;&#10;        return this;&#10;    }&#10;&#10;    @Override&#10;    public IQueryBuilder withShared(Class&lt;?&gt; unmanagedSharedType, long value) {&#10;        unmanagedSharedFilters.add(new UnmanagedFilter(unmanagedSharedType, value));&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Build an immutable query from this builder's configuration.&#10;     * &lt;p&gt;&#10;     * This method creates a snapshot of the current query configuration.&#10;     * The returned {@link IQuery} is immutable and thread-safe.&#10;     * &lt;p&gt;&#10;     * Note: Since ArchetypeQuery implements both IQueryBuilder and IQuery,&#10;     * this method simply returns itself. However, callers should treat the&#10;     * returned reference as immutable and not call builder methods on it.&#10;     *&#10;     * @return an immutable query instance&#10;     */&#10;    @Override&#10;    public IQuery build() {&#10;        // For now, we return this instance&#10;        // In a more sophisticated implementation, we could create&#10;        // a truly immutable wrapper or snapshot&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    @Override&#10;    public void forEach(IQuery.ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            // Build query key if any shared filters provided&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue; // skip archetype entirely&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    @Override&#10;    public void forEachChunk(IQuery.ChunkConsumer consumer) {&#10;        // Use group-level filtering if possible&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;            if (!archetypeMask.containsAll(with)) continue;&#10;            if (!archetypeMask.containsNone(without)) continue;&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue;&#10;                ArchetypeChunk[] chunks = group.getChunksSnapshot();&#10;                int count = group.chunkCount();&#10;                for (int i = 0; i &lt; count; i++) consumer.accept(chunks[i], archetype);&#10;            } else {&#10;                for (IArchetypeChunk chunk : archetype.getChunks()) consumer.accept(chunk, archetype);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    @Override&#10;    public void forEachEntity(IQuery.EntityConsumer consumer) {&#10;        ComponentManager mgr = world.getComponentManager();&#10;        Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;        for (int i = 0; i &lt; compList.size(); i++) componentClasses[i] = compList.get(i);&#10;&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;            if (!archetypeMask.containsAll(with)) continue;&#10;            if (!archetypeMask.containsNone(without)) continue;&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            // Precompute component indices for this archetype&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            boolean ok = true;&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) { ok = false; break; }&#10;                compIndices[i] = idx;&#10;            }&#10;            if (!ok) continue;&#10;&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue;&#10;                ArchetypeChunk[] chunks = group.getChunksSnapshot();&#10;                int count = group.chunkCount();&#10;                for (int ci = 0; ci &lt; count; ci++) {&#10;                    ArchetypeChunk chunk = chunks[ci];&#10;                    iterateChunkEntities(chunk, mgr, componentClasses, compIndices, consumer, archetype);&#10;                }&#10;            } else {&#10;                for (IArchetypeChunk chunk : archetype.getChunks()) {&#10;                    iterateChunkEntities((ArchetypeChunk) chunk, mgr, componentClasses, compIndices, consumer, archetype);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void iterateChunkEntities(ArchetypeChunk chunk, ComponentManager mgr, Class&lt;?&gt;[] componentClasses, int[] compIndices, IQuery.EntityConsumer consumer, Archetype archetype) {&#10;        ComponentHandle[] pooled = new ComponentHandle[compIndices.length];&#10;        for (int k = 0; k &lt; compIndices.length; k++) pooled[k] = mgr.acquireHandle();&#10;        try {&#10;            int idx = chunk.nextOccupiedIndex(0);&#10;            while (idx &gt;= 0) {&#10;                int entityId = chunk.getEntityId(idx);&#10;                for (int k = 0; k &lt; compIndices.length; k++) {&#10;                    var seg = chunk.getComponentData(compIndices[k], idx);&#10;                    pooled[k].reset(seg, mgr.getDescriptor(componentClasses[k]));&#10;                }&#10;                consumer.accept(entityId, pooled, archetype);&#10;                idx = chunk.nextOccupiedIndex(idx + 1);&#10;            }&#10;        } finally {&#10;            for (int k = 0; k &lt; compIndices.length; k++) if (pooled[k] != null) mgr.releaseHandle(pooled[k]);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    @Override&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    /**&#10;     * Execute the query and process matching entities in parallel across multiple CPU cores.&#10;     * &lt;p&gt;&#10;     * This method leverages Java's parallel streams to distribute entity processing across&#10;     * available CPU cores. The processing is done at the chunk level - each chunk is processed&#10;     * by a single thread, but different chunks may be processed concurrently.&#10;     * &lt;p&gt;&#10;     * &lt;strong&gt;THREAD SAFETY REQUIREMENTS:&lt;/strong&gt;&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;The provided {@code EntityConsumer} MUST be thread-safe&lt;/li&gt;&#10;     *   &lt;li&gt;Any shared state accessed or modified by the consumer must be properly synchronized&lt;/li&gt;&#10;     *   &lt;li&gt;The consumer may be called concurrently from multiple threads&lt;/li&gt;&#10;     *   &lt;li&gt;There are no ordering guarantees - entities may be processed in any order&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     * &lt;p&gt;&#10;     * Performance considerations:&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;Best suited for CPU-intensive operations on large entity sets&lt;/li&gt;&#10;     *   &lt;li&gt;Overhead of parallelization may not be worth it for very small entity counts&lt;/li&gt;&#10;     *   &lt;li&gt;The actual parallelism depends on the ForkJoinPool common pool size&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     *&#10;     * @param consumer A thread-safe callback that processes each matching entity.&#10;     *                 Called with (entityId, handles, archetype) for each entity.&#10;     * @throws NullPointerException if consumer is null&#10;     *&#10;     * @see #forEachEntity(EntityConsumer) for sequential processing&#10;     */&#10;    @Override&#10;    public void forEachParallel(IQuery.EntityConsumer consumer) {&#10;        if (consumer == null) throw new NullPointerException(&quot;EntityConsumer must not be null&quot;);&#10;        ComponentManager mgr = world.getComponentManager();&#10;        Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;        for (int i = 0; i &lt; compList.size(); i++) componentClasses[i] = compList.get(i);&#10;&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;            if (!archetypeMask.containsAll(with)) continue;&#10;            if (!archetypeMask.containsNone(without)) continue;&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            boolean ok = true;&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) { ok = false; break; }&#10;                compIndices[i] = idx;&#10;            }&#10;            if (!ok) continue;&#10;&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue;&#10;                ArchetypeChunk[] chunks = group.getChunksSnapshot();&#10;                int count = group.chunkCount();&#10;                Arrays.stream(chunks, 0, count).parallel().forEach(chunk -&gt;&#10;                    iterateChunkEntities(chunk, mgr, componentClasses, compIndices, consumer, archetype)&#10;                );&#10;            } else {&#10;                ArchetypeChunk[] chunks = archetype.getChunksSnapshot();&#10;                int count = archetype.chunkCount();&#10;                Arrays.stream(chunks, 0, count).parallel().forEach(chunk -&gt;&#10;                    iterateChunkEntities(chunk, mgr, componentClasses, compIndices, consumer, archetype)&#10;                );&#10;            }&#10;        }&#10;    }&#10;&#10;    private SharedValueKey buildQueryKey(Archetype archetype) {&#10;        int[] managedIdx = null;&#10;        long[] unmanagedVals = null;&#10;        boolean any = false;&#10;&#10;        if (managedSharedFilter != null) {&#10;            int ticket = world.findSharedIndex(managedSharedFilter);&#10;            if (ticket &lt; 0) return null;&#10;            int managedCount = archetype.getSharedManagedTypeIds().length;&#10;            if (managedCount == 0) return null;&#10;            managedIdx = new int[managedCount];&#10;            Arrays.fill(managedIdx, -1);&#10;            for (int typeId : archetype.getSharedManagedTypeIds()) {&#10;                int pos = archetype.getSharedManagedIndex(typeId);&#10;                if (pos &gt;= 0) { managedIdx[pos] = ticket; any = true; }&#10;            }&#10;        }&#10;        if (!unmanagedSharedFilters.isEmpty()) {&#10;            int unmanagedCount = archetype.getSharedUnmanagedTypeIds().length;&#10;            if (unmanagedCount == 0) return null;&#10;            unmanagedVals = new long[unmanagedCount];&#10;            Arrays.fill(unmanagedVals, Long.MIN_VALUE);&#10;            for (UnmanagedFilter f : unmanagedSharedFilters) {&#10;                Integer typeId = world.getComponentTypeId(f.type);&#10;                if (typeId == null) return null;&#10;                int pos = archetype.getSharedUnmanagedIndex(typeId);&#10;                if (pos &lt; 0) return null;&#10;                unmanagedVals[pos] = f.value; any = true;&#10;            }&#10;        }&#10;        if (!any) return null;&#10;        return new SharedValueKey(managedIdx, unmanagedVals);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeWorld.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeWorld.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;import com.ethnicthv.ecs.core.components.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ComponentManager componentManager;&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    // New: global store for managed components&#10;    private final ManagedComponentStore managedStore = new ManagedComponentStore();&#10;    // New: store for managed shared components (de-duplicated)&#10;    final SharedComponentStore sharedStore = new SharedComponentStore();&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager (SSOT for IDs).&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentManager.registerComponent(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ChunkGroup group = archetype.getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;        ArchetypeChunk.ChunkLocation location = group.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask, new SharedValueKey(null, null)));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * The components will be initialized with default (zeroed) values.&#10;     *&#10;     * @param c1 The first component class to add.&#10;     * @return The ID of the newly created entity.&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1) {&#10;        return createEntityWithComponents(c1);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2) {&#10;        return createEntityWithComponents(c1, c2);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3) {&#10;        return createEntityWithComponents(c1, c2, c3);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3, Class&lt;?&gt; c4) {&#10;        return createEntityWithComponents(c1, c2, c3, c4);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3, Class&lt;?&gt; c4, Class&lt;?&gt; c5) {&#10;        return createEntityWithComponents(c1, c2, c3, c4, c5);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3, Class&lt;?&gt; c4, Class&lt;?&gt; c5, Class&lt;?&gt; c6) {&#10;        return createEntityWithComponents(c1, c2, c3, c4, c5, c6);&#10;    }&#10;&#10;    private int createEntityWithComponents(Class&lt;?&gt;... componentClasses) {&#10;        // 1. Create the entity ID&#10;        int entityId = nextEntityId.getAndIncrement();&#10;&#10;        // 2. Build the component mask&#10;        ComponentMask mask = new ComponentMask();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = getComponentTypeId(componentClass);&#10;            if (componentTypeId == null) {&#10;                throw new IllegalArgumentException(&quot;Component type &quot; + componentClass.getName() + &quot; is not registered.&quot;);&#10;            }&#10;            mask = mask.set(componentTypeId);&#10;        }&#10;&#10;        // 3. Get or create the target archetype&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(mask);&#10;        ChunkGroup group = archetype.getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;&#10;        // 4. Add the entity to the archetype and store its record&#10;        ArchetypeChunk.ChunkLocation location = group.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, mask, new SharedValueKey(null, null)));&#10;&#10;        // 5. Allocate and assign default (zeroed) memory for each unmanaged component&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;                if (desc != null &amp;&amp; !desc.isManaged()) {&#10;                    MemorySegment data = componentManager.allocate(componentClass, arena); // Zeroed by default&#10;                    int componentIndex = archetype.indexOfComponentType(componentTypeId);&#10;                    if (componentIndex &gt;= 0) {&#10;                        archetype.setComponentData(location, componentIndex, data);&#10;                    }&#10;                }&#10;                // For managed components, default ticket remains -1 until user provides an instance&#10;            }&#10;        }&#10;&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity (unmanaged path: memory segment).&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = getComponentTypeId(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc != null &amp;&amp; desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;addComponent(entityId, Class, MemorySegment) not valid for managed component &quot; + componentClass.getName());&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype (preserve shared key)&#10;        moveEntityToArchetype(entityId, record, record.mask, newMask, record.sharedKey);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Add a managed component instance to an entity. The instance is stored in the ManagedComponentStore&#10;     * and the ticket is placed into the chunk's managed index array.&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, T componentInstance) {&#10;        if (componentInstance == null) throw new IllegalArgumentException(&quot;componentInstance must not be null&quot;);&#10;        Class&lt;?&gt; componentClass = componentInstance.getClass();&#10;&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = getComponentTypeId(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc == null || !desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass.getName() + &quot; is not marked @Component.Managed&quot;);&#10;        }&#10;&#10;        // 1) Store managed instance and get ticket&#10;        int ticket = managedStore.store(componentInstance);&#10;&#10;        // 2) Structural change: move entity to new archetype that includes this component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;        moveEntityToArchetype(entityId, record, record.mask, newMask, record.sharedKey);&#10;&#10;        // 3) Wire ticket into the new chunk's managed index array&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int managedTypeIndex = newRecord.archetype.getManagedTypeIndex(componentTypeId);&#10;        if (managedTypeIndex &lt; 0) {&#10;            throw new IllegalStateException(&quot;Managed type index not found for component id=&quot; + componentTypeId);&#10;        }&#10;        ChunkGroup newGroup = newRecord.archetype.getChunkGroup(newRecord.sharedKey);&#10;        if (newGroup == null) throw new IllegalStateException(&quot;ChunkGroup not found for new entity shared key&quot;);&#10;        ArchetypeChunk newChunk = newGroup.getChunk(newRecord.location.chunkIndex);&#10;        newChunk.setManagedTicket(managedTypeIndex, newRecord.location.indexInChunk, ticket);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity. For managed components, release the stored object.&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = getComponentTypeId(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // If managed, release the ticket before moving&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc != null &amp;&amp; desc.isManaged()) {&#10;            int managedIdx = record.archetype.getManagedTypeIndex(componentTypeId);&#10;            if (managedIdx &gt;= 0) {&#10;                ChunkGroup group = record.archetype.getChunkGroup(record.sharedKey);&#10;                if (group != null) {&#10;                    ArchetypeChunk chunk = group.getChunk(record.location.chunkIndex);&#10;                    int ticket = chunk.getManagedTicket(managedIdx, record.location.indexInChunk);&#10;                    if (ticket &gt;= 0) {&#10;                        managedStore.release(ticket);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype, preserve shared key&#10;        moveEntityToArchetype(entityId, record, record.mask, newMask, record.sharedKey);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = getComponentTypeId(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = getComponentTypeId(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            // Release all managed tickets for this entity before removing&#10;            int[] managedIds = record.archetype.getManagedTypeIds();&#10;            if (managedIds != null &amp;&amp; managedIds.length &gt; 0) {&#10;                ChunkGroup group = record.archetype.getChunkGroup(record.sharedKey);&#10;                if (group != null) {&#10;                    ArchetypeChunk chunk = group.getChunk(record.location.chunkIndex);&#10;                    for (int i = 0; i &lt; managedIds.length; i++) {&#10;                        int ticket = chunk.getManagedTicket(i, record.location.indexInChunk);&#10;                        if (ticket &gt;= 0) managedStore.release(ticket);&#10;                    }&#10;                }&#10;            }&#10;            // Release shared managed tickets referenced by key&#10;            if (record.sharedKey != null &amp;&amp; record.sharedKey.managedSharedIndices() != null) {&#10;                for (int idx : record.sharedKey.managedSharedIndices()) {&#10;                    if (idx &gt;= 0) sharedStore.releaseSharedIndex(idx);&#10;                }&#10;            }&#10;            // Remove from the correct chunk group&#10;            ChunkGroup group = record.archetype.getChunkGroup(record.sharedKey);&#10;            if (group != null) group.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query builder for entities matching component requirements.&#10;     * &lt;p&gt;&#10;     * Returns a builder that can be configured with component requirements,&#10;     * then built into an immutable {@link com.ethnicthv.ecs.core.api.archetype.IQuery}.&#10;     *&#10;     * @return a new query builder&#10;     */&#10;    public IQueryBuilder query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID via ComponentManager (SSOT).&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentManager.getTypeId(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata using ComponentManager as SSOT.&#10;     * Fast path: resolve id -&gt; descriptor in O(1) and derive class/size from it.&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentTypeId);&#10;        if (desc == null) {&#10;            throw new IllegalStateException(&quot;Khng tm thy Descriptor cho component typeId: &quot; + componentTypeId);&#10;        }&#10;        Class&lt;?&gt; componentClass = desc.getComponentClass();&#10;        return new ComponentMetadata(componentTypeId, componentClass, desc.getTotalSize());&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    /**&#10;     * Retrieve a managed component instance for an entity, or null if absent.&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getManagedComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) return null;&#10;        Integer typeId = getComponentTypeId(componentClass);&#10;        if (typeId == null || !record.mask.has(typeId)) return null;&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc == null || !desc.isManaged()) return null;&#10;        int mIdx = record.archetype.getManagedTypeIndex(typeId);&#10;        if (mIdx &lt; 0) return null;&#10;        ChunkGroup group = record.archetype.getChunkGroup(record.sharedKey);&#10;        if (group == null) return null;&#10;        ArchetypeChunk chunk = group.getChunk(record.location.chunkIndex);&#10;        int ticket = chunk.getManagedTicket(mIdx, record.location.indexInChunk);&#10;        if (ticket &lt; 0) return null;&#10;        Object obj = managedStore.get(ticket);&#10;        return (T) obj;&#10;    }&#10;&#10;    /**&#10;     * Replace or set a managed component instance for an entity.&#10;     * If an old instance exists, its ticket is released; the new instance is stored and wired.&#10;     */&#10;    public &lt;T&gt; void setManagedComponent(int entityId, T newInstance) {&#10;        if (newInstance == null) throw new IllegalArgumentException(&quot;newInstance must not be null&quot;);&#10;        Class&lt;?&gt; componentClass = newInstance.getClass();&#10;        Integer typeId = getComponentTypeId(componentClass);&#10;        if (typeId == null) throw new IllegalArgumentException(&quot;Component type not registered: &quot; + componentClass.getName());&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc == null || !desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;Component is not managed: &quot; + componentClass.getName());&#10;        }&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null || !record.mask.has(typeId)) {&#10;            // If not present, this behaves like addComponent(entityId, instance)&#10;            addComponent(entityId, newInstance);&#10;            return;&#10;        }&#10;        // Release old ticket (if any)&#10;        int mIdx = record.archetype.getManagedTypeIndex(typeId);&#10;        ChunkGroup group = record.archetype.getChunkGroup(record.sharedKey);&#10;        if (group == null) throw new IllegalStateException(&quot;ChunkGroup not found for entity shared key&quot;);&#10;        ArchetypeChunk chunk = group.getChunk(record.location.chunkIndex);&#10;        int oldTicket = chunk.getManagedTicket(mIdx, record.location.indexInChunk);&#10;        if (oldTicket &gt;= 0) managedStore.release(oldTicket);&#10;        // Store new instance and set ticket&#10;        int newTicket = managedStore.store(newInstance);&#10;        chunk.setManagedTicket(mIdx, record.location.indexInChunk, newTicket);&#10;    }&#10;&#10;    // ============ Shared Component APIs ============&#10;&#10;    public &lt;T&gt; void setSharedComponent(int entityId, T managedValue) {&#10;        if (managedValue == null) throw new IllegalArgumentException(&quot;managedValue must not be null&quot;);&#10;        Class&lt;?&gt; type = managedValue.getClass();&#10;        Integer typeId = getComponentTypeId(type);&#10;        if (typeId == null) throw new IllegalArgumentException(&quot;Shared component type not registered: &quot; + type.getName());&#10;        ComponentDescriptor desc = componentManager.getDescriptor(type);&#10;        if (desc == null || desc.getKind() != ComponentDescriptor.ComponentKind.SHARED_MANAGED) {&#10;            throw new IllegalArgumentException(&quot;Type is not a @Shared @Managed Component type: &quot; + type.getName());&#10;        }&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) throw new IllegalArgumentException(&quot;Entity does not exist: &quot; + entityId);&#10;        // If current archetype does not yet contain this shared type, structurally add it by extending the mask.&#10;        int pos = record.archetype.getSharedManagedIndex(typeId);&#10;        if (pos &lt; 0) {&#10;            ComponentMask newMask = record.mask.set(typeId);&#10;            // Move entity to new archetype with extended mask (retain old shared key first)&#10;            moveEntityToArchetype(entityId, record, record.mask, newMask, record.sharedKey);&#10;            record = entityRecords.get(entityId);&#10;            pos = record.archetype.getSharedManagedIndex(typeId);&#10;            if (pos &lt; 0) throw new IllegalStateException(&quot;Shared managed type index still missing after structural add: id=&quot; + typeId);&#10;        }&#10;        int ticket = sharedStore.getOrAddSharedIndex(managedValue);&#10;        SharedValueKey oldKey = record.sharedKey;&#10;        int[] managedIdx;&#10;        // Prepare sized array matching current archetype's shared managed type ids&#10;        int managedCount = record.archetype.getSharedManagedTypeIds().length;&#10;        if (oldKey != null &amp;&amp; oldKey.managedSharedIndices() != null &amp;&amp; oldKey.managedSharedIndices().length == managedCount) {&#10;            managedIdx = oldKey.managedSharedIndices().clone();&#10;        } else {&#10;            managedIdx = new int[managedCount];&#10;            java.util.Arrays.fill(managedIdx, -1);&#10;            if (oldKey != null &amp;&amp; oldKey.managedSharedIndices() != null) {&#10;                // Copy overlapping old indices into new sized array (in case of expansion)&#10;                int copyLen = Math.min(managedIdx.length, oldKey.managedSharedIndices().length);&#10;                System.arraycopy(oldKey.managedSharedIndices(), 0, managedIdx, 0, copyLen);&#10;            }&#10;        }&#10;        int old = managedIdx[pos];&#10;        managedIdx[pos] = ticket;&#10;        SharedValueKey newKey = new SharedValueKey(managedIdx, oldKey != null ? oldKey.unmanagedSharedValues() : null);&#10;        if (oldKey != null &amp;&amp; java.util.Arrays.equals(oldKey.managedSharedIndices(), managedIdx)) return; // unchanged&#10;        moveEntityToArchetype(entityId, record, record.mask, record.mask, newKey);&#10;        if (oldKey != null &amp;&amp; old &gt;= 0 &amp;&amp; old != ticket) sharedStore.releaseSharedIndex(old);&#10;    }&#10;&#10;    public void setSharedComponent(int entityId, Class&lt;?&gt; unmanagedSharedType, long value) {&#10;        Integer typeId = getComponentTypeId(unmanagedSharedType);&#10;        if (typeId == null) throw new IllegalArgumentException(&quot;Shared component type not registered: &quot; + unmanagedSharedType.getName());&#10;        ComponentDescriptor desc = componentManager.getDescriptor(unmanagedSharedType);&#10;        if (desc == null || desc.getKind() != ComponentDescriptor.ComponentKind.SHARED_UNMANAGED) {&#10;            throw new IllegalArgumentException(&quot;Type is not an @Unmanaged @Shared Component type: &quot; + unmanagedSharedType.getName());&#10;        }&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) throw new IllegalArgumentException(&quot;Entity does not exist: &quot; + entityId);&#10;        // Ensure archetype contains shared unmanaged type; if not, extend mask.&#10;        int pos = record.archetype.getSharedUnmanagedIndex(typeId);&#10;        if (pos &lt; 0) {&#10;            ComponentMask newMask = record.mask.set(typeId);&#10;            moveEntityToArchetype(entityId, record, record.mask, newMask, record.sharedKey);&#10;            record = entityRecords.get(entityId);&#10;            pos = record.archetype.getSharedUnmanagedIndex(typeId);&#10;            if (pos &lt; 0) throw new IllegalStateException(&quot;Shared unmanaged type index still missing after structural add: id=&quot; + typeId);&#10;        }&#10;        SharedValueKey oldKey = record.sharedKey;&#10;        int unmanagedCount = record.archetype.getSharedUnmanagedTypeIds().length;&#10;        long[] unmanagedVals;&#10;        if (oldKey != null &amp;&amp; oldKey.unmanagedSharedValues() != null &amp;&amp; oldKey.unmanagedSharedValues().length == unmanagedCount) {&#10;            unmanagedVals = oldKey.unmanagedSharedValues().clone();&#10;        } else {&#10;            unmanagedVals = new long[unmanagedCount];&#10;            java.util.Arrays.fill(unmanagedVals, Long.MIN_VALUE);&#10;            if (oldKey != null &amp;&amp; oldKey.unmanagedSharedValues() != null) {&#10;                int copyLen = Math.min(unmanagedVals.length, oldKey.unmanagedSharedValues().length);&#10;                System.arraycopy(oldKey.unmanagedSharedValues(), 0, unmanagedVals, 0, copyLen);&#10;            }&#10;        }&#10;        long oldVal = unmanagedVals[pos];&#10;        unmanagedVals[pos] = value;&#10;        SharedValueKey newKey = new SharedValueKey(oldKey != null ? oldKey.managedSharedIndices() : null, unmanagedVals);&#10;        if (oldKey != null &amp;&amp; java.util.Arrays.equals(oldKey.unmanagedSharedValues(), unmanagedVals)) return; // unchanged&#10;        moveEntityToArchetype(entityId, record, record.mask, record.mask, newKey);&#10;        // no ticket release for unmanaged values&#10;    }&#10;&#10;    // Expose non-mutating shared index lookup for query building&#10;    public int findSharedIndex(Object value) {&#10;        return sharedStore.findIndex(value);&#10;    }&#10;&#10;    // ============ Batch API ============&#10;    public static final class EntityBatch {&#10;        public final int[] entityIds;&#10;        public final int size;&#10;        private EntityBatch(int[] ids) { this.entityIds = ids; this.size = ids.length; }&#10;        public static EntityBatch of(int... ids) { return new EntityBatch(Arrays.copyOf(ids, ids.length)); }&#10;    }&#10;&#10;    public void setSharedComponent(EntityBatch batch, Object sharedValue) {&#10;        if (batch == null || batch.size == 0) return;&#10;        Objects.requireNonNull(sharedValue, &quot;sharedValue&quot;);&#10;        Class&lt;?&gt; type = sharedValue.getClass();&#10;        Integer typeId = getComponentTypeId(type);&#10;        if (typeId == null) throw new IllegalArgumentException(&quot;Shared component type not registered: &quot; + type.getName());&#10;        ComponentDescriptor desc = componentManager.getDescriptor(type);&#10;        if (desc == null || desc.getKind() != ComponentDescriptor.ComponentKind.SHARED_MANAGED) {&#10;            throw new IllegalArgumentException(&quot;Type is not a @Shared @Managed Component type: &quot; + type.getName());&#10;        }&#10;        int ticket = sharedStore.getOrAddSharedIndex(sharedValue);&#10;        // Group by old group&#10;        Map&lt;ChunkGroup, List&lt;Integer&gt;&gt; byOldGroup = new HashMap&lt;&gt;();&#10;        for (int eid : batch.entityIds) {&#10;            EntityRecord rec = entityRecords.get(eid);&#10;            if (rec == null) continue;&#10;            ChunkGroup oldGroup = rec.archetype.getChunkGroup(rec.sharedKey);&#10;            if (oldGroup == null) continue;&#10;            byOldGroup.computeIfAbsent(oldGroup, k -&gt; new ArrayList&lt;&gt;()).add(eid);&#10;        }&#10;        for (Map.Entry&lt;ChunkGroup, List&lt;Integer&gt;&gt; entry : byOldGroup.entrySet()) {&#10;            List&lt;Integer&gt; eids = entry.getValue();&#10;            if (eids.isEmpty()) continue;&#10;            ChunkGroup oldGroup = entry.getKey();&#10;            EntityRecord first = entityRecords.get(eids.get(0));&#10;            Archetype archetype = first.archetype;&#10;            int pos = archetype.getSharedManagedIndex(typeId);&#10;            // If archetype doesn't contain the shared type, fallback per-entity (mask extend) to keep logic simple now&#10;            if (pos &lt; 0) {&#10;                for (int eid : eids) setSharedComponent(eid, sharedValue);&#10;                continue;&#10;            }&#10;            // Build eids needing change and compute their respective newKey&#10;            Map&lt;SharedValueKey, List&lt;Integer&gt;&gt; byTargetKey = new HashMap&lt;&gt;();&#10;            for (int eid : eids) {&#10;                EntityRecord rec = entityRecords.get(eid);&#10;                if (rec == null) continue;&#10;                SharedValueKey oldKey = rec.sharedKey;&#10;                int managedCount = archetype.getSharedManagedTypeIds().length;&#10;                int[] managedIdx;&#10;                long[] unmanagedVals;&#10;                if (oldKey != null &amp;&amp; oldKey.managedSharedIndices() != null &amp;&amp; oldKey.managedSharedIndices().length == managedCount) {&#10;                    managedIdx = oldKey.managedSharedIndices().clone();&#10;                } else {&#10;                    managedIdx = new int[managedCount];&#10;                    java.util.Arrays.fill(managedIdx, -1);&#10;                    if (oldKey != null &amp;&amp; oldKey.managedSharedIndices() != null) {&#10;                        int copyLen = Math.min(managedIdx.length, oldKey.managedSharedIndices().length);&#10;                        System.arraycopy(oldKey.managedSharedIndices(), 0, managedIdx, 0, copyLen);&#10;                    }&#10;                }&#10;                unmanagedVals = (oldKey != null ? oldKey.unmanagedSharedValues() : null);&#10;                int prev = managedIdx[pos];&#10;                if (prev == ticket) continue; // unchanged&#10;                managedIdx[pos] = ticket;&#10;                SharedValueKey newKey = new SharedValueKey(managedIdx, unmanagedVals);&#10;                byTargetKey.computeIfAbsent(newKey, k -&gt; new ArrayList&lt;&gt;()).add(eid);&#10;            }&#10;            for (Map.Entry&lt;SharedValueKey, List&lt;Integer&gt;&gt; g : byTargetKey.entrySet()) {&#10;                SharedValueKey newKey = g.getKey();&#10;                ChunkGroup newGroup = archetype.getOrCreateChunkGroup(newKey);&#10;                if (newGroup == oldGroup) continue;&#10;                batchMoveShared(archetype, oldGroup, newGroup, g.getValue(), first.mask, first.mask, newKey);&#10;            }&#10;        }&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask oldMask, ComponentMask newMask, SharedValueKey newSharedKey) {&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;        ChunkGroup newGroup = newArchetype.getOrCreateChunkGroup(newSharedKey);&#10;        // Determine old group from current record&#10;        ChunkGroup oldGroup = oldRecord.archetype.getChunkGroup(oldRecord.sharedKey);&#10;&#10;        // Acquire locks in stable order to avoid deadlocks; handle null oldGroup&#10;        if (oldGroup == null || oldGroup == newGroup) {&#10;            newGroup.getResizeLock().lock();&#10;            try {&#10;                // Allocate in target&#10;                ArchetypeChunk.ChunkLocation newLocation = newGroup.addEntity(entityId);&#10;                ArchetypeChunk newChunk = newGroup.getChunk(newLocation.chunkIndex);&#10;                // Copy unmanaged data intersection (oldGroup may be null; skip copies if so)&#10;                ArchetypeChunk oldChunk = null;&#10;                if (oldGroup != null) {&#10;                    oldChunk = oldGroup.getChunk(oldRecord.location.chunkIndex);&#10;                }&#10;                int[] typeIds = newMask.toComponentIdArray();&#10;                if (oldChunk != null) {&#10;                    for (int componentTypeId : typeIds) {&#10;                        if (oldMask.has(componentTypeId)) {&#10;                            int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                            int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                            if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                                var oldData = oldChunk.getComponentData(oldIdx, oldRecord.location.indexInChunk);&#10;                                if (oldData != null) newChunk.setComponentData(newIdx, newLocation.indexInChunk, oldData);&#10;                            }&#10;                        }&#10;                    }&#10;                    // Transfer managed tickets intersection&#10;                    int[] oldManaged = oldRecord.archetype.getManagedTypeIds();&#10;                    int[] newManaged = newArchetype.getManagedTypeIds();&#10;                    if (oldManaged != null &amp;&amp; newManaged != null &amp;&amp; oldManaged.length &gt; 0 &amp;&amp; newManaged.length &gt; 0) {&#10;                        for (int tid : oldManaged) {&#10;                            int oldMIdx = oldRecord.archetype.getManagedTypeIndex(tid);&#10;                            int newMIdx = newArchetype.getManagedTypeIndex(tid);&#10;                            if (oldMIdx &gt;= 0 &amp;&amp; newMIdx &gt;= 0) {&#10;                                int ticket = oldChunk.getManagedTicket(oldMIdx, oldRecord.location.indexInChunk);&#10;                                if (ticket &gt;= 0) newChunk.setManagedTicket(newMIdx, newLocation.indexInChunk, ticket);&#10;                            }&#10;                        }&#10;                    }&#10;                    // Remove from old group now that copy is done&#10;                    oldGroup.removeEntity(oldRecord.location);&#10;                }&#10;                // Update record&#10;                entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask, newSharedKey));&#10;            } finally {&#10;                newGroup.getResizeLock().unlock();&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Two distinct groups: lock both in identity order&#10;        ChunkGroup first = oldGroup;&#10;        ChunkGroup second = newGroup;&#10;        if (System.identityHashCode(first) &gt; System.identityHashCode(second)) { first = newGroup; second = oldGroup; }&#10;        first.getResizeLock().lock();&#10;        try {&#10;            second.getResizeLock().lock();&#10;            try {&#10;                // Allocate in target&#10;                ArchetypeChunk.ChunkLocation newLocation = newGroup.addEntity(entityId);&#10;                ArchetypeChunk oldChunk = oldGroup.getChunk(oldRecord.location.chunkIndex);&#10;                ArchetypeChunk newChunk = newGroup.getChunk(newLocation.chunkIndex);&#10;                // Copy unmanaged instance data intersection&#10;                int[] typeIds = newMask.toComponentIdArray();&#10;                for (int componentTypeId : typeIds) {&#10;                    if (oldMask.has(componentTypeId)) {&#10;                        int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                        int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                        if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                            var oldData = oldChunk.getComponentData(oldIdx, oldRecord.location.indexInChunk);&#10;                            if (oldData != null) newChunk.setComponentData(newIdx, newLocation.indexInChunk, oldData);&#10;                        }&#10;                    }&#10;                }&#10;                // Transfer managed instance tickets intersection&#10;                int[] oldManaged = oldRecord.archetype.getManagedTypeIds();&#10;                int[] newManaged = newArchetype.getManagedTypeIds();&#10;                if (oldManaged != null &amp;&amp; newManaged != null &amp;&amp; oldManaged.length &gt; 0 &amp;&amp; newManaged.length &gt; 0) {&#10;                    for (int tid : oldManaged) {&#10;                        int oldMIdx = oldRecord.archetype.getManagedTypeIndex(tid);&#10;                        int newMIdx = newArchetype.getManagedTypeIndex(tid);&#10;                        if (oldMIdx &gt;= 0 &amp;&amp; newMIdx &gt;= 0) {&#10;                            int ticket = oldChunk.getManagedTicket(oldMIdx, oldRecord.location.indexInChunk);&#10;                            if (ticket &gt;= 0) newChunk.setManagedTicket(newMIdx, newLocation.indexInChunk, ticket);&#10;                        }&#10;                    }&#10;                }&#10;                // Remove from old group and update record&#10;                oldGroup.removeEntity(oldRecord.location);&#10;                entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask, newSharedKey));&#10;            } finally {&#10;                second.getResizeLock().unlock();&#10;            }&#10;        } finally {&#10;            first.getResizeLock().unlock();&#10;        }&#10;    }&#10;&#10;    private void batchMoveShared(Archetype archetype, ChunkGroup oldGroup, ChunkGroup newGroup, List&lt;Integer&gt; eids, ComponentMask oldMask, ComponentMask newMask, SharedValueKey newSharedKey) {&#10;        if (eids == null || eids.isEmpty()) return;&#10;        ChunkGroup first = oldGroup;&#10;        ChunkGroup second = newGroup;&#10;        if (System.identityHashCode(first) &gt; System.identityHashCode(second)) { first = newGroup; second = oldGroup; }&#10;        first.getResizeLock().lock();&#10;        try {&#10;            if (second != first) second.getResizeLock().lock();&#10;            try {&#10;                int n = eids.size();&#10;                int[] idsArr = new int[n];&#10;                for (int i = 0; i &lt; n; i++) idsArr[i] = eids.get(i);&#10;                ArchetypeChunk.ChunkLocation[] newLocs = newGroup.addEntities(idsArr);&#10;                ArchetypeChunk.ChunkLocation[] oldLocs = new ArchetypeChunk.ChunkLocation[n];&#10;                for (int i = 0; i &lt; n; i++) oldLocs[i] = entityRecords.get(idsArr[i]).location;&#10;&#10;                // Precompute unmanaged intersection index pairs&#10;                int[] compTypeIds = archetype.getComponentTypeIds();&#10;                int maxC = compTypeIds != null ? compTypeIds.length : 0;&#10;                int[] compOldIdx = new int[maxC];&#10;                int[] compNewIdx = new int[maxC];&#10;                int cCount = 0;&#10;                for (int t = 0; t &lt; maxC; t++) {&#10;                    int compTypeId = compTypeIds[t];&#10;                    if (!oldMask.has(compTypeId) || !newMask.has(compTypeId)) continue;&#10;                    int oi = archetype.indexOfComponentType(compTypeId);&#10;                    int ni = oi; // same archetype&#10;                    if (oi &gt;= 0 &amp;&amp; ni &gt;= 0) { compOldIdx[cCount] = oi; compNewIdx[cCount] = ni; cCount++; }&#10;                }&#10;                // Precompute managed intersection pairs&#10;                int[] managedTypeIds = archetype.getManagedTypeIds();&#10;                int maxM = managedTypeIds != null ? managedTypeIds.length : 0;&#10;                int[] manIdx = new int[maxM]; // same index on both sides for same archetype&#10;                int mCount = 0;&#10;                for (int t = 0; t &lt; maxM; t++) {&#10;                    int tid = managedTypeIds[t];&#10;                    if (!oldMask.has(tid) || !newMask.has(tid)) continue;&#10;                    int mi = archetype.getManagedTypeIndex(tid);&#10;                    if (mi &gt;= 0) { manIdx[mCount] = mi; mCount++; }&#10;                }&#10;&#10;                // Entity-first copy using precomputed indices&#10;                for (int i = 0; i &lt; n; i++) {&#10;                    ArchetypeChunk oldChunk = oldGroup.getChunk(oldLocs[i].chunkIndex);&#10;                    ArchetypeChunk newChunk = newGroup.getChunk(newLocs[i].chunkIndex);&#10;                    int oldSlot = oldLocs[i].indexInChunk;&#10;                    int newSlot = newLocs[i].indexInChunk;&#10;                    for (int k = 0; k &lt; cCount; k++) {&#10;                        MemorySegment src = oldChunk.getComponentData(compOldIdx[k], oldSlot);&#10;                        newChunk.setComponentData(compNewIdx[k], newSlot, src);&#10;                    }&#10;                    for (int k = 0; k &lt; mCount; k++) {&#10;                        int mi = manIdx[k];&#10;                        int ticket = oldChunk.getManagedTicket(mi, oldSlot);&#10;                        if (ticket &gt;= 0) newChunk.setManagedTicket(mi, newSlot, ticket);&#10;                    }&#10;                }&#10;&#10;                oldGroup.removeEntities(oldLocs);&#10;                for (int i = 0; i &lt; n; i++) entityRecords.put(idsArr[i], new EntityRecord(archetype, newLocs[i], newMask, newSharedKey));&#10;            } finally {&#10;                if (second != first) second.getResizeLock().unlock();&#10;            }&#10;        } finally {&#10;            first.getResizeLock().unlock();&#10;        }&#10;    }&#10;&#10;    private void batchMoveStructural(Archetype oldArch, Archetype newArch, ChunkGroup oldGroup, ChunkGroup newGroup, List&lt;Integer&gt; eids, ComponentMask oldMask, ComponentMask newMask, SharedValueKey key) {&#10;        if (eids.isEmpty()) return;&#10;        ChunkGroup first = oldGroup;&#10;        ChunkGroup second = newGroup;&#10;        if (System.identityHashCode(first) &gt; System.identityHashCode(second)) { first = newGroup; second = oldGroup; }&#10;        first.getResizeLock().lock();&#10;        try {&#10;            if (second != first) second.getResizeLock().lock();&#10;            try {&#10;                int n = eids.size();&#10;                int[] ids = new int[n];&#10;                for (int i = 0; i &lt; n; i++) ids[i] = eids.get(i);&#10;                ArchetypeChunk.ChunkLocation[] newLocs = newGroup.addEntities(ids);&#10;                ArchetypeChunk.ChunkLocation[] oldLocs = new ArchetypeChunk.ChunkLocation[n];&#10;                for (int i = 0; i &lt; n; i++) oldLocs[i] = entityRecords.get(ids[i]).location;&#10;&#10;                // Precompute unmanaged intersection index pairs between oldArch and newArch&#10;                int[] compTypeIds = newArch.getComponentTypeIds();&#10;                int maxC = compTypeIds != null ? compTypeIds.length : 0;&#10;                int[] compOldIdx = new int[maxC];&#10;                int[] compNewIdx = new int[maxC];&#10;                int cCount = 0;&#10;                for (int t = 0; t &lt; maxC; t++) {&#10;                    int compTypeId = compTypeIds[t];&#10;                    if (!oldMask.has(compTypeId) || !newMask.has(compTypeId)) continue;&#10;                    int oi = oldArch.indexOfComponentType(compTypeId);&#10;                    int ni = newArch.indexOfComponentType(compTypeId);&#10;                    if (oi &gt;= 0 &amp;&amp; ni &gt;= 0) { compOldIdx[cCount] = oi; compNewIdx[cCount] = ni; cCount++; }&#10;                }&#10;                // Precompute managed intersection and removals&#10;                int[] oldManagedIds = oldArch.getManagedTypeIds();&#10;                int[] newManagedIds = newArch.getManagedTypeIds();&#10;                int maxMi = oldManagedIds != null ? oldManagedIds.length : 0;&#10;                int[] manOldIdx = new int[maxMi];&#10;                int[] manNewIdx = new int[maxMi];&#10;                int miCount = 0;&#10;                int[] removeOldIdx = new int[maxMi];&#10;                int rCount = 0;&#10;                if (oldManagedIds != null) {&#10;                    for (int tid : oldManagedIds) {&#10;                        int oi = oldArch.getManagedTypeIndex(tid);&#10;                        boolean inOld = oldMask.has(tid);&#10;                        boolean inNew = newMask.has(tid);&#10;                        if (inOld &amp;&amp; inNew) {&#10;                            int ni = newArch.getManagedTypeIndex(tid);&#10;                            if (oi &gt;= 0 &amp;&amp; ni &gt;= 0) { manOldIdx[miCount] = oi; manNewIdx[miCount] = ni; miCount++; }&#10;                        } else if (inOld &amp;&amp; !inNew) {&#10;                            if (oi &gt;= 0) { removeOldIdx[rCount] = oi; rCount++; }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Entity-first copy and releases using precomputed indices&#10;                for (int i = 0; i &lt; n; i++) {&#10;                    ArchetypeChunk oldChunk = oldGroup.getChunk(oldLocs[i].chunkIndex);&#10;                    ArchetypeChunk newChunk = newGroup.getChunk(newLocs[i].chunkIndex);&#10;                    int oldSlot = oldLocs[i].indexInChunk;&#10;                    int newSlot = newLocs[i].indexInChunk;&#10;                    for (int k = 0; k &lt; cCount; k++) {&#10;                        MemorySegment src = oldChunk.getComponentData(compOldIdx[k], oldSlot);&#10;                        newChunk.setComponentData(compNewIdx[k], newSlot, src);&#10;                    }&#10;                    for (int k = 0; k &lt; miCount; k++) {&#10;                        int ticket = oldChunk.getManagedTicket(manOldIdx[k], oldSlot);&#10;                        if (ticket &gt;= 0) newChunk.setManagedTicket(manNewIdx[k], newSlot, ticket);&#10;                    }&#10;                    for (int k = 0; k &lt; rCount; k++) {&#10;                        int ticket = oldChunk.getManagedTicket(removeOldIdx[k], oldSlot);&#10;                        if (ticket &gt;= 0) managedStore.release(ticket);&#10;                    }&#10;                }&#10;&#10;                oldGroup.removeEntities(oldLocs);&#10;                for (int i = 0; i &lt; n; i++) entityRecords.put(ids[i], new EntityRecord(newArch, newLocs[i], newMask, key));&#10;            } finally {&#10;                if (second != first) second.getResizeLock().unlock();&#10;            }&#10;        } finally {&#10;            first.getResizeLock().unlock();&#10;        }&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask, SharedValueKey sharedKey) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;&#10;    public void addComponents(EntityBatch batch, Class&lt;?&gt; componentClass) {&#10;        if (batch == null || batch.size == 0) return;&#10;        addComponents(batch, new Class&lt;?&gt;[]{componentClass});&#10;    }&#10;&#10;    public void removeComponents(EntityBatch batch, Class&lt;?&gt; componentClass) {&#10;        if (batch == null || batch.size == 0) return;&#10;        removeComponents(batch, new Class&lt;?&gt;[]{componentClass});&#10;    }&#10;&#10;    // New: multi-component batch add/remove/mutate&#10;    public void addComponents(EntityBatch batch, Class&lt;?&gt;... componentClasses) {&#10;        if (batch == null || batch.size == 0 || componentClasses == null || componentClasses.length == 0) return;&#10;        mutateComponents(batch, componentClasses, new Class&lt;?&gt;[0]);&#10;    }&#10;&#10;    public void removeComponents(EntityBatch batch, Class&lt;?&gt;... componentClasses) {&#10;        if (batch == null || batch.size == 0 || componentClasses == null || componentClasses.length == 0) return;&#10;        mutateComponents(batch, new Class&lt;?&gt;[0], componentClasses);&#10;    }&#10;&#10;    public void mutateComponents(EntityBatch batch, Class&lt;?&gt;[] addClasses, Class&lt;?&gt;[] removeClasses) {&#10;        if (batch == null || batch.size == 0) return;&#10;        // Pre-resolve type ids&#10;        int addCount = addClasses != null ? addClasses.length : 0;&#10;        int remCount = removeClasses != null ? removeClasses.length : 0;&#10;        int[] addTypeIds = new int[addCount];&#10;        int[] remTypeIds = new int[remCount];&#10;        for (int i = 0; i &lt; addCount; i++) {&#10;            Integer tid = getComponentTypeId(addClasses[i]);&#10;            if (tid == null) throw new IllegalArgumentException(&quot;Component type not registered: &quot; + addClasses[i].getName());&#10;            addTypeIds[i] = tid;&#10;        }&#10;        for (int i = 0; i &lt; remCount; i++) {&#10;            Integer tid = getComponentTypeId(removeClasses[i]);&#10;            if (tid == null) throw new IllegalArgumentException(&quot;Component type not registered: &quot; + removeClasses[i].getName());&#10;            remTypeIds[i] = tid;&#10;        }&#10;        // Group by old archetype&#10;        Map&lt;Archetype, List&lt;Integer&gt;&gt; byArchetype = new HashMap&lt;&gt;();&#10;        for (int eid : batch.entityIds) {&#10;            EntityRecord rec = entityRecords.get(eid);&#10;            if (rec == null) continue;&#10;            byArchetype.computeIfAbsent(rec.archetype, k -&gt; new ArrayList&lt;&gt;()).add(eid);&#10;        }&#10;        for (Map.Entry&lt;Archetype, List&lt;Integer&gt;&gt; entry : byArchetype.entrySet()) {&#10;            Archetype oldArch = entry.getKey();&#10;            List&lt;Integer&gt; eids = entry.getValue();&#10;            if (eids.isEmpty()) continue;&#10;            // Build new mask once for this old archetype&#10;            ComponentMask newMask = oldArch.getMask();&#10;            for (int tid : addTypeIds) newMask = newMask.set(tid);&#10;            for (int tid : remTypeIds) newMask = newMask.clear(tid);&#10;            if (newMask.equals(oldArch.getMask())) continue; // nothing to do&#10;            Archetype newArch = archetypeManager.getOrCreateArchetype(newMask);&#10;            // Partition by shared key to keep batch moves localized&#10;            Map&lt;SharedValueKey, List&lt;Integer&gt;&gt; byShared = new HashMap&lt;&gt;();&#10;            for (int eid : eids) {&#10;                EntityRecord rec = entityRecords.get(eid);&#10;                byShared.computeIfAbsent(rec.sharedKey, k -&gt; new ArrayList&lt;&gt;()).add(eid);&#10;            }&#10;            for (Map.Entry&lt;SharedValueKey, List&lt;Integer&gt;&gt; sg : byShared.entrySet()) {&#10;                SharedValueKey key = sg.getKey();&#10;                ChunkGroup oldGroup = oldArch.getChunkGroup(key);&#10;                ChunkGroup newGroup = newArch.getOrCreateChunkGroup(key);&#10;                batchMoveStructural(oldArch, newArch, oldGroup, newGroup, sg.getValue(), oldArch.getMask(), newMask, key);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Expose arena for ECB lane allocations (package-private for now)&#10;    Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Thm mt component (unmanaged) vo entity v khi to n ngay lp tc&#10;     * bng cch s dng mt initializer lambda type-safe.&#10;     * y l phng thc zero-copy, zero-allocation (ngoi tr vic di chuyn archetype).&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;THandle extends IBindableHandle&gt; void addComponent(&#10;        int entityId,&#10;        Class&lt;?&gt; componentClass,&#10;        java.util.function.Consumer&lt;THandle&gt; initializer&#10;    ) {&#10;        // 1. Ly record hin ti&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;        Integer componentTypeId = getComponentTypeId(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass.getName() + &quot; not registered&quot;);&#10;        }&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc != null &amp;&amp; desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;addComponent(entityId, Class, Consumer) khng h tr managed component &quot; + componentClass.getName());&#10;        }&#10;        if (record.mask.has(componentTypeId)) {&#10;            // Entity  c component ny, ch cn chy initializer&#10;            initializeComponent(entityId, record, componentClass, initializer);&#10;            return;&#10;        }&#10;&#10;        // 2. Di chuyn entity (Structural Change)&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;        moveEntityToArchetype(entityId, record, record.mask, newMask, record.sharedKey);&#10;&#10;        // 3. Ly record MI (sau khi di chuyn)&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;&#10;        // 4. Chy logic khi to&#10;        initializeComponent(entityId, newRecord, componentClass, initializer);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    private &lt;THandle extends IBindableHandle&gt; void initializeComponent(&#10;        int entityId,&#10;        EntityRecord record,&#10;        Class&lt;?&gt; componentClass,&#10;        java.util.function.Consumer&lt;THandle&gt; initializer&#10;    ) {&#10;        // 1. Chun b cc handle t pool&#10;        ComponentHandle rawHandle = componentManager.acquireHandle();&#10;        IBindableHandle typedHandle = componentManager.acquireTypedHandle(componentClass);&#10;&#10;        try {&#10;            // 2. Tm slot b nh (memory slot) THC T ca component&#10;            ChunkGroup group = record.archetype.getChunkGroup(record.sharedKey);&#10;            if (group == null) throw new IllegalStateException(&quot;ChunkGroup not found&quot;);&#10;&#10;            ArchetypeChunk chunk = group.getChunk(record.location.chunkIndex);&#10;            Integer typeId = getComponentTypeId(componentClass);&#10;            if (typeId == null) {&#10;                throw new IllegalStateException(&quot;Component type &quot; + componentClass.getName() + &quot; not registered in world&quot;);&#10;            }&#10;            int componentIndex = record.archetype.indexOfComponentType(typeId);&#10;            if (componentIndex &lt; 0) {&#10;                throw new IllegalStateException(&quot;Component index not found after add for &quot; + componentClass.getName());&#10;            }&#10;&#10;            // B NH  TN TI V C ZERO-ED TRONG CHUNK CONSTRUCTOR&#10;            MemorySegment liveSegment = chunk.getComponentData(componentIndex, record.location.indexInChunk);&#10;&#10;            // 3. &quot;Bind&quot; (tr) cc handle vo slot b nh &#10;            rawHandle.reset(liveSegment, componentManager.getDescriptor(componentClass));&#10;            typedHandle.__bind(rawHandle);&#10;&#10;            // 4. Gi lambda ca user: user ang ghi TRC TIP vo b nh ca chunk&#10;            initializer.accept((THandle) typedHandle);&#10;&#10;        } finally {&#10;            // 5. Lun lun tr handle v pool&#10;            componentManager.releaseHandle(rawHandle);&#10;            componentManager.releaseTypedHandle(componentClass, typedHandle);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;import com.ethnicthv.ecs.core.components.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ComponentManager componentManager;&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    // New: global store for managed components&#10;    private final ManagedComponentStore managedStore = new ManagedComponentStore();&#10;    // New: store for managed shared components (de-duplicated)&#10;    final SharedComponentStore sharedStore = new SharedComponentStore();&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager (SSOT for IDs).&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentManager.registerComponent(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ChunkGroup group = archetype.getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;        ArchetypeChunk.ChunkLocation location = group.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask, new SharedValueKey(null, null)));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * The components will be initialized with default (zeroed) values.&#10;     *&#10;     * @param c1 The first component class to add.&#10;     * @return The ID of the newly created entity.&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1) {&#10;        return createEntityWithComponents(c1);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2) {&#10;        return createEntityWithComponents(c1, c2);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3) {&#10;        return createEntityWithComponents(c1, c2, c3);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3, Class&lt;?&gt; c4) {&#10;        return createEntityWithComponents(c1, c2, c3, c4);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3, Class&lt;?&gt; c4, Class&lt;?&gt; c5) {&#10;        return createEntityWithComponents(c1, c2, c3, c4, c5);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3, Class&lt;?&gt; c4, Class&lt;?&gt; c5, Class&lt;?&gt; c6) {&#10;        return createEntityWithComponents(c1, c2, c3, c4, c5, c6);&#10;    }&#10;&#10;    private int createEntityWithComponents(Class&lt;?&gt;... componentClasses) {&#10;        // 1. Create the entity ID&#10;        int entityId = nextEntityId.getAndIncrement();&#10;&#10;        // 2. Build the component mask&#10;        ComponentMask mask = new ComponentMask();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = getComponentTypeId(componentClass);&#10;            if (componentTypeId == null) {&#10;                throw new IllegalArgumentException(&quot;Component type &quot; + componentClass.getName() + &quot; is not registered.&quot;);&#10;            }&#10;            mask = mask.set(componentTypeId);&#10;        }&#10;&#10;        // 3. Get or create the target archetype&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(mask);&#10;        ChunkGroup group = archetype.getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;&#10;        // 4. Add the entity to the archetype and store its record&#10;        ArchetypeChunk.ChunkLocation location = group.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, mask, new SharedValueKey(null, null)));&#10;&#10;        // 5. Allocate and assign default (zeroed) memory for each unmanaged component&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;                if (desc != null &amp;&amp; !desc.isManaged()) {&#10;                    MemorySegment data = componentManager.allocate(componentClass, arena); // Zeroed by default&#10;                    int componentIndex = archetype.indexOfComponentType(componentTypeId);&#10;                    if (componentIndex &gt;= 0) {&#10;                        archetype.setComponentData(location, componentIndex, data);&#10;                    }&#10;                }&#10;                // For managed components, default ticket remains -1 until user provides an instance&#10;            }&#10;        }&#10;&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity (unmanaged path: memory segment).&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = getComponentTypeId(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc != null &amp;&amp; desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;addComponent(entityId, Class, MemorySegment) not valid for managed component &quot; + componentClass.getName());&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype (preserve shared key)&#10;        moveEntityToArchetype(entityId, record, record.mask, newMask, record.sharedKey);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Add a managed component instance to an entity. The instance is stored in the ManagedComponentStore&#10;     * and the ticket is placed into the chunk's managed index array.&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, T componentInstance) {&#10;        if (componentInstance == null) throw new IllegalArgumentException(&quot;componentInstance must not be null&quot;);&#10;        Class&lt;?&gt; componentClass = componentInstance.getClass();&#10;&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = getComponentTypeId(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc == null || !desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass.getName() + &quot; is not marked @Component.Managed&quot;);&#10;        }&#10;&#10;        // 1) Store managed instance and get ticket&#10;        int ticket = managedStore.store(componentInstance);&#10;&#10;        // 2) Structural change: move entity to new archetype that includes this component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;        moveEntityToArchetype(entityId, record, record.mask, newMask, record.sharedKey);&#10;&#10;        // 3) Wire ticket into the new chunk's managed index array&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int managedTypeIndex = newRecord.archetype.getManagedTypeIndex(componentTypeId);&#10;        if (managedTypeIndex &lt; 0) {&#10;            throw new IllegalStateException(&quot;Managed type index not found for component id=&quot; + componentTypeId);&#10;        }&#10;        ChunkGroup newGroup = newRecord.archetype.getChunkGroup(newRecord.sharedKey);&#10;        if (newGroup == null) throw new IllegalStateException(&quot;ChunkGroup not found for new entity shared key&quot;);&#10;        ArchetypeChunk newChunk = newGroup.getChunk(newRecord.location.chunkIndex);&#10;        newChunk.setManagedTicket(managedTypeIndex, newRecord.location.indexInChunk, ticket);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity. For managed components, release the stored object.&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = getComponentTypeId(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // If managed, release the ticket before moving&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc != null &amp;&amp; desc.isManaged()) {&#10;            int managedIdx = record.archetype.getManagedTypeIndex(componentTypeId);&#10;            if (managedIdx &gt;= 0) {&#10;                ChunkGroup group = record.archetype.getChunkGroup(record.sharedKey);&#10;                if (group != null) {&#10;                    ArchetypeChunk chunk = group.getChunk(record.location.chunkIndex);&#10;                    int ticket = chunk.getManagedTicket(managedIdx, record.location.indexInChunk);&#10;                    if (ticket &gt;= 0) {&#10;                        managedStore.release(ticket);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype, preserve shared key&#10;        moveEntityToArchetype(entityId, record, record.mask, newMask, record.sharedKey);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = getComponentTypeId(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = getComponentTypeId(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            // Release all managed tickets for this entity before removing&#10;            int[] managedIds = record.archetype.getManagedTypeIds();&#10;            if (managedIds != null &amp;&amp; managedIds.length &gt; 0) {&#10;                ChunkGroup group = record.archetype.getChunkGroup(record.sharedKey);&#10;                if (group != null) {&#10;                    ArchetypeChunk chunk = group.getChunk(record.location.chunkIndex);&#10;                    for (int i = 0; i &lt; managedIds.length; i++) {&#10;                        int ticket = chunk.getManagedTicket(i, record.location.indexInChunk);&#10;                        if (ticket &gt;= 0) managedStore.release(ticket);&#10;                    }&#10;                }&#10;            }&#10;            // Release shared managed tickets referenced by key&#10;            if (record.sharedKey != null &amp;&amp; record.sharedKey.managedSharedIndices() != null) {&#10;                for (int idx : record.sharedKey.managedSharedIndices()) {&#10;                    if (idx &gt;= 0) sharedStore.releaseSharedIndex(idx);&#10;                }&#10;            }&#10;            // Remove from the correct chunk group&#10;            ChunkGroup group = record.archetype.getChunkGroup(record.sharedKey);&#10;            if (group != null) group.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query builder for entities matching component requirements.&#10;     * &lt;p&gt;&#10;     * Returns a builder that can be configured with component requirements,&#10;     * then built into an immutable {@link com.ethnicthv.ecs.core.api.archetype.IQuery}.&#10;     *&#10;     * @return a new query builder&#10;     */&#10;    public IQueryBuilder query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID via ComponentManager (SSOT).&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentManager.getTypeId(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata using ComponentManager as SSOT.&#10;     * Fast path: resolve id -&gt; descriptor in O(1) and derive class/size from it.&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentTypeId);&#10;        if (desc == null) {&#10;            throw new IllegalStateException(&quot;Khng tm thy Descriptor cho component typeId: &quot; + componentTypeId);&#10;        }&#10;        Class&lt;?&gt; componentClass = desc.getComponentClass();&#10;        return new ComponentMetadata(componentTypeId, componentClass, desc.getTotalSize());&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    /**&#10;     * Retrieve a managed component instance for an entity, or null if absent.&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getManagedComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) return null;&#10;        Integer typeId = getComponentTypeId(componentClass);&#10;        if (typeId == null || !record.mask.has(typeId)) return null;&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc == null || !desc.isManaged()) return null;&#10;        int mIdx = record.archetype.getManagedTypeIndex(typeId);&#10;        if (mIdx &lt; 0) return null;&#10;        ChunkGroup group = record.archetype.getChunkGroup(record.sharedKey);&#10;        if (group == null) return null;&#10;        ArchetypeChunk chunk = group.getChunk(record.location.chunkIndex);&#10;        int ticket = chunk.getManagedTicket(mIdx, record.location.indexInChunk);&#10;        if (ticket &lt; 0) return null;&#10;        Object obj = managedStore.get(ticket);&#10;        return (T) obj;&#10;    }&#10;&#10;    /**&#10;     * Replace or set a managed component instance for an entity.&#10;     * If an old instance exists, its ticket is released; the new instance is stored and wired.&#10;     */&#10;    public &lt;T&gt; void setManagedComponent(int entityId, T newInstance) {&#10;        if (newInstance == null) throw new IllegalArgumentException(&quot;newInstance must not be null&quot;);&#10;        Class&lt;?&gt; componentClass = newInstance.getClass();&#10;        Integer typeId = getComponentTypeId(componentClass);&#10;        if (typeId == null) throw new IllegalArgumentException(&quot;Component type not registered: &quot; + componentClass.getName());&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc == null || !desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;Component is not managed: &quot; + componentClass.getName());&#10;        }&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null || !record.mask.has(typeId)) {&#10;            // If not present, this behaves like addComponent(entityId, instance)&#10;            addComponent(entityId, newInstance);&#10;            return;&#10;        }&#10;        // Release old ticket (if any)&#10;        int mIdx = record.archetype.getManagedTypeIndex(typeId);&#10;        ChunkGroup group = record.archetype.getChunkGroup(record.sharedKey);&#10;        if (group == null) throw new IllegalStateException(&quot;ChunkGroup not found for entity shared key&quot;);&#10;        ArchetypeChunk chunk = group.getChunk(record.location.chunkIndex);&#10;        int oldTicket = chunk.getManagedTicket(mIdx, record.location.indexInChunk);&#10;        if (oldTicket &gt;= 0) managedStore.release(oldTicket);&#10;        // Store new instance and set ticket&#10;        int newTicket = managedStore.store(newInstance);&#10;        chunk.setManagedTicket(mIdx, record.location.indexInChunk, newTicket);&#10;    }&#10;&#10;    // ============ Shared Component APIs ============&#10;&#10;    public &lt;T&gt; void setSharedComponent(int entityId, T managedValue) {&#10;        if (managedValue == null) throw new IllegalArgumentException(&quot;managedValue must not be null&quot;);&#10;        Class&lt;?&gt; type = managedValue.getClass();&#10;        Integer typeId = getComponentTypeId(type);&#10;        if (typeId == null) throw new IllegalArgumentException(&quot;Shared component type not registered: &quot; + type.getName());&#10;        ComponentDescriptor desc = componentManager.getDescriptor(type);&#10;        if (desc == null || desc.getKind() != ComponentDescriptor.ComponentKind.SHARED_MANAGED) {&#10;            throw new IllegalArgumentException(&quot;Type is not a @Shared @Managed Component type: &quot; + type.getName());&#10;        }&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) throw new IllegalArgumentException(&quot;Entity does not exist: &quot; + entityId);&#10;        // If current archetype does not yet contain this shared type, structurally add it by extending the mask.&#10;        int pos = record.archetype.getSharedManagedIndex(typeId);&#10;        if (pos &lt; 0) {&#10;            ComponentMask newMask = record.mask.set(typeId);&#10;            // Move entity to new archetype with extended mask (retain old shared key first)&#10;            moveEntityToArchetype(entityId, record, record.mask, newMask, record.sharedKey);&#10;            record = entityRecords.get(entityId);&#10;            pos = record.archetype.getSharedManagedIndex(typeId);&#10;            if (pos &lt; 0) throw new IllegalStateException(&quot;Shared managed type index still missing after structural add: id=&quot; + typeId);&#10;        }&#10;        int ticket = sharedStore.getOrAddSharedIndex(managedValue);&#10;        SharedValueKey oldKey = record.sharedKey;&#10;        int[] managedIdx;&#10;        // Prepare sized array matching current archetype's shared managed type ids&#10;        int managedCount = record.archetype.getSharedManagedTypeIds().length;&#10;        if (oldKey != null &amp;&amp; oldKey.managedSharedIndices() != null &amp;&amp; oldKey.managedSharedIndices().length == managedCount) {&#10;            managedIdx = oldKey.managedSharedIndices().clone();&#10;        } else {&#10;            managedIdx = new int[managedCount];&#10;            java.util.Arrays.fill(managedIdx, -1);&#10;            if (oldKey != null &amp;&amp; oldKey.managedSharedIndices() != null) {&#10;                // Copy overlapping old indices into new sized array (in case of expansion)&#10;                int copyLen = Math.min(managedIdx.length, oldKey.managedSharedIndices().length);&#10;                System.arraycopy(oldKey.managedSharedIndices(), 0, managedIdx, 0, copyLen);&#10;            }&#10;        }&#10;        int old = managedIdx[pos];&#10;        managedIdx[pos] = ticket;&#10;        SharedValueKey newKey = new SharedValueKey(managedIdx, oldKey != null ? oldKey.unmanagedSharedValues() : null);&#10;        if (oldKey != null &amp;&amp; java.util.Arrays.equals(oldKey.managedSharedIndices(), managedIdx)) return; // unchanged&#10;        moveEntityToArchetype(entityId, record, record.mask, record.mask, newKey);&#10;        if (oldKey != null &amp;&amp; old &gt;= 0 &amp;&amp; old != ticket) sharedStore.releaseSharedIndex(old);&#10;    }&#10;&#10;    public void setSharedComponent(int entityId, Class&lt;?&gt; unmanagedSharedType, long value) {&#10;        Integer typeId = getComponentTypeId(unmanagedSharedType);&#10;        if (typeId == null) throw new IllegalArgumentException(&quot;Shared component type not registered: &quot; + unmanagedSharedType.getName());&#10;        ComponentDescriptor desc = componentManager.getDescriptor(unmanagedSharedType);&#10;        if (desc == null || desc.getKind() != ComponentDescriptor.ComponentKind.SHARED_UNMANAGED) {&#10;            throw new IllegalArgumentException(&quot;Type is not an @Unmanaged @Shared Component type: &quot; + unmanagedSharedType.getName());&#10;        }&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) throw new IllegalArgumentException(&quot;Entity does not exist: &quot; + entityId);&#10;        // Ensure archetype contains shared unmanaged type; if not, extend mask.&#10;        int pos = record.archetype.getSharedUnmanagedIndex(typeId);&#10;        if (pos &lt; 0) {&#10;            ComponentMask newMask = record.mask.set(typeId);&#10;            moveEntityToArchetype(entityId, record, record.mask, newMask, record.sharedKey);&#10;            record = entityRecords.get(entityId);&#10;            pos = record.archetype.getSharedUnmanagedIndex(typeId);&#10;            if (pos &lt; 0) throw new IllegalStateException(&quot;Shared unmanaged type index still missing after structural add: id=&quot; + typeId);&#10;        }&#10;        SharedValueKey oldKey = record.sharedKey;&#10;        int unmanagedCount = record.archetype.getSharedUnmanagedTypeIds().length;&#10;        long[] unmanagedVals;&#10;        if (oldKey != null &amp;&amp; oldKey.unmanagedSharedValues() != null &amp;&amp; oldKey.unmanagedSharedValues().length == unmanagedCount) {&#10;            unmanagedVals = oldKey.unmanagedSharedValues().clone();&#10;        } else {&#10;            unmanagedVals = new long[unmanagedCount];&#10;            java.util.Arrays.fill(unmanagedVals, Long.MIN_VALUE);&#10;            if (oldKey != null &amp;&amp; oldKey.unmanagedSharedValues() != null) {&#10;                int copyLen = Math.min(unmanagedVals.length, oldKey.unmanagedSharedValues().length);&#10;                System.arraycopy(oldKey.unmanagedSharedValues(), 0, unmanagedVals, 0, copyLen);&#10;            }&#10;        }&#10;        long oldVal = unmanagedVals[pos];&#10;        unmanagedVals[pos] = value;&#10;        SharedValueKey newKey = new SharedValueKey(oldKey != null ? oldKey.managedSharedIndices() : null, unmanagedVals);&#10;        if (oldKey != null &amp;&amp; java.util.Arrays.equals(oldKey.unmanagedSharedValues(), unmanagedVals)) return; // unchanged&#10;        moveEntityToArchetype(entityId, record, record.mask, record.mask, newKey);&#10;        // no ticket release for unmanaged values&#10;    }&#10;&#10;    // Expose non-mutating shared index lookup for query building&#10;    public int findSharedIndex(Object value) {&#10;        return sharedStore.findIndex(value);&#10;    }&#10;&#10;    // ============ Batch API ============&#10;    public static final class EntityBatch {&#10;        public final int[] entityIds;&#10;        public final int size;&#10;        private EntityBatch(int[] ids) { this.entityIds = ids; this.size = ids.length; }&#10;        public static EntityBatch of(int... ids) { return new EntityBatch(Arrays.copyOf(ids, ids.length)); }&#10;    }&#10;&#10;    public void setSharedComponent(EntityBatch batch, Object sharedValue) {&#10;        if (batch == null || batch.size == 0) return;&#10;        Objects.requireNonNull(sharedValue, &quot;sharedValue&quot;);&#10;        Class&lt;?&gt; type = sharedValue.getClass();&#10;        Integer typeId = getComponentTypeId(type);&#10;        if (typeId == null) throw new IllegalArgumentException(&quot;Shared component type not registered: &quot; + type.getName());&#10;        ComponentDescriptor desc = componentManager.getDescriptor(type);&#10;        if (desc == null || desc.getKind() != ComponentDescriptor.ComponentKind.SHARED_MANAGED) {&#10;            throw new IllegalArgumentException(&quot;Type is not a @Shared @Managed Component type: &quot; + type.getName());&#10;        }&#10;        int ticket = sharedStore.getOrAddSharedIndex(sharedValue);&#10;        // Group by old group&#10;        Map&lt;ChunkGroup, List&lt;Integer&gt;&gt; byOldGroup = new HashMap&lt;&gt;();&#10;        for (int eid : batch.entityIds) {&#10;            EntityRecord rec = entityRecords.get(eid);&#10;            if (rec == null) continue;&#10;            ChunkGroup oldGroup = rec.archetype.getChunkGroup(rec.sharedKey);&#10;            if (oldGroup == null) continue;&#10;            byOldGroup.computeIfAbsent(oldGroup, k -&gt; new ArrayList&lt;&gt;()).add(eid);&#10;        }&#10;        for (Map.Entry&lt;ChunkGroup, List&lt;Integer&gt;&gt; entry : byOldGroup.entrySet()) {&#10;            List&lt;Integer&gt; eids = entry.getValue();&#10;            if (eids.isEmpty()) continue;&#10;            ChunkGroup oldGroup = entry.getKey();&#10;            EntityRecord first = entityRecords.get(eids.get(0));&#10;            Archetype archetype = first.archetype;&#10;            int pos = archetype.getSharedManagedIndex(typeId);&#10;            // If archetype doesn't contain the shared type, fallback per-entity (mask extend) to keep logic simple now&#10;            if (pos &lt; 0) {&#10;                for (int eid : eids) setSharedComponent(eid, sharedValue);&#10;                continue;&#10;            }&#10;            // Build eids needing change and compute their respective newKey&#10;            Map&lt;SharedValueKey, List&lt;Integer&gt;&gt; byTargetKey = new HashMap&lt;&gt;();&#10;            for (int eid : eids) {&#10;                EntityRecord rec = entityRecords.get(eid);&#10;                if (rec == null) continue;&#10;                SharedValueKey oldKey = rec.sharedKey;&#10;                int managedCount = archetype.getSharedManagedTypeIds().length;&#10;                int[] managedIdx;&#10;                long[] unmanagedVals;&#10;                if (oldKey != null &amp;&amp; oldKey.managedSharedIndices() != null &amp;&amp; oldKey.managedSharedIndices().length == managedCount) {&#10;                    managedIdx = oldKey.managedSharedIndices().clone();&#10;                } else {&#10;                    managedIdx = new int[managedCount];&#10;                    java.util.Arrays.fill(managedIdx, -1);&#10;                    if (oldKey != null &amp;&amp; oldKey.managedSharedIndices() != null) {&#10;                        int copyLen = Math.min(managedIdx.length, oldKey.managedSharedIndices().length);&#10;                        System.arraycopy(oldKey.managedSharedIndices(), 0, managedIdx, 0, copyLen);&#10;                    }&#10;                }&#10;                unmanagedVals = (oldKey != null ? oldKey.unmanagedSharedValues() : null);&#10;                int prev = managedIdx[pos];&#10;                if (prev == ticket) continue; // unchanged&#10;                managedIdx[pos] = ticket;&#10;                SharedValueKey newKey = new SharedValueKey(managedIdx, unmanagedVals);&#10;                byTargetKey.computeIfAbsent(newKey, k -&gt; new ArrayList&lt;&gt;()).add(eid);&#10;            }&#10;            for (Map.Entry&lt;SharedValueKey, List&lt;Integer&gt;&gt; g : byTargetKey.entrySet()) {&#10;                SharedValueKey newKey = g.getKey();&#10;                ChunkGroup newGroup = archetype.getOrCreateChunkGroup(newKey);&#10;                if (newGroup == oldGroup) continue;&#10;                batchMoveShared(archetype, oldGroup, newGroup, g.getValue(), first.mask, first.mask, newKey);&#10;            }&#10;        }&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask oldMask, ComponentMask newMask, SharedValueKey newSharedKey) {&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;        ChunkGroup newGroup = newArchetype.getOrCreateChunkGroup(newSharedKey);&#10;        // Determine old group from current record&#10;        ChunkGroup oldGroup = oldRecord.archetype.getChunkGroup(oldRecord.sharedKey);&#10;&#10;        // Acquire locks in stable order to avoid deadlocks; handle null oldGroup&#10;        if (oldGroup == null || oldGroup == newGroup) {&#10;            newGroup.getResizeLock().lock();&#10;            try {&#10;                // Allocate in target&#10;                ArchetypeChunk.ChunkLocation newLocation = newGroup.addEntity(entityId);&#10;                ArchetypeChunk newChunk = newGroup.getChunk(newLocation.chunkIndex);&#10;                // Copy unmanaged data intersection (oldGroup may be null; skip copies if so)&#10;                ArchetypeChunk oldChunk = null;&#10;                if (oldGroup != null) {&#10;                    oldChunk = oldGroup.getChunk(oldRecord.location.chunkIndex);&#10;                }&#10;                int[] typeIds = newMask.toComponentIdArray();&#10;                if (oldChunk != null) {&#10;                    for (int componentTypeId : typeIds) {&#10;                        if (oldMask.has(componentTypeId)) {&#10;                            int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                            int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                            if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                                var oldData = oldChunk.getComponentData(oldIdx, oldRecord.location.indexInChunk);&#10;                                if (oldData != null) newChunk.setComponentData(newIdx, newLocation.indexInChunk, oldData);&#10;                            }&#10;                        }&#10;                    }&#10;                    // Transfer managed tickets intersection&#10;                    int[] oldManaged = oldRecord.archetype.getManagedTypeIds();&#10;                    int[] newManaged = newArchetype.getManagedTypeIds();&#10;                    if (oldManaged != null &amp;&amp; newManaged != null &amp;&amp; oldManaged.length &gt; 0 &amp;&amp; newManaged.length &gt; 0) {&#10;                        for (int tid : oldManaged) {&#10;                            int oldMIdx = oldRecord.archetype.getManagedTypeIndex(tid);&#10;                            int newMIdx = newArchetype.getManagedTypeIndex(tid);&#10;                            if (oldMIdx &gt;= 0 &amp;&amp; newMIdx &gt;= 0) {&#10;                                int ticket = oldChunk.getManagedTicket(oldMIdx, oldRecord.location.indexInChunk);&#10;                                if (ticket &gt;= 0) newChunk.setManagedTicket(newMIdx, newLocation.indexInChunk, ticket);&#10;                            }&#10;                        }&#10;                    }&#10;                    // Remove from old group now that copy is done&#10;                    oldGroup.removeEntity(oldRecord.location);&#10;                }&#10;                // Update record&#10;                entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask, newSharedKey));&#10;            } finally {&#10;                newGroup.getResizeLock().unlock();&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Two distinct groups: lock both in identity order&#10;        ChunkGroup first = oldGroup;&#10;        ChunkGroup second = newGroup;&#10;        if (System.identityHashCode(first) &gt; System.identityHashCode(second)) { first = newGroup; second = oldGroup; }&#10;        first.getResizeLock().lock();&#10;        try {&#10;            second.getResizeLock().lock();&#10;            try {&#10;                // Allocate in target&#10;                ArchetypeChunk.ChunkLocation newLocation = newGroup.addEntity(entityId);&#10;                ArchetypeChunk oldChunk = oldGroup.getChunk(oldRecord.location.chunkIndex);&#10;                ArchetypeChunk newChunk = newGroup.getChunk(newLocation.chunkIndex);&#10;                // Copy unmanaged instance data intersection&#10;                int[] typeIds = newMask.toComponentIdArray();&#10;                for (int componentTypeId : typeIds) {&#10;                    if (oldMask.has(componentTypeId)) {&#10;                        int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                        int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                        if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                            var oldData = oldChunk.getComponentData(oldIdx, oldRecord.location.indexInChunk);&#10;                            if (oldData != null) newChunk.setComponentData(newIdx, newLocation.indexInChunk, oldData);&#10;                        }&#10;                    }&#10;                }&#10;                // Transfer managed instance tickets intersection&#10;                int[] oldManaged = oldRecord.archetype.getManagedTypeIds();&#10;                int[] newManaged = newArchetype.getManagedTypeIds();&#10;                if (oldManaged != null &amp;&amp; newManaged != null &amp;&amp; oldManaged.length &gt; 0 &amp;&amp; newManaged.length &gt; 0) {&#10;                    for (int tid : oldManaged) {&#10;                        int oldMIdx = oldRecord.archetype.getManagedTypeIndex(tid);&#10;                        int newMIdx = newArchetype.getManagedTypeIndex(tid);&#10;                        if (oldMIdx &gt;= 0 &amp;&amp; newMIdx &gt;= 0) {&#10;                            int ticket = oldChunk.getManagedTicket(oldMIdx, oldRecord.location.indexInChunk);&#10;                            if (ticket &gt;= 0) newChunk.setManagedTicket(newMIdx, newLocation.indexInChunk, ticket);&#10;                        }&#10;                    }&#10;                }&#10;                // Remove from old group and update record&#10;                oldGroup.removeEntity(oldRecord.location);&#10;                entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask, newSharedKey));&#10;            } finally {&#10;                second.getResizeLock().unlock();&#10;            }&#10;        } finally {&#10;            first.getResizeLock().unlock();&#10;        }&#10;    }&#10;&#10;    private void batchMoveShared(Archetype archetype, ChunkGroup oldGroup, ChunkGroup newGroup, List&lt;Integer&gt; eids, ComponentMask oldMask, ComponentMask newMask, SharedValueKey newSharedKey) {&#10;        if (eids == null || eids.isEmpty()) return;&#10;        ChunkGroup first = oldGroup;&#10;        ChunkGroup second = newGroup;&#10;        if (System.identityHashCode(first) &gt; System.identityHashCode(second)) { first = newGroup; second = oldGroup; }&#10;        first.getResizeLock().lock();&#10;        try {&#10;            if (second != first) second.getResizeLock().lock();&#10;            try {&#10;                int n = eids.size();&#10;                int[] idsArr = new int[n];&#10;                for (int i = 0; i &lt; n; i++) idsArr[i] = eids.get(i);&#10;                ArchetypeChunk.ChunkLocation[] newLocs = newGroup.addEntities(idsArr);&#10;                ArchetypeChunk.ChunkLocation[] oldLocs = new ArchetypeChunk.ChunkLocation[n];&#10;                for (int i = 0; i &lt; n; i++) oldLocs[i] = entityRecords.get(idsArr[i]).location;&#10;&#10;                // Precompute unmanaged intersection index pairs&#10;                int[] compTypeIds = archetype.getComponentTypeIds();&#10;                int maxC = compTypeIds != null ? compTypeIds.length : 0;&#10;                int[] compOldIdx = new int[maxC];&#10;                int[] compNewIdx = new int[maxC];&#10;                int cCount = 0;&#10;                for (int t = 0; t &lt; maxC; t++) {&#10;                    int compTypeId = compTypeIds[t];&#10;                    if (!oldMask.has(compTypeId) || !newMask.has(compTypeId)) continue;&#10;                    int oi = archetype.indexOfComponentType(compTypeId);&#10;                    int ni = oi; // same archetype&#10;                    if (oi &gt;= 0 &amp;&amp; ni &gt;= 0) { compOldIdx[cCount] = oi; compNewIdx[cCount] = ni; cCount++; }&#10;                }&#10;                // Precompute managed intersection pairs&#10;                int[] managedTypeIds = archetype.getManagedTypeIds();&#10;                int maxM = managedTypeIds != null ? managedTypeIds.length : 0;&#10;                int[] manIdx = new int[maxM]; // same index on both sides for same archetype&#10;                int mCount = 0;&#10;                for (int t = 0; t &lt; maxM; t++) {&#10;                    int tid = managedTypeIds[t];&#10;                    if (!oldMask.has(tid) || !newMask.has(tid)) continue;&#10;                    int mi = archetype.getManagedTypeIndex(tid);&#10;                    if (mi &gt;= 0) { manIdx[mCount] = mi; mCount++; }&#10;                }&#10;&#10;                // Entity-first copy using precomputed indices&#10;                for (int i = 0; i &lt; n; i++) {&#10;                    ArchetypeChunk oldChunk = oldGroup.getChunk(oldLocs[i].chunkIndex);&#10;                    ArchetypeChunk newChunk = newGroup.getChunk(newLocs[i].chunkIndex);&#10;                    int oldSlot = oldLocs[i].indexInChunk;&#10;                    int newSlot = newLocs[i].indexInChunk;&#10;                    for (int k = 0; k &lt; cCount; k++) {&#10;                        MemorySegment src = oldChunk.getComponentData(compOldIdx[k], oldSlot);&#10;                        newChunk.setComponentData(compNewIdx[k], newSlot, src);&#10;                    }&#10;                    for (int k = 0; k &lt; mCount; k++) {&#10;                        int mi = manIdx[k];&#10;                        int ticket = oldChunk.getManagedTicket(mi, oldSlot);&#10;                        if (ticket &gt;= 0) newChunk.setManagedTicket(mi, newSlot, ticket);&#10;                    }&#10;                }&#10;&#10;                oldGroup.removeEntities(oldLocs);&#10;                for (int i = 0; i &lt; n; i++) entityRecords.put(idsArr[i], new EntityRecord(archetype, newLocs[i], newMask, newSharedKey));&#10;            } finally {&#10;                if (second != first) second.getResizeLock().unlock();&#10;            }&#10;        } finally {&#10;            first.getResizeLock().unlock();&#10;        }&#10;    }&#10;&#10;    private void batchMoveStructural(Archetype oldArch, Archetype newArch, ChunkGroup oldGroup, ChunkGroup newGroup, List&lt;Integer&gt; eids, ComponentMask oldMask, ComponentMask newMask, SharedValueKey key) {&#10;        if (eids.isEmpty()) return;&#10;        ChunkGroup first = oldGroup;&#10;        ChunkGroup second = newGroup;&#10;        if (System.identityHashCode(first) &gt; System.identityHashCode(second)) { first = newGroup; second = oldGroup; }&#10;        first.getResizeLock().lock();&#10;        try {&#10;            if (second != first) second.getResizeLock().lock();&#10;            try {&#10;                int n = eids.size();&#10;                int[] ids = new int[n];&#10;                for (int i = 0; i &lt; n; i++) ids[i] = eids.get(i);&#10;                ArchetypeChunk.ChunkLocation[] newLocs = newGroup.addEntities(ids);&#10;                ArchetypeChunk.ChunkLocation[] oldLocs = new ArchetypeChunk.ChunkLocation[n];&#10;                for (int i = 0; i &lt; n; i++) oldLocs[i] = entityRecords.get(ids[i]).location;&#10;&#10;                // Precompute unmanaged intersection index pairs between oldArch and newArch&#10;                int[] compTypeIds = newArch.getComponentTypeIds();&#10;                int maxC = compTypeIds != null ? compTypeIds.length : 0;&#10;                int[] compOldIdx = new int[maxC];&#10;                int[] compNewIdx = new int[maxC];&#10;                int cCount = 0;&#10;                for (int t = 0; t &lt; maxC; t++) {&#10;                    int compTypeId = compTypeIds[t];&#10;                    if (!oldMask.has(compTypeId) || !newMask.has(compTypeId)) continue;&#10;                    int oi = oldArch.indexOfComponentType(compTypeId);&#10;                    int ni = newArch.indexOfComponentType(compTypeId);&#10;                    if (oi &gt;= 0 &amp;&amp; ni &gt;= 0) { compOldIdx[cCount] = oi; compNewIdx[cCount] = ni; cCount++; }&#10;                }&#10;                // Precompute managed intersection and removals&#10;                int[] oldManagedIds = oldArch.getManagedTypeIds();&#10;                int[] newManagedIds = newArch.getManagedTypeIds();&#10;                int maxMi = oldManagedIds != null ? oldManagedIds.length : 0;&#10;                int[] manOldIdx = new int[maxMi];&#10;                int[] manNewIdx = new int[maxMi];&#10;                int miCount = 0;&#10;                int[] removeOldIdx = new int[maxMi];&#10;                int rCount = 0;&#10;                if (oldManagedIds != null) {&#10;                    for (int tid : oldManagedIds) {&#10;                        int oi = oldArch.getManagedTypeIndex(tid);&#10;                        boolean inOld = oldMask.has(tid);&#10;                        boolean inNew = newMask.has(tid);&#10;                        if (inOld &amp;&amp; inNew) {&#10;                            int ni = newArch.getManagedTypeIndex(tid);&#10;                            if (oi &gt;= 0 &amp;&amp; ni &gt;= 0) { manOldIdx[miCount] = oi; manNewIdx[miCount] = ni; miCount++; }&#10;                        } else if (inOld &amp;&amp; !inNew) {&#10;                            if (oi &gt;= 0) { removeOldIdx[rCount] = oi; rCount++; }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Entity-first copy and releases using precomputed indices&#10;                for (int i = 0; i &lt; n; i++) {&#10;                    ArchetypeChunk oldChunk = oldGroup.getChunk(oldLocs[i].chunkIndex);&#10;                    ArchetypeChunk newChunk = newGroup.getChunk(newLocs[i].chunkIndex);&#10;                    int oldSlot = oldLocs[i].indexInChunk;&#10;                    int newSlot = newLocs[i].indexInChunk;&#10;                    for (int k = 0; k &lt; cCount; k++) {&#10;                        MemorySegment src = oldChunk.getComponentData(compOldIdx[k], oldSlot);&#10;                        newChunk.setComponentData(compNewIdx[k], newSlot, src);&#10;                    }&#10;                    for (int k = 0; k &lt; miCount; k++) {&#10;                        int ticket = oldChunk.getManagedTicket(manOldIdx[k], oldSlot);&#10;                        if (ticket &gt;= 0) newChunk.setManagedTicket(manNewIdx[k], newSlot, ticket);&#10;                    }&#10;                    for (int k = 0; k &lt; rCount; k++) {&#10;                        int ticket = oldChunk.getManagedTicket(removeOldIdx[k], oldSlot);&#10;                        if (ticket &gt;= 0) managedStore.release(ticket);&#10;                    }&#10;                }&#10;&#10;                oldGroup.removeEntities(oldLocs);&#10;                for (int i = 0; i &lt; n; i++) entityRecords.put(ids[i], new EntityRecord(newArch, newLocs[i], newMask, key));&#10;            } finally {&#10;                if (second != first) second.getResizeLock().unlock();&#10;            }&#10;        } finally {&#10;            first.getResizeLock().unlock();&#10;        }&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask, SharedValueKey sharedKey) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;&#10;    public void addComponents(EntityBatch batch, Class&lt;?&gt; componentClass) {&#10;        if (batch == null || batch.size == 0) return;&#10;        addComponents(batch, new Class&lt;?&gt;[]{componentClass});&#10;    }&#10;&#10;    public void removeComponents(EntityBatch batch, Class&lt;?&gt; componentClass) {&#10;        if (batch == null || batch.size == 0) return;&#10;        removeComponents(batch, new Class&lt;?&gt;[]{componentClass});&#10;    }&#10;&#10;    // New: multi-component batch add/remove/mutate&#10;    public void addComponents(EntityBatch batch, Class&lt;?&gt;... componentClasses) {&#10;        if (batch == null || batch.size == 0 || componentClasses == null || componentClasses.length == 0) return;&#10;        mutateComponents(batch, componentClasses, new Class&lt;?&gt;[0]);&#10;    }&#10;&#10;    public void removeComponents(EntityBatch batch, Class&lt;?&gt;... componentClasses) {&#10;        if (batch == null || batch.size == 0 || componentClasses == null || componentClasses.length == 0) return;&#10;        mutateComponents(batch, new Class&lt;?&gt;[0], componentClasses);&#10;    }&#10;&#10;    public void mutateComponents(EntityBatch batch, Class&lt;?&gt;[] addClasses, Class&lt;?&gt;[] removeClasses) {&#10;        if (batch == null || batch.size == 0) return;&#10;        // Pre-resolve type ids&#10;        int addCount = addClasses != null ? addClasses.length : 0;&#10;        int remCount = removeClasses != null ? removeClasses.length : 0;&#10;        int[] addTypeIds = new int[addCount];&#10;        int[] remTypeIds = new int[remCount];&#10;        for (int i = 0; i &lt; addCount; i++) {&#10;            Integer tid = getComponentTypeId(addClasses[i]);&#10;            if (tid == null) throw new IllegalArgumentException(&quot;Component type not registered: &quot; + addClasses[i].getName());&#10;            addTypeIds[i] = tid;&#10;        }&#10;        for (int i = 0; i &lt; remCount; i++) {&#10;            Integer tid = getComponentTypeId(removeClasses[i]);&#10;            if (tid == null) throw new IllegalArgumentException(&quot;Component type not registered: &quot; + removeClasses[i].getName());&#10;            remTypeIds[i] = tid;&#10;        }&#10;        // Group by old archetype&#10;        Map&lt;Archetype, List&lt;Integer&gt;&gt; byArchetype = new HashMap&lt;&gt;();&#10;        for (int eid : batch.entityIds) {&#10;            EntityRecord rec = entityRecords.get(eid);&#10;            if (rec == null) continue;&#10;            byArchetype.computeIfAbsent(rec.archetype, k -&gt; new ArrayList&lt;&gt;()).add(eid);&#10;        }&#10;        for (Map.Entry&lt;Archetype, List&lt;Integer&gt;&gt; entry : byArchetype.entrySet()) {&#10;            Archetype oldArch = entry.getKey();&#10;            List&lt;Integer&gt; eids = entry.getValue();&#10;            if (eids.isEmpty()) continue;&#10;            // Build new mask once for this old archetype&#10;            ComponentMask newMask = oldArch.getMask();&#10;            for (int tid : addTypeIds) newMask = newMask.set(tid);&#10;            for (int tid : remTypeIds) newMask = newMask.clear(tid);&#10;            if (newMask.equals(oldArch.getMask())) continue; // nothing to do&#10;            Archetype newArch = archetypeManager.getOrCreateArchetype(newMask);&#10;            // Partition by shared key to keep batch moves localized&#10;            Map&lt;SharedValueKey, List&lt;Integer&gt;&gt; byShared = new HashMap&lt;&gt;();&#10;            for (int eid : eids) {&#10;                EntityRecord rec = entityRecords.get(eid);&#10;                byShared.computeIfAbsent(rec.sharedKey, k -&gt; new ArrayList&lt;&gt;()).add(eid);&#10;            }&#10;            for (Map.Entry&lt;SharedValueKey, List&lt;Integer&gt;&gt; sg : byShared.entrySet()) {&#10;                SharedValueKey key = sg.getKey();&#10;                ChunkGroup oldGroup = oldArch.getChunkGroup(key);&#10;                ChunkGroup newGroup = newArch.getOrCreateChunkGroup(key);&#10;                batchMoveStructural(oldArch, newArch, oldGroup, newGroup, sg.getValue(), oldArch.getMask(), newMask, key);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Expose arena for ECB lane allocations (package-private for now)&#10;    Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Thm mt component (unmanaged) vo entity v khi to n ngay lp tc&#10;     * bng cch s dng mt initializer lambda type-safe.&#10;     * y l phng thc zero-copy, zero-allocation (ngoi tr vic di chuyn archetype).&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;THandle extends IBindableHandle&gt; void addComponent(&#10;        int entityId,&#10;        Class&lt;?&gt; componentClass,&#10;        java.util.function.Consumer&lt;THandle&gt; initializer&#10;    ) {&#10;        // 1. Ly record hin ti&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;        Integer componentTypeId = getComponentTypeId(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass.getName() + &quot; not registered&quot;);&#10;        }&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc != null &amp;&amp; desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;addComponent(entityId, Class, Consumer) khng h tr managed component &quot; + componentClass.getName());&#10;        }&#10;        if (record.mask.has(componentTypeId)) {&#10;            // Entity  c component ny, ch cn chy initializer&#10;            initializeComponent(entityId, record, componentClass, initializer);&#10;            return;&#10;        }&#10;&#10;        // 2. Di chuyn entity (Structural Change)&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;        moveEntityToArchetype(entityId, record, record.mask, newMask, record.sharedKey);&#10;&#10;        // 3. Ly record MI (sau khi di chuyn)&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;&#10;        // 4. Chy logic khi to&#10;        initializeComponent(entityId, newRecord, componentClass, initializer);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    private &lt;THandle extends IBindableHandle&gt; void initializeComponent(&#10;        int entityId,&#10;        EntityRecord record,&#10;        Class&lt;?&gt; componentClass,&#10;        java.util.function.Consumer&lt;THandle&gt; initializer&#10;    ) {&#10;        // 1. Chun b cc handle t pool&#10;        ComponentHandle rawHandle = componentManager.acquireHandle();&#10;        IBindableHandle typedHandle = componentManager.acquireTypedHandle(componentClass);&#10;&#10;        try {&#10;            // 2. Tm slot b nh (memory slot) THC T ca component&#10;            ChunkGroup group = record.archetype.getChunkGroup(record.sharedKey);&#10;            if (group == null) throw new IllegalStateException(&quot;ChunkGroup not found&quot;);&#10;&#10;            ArchetypeChunk chunk = group.getChunk(record.location.chunkIndex);&#10;            Integer typeId = getComponentTypeId(componentClass);&#10;            if (typeId == null) {&#10;                throw new IllegalStateException(&quot;Component type &quot; + componentClass.getName() + &quot; not registered in world&quot;);&#10;            }&#10;            int componentIndex = record.archetype.indexOfComponentType(typeId);&#10;            if (componentIndex &lt; 0) {&#10;                throw new IllegalStateException(&quot;Component index not found after add for &quot; + componentClass.getName());&#10;            }&#10;&#10;            // B NH  TN TI V C ZERO-ED TRONG CHUNK CONSTRUCTOR&#10;            MemorySegment liveSegment = chunk.getComponentData(componentIndex, record.location.indexInChunk);&#10;&#10;            // 3. &quot;Bind&quot; (tr) cc handle vo slot b nh &#10;            rawHandle.reset(liveSegment, componentManager.getDescriptor(componentClass));&#10;            typedHandle.__bind(rawHandle);&#10;&#10;            // 4. Gi lambda ca user: user ang ghi TRC TIP vo b nh ca chunk&#10;            initializer.accept((THandle) typedHandle);&#10;&#10;        } finally {&#10;            // 5. Lun lun tr handle v pool&#10;            componentManager.releaseHandle(rawHandle);&#10;            componentManager.releaseTypedHandle(componentClass, typedHandle);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ChunkGroup.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ChunkGroup.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;/**&#10; * ChunkGroup encapsulates chunk management logic for an Archetype.&#10; * Simplified provisioning logic: only uses resizeLock (no spin / atomic boolean coordination).&#10; */&#10;public final class ChunkGroup {&#10;    private volatile ArchetypeChunk[] chunks;&#10;    private final AtomicInteger chunkCount = new AtomicInteger(0);&#10;    private final ReentrantLock resizeLock = new ReentrantLock();&#10;    private final ConcurrentLinkedQueue&lt;Integer&gt; availableChunks = new ConcurrentLinkedQueue&lt;&gt;();&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final Arena arena;&#10;    private final int managedTypeCount;&#10;&#10;    public ChunkGroup(ComponentDescriptor[] descriptors, long[] elementSizes, int entitiesPerChunk, Arena arena, int managedTypeCount) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.entitiesPerChunk = entitiesPerChunk;&#10;        this.arena = arena;&#10;        this.managedTypeCount = managedTypeCount;&#10;        this.chunks = new ArchetypeChunk[Math.max(4, 1)];&#10;        ArchetypeChunk first = new ArchetypeChunk(descriptors, elementSizes, entitiesPerChunk, arena, managedTypeCount);&#10;        this.chunks[0] = first;&#10;        chunkCount.set(1);&#10;        if (first.tryMarkQueued()) {&#10;            this.availableChunks.add(0);&#10;        }&#10;    }&#10;&#10;    // --- New optimistic addEntity implementation ---&#10;    public ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        // 1. Fast path attempt without locking&#10;        ArchetypeChunk.ChunkLocation loc = tryFastPathAllocate(entityId);&#10;        if (loc != null) return loc;&#10;&#10;        // 2. Slow path: acquire real lock, double-check, then create&#10;        resizeLock.lock();&#10;        try {&#10;            // 3. Double-check after acquiring lock (another thread may have inserted a chunk)&#10;            loc = tryFastPathAllocate(entityId);&#10;            if (loc != null) return loc;&#10;            // 4. Still no space: create new chunk and allocate&#10;            return createChunkAndAllocate(entityId);&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;    }&#10;&#10;    private ArchetypeChunk.ChunkLocation tryFastPathAllocate(int entityId) {&#10;        Integer idxChunk;&#10;        while ((idxChunk = availableChunks.poll()) != null) { // dequeue a chunk with (expected) free slots&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idxChunk];&#10;            if (chunk == null) continue;&#10;            chunk.markDequeued();&#10;            int slot = chunk.allocateSlot(entityId);&#10;            if (slot &gt;= 0) {&#10;                if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) { // requeue if still space&#10;                    availableChunks.offer(idxChunk);&#10;                }&#10;                return new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;            }&#10;            // If allocation failed (race filled chunk), just loop to next available&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private ArchetypeChunk.ChunkLocation createChunkAndAllocate(int entityId) {&#10;        ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, elementSizes, entitiesPerChunk, arena, managedTypeCount);&#10;        int newIndex = appendChunk(newChunk); // appendChunk already uses resizeLock (reentrant safe)&#10;        int slot = newChunk.allocateSlot(entityId);&#10;        if (newChunk.hasFree() &amp;&amp; newChunk.tryMarkQueued()) {&#10;            availableChunks.offer(newIndex);&#10;        }&#10;        return new ArchetypeChunk.ChunkLocation(newIndex, slot);&#10;    }&#10;&#10;    public int appendChunk(ArchetypeChunk newChunk) {&#10;        resizeLock.lock();&#10;        try {&#10;            ArchetypeChunk[] arr = this.chunks;&#10;            int idx = chunkCount.get();&#10;            if (idx &lt; arr.length) {&#10;                arr[idx] = newChunk;&#10;                chunkCount.incrementAndGet();&#10;                return idx;&#10;            }&#10;            int newCap = Math.max(4, arr.length &lt;&lt; 1);&#10;            ArchetypeChunk[] newArr = new ArchetypeChunk[newCap];&#10;            System.arraycopy(arr, 0, newArr, 0, idx);&#10;            newArr[idx] = newChunk;&#10;            this.chunks = newArr;&#10;            chunkCount.incrementAndGet();&#10;            return idx;&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;    }&#10;&#10;    public void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        int idx = location.chunkIndex;&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        if (idx &lt; 0 || idx &gt;= chunkCount.get()) return;&#10;        ArchetypeChunk chunk = snap[idx];&#10;        if (chunk == null) return;&#10;        chunk.freeSlot(location.indexInChunk);&#10;        if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;            availableChunks.offer(idx);&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk[] getChunksSnapshot() { return this.chunks; }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        if (chunkIndex &lt; 0 || chunkIndex &gt;= count) throw new IndexOutOfBoundsException();&#10;        return snap[chunkIndex];&#10;    }&#10;&#10;    public int chunkCount() { return this.chunkCount.get(); }&#10;&#10;    public int getEntityCount() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        int total = 0;&#10;        for (int i = 0; i &lt; count; i++) total += snap[i].size();&#10;        return total;&#10;    }&#10;&#10;    public List&lt;ArchetypeChunk&gt; getChunks() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        List&lt;ArchetypeChunk&gt; list = new ArrayList&lt;&gt;(count);&#10;        for (int i = 0; i &lt; count; i++) list.add(snap[i]);&#10;        return list;&#10;    }&#10;&#10;    public void forEach(IArchetype.ArchetypeIterator iterator) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        for (int chunkId = 0; chunkId &lt; count; chunkId++) {&#10;            ArchetypeChunk chunk = snap[chunkId];&#10;            int i = chunk.nextOccupiedIndex(0);&#10;            while (i != -1) {&#10;                int eid = chunk.getEntityId(i);&#10;                if (eid != -1) iterator.accept(eid, new ArchetypeChunk.ChunkLocation(chunkId, i), chunk);&#10;                i = chunk.nextOccupiedIndex(i + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Batch APIs ---&#10;    public ArchetypeChunk.ChunkLocation[] addEntities(int[] entityIds) {&#10;        if (entityIds == null || entityIds.length == 0) return new ArchetypeChunk.ChunkLocation[0];&#10;        ArchetypeChunk.ChunkLocation[] out = new ArchetypeChunk.ChunkLocation[entityIds.length];&#10;        int need = entityIds.length;&#10;        int produced = 0;&#10;        // Consume available queued chunks, allocate as many as possible from each before moving on&#10;        Integer idxChunk;&#10;        while (produced &lt; need &amp;&amp; (idxChunk = availableChunks.poll()) != null) {&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idxChunk];&#10;            if (chunk == null) continue;&#10;            chunk.markDequeued();&#10;            while (produced &lt; need) {&#10;                int slot = chunk.allocateSlot(entityIds[produced]);&#10;                if (slot &lt; 0) break;&#10;                out[produced] = new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;                produced++;&#10;            }&#10;            if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;                availableChunks.offer(idxChunk);&#10;            }&#10;        }&#10;        if (produced == need) return out;&#10;        // Slow path: lock and either consume any newly queued chunks or create new chunks&#10;        resizeLock.lock();&#10;        try {&#10;            // Double-check: consume any available after acquiring lock&#10;            while (produced &lt; need &amp;&amp; (idxChunk = availableChunks.poll()) != null) {&#10;                ArchetypeChunk[] snap = this.chunks;&#10;                int count = this.chunkCount.get();&#10;                if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;                ArchetypeChunk chunk = snap[idxChunk];&#10;                if (chunk == null) continue;&#10;                chunk.markDequeued();&#10;                while (produced &lt; need) {&#10;                    int slot = chunk.allocateSlot(entityIds[produced]);&#10;                    if (slot &lt; 0) break;&#10;                    out[produced] = new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;                    produced++;&#10;                }&#10;                if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) availableChunks.offer(idxChunk);&#10;            }&#10;            // Create new chunks until satisfied&#10;            while (produced &lt; need) {&#10;                ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, elementSizes, entitiesPerChunk, arena, managedTypeCount);&#10;                int newIndex = appendChunk(newChunk); // appendChunk is reentrant with resizeLock&#10;                int toAlloc = Math.min(need - produced, entitiesPerChunk);&#10;                // Fresh chunk yields contiguous indices [0..toAlloc-1]&#10;                for (int i = 0; i &lt; toAlloc; i++) {&#10;                    int slot = newChunk.allocateSlot(entityIds[produced]);&#10;                    out[produced] = new ArchetypeChunk.ChunkLocation(newIndex, slot);&#10;                    produced++;&#10;                }&#10;                if (newChunk.hasFree() &amp;&amp; newChunk.tryMarkQueued()) availableChunks.offer(newIndex);&#10;            }&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;        return out;&#10;    }&#10;&#10;    public void removeEntities(ArchetypeChunk.ChunkLocation[] locations) {&#10;        if (locations == null || locations.length == 0) return;&#10;        // Free slots; afterwards enqueue chunks that still have free space&#10;        // Group by chunk to reduce repeated offers; but offering multiple times is harmless due to tryMarkQueued&#10;        for (ArchetypeChunk.ChunkLocation loc : locations) {&#10;            if (loc == null) continue;&#10;            int idx = loc.chunkIndex;&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idx &lt; 0 || idx &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idx];&#10;            if (chunk == null) continue;&#10;            chunk.freeSlot(loc.indexInChunk);&#10;            if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) availableChunks.offer(idx);&#10;        }&#10;    }&#10;&#10;    public ReentrantLock getResizeLock() { return resizeLock; }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;/**&#10; * ChunkGroup encapsulates chunk management logic for an Archetype.&#10; * Simplified provisioning logic: only uses resizeLock (no spin / atomic boolean coordination).&#10; */&#10;public final class ChunkGroup {&#10;    private volatile ArchetypeChunk[] chunks;&#10;    private final AtomicInteger chunkCount = new AtomicInteger(0);&#10;    private final ReentrantLock resizeLock = new ReentrantLock();&#10;    private final ConcurrentLinkedQueue&lt;Integer&gt; availableChunks = new ConcurrentLinkedQueue&lt;&gt;();&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final Arena arena;&#10;    private final int managedTypeCount;&#10;&#10;    public ChunkGroup(ComponentDescriptor[] descriptors, long[] elementSizes, int entitiesPerChunk, Arena arena, int managedTypeCount) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.entitiesPerChunk = entitiesPerChunk;&#10;        this.arena = arena;&#10;        this.managedTypeCount = managedTypeCount;&#10;        this.chunks = new ArchetypeChunk[Math.max(4, 1)];&#10;        ArchetypeChunk first = new ArchetypeChunk(descriptors, elementSizes, entitiesPerChunk, arena, managedTypeCount);&#10;        this.chunks[0] = first;&#10;        chunkCount.set(1);&#10;        if (first.tryMarkQueued()) {&#10;            this.availableChunks.add(0);&#10;        }&#10;    }&#10;&#10;    // --- New optimistic addEntity implementation ---&#10;    public ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        // 1. Fast path attempt without locking&#10;        ArchetypeChunk.ChunkLocation loc = tryFastPathAllocate(entityId);&#10;        if (loc != null) return loc;&#10;&#10;        // 2. Slow path: acquire real lock, double-check, then create&#10;        resizeLock.lock();&#10;        try {&#10;            // 3. Double-check after acquiring lock (another thread may have inserted a chunk)&#10;            loc = tryFastPathAllocate(entityId);&#10;            if (loc != null) return loc;&#10;            // 4. Still no space: create new chunk and allocate&#10;            return createChunkAndAllocate(entityId);&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;    }&#10;&#10;    private ArchetypeChunk.ChunkLocation tryFastPathAllocate(int entityId) {&#10;        Integer idxChunk;&#10;        while ((idxChunk = availableChunks.poll()) != null) { // dequeue a chunk with (expected) free slots&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idxChunk];&#10;            if (chunk == null) continue;&#10;            chunk.markDequeued();&#10;            int slot = chunk.allocateSlot(entityId);&#10;            if (slot &gt;= 0) {&#10;                if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) { // requeue if still space&#10;                    availableChunks.offer(idxChunk);&#10;                }&#10;                return new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;            }&#10;            // If allocation failed (race filled chunk), just loop to next available&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private ArchetypeChunk.ChunkLocation createChunkAndAllocate(int entityId) {&#10;        ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, elementSizes, entitiesPerChunk, arena, managedTypeCount);&#10;        int newIndex = appendChunk(newChunk); // appendChunk already uses resizeLock (reentrant safe)&#10;        int slot = newChunk.allocateSlot(entityId);&#10;        if (newChunk.hasFree() &amp;&amp; newChunk.tryMarkQueued()) {&#10;            availableChunks.offer(newIndex);&#10;        }&#10;        return new ArchetypeChunk.ChunkLocation(newIndex, slot);&#10;    }&#10;&#10;    public int appendChunk(ArchetypeChunk newChunk) {&#10;        resizeLock.lock();&#10;        try {&#10;            ArchetypeChunk[] arr = this.chunks;&#10;            int idx = chunkCount.get();&#10;            if (idx &lt; arr.length) {&#10;                arr[idx] = newChunk;&#10;                chunkCount.incrementAndGet();&#10;                return idx;&#10;            }&#10;            int newCap = Math.max(4, arr.length &lt;&lt; 1);&#10;            ArchetypeChunk[] newArr = new ArchetypeChunk[newCap];&#10;            System.arraycopy(arr, 0, newArr, 0, idx);&#10;            newArr[idx] = newChunk;&#10;            this.chunks = newArr;&#10;            chunkCount.incrementAndGet();&#10;            return idx;&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;    }&#10;&#10;    public void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        int idx = location.chunkIndex;&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        if (idx &lt; 0 || idx &gt;= chunkCount.get()) return;&#10;        ArchetypeChunk chunk = snap[idx];&#10;        if (chunk == null) return;&#10;        chunk.freeSlot(location.indexInChunk);&#10;        if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;            availableChunks.offer(idx);&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk[] getChunksSnapshot() { return this.chunks; }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        if (chunkIndex &lt; 0 || chunkIndex &gt;= count) throw new IndexOutOfBoundsException();&#10;        return snap[chunkIndex];&#10;    }&#10;&#10;    public int chunkCount() { return this.chunkCount.get(); }&#10;&#10;    public int getEntityCount() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        int total = 0;&#10;        for (int i = 0; i &lt; count; i++) total += snap[i].size();&#10;        return total;&#10;    }&#10;&#10;    public List&lt;ArchetypeChunk&gt; getChunks() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        List&lt;ArchetypeChunk&gt; list = new ArrayList&lt;&gt;(count);&#10;        for (int i = 0; i &lt; count; i++) list.add(snap[i]);&#10;        return list;&#10;    }&#10;&#10;    public void forEach(IArchetype.ArchetypeIterator iterator) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        for (int chunkId = 0; chunkId &lt; count; chunkId++) {&#10;            ArchetypeChunk chunk = snap[chunkId];&#10;            int i = chunk.nextOccupiedIndex(0);&#10;            while (i != -1) {&#10;                int eid = chunk.getEntityId(i);&#10;                if (eid != -1) iterator.accept(eid, new ArchetypeChunk.ChunkLocation(chunkId, i), chunk);&#10;                i = chunk.nextOccupiedIndex(i + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Batch APIs ---&#10;    public ArchetypeChunk.ChunkLocation[] addEntities(int[] entityIds) {&#10;        if (entityIds == null || entityIds.length == 0) return new ArchetypeChunk.ChunkLocation[0];&#10;        ArchetypeChunk.ChunkLocation[] out = new ArchetypeChunk.ChunkLocation[entityIds.length];&#10;        int need = entityIds.length;&#10;        int produced = 0;&#10;        // Consume available queued chunks, allocate as many as possible from each before moving on&#10;        Integer idxChunk;&#10;        while (produced &lt; need &amp;&amp; (idxChunk = availableChunks.poll()) != null) {&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idxChunk];&#10;            if (chunk == null) continue;&#10;            chunk.markDequeued();&#10;            while (produced &lt; need) {&#10;                int slot = chunk.allocateSlot(entityIds[produced]);&#10;                if (slot &lt; 0) break;&#10;                out[produced] = new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;                produced++;&#10;            }&#10;            if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;                availableChunks.offer(idxChunk);&#10;            }&#10;        }&#10;        if (produced == need) return out;&#10;        // Slow path: lock and either consume any newly queued chunks or create new chunks&#10;        resizeLock.lock();&#10;        try {&#10;            // Double-check: consume any available after acquiring lock&#10;            while (produced &lt; need &amp;&amp; (idxChunk = availableChunks.poll()) != null) {&#10;                ArchetypeChunk[] snap = this.chunks;&#10;                int count = this.chunkCount.get();&#10;                if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;                ArchetypeChunk chunk = snap[idxChunk];&#10;                if (chunk == null) continue;&#10;                chunk.markDequeued();&#10;                while (produced &lt; need) {&#10;                    int slot = chunk.allocateSlot(entityIds[produced]);&#10;                    if (slot &lt; 0) break;&#10;                    out[produced] = new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;                    produced++;&#10;                }&#10;                if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) availableChunks.offer(idxChunk);&#10;            }&#10;            // Create new chunks until satisfied&#10;            while (produced &lt; need) {&#10;                ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, elementSizes, entitiesPerChunk, arena, managedTypeCount);&#10;                int newIndex = appendChunk(newChunk); // appendChunk is reentrant with resizeLock&#10;                int toAlloc = Math.min(need - produced, entitiesPerChunk);&#10;                // Fresh chunk yields contiguous indices [0..toAlloc-1]&#10;                for (int i = 0; i &lt; toAlloc; i++) {&#10;                    int slot = newChunk.allocateSlot(entityIds[produced]);&#10;                    out[produced] = new ArchetypeChunk.ChunkLocation(newIndex, slot);&#10;                    produced++;&#10;                }&#10;                if (newChunk.hasFree() &amp;&amp; newChunk.tryMarkQueued()) availableChunks.offer(newIndex);&#10;            }&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;        return out;&#10;    }&#10;&#10;    public void removeEntities(ArchetypeChunk.ChunkLocation[] locations) {&#10;        if (locations == null || locations.length == 0) return;&#10;        // Free slots; afterwards enqueue chunks that still have free space&#10;        // Group by chunk to reduce repeated offers; but offering multiple times is harmless due to tryMarkQueued&#10;        for (ArchetypeChunk.ChunkLocation loc : locations) {&#10;            if (loc == null) continue;&#10;            int idx = loc.chunkIndex;&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idx &lt; 0 || idx &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idx];&#10;            if (chunk == null) continue;&#10;            chunk.freeSlot(loc.indexInChunk);&#10;            if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) availableChunks.offer(idx);&#10;        }&#10;    }&#10;&#10;    public ReentrantLock getResizeLock() { return resizeLock; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/EntityCommandBuffer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/EntityCommandBuffer.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;&#10;/**&#10; * EntityCommandBuffer  Pillar 4: Write-Fast, Sort-on-Playback.&#10; *&#10; * Phase 1: write-side O(1) zero-garbage API backed by per-thread lanes.&#10; * Phase 2: playback-side O(N log N) sorting and batch execution.&#10; */&#10;public final class EntityCommandBuffer implements AutoCloseable {&#10;    // ---- Command opcodes ----&#10;    static final int CMD_ADD_COMPONENT = 1;&#10;    static final int CMD_REMOVE_COMPONENT = 2;&#10;    static final int CMD_SET_SHARED_MANAGED = 3;&#10;    static final int CMD_DESTROY_ENTITY = 4;&#10;    static final int CMD_MUTATE_COMPONENTS = 5; // multi add/remove per entity&#10;&#10;    // Size in bytes reserved per lane segment&#10;    private static final long LANE_CAPACITY = 64 * 1024; // 64KB&#10;&#10;    private final Arena bufferArena;&#10;&#10;    // Pool of reusable lanes&#10;    private final ConcurrentLinkedQueue&lt;ECBWriterLane&gt; freeLanes = new ConcurrentLinkedQueue&lt;&gt;();&#10;    // Collected lanes for playback&#10;    private final ConcurrentLinkedQueue&lt;ECBWriterLane&gt; usedLanes = new ConcurrentLinkedQueue&lt;&gt;();&#10;&#10;    // Per-thread writer lane&#10;    private final ThreadLocal&lt;ECBWriterLane&gt; threadLocalLane;&#10;&#10;    public EntityCommandBuffer(Arena parentArena) {&#10;        // For now reuse parent arena; playback phase may introduce a dedicated arena strategy.&#10;        this.bufferArena = parentArena;&#10;        this.threadLocalLane = ThreadLocal.withInitial(() -&gt; {&#10;            ECBWriterLane lane = freeLanes.poll();&#10;            if (lane == null) {&#10;                lane = new ECBWriterLane(bufferArena.allocate(LANE_CAPACITY));&#10;            } else {&#10;                lane.reset();&#10;            }&#10;            usedLanes.add(lane);&#10;            return lane;&#10;        });&#10;    }&#10;&#10;    // Expose a lightweight writer for use in parallel jobs&#10;    public ParallelWriter asParallelWriter(ArchetypeWorld world) {&#10;        return new ParallelWriter(threadLocalLane.get(), world);&#10;    }&#10;&#10;    @Override&#10;    public void close() {&#10;        // Lanes memory is owned by bufferArena; do not close arena here.&#10;        freeLanes.clear();&#10;        usedLanes.clear();&#10;    }&#10;&#10;    /**&#10;     * Decode all lanes, sort commands, and execute them in batches against the world.&#10;     */&#10;    public void playback(ArchetypeWorld world) {&#10;        // 1) Gather &amp; decode raw lanes into interpreted commands (O(N))&#10;        List&lt;InterpretedCommand&gt; allCommands = new ArrayList&lt;&gt;();&#10;        for (ECBWriterLane lane : usedLanes) {&#10;            long offset = 0L;&#10;            long limit = lane.offset;&#10;            MemorySegment segment = lane.segment;&#10;            while (offset &lt; limit) {&#10;                int cmdId = segment.get(ValueLayout.JAVA_INT, offset);&#10;                switch (cmdId) {&#10;                    case CMD_ADD_COMPONENT: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int tid = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        allCommands.add(InterpretedCommand.addComponent(eid, tid));&#10;                        offset += 12L;&#10;                        break;&#10;                    }&#10;                    case CMD_REMOVE_COMPONENT: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int tid = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        allCommands.add(InterpretedCommand.removeComponent(eid, tid));&#10;                        offset += 12L;&#10;                        break;&#10;                    }&#10;                    case CMD_DESTROY_ENTITY: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        allCommands.add(InterpretedCommand.destroyEntity(eid));&#10;                        offset += 8L;&#10;                        break;&#10;                    }&#10;                    case CMD_SET_SHARED_MANAGED: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int tid = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        int sharedIndex = segment.get(ValueLayout.JAVA_INT, offset + 12);&#10;                        allCommands.add(InterpretedCommand.setSharedManaged(eid, tid, sharedIndex));&#10;                        offset += 16L;&#10;                        break;&#10;                    }&#10;                    case CMD_MUTATE_COMPONENTS: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int addCount = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        int remCount = segment.get(ValueLayout.JAVA_INT, offset + 12);&#10;                        int[] addIds = new int[addCount];&#10;                        int[] remIds = new int[remCount];&#10;                        long p = offset + 16L;&#10;                        for (int i = 0; i &lt; addCount; i++) {&#10;                            addIds[i] = segment.get(ValueLayout.JAVA_INT, p);&#10;                            p += 4L;&#10;                        }&#10;                        for (int i = 0; i &lt; remCount; i++) {&#10;                            remIds[i] = segment.get(ValueLayout.JAVA_INT, p);&#10;                            p += 4L;&#10;                        }&#10;                        allCommands.add(InterpretedCommand.mutateComponents(eid, addIds, remIds));&#10;                        offset = p;&#10;                        break;&#10;                    }&#10;                    default:&#10;                        // Unknown or unimplemented command id  skip one int to avoid infinite loop&#10;                        offset += 4L;&#10;                        break;&#10;                }&#10;            }&#10;        }&#10;        // recycle lanes for next frame&#10;        recycleLanes();&#10;        if (allCommands.isEmpty()) return;&#10;&#10;        // 2) Sort commands using the massive O(N log N) comparator&#10;        Collections.sort(allCommands);&#10;&#10;        // 3) Execute sorted commands in batches via ArchetypeWorld batch API&#10;        executeSortedCommands(allCommands, world);&#10;    }&#10;&#10;    /**&#10;     * Return used lanes back to free pool and reset offsets.&#10;     */&#10;    private void recycleLanes() {&#10;        ECBWriterLane lane;&#10;        while ((lane = usedLanes.poll()) != null) {&#10;            lane.reset();&#10;            freeLanes.offer(lane);&#10;        }&#10;    }&#10;&#10;    // ---- Inner types ----&#10;&#10;    /**&#10;     * One contiguous lane of raw command bytes for a single writer thread.&#10;     * Not thread-safe by design; only the owning thread writes to offset.&#10;     */&#10;    static final class ECBWriterLane {&#10;        MemorySegment segment;&#10;        long offset;&#10;&#10;        ECBWriterLane(MemorySegment segment) {&#10;            this.segment = segment;&#10;            this.offset = 0L;&#10;        }&#10;&#10;        void reset() {&#10;            this.offset = 0L;&#10;        }&#10;&#10;        // Simple ensureCapacity: if not enough space, allocate a fresh segment&#10;        // and swap; old contents are expected to be consumed in playback before&#10;        // reuse. For Phase 1 we keep it simple and single-chunk per lane.&#10;        void ensureCapacity(long needed, Arena arena) {&#10;            long remaining = segment.byteSize() - offset;&#10;            if (remaining &gt;= needed) return;&#10;            // allocate a new chunk and reset offset&#10;            this.segment = arena.allocate(Math.max(LANE_CAPACITY, needed));&#10;            this.offset = 0L;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lightweight, zero-allocation facade to record commands into a lane.&#10;     */&#10;    public static final class ParallelWriter {&#10;        private final ECBWriterLane lane;&#10;        private final ArchetypeWorld world;&#10;&#10;        public ParallelWriter(ECBWriterLane lane, ArchetypeWorld world) {&#10;            this.lane = lane;&#10;            this.world = world;&#10;        }&#10;&#10;        public void addComponent(int entityId, Class&lt;?&gt; type) {&#10;            // getComponentTypeId returns Integer; handle unknown types cheaply&#10;            Integer typeId = world.getComponentTypeId(type);&#10;            if (typeId == null) return; // or throw, but write side should be cheap&#10;            long bytes = 12L; // opcode + entityId + typeId&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_ADD_COMPONENT);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, typeId);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        public void removeComponent(int entityId, Class&lt;?&gt; type) {&#10;            Integer typeId = world.getComponentTypeId(type);&#10;            if (typeId == null) return;&#10;            long bytes = 12L;&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_REMOVE_COMPONENT);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, typeId);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        public void destroyEntity(int entityId) {&#10;            long bytes = 8L; // opcode + entityId&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_DESTROY_ENTITY);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        // New: record a shared-managed component assignment.&#10;        public void setSharedManaged(int entityId, Object sharedValue) {&#10;            if (sharedValue == null) return;&#10;            Class&lt;?&gt; type = sharedValue.getClass();&#10;            Integer typeId = world.getComponentTypeId(type);&#10;            if (typeId == null) return; // unknown type: ignore at write side&#10;            // Ensure the value has a stable shared index in the store.&#10;            // Using getOrAddSharedIndex here guarantees we never encode -1,&#10;            // and that playback can always reconstruct the value via the store.&#10;            int sharedIndex = world.sharedStore.getOrAddSharedIndex(sharedValue);&#10;            long bytes = 16L; // cmdId + entityId + typeId + sharedIndex&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_SET_SHARED_MANAGED);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, typeId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 12, sharedIndex);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        /**&#10;         * Multi-component structural mutation for a single entity: add/remove multiple component types.&#10;         * This encodes a compact command that playback can batch across entities with the same add/remove sets.&#10;         */&#10;        public void mutateComponents(int entityId, Class&lt;?&gt;[] addTypes, Class&lt;?&gt;[] removeTypes) {&#10;            int addCount = addTypes != null ? addTypes.length : 0;&#10;            int remCount = removeTypes != null ? removeTypes.length : 0;&#10;            if (addCount == 0 &amp;&amp; remCount == 0) return;&#10;            int[] addIds = new int[addCount];&#10;            int[] remIds = new int[remCount];&#10;            for (int i = 0; i &lt; addCount; i++) {&#10;                Integer tid = world.getComponentTypeId(addTypes[i]);&#10;                if (tid == null) throw new IllegalArgumentException(&quot;Unregistered component: &quot; + addTypes[i]);&#10;                addIds[i] = tid;&#10;            }&#10;            for (int i = 0; i &lt; remCount; i++) {&#10;                Integer tid = world.getComponentTypeId(removeTypes[i]);&#10;                if (tid == null) throw new IllegalArgumentException(&quot;Unregistered component: &quot; + removeTypes[i]);&#10;                remIds[i] = tid;&#10;            }&#10;            // Encode: [cmdId, entityId, addCount, remCount, addIds..., remIds...]&#10;            long bytes = 16L + 4L * (addCount + remCount);&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_MUTATE_COMPONENTS);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, addCount);&#10;            seg.set(ValueLayout.JAVA_INT, off + 12, remCount);&#10;            long p = off + 16L;&#10;            for (int id : addIds) {&#10;                seg.set(ValueLayout.JAVA_INT, p, id);&#10;                p += 4L;&#10;            }&#10;            for (int id : remIds) {&#10;                seg.set(ValueLayout.JAVA_INT, p, id);&#10;                p += 4L;&#10;            }&#10;            lane.offset = p;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Decoded command representation used for sorting &amp; batching.&#10;     */&#10;    private static final class InterpretedCommand implements Comparable&lt;InterpretedCommand&gt; {&#10;        final int commandId;&#10;        final int entityId;&#10;        final int typeId1;   // primary component type (for add/remove/shared)&#10;        final int typeId2;   // used as sharedIndex for CMD_SET_SHARED_MANAGED&#10;        final int[] addTypeIds;    // for CMD_MUTATE_COMPONENTS&#10;        final int[] removeTypeIds; // for CMD_MUTATE_COMPONENTS&#10;&#10;        private InterpretedCommand(int commandId, int entityId, int typeId1, int typeId2,&#10;                                   int[] addTypeIds, int[] removeTypeIds) {&#10;            this.commandId = commandId;&#10;            this.entityId = entityId;&#10;            this.typeId1 = typeId1;&#10;            this.typeId2 = typeId2;&#10;            this.addTypeIds = addTypeIds;&#10;            this.removeTypeIds = removeTypeIds;&#10;        }&#10;&#10;        static InterpretedCommand addComponent(int entityId, int typeId) {&#10;            return new InterpretedCommand(CMD_ADD_COMPONENT, entityId, typeId, -1, null, null);&#10;        }&#10;&#10;        static InterpretedCommand removeComponent(int entityId, int typeId) {&#10;            return new InterpretedCommand(CMD_REMOVE_COMPONENT, entityId, typeId, -1, null, null);&#10;        }&#10;&#10;        static InterpretedCommand destroyEntity(int entityId) {&#10;            return new InterpretedCommand(CMD_DESTROY_ENTITY, entityId, -1, -1, null, null);&#10;        }&#10;&#10;        static InterpretedCommand setSharedManaged(int entityId, int typeId, int sharedIndex) {&#10;            return new InterpretedCommand(CMD_SET_SHARED_MANAGED, entityId, typeId, sharedIndex, null, null);&#10;        }&#10;&#10;        static InterpretedCommand mutateComponents(int entityId, int[] addIds, int[] remIds) {&#10;            // For sorting/batching, we normalize (sort) the id arrays&#10;            int[] a = addIds != null ? addIds.clone() : new int[0];&#10;            int[] r = remIds != null ? remIds.clone() : new int[0];&#10;            java.util.Arrays.sort(a);&#10;            java.util.Arrays.sort(r);&#10;            return new InterpretedCommand(CMD_MUTATE_COMPONENTS, entityId, 0, 0, a, r);&#10;        }&#10;&#10;        @Override&#10;        public int compareTo(InterpretedCommand other) {&#10;            // 1) Destroy trc&#10;            boolean thisDestroy = this.commandId == CMD_DESTROY_ENTITY;&#10;            boolean otherDestroy = other.commandId == CMD_DESTROY_ENTITY;&#10;            if (thisDestroy &amp;&amp; !otherDestroy) return -1;&#10;            if (!thisDestroy &amp;&amp; otherDestroy) return 1;&#10;&#10;            // 2) Gom theo loi lnh&#10;            int c = Integer.compare(this.commandId, other.commandId);&#10;            if (c != 0) return c;&#10;&#10;            // 3) Vi multi-mutate, gom theo add/remove sets&#10;            if (this.commandId == CMD_MUTATE_COMPONENTS) {&#10;                int lenA = this.addTypeIds.length;&#10;                int lenB = other.addTypeIds.length;&#10;                c = Integer.compare(lenA, lenB);&#10;                if (c != 0) return c;&#10;                for (int i = 0; i &lt; lenA; i++) {&#10;                    c = Integer.compare(this.addTypeIds[i], other.addTypeIds[i]);&#10;                    if (c != 0) return c;&#10;                }&#10;                int lenRA = this.removeTypeIds.length;&#10;                int lenRB = other.removeTypeIds.length;&#10;                c = Integer.compare(lenRA, lenRB);&#10;                if (c != 0) return c;&#10;                for (int i = 0; i &lt; lenRA; i++) {&#10;                    c = Integer.compare(this.removeTypeIds[i], other.removeTypeIds[i]);&#10;                    if (c != 0) return c;&#10;                }&#10;            } else {&#10;                // 3b) Cc loi lnh khc gom theo typeId1 (component type) v sharedIndex nu cn&#10;                c = Integer.compare(this.typeId1, other.typeId1);&#10;                if (c != 0) return c;&#10;                if (this.commandId == CMD_SET_SHARED_MANAGED) {&#10;                    c = Integer.compare(this.typeId2, other.typeId2);&#10;                    if (c != 0) return c;&#10;                }&#10;            }&#10;&#10;            // 4) Cui cng theo entity id&#10;            return Integer.compare(this.entityId, other.entityId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Key describing a batch of structural mutations by command kind and component type.&#10;     */&#10;    private static final class MutateKey {&#10;        final int commandId;&#10;        final int typeId;&#10;        final int sharedIndex; // only meaningful for CMD_SET_SHARED_MANAGED&#10;        final int[] addTypeIds;    // for CMD_MUTATE_COMPONENTS&#10;        final int[] removeTypeIds; // for CMD_MUTATE_COMPONENTS&#10;&#10;        MutateKey(int commandId, int typeId, int sharedIndex) {&#10;            this(commandId, typeId, sharedIndex, null, null);&#10;        }&#10;&#10;        MutateKey(int commandId, int typeId, int sharedIndex, int[] addTypeIds, int[] removeTypeIds) {&#10;            this.commandId = commandId;&#10;            this.typeId = typeId;&#10;            this.sharedIndex = sharedIndex;&#10;            this.addTypeIds = addTypeIds;&#10;            this.removeTypeIds = removeTypeIds;&#10;        }&#10;&#10;        boolean isDestroy() { return commandId == CMD_DESTROY_ENTITY; }&#10;        boolean isAdd()     { return commandId == CMD_ADD_COMPONENT; }&#10;        boolean isRemove()  { return commandId == CMD_REMOVE_COMPONENT; }&#10;        boolean isSetShared() { return commandId == CMD_SET_SHARED_MANAGED; }&#10;        boolean isMutateMulti() { return commandId == CMD_MUTATE_COMPONENTS; }&#10;&#10;        @Override&#10;        public boolean equals(Object o) {&#10;            if (this == o) return true;&#10;            if (!(o instanceof MutateKey other)) return false;&#10;            if (commandId != other.commandId) return false;&#10;            if (commandId == CMD_MUTATE_COMPONENTS) {&#10;                return java.util.Arrays.equals(this.addTypeIds, other.addTypeIds)&#10;                        &amp;&amp; java.util.Arrays.equals(this.removeTypeIds, other.removeTypeIds);&#10;            }&#10;            return typeId == other.typeId &amp;&amp; sharedIndex == other.sharedIndex;&#10;        }&#10;&#10;        @Override&#10;        public int hashCode() {&#10;            int result = commandId;&#10;            if (commandId == CMD_MUTATE_COMPONENTS) {&#10;                result = 31 * result + java.util.Arrays.hashCode(addTypeIds);&#10;                result = 31 * result + java.util.Arrays.hashCode(removeTypeIds);&#10;            } else {&#10;                result = 31 * result + typeId;&#10;                result = 31 * result + sharedIndex;&#10;            }&#10;            return result;&#10;        }&#10;    }&#10;&#10;    private void executeSortedCommands(List&lt;InterpretedCommand&gt; sortedCommands, ArchetypeWorld world) {&#10;        List&lt;Integer&gt; entityBatch = new ArrayList&lt;&gt;();&#10;        MutateKey currentKey = null;&#10;&#10;        for (InterpretedCommand cmd : sortedCommands) {&#10;            MutateKey cmdKey;&#10;            if (cmd.commandId == CMD_MUTATE_COMPONENTS) {&#10;                cmdKey = new MutateKey(cmd.commandId, 0, 0, cmd.addTypeIds, cmd.removeTypeIds);&#10;            } else {&#10;                int sharedIndex = (cmd.commandId == CMD_SET_SHARED_MANAGED) ? cmd.typeId2 : -1;&#10;                cmdKey = new MutateKey(cmd.commandId, cmd.typeId1, sharedIndex);&#10;            }&#10;            if (currentKey != null &amp;&amp; cmdKey.equals(currentKey)) {&#10;                entityBatch.add(cmd.entityId);&#10;            } else {&#10;                if (!entityBatch.isEmpty()) {&#10;                    flushBatch(currentKey, entityBatch, world);&#10;                }&#10;                entityBatch.clear();&#10;                entityBatch.add(cmd.entityId);&#10;                currentKey = cmdKey;&#10;            }&#10;        }&#10;        if (!entityBatch.isEmpty() &amp;&amp; currentKey != null) {&#10;            flushBatch(currentKey, entityBatch, world);&#10;        }&#10;    }&#10;&#10;    private void flushBatch(MutateKey key, List&lt;Integer&gt; entityBatch, ArchetypeWorld world) {&#10;        int size = entityBatch.size();&#10;        int[] ids = new int[size];&#10;        for (int i = 0; i &lt; size; i++) ids[i] = entityBatch.get(i);&#10;        ArchetypeWorld.EntityBatch batch = ArchetypeWorld.EntityBatch.of(ids);&#10;&#10;        if (key.isDestroy()) {&#10;            for (int id : ids) {&#10;                world.destroyEntity(id);&#10;            }&#10;        } else if (key.isAdd()) {&#10;            Class&lt;?&gt; componentClass = world.getComponentMetadata(key.typeId).type();&#10;            world.addComponents(batch, componentClass);&#10;        } else if (key.isRemove()) {&#10;            Class&lt;?&gt; componentClass = world.getComponentMetadata(key.typeId).type();&#10;            world.removeComponents(batch, componentClass);&#10;        } else if (key.isSetShared()) {&#10;            Object sharedValue = world.sharedStore.getValue(key.sharedIndex);&#10;            if (sharedValue != null) {&#10;                // Use batch shared API to leverage O(M + N*M_intersect) path.&#10;                world.setSharedComponent(batch, sharedValue);&#10;            }&#10;        } else if (key.isMutateMulti()) {&#10;            // Multi-component mutate: map type ids back to classes and delegate to ArchetypeWorld&#10;            Class&lt;?&gt;[] addClasses = new Class&lt;?&gt;[key.addTypeIds.length];&#10;            for (int i = 0; i &lt; key.addTypeIds.length; i++) {&#10;                addClasses[i] = world.getComponentMetadata(key.addTypeIds[i]).type();&#10;            }&#10;            Class&lt;?&gt;[] remClasses = new Class&lt;?&gt;[key.removeTypeIds.length];&#10;            for (int i = 0; i &lt; key.removeTypeIds.length; i++) {&#10;                remClasses[i] = world.getComponentMetadata(key.removeTypeIds[i]).type();&#10;            }&#10;            world.mutateComponents(batch, addClasses, remClasses);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;&#10;/**&#10; * EntityCommandBuffer  Pillar 4: Write-Fast, Sort-on-Playback.&#10; *&#10; * Phase 1: write-side O(1) zero-garbage API backed by per-thread lanes.&#10; * Phase 2: playback-side O(N log N) sorting and batch execution.&#10; */&#10;public final class EntityCommandBuffer implements AutoCloseable {&#10;    // ---- Command opcodes ----&#10;    static final int CMD_ADD_COMPONENT = 1;&#10;    static final int CMD_REMOVE_COMPONENT = 2;&#10;    static final int CMD_SET_SHARED_MANAGED = 3;&#10;    static final int CMD_DESTROY_ENTITY = 4;&#10;    static final int CMD_MUTATE_COMPONENTS = 5; // multi add/remove per entity&#10;&#10;    // Size in bytes reserved per lane segment&#10;    private static final long LANE_CAPACITY = 64 * 1024; // 64KB&#10;&#10;    private final Arena bufferArena;&#10;&#10;    // Pool of reusable lanes&#10;    private final ConcurrentLinkedQueue&lt;ECBWriterLane&gt; freeLanes = new ConcurrentLinkedQueue&lt;&gt;();&#10;    // Collected lanes for playback&#10;    private final ConcurrentLinkedQueue&lt;ECBWriterLane&gt; usedLanes = new ConcurrentLinkedQueue&lt;&gt;();&#10;&#10;    // Per-thread writer lane&#10;    private final ThreadLocal&lt;ECBWriterLane&gt; threadLocalLane;&#10;&#10;    public EntityCommandBuffer(Arena parentArena) {&#10;        // For now reuse parent arena; playback phase may introduce a dedicated arena strategy.&#10;        this.bufferArena = parentArena;&#10;        this.threadLocalLane = ThreadLocal.withInitial(() -&gt; {&#10;            ECBWriterLane lane = freeLanes.poll();&#10;            if (lane == null) {&#10;                lane = new ECBWriterLane(bufferArena.allocate(LANE_CAPACITY));&#10;            } else {&#10;                lane.reset();&#10;            }&#10;            usedLanes.add(lane);&#10;            return lane;&#10;        });&#10;    }&#10;&#10;    // Expose a lightweight writer for use in parallel jobs&#10;    public ParallelWriter asParallelWriter(ArchetypeWorld world) {&#10;        return new ParallelWriter(threadLocalLane.get(), world);&#10;    }&#10;&#10;    @Override&#10;    public void close() {&#10;        // Lanes memory is owned by bufferArena; do not close arena here.&#10;        freeLanes.clear();&#10;        usedLanes.clear();&#10;    }&#10;&#10;    /**&#10;     * Decode all lanes, sort commands, and execute them in batches against the world.&#10;     */&#10;    public void playback(ArchetypeWorld world) {&#10;        // 1) Gather &amp; decode raw lanes into interpreted commands (O(N))&#10;        List&lt;InterpretedCommand&gt; allCommands = new ArrayList&lt;&gt;();&#10;        for (ECBWriterLane lane : usedLanes) {&#10;            long offset = 0L;&#10;            long limit = lane.offset;&#10;            MemorySegment segment = lane.segment;&#10;            while (offset &lt; limit) {&#10;                int cmdId = segment.get(ValueLayout.JAVA_INT, offset);&#10;                switch (cmdId) {&#10;                    case CMD_ADD_COMPONENT: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int tid = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        allCommands.add(InterpretedCommand.addComponent(eid, tid));&#10;                        offset += 12L;&#10;                        break;&#10;                    }&#10;                    case CMD_REMOVE_COMPONENT: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int tid = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        allCommands.add(InterpretedCommand.removeComponent(eid, tid));&#10;                        offset += 12L;&#10;                        break;&#10;                    }&#10;                    case CMD_DESTROY_ENTITY: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        allCommands.add(InterpretedCommand.destroyEntity(eid));&#10;                        offset += 8L;&#10;                        break;&#10;                    }&#10;                    case CMD_SET_SHARED_MANAGED: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int tid = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        int sharedIndex = segment.get(ValueLayout.JAVA_INT, offset + 12);&#10;                        allCommands.add(InterpretedCommand.setSharedManaged(eid, tid, sharedIndex));&#10;                        offset += 16L;&#10;                        break;&#10;                    }&#10;                    case CMD_MUTATE_COMPONENTS: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int addCount = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        int remCount = segment.get(ValueLayout.JAVA_INT, offset + 12);&#10;                        int[] addIds = new int[addCount];&#10;                        int[] remIds = new int[remCount];&#10;                        long p = offset + 16L;&#10;                        for (int i = 0; i &lt; addCount; i++) {&#10;                            addIds[i] = segment.get(ValueLayout.JAVA_INT, p);&#10;                            p += 4L;&#10;                        }&#10;                        for (int i = 0; i &lt; remCount; i++) {&#10;                            remIds[i] = segment.get(ValueLayout.JAVA_INT, p);&#10;                            p += 4L;&#10;                        }&#10;                        allCommands.add(InterpretedCommand.mutateComponents(eid, addIds, remIds));&#10;                        offset = p;&#10;                        break;&#10;                    }&#10;                    default:&#10;                        // Unknown or unimplemented command id  skip one int to avoid infinite loop&#10;                        offset += 4L;&#10;                        break;&#10;                }&#10;            }&#10;        }&#10;        // recycle lanes for next frame&#10;        recycleLanes();&#10;        if (allCommands.isEmpty()) return;&#10;&#10;        // 2) Sort commands using the massive O(N log N) comparator&#10;        Collections.sort(allCommands);&#10;&#10;        // 3) Execute sorted commands in batches via ArchetypeWorld batch API&#10;        executeSortedCommands(allCommands, world);&#10;    }&#10;&#10;    /**&#10;     * Return used lanes back to free pool and reset offsets.&#10;     */&#10;    private void recycleLanes() {&#10;        ECBWriterLane lane;&#10;        while ((lane = usedLanes.poll()) != null) {&#10;            lane.reset();&#10;            freeLanes.offer(lane);&#10;        }&#10;    }&#10;&#10;    // ---- Inner types ----&#10;&#10;    /**&#10;     * One contiguous lane of raw command bytes for a single writer thread.&#10;     * Not thread-safe by design; only the owning thread writes to offset.&#10;     */&#10;    static final class ECBWriterLane {&#10;        MemorySegment segment;&#10;        long offset;&#10;&#10;        ECBWriterLane(MemorySegment segment) {&#10;            this.segment = segment;&#10;            this.offset = 0L;&#10;        }&#10;&#10;        void reset() {&#10;            this.offset = 0L;&#10;        }&#10;&#10;        // Simple ensureCapacity: if not enough space, allocate a fresh segment&#10;        // and swap; old contents are expected to be consumed in playback before&#10;        // reuse. For Phase 1 we keep it simple and single-chunk per lane.&#10;        void ensureCapacity(long needed, Arena arena) {&#10;            long remaining = segment.byteSize() - offset;&#10;            if (remaining &gt;= needed) return;&#10;            // allocate a new chunk and reset offset&#10;            this.segment = arena.allocate(Math.max(LANE_CAPACITY, needed));&#10;            this.offset = 0L;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lightweight, zero-allocation facade to record commands into a lane.&#10;     */&#10;    public static final class ParallelWriter {&#10;        private final ECBWriterLane lane;&#10;        private final ArchetypeWorld world;&#10;&#10;        public ParallelWriter(ECBWriterLane lane, ArchetypeWorld world) {&#10;            this.lane = lane;&#10;            this.world = world;&#10;        }&#10;&#10;        public void addComponent(int entityId, Class&lt;?&gt; type) {&#10;            // getComponentTypeId returns Integer; handle unknown types cheaply&#10;            Integer typeId = world.getComponentTypeId(type);&#10;            if (typeId == null) return; // or throw, but write side should be cheap&#10;            long bytes = 12L; // opcode + entityId + typeId&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_ADD_COMPONENT);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, typeId);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        public void removeComponent(int entityId, Class&lt;?&gt; type) {&#10;            Integer typeId = world.getComponentTypeId(type);&#10;            if (typeId == null) return;&#10;            long bytes = 12L;&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_REMOVE_COMPONENT);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, typeId);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        public void destroyEntity(int entityId) {&#10;            long bytes = 8L; // opcode + entityId&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_DESTROY_ENTITY);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        // New: record a shared-managed component assignment.&#10;        public void setSharedManaged(int entityId, Object sharedValue) {&#10;            if (sharedValue == null) return;&#10;            Class&lt;?&gt; type = sharedValue.getClass();&#10;            Integer typeId = world.getComponentTypeId(type);&#10;            if (typeId == null) return; // unknown type: ignore at write side&#10;            // Ensure the value has a stable shared index in the store.&#10;            // Using getOrAddSharedIndex here guarantees we never encode -1,&#10;            // and that playback can always reconstruct the value via the store.&#10;            int sharedIndex = world.sharedStore.getOrAddSharedIndex(sharedValue);&#10;            long bytes = 16L; // cmdId + entityId + typeId + sharedIndex&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_SET_SHARED_MANAGED);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, typeId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 12, sharedIndex);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        /**&#10;         * Multi-component structural mutation for a single entity: add/remove multiple component types.&#10;         * This encodes a compact command that playback can batch across entities with the same add/remove sets.&#10;         */&#10;        public void mutateComponents(int entityId, Class&lt;?&gt;[] addTypes, Class&lt;?&gt;[] removeTypes) {&#10;            int addCount = addTypes != null ? addTypes.length : 0;&#10;            int remCount = removeTypes != null ? removeTypes.length : 0;&#10;            if (addCount == 0 &amp;&amp; remCount == 0) return;&#10;            int[] addIds = new int[addCount];&#10;            int[] remIds = new int[remCount];&#10;            for (int i = 0; i &lt; addCount; i++) {&#10;                Integer tid = world.getComponentTypeId(addTypes[i]);&#10;                if (tid == null) throw new IllegalArgumentException(&quot;Unregistered component: &quot; + addTypes[i]);&#10;                addIds[i] = tid;&#10;            }&#10;            for (int i = 0; i &lt; remCount; i++) {&#10;                Integer tid = world.getComponentTypeId(removeTypes[i]);&#10;                if (tid == null) throw new IllegalArgumentException(&quot;Unregistered component: &quot; + removeTypes[i]);&#10;                remIds[i] = tid;&#10;            }&#10;            // Encode: [cmdId, entityId, addCount, remCount, addIds..., remIds...]&#10;            long bytes = 16L + 4L * (addCount + remCount);&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_MUTATE_COMPONENTS);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, addCount);&#10;            seg.set(ValueLayout.JAVA_INT, off + 12, remCount);&#10;            long p = off + 16L;&#10;            for (int id : addIds) {&#10;                seg.set(ValueLayout.JAVA_INT, p, id);&#10;                p += 4L;&#10;            }&#10;            for (int id : remIds) {&#10;                seg.set(ValueLayout.JAVA_INT, p, id);&#10;                p += 4L;&#10;            }&#10;            lane.offset = p;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Decoded command representation used for sorting &amp; batching.&#10;     */&#10;    private static final class InterpretedCommand implements Comparable&lt;InterpretedCommand&gt; {&#10;        final int commandId;&#10;        final int entityId;&#10;        final int typeId1;   // primary component type (for add/remove/shared)&#10;        final int typeId2;   // used as sharedIndex for CMD_SET_SHARED_MANAGED&#10;        final int[] addTypeIds;    // for CMD_MUTATE_COMPONENTS&#10;        final int[] removeTypeIds; // for CMD_MUTATE_COMPONENTS&#10;&#10;        private InterpretedCommand(int commandId, int entityId, int typeId1, int typeId2,&#10;                                   int[] addTypeIds, int[] removeTypeIds) {&#10;            this.commandId = commandId;&#10;            this.entityId = entityId;&#10;            this.typeId1 = typeId1;&#10;            this.typeId2 = typeId2;&#10;            this.addTypeIds = addTypeIds;&#10;            this.removeTypeIds = removeTypeIds;&#10;        }&#10;&#10;        static InterpretedCommand addComponent(int entityId, int typeId) {&#10;            return new InterpretedCommand(CMD_ADD_COMPONENT, entityId, typeId, -1, null, null);&#10;        }&#10;&#10;        static InterpretedCommand removeComponent(int entityId, int typeId) {&#10;            return new InterpretedCommand(CMD_REMOVE_COMPONENT, entityId, typeId, -1, null, null);&#10;        }&#10;&#10;        static InterpretedCommand destroyEntity(int entityId) {&#10;            return new InterpretedCommand(CMD_DESTROY_ENTITY, entityId, -1, -1, null, null);&#10;        }&#10;&#10;        static InterpretedCommand setSharedManaged(int entityId, int typeId, int sharedIndex) {&#10;            return new InterpretedCommand(CMD_SET_SHARED_MANAGED, entityId, typeId, sharedIndex, null, null);&#10;        }&#10;&#10;        static InterpretedCommand mutateComponents(int entityId, int[] addIds, int[] remIds) {&#10;            // For sorting/batching, we normalize (sort) the id arrays&#10;            int[] a = addIds != null ? addIds.clone() : new int[0];&#10;            int[] r = remIds != null ? remIds.clone() : new int[0];&#10;            java.util.Arrays.sort(a);&#10;            java.util.Arrays.sort(r);&#10;            return new InterpretedCommand(CMD_MUTATE_COMPONENTS, entityId, 0, 0, a, r);&#10;        }&#10;&#10;        @Override&#10;        public int compareTo(InterpretedCommand other) {&#10;            // 1) Destroy trc&#10;            boolean thisDestroy = this.commandId == CMD_DESTROY_ENTITY;&#10;            boolean otherDestroy = other.commandId == CMD_DESTROY_ENTITY;&#10;            if (thisDestroy &amp;&amp; !otherDestroy) return -1;&#10;            if (!thisDestroy &amp;&amp; otherDestroy) return 1;&#10;&#10;            // 2) Gom theo loi lnh&#10;            int c = Integer.compare(this.commandId, other.commandId);&#10;            if (c != 0) return c;&#10;&#10;            // 3) Vi multi-mutate, gom theo add/remove sets&#10;            if (this.commandId == CMD_MUTATE_COMPONENTS) {&#10;                int lenA = this.addTypeIds.length;&#10;                int lenB = other.addTypeIds.length;&#10;                c = Integer.compare(lenA, lenB);&#10;                if (c != 0) return c;&#10;                for (int i = 0; i &lt; lenA; i++) {&#10;                    c = Integer.compare(this.addTypeIds[i], other.addTypeIds[i]);&#10;                    if (c != 0) return c;&#10;                }&#10;                int lenRA = this.removeTypeIds.length;&#10;                int lenRB = other.removeTypeIds.length;&#10;                c = Integer.compare(lenRA, lenRB);&#10;                if (c != 0) return c;&#10;                for (int i = 0; i &lt; lenRA; i++) {&#10;                    c = Integer.compare(this.removeTypeIds[i], other.removeTypeIds[i]);&#10;                    if (c != 0) return c;&#10;                }&#10;            } else {&#10;                // 3b) Cc loi lnh khc gom theo typeId1 (component type) v sharedIndex nu cn&#10;                c = Integer.compare(this.typeId1, other.typeId1);&#10;                if (c != 0) return c;&#10;                if (this.commandId == CMD_SET_SHARED_MANAGED) {&#10;                    c = Integer.compare(this.typeId2, other.typeId2);&#10;                    if (c != 0) return c;&#10;                }&#10;            }&#10;&#10;            // 4) Cui cng theo entity id&#10;            return Integer.compare(this.entityId, other.entityId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Key describing a batch of structural mutations by command kind and component type.&#10;     */&#10;    private static final class MutateKey {&#10;        final int commandId;&#10;        final int typeId;&#10;        final int sharedIndex; // only meaningful for CMD_SET_SHARED_MANAGED&#10;        final int[] addTypeIds;    // for CMD_MUTATE_COMPONENTS&#10;        final int[] removeTypeIds; // for CMD_MUTATE_COMPONENTS&#10;&#10;        MutateKey(int commandId, int typeId, int sharedIndex) {&#10;            this(commandId, typeId, sharedIndex, null, null);&#10;        }&#10;&#10;        MutateKey(int commandId, int typeId, int sharedIndex, int[] addTypeIds, int[] removeTypeIds) {&#10;            this.commandId = commandId;&#10;            this.typeId = typeId;&#10;            this.sharedIndex = sharedIndex;&#10;            this.addTypeIds = addTypeIds;&#10;            this.removeTypeIds = removeTypeIds;&#10;        }&#10;&#10;        boolean isDestroy() { return commandId == CMD_DESTROY_ENTITY; }&#10;        boolean isAdd()     { return commandId == CMD_ADD_COMPONENT; }&#10;        boolean isRemove()  { return commandId == CMD_REMOVE_COMPONENT; }&#10;        boolean isSetShared() { return commandId == CMD_SET_SHARED_MANAGED; }&#10;        boolean isMutateMulti() { return commandId == CMD_MUTATE_COMPONENTS; }&#10;&#10;        @Override&#10;        public boolean equals(Object o) {&#10;            if (this == o) return true;&#10;            if (!(o instanceof MutateKey other)) return false;&#10;            if (commandId != other.commandId) return false;&#10;            if (commandId == CMD_MUTATE_COMPONENTS) {&#10;                return java.util.Arrays.equals(this.addTypeIds, other.addTypeIds)&#10;                        &amp;&amp; java.util.Arrays.equals(this.removeTypeIds, other.removeTypeIds);&#10;            }&#10;            return typeId == other.typeId &amp;&amp; sharedIndex == other.sharedIndex;&#10;        }&#10;&#10;        @Override&#10;        public int hashCode() {&#10;            int result = commandId;&#10;            if (commandId == CMD_MUTATE_COMPONENTS) {&#10;                result = 31 * result + java.util.Arrays.hashCode(addTypeIds);&#10;                result = 31 * result + java.util.Arrays.hashCode(removeTypeIds);&#10;            } else {&#10;                result = 31 * result + typeId;&#10;                result = 31 * result + sharedIndex;&#10;            }&#10;            return result;&#10;        }&#10;    }&#10;&#10;    private void executeSortedCommands(List&lt;InterpretedCommand&gt; sortedCommands, ArchetypeWorld world) {&#10;        List&lt;Integer&gt; entityBatch = new ArrayList&lt;&gt;();&#10;        MutateKey currentKey = null;&#10;&#10;        for (InterpretedCommand cmd : sortedCommands) {&#10;            MutateKey cmdKey;&#10;            if (cmd.commandId == CMD_MUTATE_COMPONENTS) {&#10;                cmdKey = new MutateKey(cmd.commandId, 0, 0, cmd.addTypeIds, cmd.removeTypeIds);&#10;            } else {&#10;                int sharedIndex = (cmd.commandId == CMD_SET_SHARED_MANAGED) ? cmd.typeId2 : -1;&#10;                cmdKey = new MutateKey(cmd.commandId, cmd.typeId1, sharedIndex);&#10;            }&#10;            if (currentKey != null &amp;&amp; cmdKey.equals(currentKey)) {&#10;                entityBatch.add(cmd.entityId);&#10;            } else {&#10;                if (!entityBatch.isEmpty()) {&#10;                    flushBatch(currentKey, entityBatch, world);&#10;                }&#10;                entityBatch.clear();&#10;                entityBatch.add(cmd.entityId);&#10;                currentKey = cmdKey;&#10;            }&#10;        }&#10;        if (!entityBatch.isEmpty() &amp;&amp; currentKey != null) {&#10;            flushBatch(currentKey, entityBatch, world);&#10;        }&#10;    }&#10;&#10;    private void flushBatch(MutateKey key, List&lt;Integer&gt; entityBatch, ArchetypeWorld world) {&#10;        int size = entityBatch.size();&#10;        int[] ids = new int[size];&#10;        for (int i = 0; i &lt; size; i++) ids[i] = entityBatch.get(i);&#10;        ArchetypeWorld.EntityBatch batch = ArchetypeWorld.EntityBatch.of(ids);&#10;&#10;        if (key.isDestroy()) {&#10;            for (int id : ids) {&#10;                world.destroyEntity(id);&#10;            }&#10;        } else if (key.isAdd()) {&#10;            Class&lt;?&gt; componentClass = world.getComponentMetadata(key.typeId).type();&#10;            world.addComponents(batch, componentClass);&#10;        } else if (key.isRemove()) {&#10;            Class&lt;?&gt; componentClass = world.getComponentMetadata(key.typeId).type();&#10;            world.removeComponents(batch, componentClass);&#10;        } else if (key.isSetShared()) {&#10;            Object sharedValue = world.sharedStore.getValue(key.sharedIndex);&#10;            if (sharedValue != null) {&#10;                // Use batch shared API to leverage O(M + N*M_intersect) path.&#10;                world.setSharedComponent(batch, sharedValue);&#10;            }&#10;        } else if (key.isMutateMulti()) {&#10;            // Multi-component mutate: map type ids back to classes and delegate to ArchetypeWorld&#10;            Class&lt;?&gt;[] addClasses = new Class&lt;?&gt;[key.addTypeIds.length];&#10;            for (int i = 0; i &lt; key.addTypeIds.length; i++) {&#10;                addClasses[i] = world.getComponentMetadata(key.addTypeIds[i]).type();&#10;            }&#10;            Class&lt;?&gt;[] remClasses = new Class&lt;?&gt;[key.removeTypeIds.length];&#10;            for (int i = 0; i &lt; key.removeTypeIds.length; i++) {&#10;                remClasses[i] = world.getComponentMetadata(key.removeTypeIds[i]).type();&#10;            }&#10;            world.mutateComponents(batch, addClasses, remClasses);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentDescriptor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentDescriptor.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.util.*;&#10;&#10;/**&#10; * Descriptor containing metadata about a component's memory layout&#10; * Generated by ComponentManager through reflection&#10; */&#10;public class ComponentDescriptor {&#10;    private final Class&lt;?&gt; componentClass;&#10;    private final long totalSize;&#10;    private final Map&lt;String, FieldDescriptor&gt; fields; // legacy name-&gt;descriptor&#10;    private final List&lt;FieldDescriptor&gt; fieldList;     // legacy ordered list (immutable)&#10;    private final FieldDescriptor[] fieldArray;        // fast array for index-based access&#10;    private final Map&lt;String, Integer&gt; fieldIndexMap;  // name -&gt; index (immutable)&#10;    private final Component.LayoutType layoutType;&#10;    // New: whether this component is managed (@Component.Managed) or unmanaged (default/@Unmanaged)&#10;    private final boolean managed;&#10;    // New: fine-grained kind distinguishing instance/shared and managed/unmanaged&#10;    public enum ComponentKind { INSTANCE_UNMANAGED, INSTANCE_MANAGED, SHARED_UNMANAGED, SHARED_MANAGED }&#10;    private final ComponentKind kind;&#10;&#10;    public ComponentDescriptor(Class&lt;?&gt; componentClass, long totalSize,&#10;                              List&lt;FieldDescriptor&gt; fields, Component.LayoutType layoutType) {&#10;        this(componentClass, totalSize, fields, layoutType, null);&#10;    }&#10;&#10;    // Overload that allows explicit kind; if null, derives from managed flag&#10;    public ComponentDescriptor(Class&lt;?&gt; componentClass, long totalSize,&#10;                               List&lt;FieldDescriptor&gt; fields, Component.LayoutType layoutType,&#10;                               ComponentKind explicitKind) {&#10;        this.componentClass = componentClass;&#10;        this.totalSize = totalSize;&#10;        this.fieldList = Collections.unmodifiableList(new ArrayList&lt;&gt;(fields));&#10;        this.fields = new HashMap&lt;&gt;();&#10;        for (FieldDescriptor field : fields) {&#10;            this.fields.put(field.name(), field);&#10;        }&#10;        // Build fast structures&#10;        this.fieldArray = this.fieldList.toArray(new FieldDescriptor[0]);&#10;        Map&lt;String, Integer&gt; indexMap = new HashMap&lt;&gt;(fieldArray.length);&#10;        for (int i = 0; i &lt; fieldArray.length; i++) {&#10;            indexMap.put(fieldArray[i].name(), i);&#10;        }&#10;        this.fieldIndexMap = Collections.unmodifiableMap(indexMap);&#10;&#10;        this.layoutType = layoutType;&#10;        // Determine managed kind from annotation on the component type&#10;        this.managed = componentClass.isAnnotationPresent(Component.Managed.class);&#10;        // Determine kind: prefer explicit, else derive from managed flag as instance component&#10;        this.kind = (explicitKind != null) ? explicitKind : (this.managed ? ComponentKind.INSTANCE_MANAGED : ComponentKind.INSTANCE_UNMANAGED);&#10;    }&#10;&#10;    public Class&lt;?&gt; getComponentClass() {&#10;        return componentClass;&#10;    }&#10;&#10;    public long getTotalSize() {&#10;        return totalSize;&#10;    }&#10;&#10;    // Legacy name-based lookup (setup-time, not hot-path)&#10;    public FieldDescriptor getField(String name) {&#10;        return fields.get(name);&#10;    }&#10;&#10;    // New: O(1) index-based access&#10;    public int getFieldIndex(String fieldName) {&#10;        Integer idx = fieldIndexMap.get(fieldName);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public FieldDescriptor getField(int index) {&#10;        return fieldArray[index];&#10;    }&#10;&#10;    public int fieldCount() {&#10;        return fieldArray.length;&#10;    }&#10;&#10;    public List&lt;FieldDescriptor&gt; getFields() {&#10;        return fieldList;&#10;    }&#10;&#10;    public Component.LayoutType getLayoutType() {&#10;        return layoutType;&#10;    }&#10;&#10;    // New: managed flag&#10;    public boolean isManaged() { return managed; }&#10;&#10;    // New: fine-grained kind&#10;    public ComponentKind getKind() { return kind; }&#10;&#10;    /**&#10;     * Field descriptor with type and layout information&#10;     */&#10;    public record FieldDescriptor(&#10;        String name,&#10;        FieldType type,&#10;        long offset,&#10;        long size,&#10;        int alignment&#10;    ) {}&#10;&#10;    /**&#10;     * Supported field types&#10;     */&#10;    public enum FieldType {&#10;        BYTE(1, 1),&#10;        SHORT(2, 2),&#10;        INT(4, 4),&#10;        LONG(8, 8),&#10;        FLOAT(4, 4),&#10;        DOUBLE(8, 8),&#10;        BOOLEAN(1, 1),&#10;        CHAR(2, 2);&#10;&#10;        private final long size;&#10;        private final int naturalAlignment;&#10;&#10;        FieldType(long size, int naturalAlignment) {&#10;            this.size = size;&#10;            this.naturalAlignment = naturalAlignment;&#10;        }&#10;&#10;        public long getSize() {&#10;            return size;&#10;        }&#10;&#10;        public int getNaturalAlignment() {&#10;            return naturalAlignment;&#10;        }&#10;&#10;        public static FieldType fromJavaType(Class&lt;?&gt; type) {&#10;            if (type == byte.class || type == Byte.class) return BYTE;&#10;            if (type == short.class || type == Short.class) return SHORT;&#10;            if (type == int.class || type == Integer.class) return INT;&#10;            if (type == long.class || type == Long.class) return LONG;&#10;            if (type == float.class || type == Float.class) return FLOAT;&#10;            if (type == double.class || type == Double.class) return DOUBLE;&#10;            if (type == boolean.class || type == Boolean.class) return BOOLEAN;&#10;            if (type == char.class || type == Character.class) return CHAR;&#10;            throw new IllegalArgumentException(&quot;Unsupported field type: &quot; + type);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;ComponentDescriptor[&quot;)&#10;          .append(componentClass.getSimpleName())&#10;          .append(&quot;, size=&quot;).append(totalSize)&#10;          .append(&quot;, layout=&quot;).append(layoutType)&#10;          .append(&quot;, managed=&quot;).append(managed)&#10;          .append(&quot;, kind=&quot;).append(kind)&#10;          .append(&quot;, fields=[\n&quot;);&#10;        for (FieldDescriptor field : fieldList) {&#10;            sb.append(&quot;  &quot;).append(field.name())&#10;              .append(&quot;: &quot;).append(field.type())&#10;              .append(&quot; @&quot;).append(field.offset())&#10;              .append(&quot; (size=&quot;).append(field.size())&#10;              .append(&quot;, align=&quot;).append(field.alignment())&#10;              .append(&quot;)\n&quot;);&#10;        }&#10;        sb.append(&quot;]] &quot;);&#10;        return sb.toString();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.components;&#13;&#10;&#13;&#10;import java.util.*;&#13;&#10;&#13;&#10;/**&#13;&#10; * Descriptor containing metadata about a component's memory layout&#13;&#10; * Generated by ComponentManager through reflection&#13;&#10; */&#13;&#10;public class ComponentDescriptor {&#13;&#10;    private final Class&lt;?&gt; componentClass;&#13;&#10;    private final long totalSize;&#13;&#10;    private final Map&lt;String, FieldDescriptor&gt; fields; // legacy name-&gt;descriptor&#13;&#10;    private final List&lt;FieldDescriptor&gt; fieldList;     // legacy ordered list (immutable)&#13;&#10;    private final FieldDescriptor[] fieldArray;        // fast array for index-based access&#13;&#10;    private final Map&lt;String, Integer&gt; fieldIndexMap;  // name -&gt; index (immutable)&#13;&#10;    private final Component.LayoutType layoutType;&#13;&#10;    // New: whether this component is managed (@Component.Managed) or unmanaged (default/@Unmanaged)&#13;&#10;    private final boolean managed;&#13;&#10;    // New: fine-grained kind distinguishing instance/shared and managed/unmanaged&#13;&#10;    public enum ComponentKind { INSTANCE_UNMANAGED, INSTANCE_MANAGED, SHARED_UNMANAGED, SHARED_MANAGED }&#13;&#10;    private final ComponentKind kind;&#13;&#10;&#13;&#10;    public ComponentDescriptor(Class&lt;?&gt; componentClass, long totalSize,&#13;&#10;                              List&lt;FieldDescriptor&gt; fields, Component.LayoutType layoutType) {&#13;&#10;        this(componentClass, totalSize, fields, layoutType, null);&#13;&#10;    }&#13;&#10;&#13;&#10;    // Overload that allows explicit kind; if null, derives from managed flag&#13;&#10;    public ComponentDescriptor(Class&lt;?&gt; componentClass, long totalSize,&#13;&#10;                               List&lt;FieldDescriptor&gt; fields, Component.LayoutType layoutType,&#13;&#10;                               ComponentKind explicitKind) {&#13;&#10;        this.componentClass = componentClass;&#13;&#10;        this.totalSize = totalSize;&#13;&#10;        this.fieldList = Collections.unmodifiableList(new ArrayList&lt;&gt;(fields));&#13;&#10;        this.fields = new HashMap&lt;&gt;();&#13;&#10;        for (FieldDescriptor field : fields) {&#13;&#10;            this.fields.put(field.name(), field);&#13;&#10;        }&#13;&#10;        // Build fast structures&#13;&#10;        this.fieldArray = this.fieldList.toArray(new FieldDescriptor[0]);&#13;&#10;        Map&lt;String, Integer&gt; indexMap = new HashMap&lt;&gt;(fieldArray.length);&#13;&#10;        for (int i = 0; i &lt; fieldArray.length; i++) {&#13;&#10;            indexMap.put(fieldArray[i].name(), i);&#13;&#10;        }&#13;&#10;        this.fieldIndexMap = Collections.unmodifiableMap(indexMap);&#13;&#10;&#13;&#10;        this.layoutType = layoutType;&#13;&#10;        // Determine managed kind from annotation on the component type&#13;&#10;        this.managed = componentClass.isAnnotationPresent(Component.Managed.class);&#13;&#10;        // Determine kind: prefer explicit, else derive from managed flag as instance component&#13;&#10;        this.kind = (explicitKind != null) ? explicitKind : (this.managed ? ComponentKind.INSTANCE_MANAGED : ComponentKind.INSTANCE_UNMANAGED);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Class&lt;?&gt; getComponentClass() {&#13;&#10;        return componentClass;&#13;&#10;    }&#13;&#10;&#13;&#10;    public long getTotalSize() {&#13;&#10;        return totalSize;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Legacy name-based lookup (setup-time, not hot-path)&#13;&#10;    public FieldDescriptor getField(String name) {&#13;&#10;        return fields.get(name);&#13;&#10;    }&#13;&#10;&#13;&#10;    // New: O(1) index-based access&#13;&#10;    public int getFieldIndex(String fieldName) {&#13;&#10;        Integer idx = fieldIndexMap.get(fieldName);&#13;&#10;        return idx == null ? -1 : idx;&#13;&#10;    }&#13;&#10;&#13;&#10;    public FieldDescriptor getField(int index) {&#13;&#10;        return fieldArray[index];&#13;&#10;    }&#13;&#10;&#13;&#10;    public int fieldCount() {&#13;&#10;        return fieldArray.length;&#13;&#10;    }&#13;&#10;&#13;&#10;    public List&lt;FieldDescriptor&gt; getFields() {&#13;&#10;        return fieldList;&#13;&#10;    }&#13;&#10;&#13;&#10;    public Component.LayoutType getLayoutType() {&#13;&#10;        return layoutType;&#13;&#10;    }&#13;&#10;&#13;&#10;    // New: managed flag&#13;&#10;    public boolean isManaged() { return managed; }&#13;&#10;&#13;&#10;    // New: fine-grained kind&#13;&#10;    public ComponentKind getKind() { return kind; }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Field descriptor with type and layout information&#13;&#10;     */&#13;&#10;    public record FieldDescriptor(&#13;&#10;        String name,&#13;&#10;        FieldType type,&#13;&#10;        long offset,&#13;&#10;        long size,&#13;&#10;        int alignment&#13;&#10;    ) {}&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Supported field types&#13;&#10;     */&#13;&#10;    public enum FieldType {&#13;&#10;        BYTE(1, 1),&#13;&#10;        SHORT(2, 2),&#13;&#10;        INT(4, 4),&#13;&#10;        LONG(8, 8),&#13;&#10;        FLOAT(4, 4),&#13;&#10;        DOUBLE(8, 8),&#13;&#10;        BOOLEAN(1, 1),&#13;&#10;        CHAR(2, 2);&#13;&#10;&#13;&#10;        private final long size;&#13;&#10;        private final int naturalAlignment;&#13;&#10;&#13;&#10;        FieldType(long size, int naturalAlignment) {&#13;&#10;            this.size = size;&#13;&#10;            this.naturalAlignment = naturalAlignment;&#13;&#10;        }&#13;&#10;&#13;&#10;        public long getSize() {&#13;&#10;            return size;&#13;&#10;        }&#13;&#10;&#13;&#10;        public int getNaturalAlignment() {&#13;&#10;            return naturalAlignment;&#13;&#10;        }&#13;&#10;&#13;&#10;        public static FieldType fromJavaType(Class&lt;?&gt; type) {&#13;&#10;            if (type == byte.class || type == Byte.class) return BYTE;&#13;&#10;            if (type == short.class || type == Short.class) return SHORT;&#13;&#10;            if (type == int.class || type == Integer.class) return INT;&#13;&#10;            if (type == long.class || type == Long.class) return LONG;&#13;&#10;            if (type == float.class || type == Float.class) return FLOAT;&#13;&#10;            if (type == double.class || type == Double.class) return DOUBLE;&#13;&#10;            if (type == boolean.class || type == Boolean.class) return BOOLEAN;&#13;&#10;            if (type == char.class || type == Character.class) return CHAR;&#13;&#10;            throw new IllegalArgumentException(&quot;Unsupported field type: &quot; + type);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public String toString() {&#13;&#10;        StringBuilder sb = new StringBuilder();&#13;&#10;        sb.append(&quot;ComponentDescriptor[&quot;)&#13;&#10;          .append(componentClass.getSimpleName())&#13;&#10;          .append(&quot;, size=&quot;).append(totalSize)&#13;&#10;          .append(&quot;, layout=&quot;).append(layoutType)&#13;&#10;          .append(&quot;, managed=&quot;).append(managed)&#13;&#10;          .append(&quot;, kind=&quot;).append(kind)&#13;&#10;          .append(&quot;, fields=[\n&quot;);&#13;&#10;        for (FieldDescriptor field : fieldList) {&#13;&#10;            sb.append(&quot;  &quot;).append(field.name())&#13;&#10;              .append(&quot;: &quot;).append(field.type())&#13;&#10;              .append(&quot; @&quot;).append(field.offset())&#13;&#10;              .append(&quot; (size=&quot;).append(field.size())&#13;&#10;              .append(&quot;, align=&quot;).append(field.alignment())&#13;&#10;              .append(&quot;)\n&quot;);&#13;&#10;        }&#13;&#10;        sb.append(&quot;]] &quot;);&#13;&#10;        return sb.toString();&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Method;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    // Thread-safe registries&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;    // [THM VO] Map ID -&gt; Descriptor  tra cu O(1) theo typeId&#10;    private final ConcurrentHashMap&lt;Integer, ComponentDescriptor&gt; idToDescriptorMap = new ConcurrentHashMap&lt;&gt;();&#10;    private final AtomicInteger nextTypeId = new AtomicInteger(0);&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    // Typed handle pools keyed by component class, used by AP-generated code for PositionHandle, etc.&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, HandlePool&lt;? extends IBindableHandle&gt;&gt; typedHandlePools = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Lightweight validation for shared component annotations&#10;        validateSharedAnnotations(componentClass);&#10;&#10;        // Assign a stable type id exactly once, even under races&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;&#10;        // Prefer generated descriptor if present; else build via reflection&#10;        descriptors.computeIfAbsent(componentClass, cls -&gt; {&#10;            ComponentDescriptor gen = tryLoadGeneratedDescriptor(cls);&#10;            ComponentDescriptor desc = gen != null ? gen : buildDescriptor(cls);&#10;            // Cp nht map ID -&gt; Descriptor cho lookup O(1)&#10;            idToDescriptorMap.put(typeId, desc);&#10;            return desc;&#10;        });&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Register a component class with a prebuilt descriptor (e.g., from generated meta).&#10;     * Thread-safe and idempotent: type id is assigned once; descriptor installed if absent.&#10;     */&#10;    public &lt;T&gt; int registerComponentWithDescriptor(Class&lt;T&gt; componentClass, ComponentDescriptor descriptor) {&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;        // Validate shared annotations even if descriptor is provided&#10;        validateSharedAnnotations(componentClass);&#10;&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;descriptor must not be null for &quot; + componentClass.getName());&#10;        }&#10;        descriptors.putIfAbsent(componentClass, descriptor);&#10;        // Cp nht c map ID -&gt; Descriptor (khng ghi  nu  c)&#10;        idToDescriptorMap.putIfAbsent(typeId, descriptor);&#10;        return typeId;&#10;    }&#10;&#10;    // High-level registration used by AP-generated code to install both descriptor and typed handle pool.&#10;    public &lt;T extends IBindableHandle&gt; void registerComponentWithHandle(&#10;        Class&lt;?&gt; componentClass,&#10;        ComponentDescriptor descriptor,&#10;        java.util.function.Supplier&lt;T&gt; handleFactory&#10;    ) {&#10;        int typeId = registerComponentWithDescriptor(componentClass, descriptor);&#10;        HandlePool&lt;T&gt; pool = new HandlePool&lt;&gt;(handleFactory);&#10;        typedHandlePools.put(componentClass, pool);&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Determine kind from annotations&#10;        ComponentDescriptor.ComponentKind kind = getComponentKind(componentClass);&#10;&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType, kind);&#10;    }&#10;&#10;    private static ComponentDescriptor.ComponentKind getComponentKind(Class&lt;?&gt; componentClass) {&#10;        boolean isManaged = componentClass.isAnnotationPresent(Component.Managed.class);&#10;        boolean isShared = componentClass.isAnnotationPresent(Component.Shared.class);&#10;        ComponentDescriptor.ComponentKind kind;&#10;        if (isShared) {&#10;            kind = isManaged ? ComponentDescriptor.ComponentKind.SHARED_MANAGED : ComponentDescriptor.ComponentKind.SHARED_UNMANAGED;&#10;        } else {&#10;            kind = isManaged ? ComponentDescriptor.ComponentKind.INSTANCE_MANAGED : ComponentDescriptor.ComponentKind.INSTANCE_UNMANAGED;&#10;        }&#10;        return kind;&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;&#10;    // Try to load a generated meta class &lt;FQN&gt; + &quot;Meta&quot; exposing DESCRIPTOR field or descriptor() method.&#10;    private ComponentDescriptor tryLoadGeneratedDescriptor(Class&lt;?&gt; componentClass) {&#10;        String metaName = componentClass.getName() + &quot;Meta&quot;;&#10;        try {&#10;            Class&lt;?&gt; meta = Class.forName(metaName, false, componentClass.getClassLoader());&#10;            try {&#10;                java.lang.reflect.Field f = meta.getField(&quot;DESCRIPTOR&quot;);&#10;                Object v = f.get(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchFieldException ignored) { }&#10;            try {&#10;                java.lang.reflect.Method m = meta.getMethod(&quot;descriptor&quot;);&#10;                Object v = m.invoke(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchMethodException ignored) { }&#10;        } catch (Throwable ignored) {&#10;            // not generated/present&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Lightweight validation for shared component annotations.&#10;     * or setters (1-arg int/long, returns void).&#10;     */&#10;    private void validateSharedAnnotations(Class&lt;?&gt; cls) {&#10;        boolean hasShared = cls.isAnnotationPresent(Component.Shared.class);&#10;        boolean hasManaged = cls.isAnnotationPresent(Component.Managed.class);&#10;&#10;        if (!hasShared) return; // nothing to validate&#10;&#10;        // Managed-shared: @Shared + @Managed must be a class overriding equals/hashCode&#10;        if (hasManaged) {&#10;            if (cls.isInterface()) {&#10;                throw new IllegalArgumentException(&quot;@Shared (managed) must be placed on a class, not an interface: &quot; + cls.getName());&#10;            }&#10;            try {&#10;                Method eq = cls.getMethod(&quot;equals&quot;, Object.class);&#10;                if (eq.getDeclaringClass() == Object.class) throw new NoSuchMethodException();&#10;            } catch (NoSuchMethodException e) {&#10;                throw new IllegalArgumentException(&quot;Class &quot; + cls.getName() + &quot; is annotated @Shared but does not override equals(Object)&quot;);&#10;            }&#10;            try {&#10;                Method hc = cls.getMethod(&quot;hashCode&quot;);&#10;                if (hc.getDeclaringClass() == Object.class) throw new NoSuchMethodException();&#10;            } catch (NoSuchMethodException e) {&#10;                throw new IllegalArgumentException(&quot;Class &quot; + cls.getName() + &quot; is annotated @Shared but does not override hashCode()&quot;);&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Unmanaged-shared: @Shared without @Managed must be an class with at least one field (primitive types)&#10;        if (cls.isInterface()) {&#10;            throw new IllegalArgumentException(&quot;@Shared (unmanaged) must be placed on a class, not an interface: &quot; + cls.getName());&#10;        }&#10;        Field[] fields = cls.getDeclaredFields();&#10;        if (fields.length == 0) {&#10;            throw new IllegalArgumentException(&quot;Class &quot; + cls.getName() + &quot; is annotated @Shared but has no fields&quot;);&#10;        }&#10;&#10;        for( Field f : fields) {&#10;            Class&lt;?&gt; t = f.getType();&#10;            if (!(t == int.class || t == long.class || t == float.class || t == double.class || t == boolean.class)) {&#10;                throw new IllegalArgumentException(&quot;Field &quot; + f.getName() + &quot; in @Shared unmanaged component &quot; + cls.getName() +&#10;                    &quot; has unsupported type &quot; + t.getName() + &quot;. Only primitive types are allowed.&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Acquire a typed handle instance from the pool for the given component class.&#10;    public IBindableHandle acquireTypedHandle(Class&lt;?&gt; componentClass) {&#10;        HandlePool&lt;?&gt; pool = typedHandlePools.get(componentClass);&#10;        if (pool == null) {&#10;            throw new IllegalArgumentException(&quot;No typed handle pool registered for component: &quot; + componentClass.getName());&#10;        }&#10;        return pool.acquire();&#10;    }&#10;&#10;    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})&#10;    public void releaseTypedHandle(Class&lt;?&gt; componentClass, IBindableHandle handle) {&#10;        HandlePool pool = typedHandlePools.get(componentClass);&#10;        if (pool != null) {&#10;            pool.release(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Returns an unmodifiable view of the registered component-&gt;id mapping.&#10;     * This allows external clients (e.g., ArchetypeWorld) to resolve ids back to classes&#10;     * without duplicating ID ownership.&#10;     */&#10;    public Set&lt;Map.Entry&lt;Class&lt;?&gt;, Integer&gt;&gt; getRegisteredComponentIds() {&#10;        return componentTypeIds.entrySet();&#10;    }&#10;&#10;    /**&#10;     * Ly ComponentDescriptor trc tip bng Type ID (O(1)).&#10;     */&#10;    public ComponentDescriptor getDescriptor(int typeId) {&#10;        return idToDescriptorMap.get(typeId);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Method;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    // Thread-safe registries&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;    // [THM VO] Map ID -&gt; Descriptor  tra cu O(1) theo typeId&#10;    private final ConcurrentHashMap&lt;Integer, ComponentDescriptor&gt; idToDescriptorMap = new ConcurrentHashMap&lt;&gt;();&#10;    private final AtomicInteger nextTypeId = new AtomicInteger(0);&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    // Typed handle pools keyed by component class, used by AP-generated code for PositionHandle, etc.&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, HandlePool&lt;? extends IBindableHandle&gt;&gt; typedHandlePools = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Lightweight validation for shared component annotations&#10;        validateSharedAnnotations(componentClass);&#10;&#10;        // Assign a stable type id exactly once, even under races&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;&#10;        // Prefer generated descriptor if present; else build via reflection&#10;        descriptors.computeIfAbsent(componentClass, cls -&gt; {&#10;            ComponentDescriptor gen = tryLoadGeneratedDescriptor(cls);&#10;            ComponentDescriptor desc = gen != null ? gen : buildDescriptor(cls);&#10;            // Cp nht map ID -&gt; Descriptor cho lookup O(1)&#10;            idToDescriptorMap.put(typeId, desc);&#10;            return desc;&#10;        });&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Register a component class with a prebuilt descriptor (e.g., from generated meta).&#10;     * Thread-safe and idempotent: type id is assigned once; descriptor installed if absent.&#10;     */&#10;    public &lt;T&gt; int registerComponentWithDescriptor(Class&lt;T&gt; componentClass, ComponentDescriptor descriptor) {&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;        // Validate shared annotations even if descriptor is provided&#10;        validateSharedAnnotations(componentClass);&#10;&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;descriptor must not be null for &quot; + componentClass.getName());&#10;        }&#10;        descriptors.putIfAbsent(componentClass, descriptor);&#10;        // Cp nht c map ID -&gt; Descriptor (khng ghi  nu  c)&#10;        idToDescriptorMap.putIfAbsent(typeId, descriptor);&#10;        return typeId;&#10;    }&#10;&#10;    // High-level registration used by AP-generated code to install both descriptor and typed handle pool.&#10;    public &lt;T extends IBindableHandle&gt; void registerComponentWithHandle(&#10;        Class&lt;?&gt; componentClass,&#10;        ComponentDescriptor descriptor,&#10;        java.util.function.Supplier&lt;T&gt; handleFactory&#10;    ) {&#10;        int typeId = registerComponentWithDescriptor(componentClass, descriptor);&#10;        HandlePool&lt;T&gt; pool = new HandlePool&lt;&gt;(handleFactory);&#10;        typedHandlePools.put(componentClass, pool);&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Determine kind from annotations&#10;        ComponentDescriptor.ComponentKind kind = getComponentKind(componentClass);&#10;&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType, kind);&#10;    }&#10;&#10;    private static ComponentDescriptor.ComponentKind getComponentKind(Class&lt;?&gt; componentClass) {&#10;        boolean isManaged = componentClass.isAnnotationPresent(Component.Managed.class);&#10;        boolean isShared = componentClass.isAnnotationPresent(Component.Shared.class);&#10;        ComponentDescriptor.ComponentKind kind;&#10;        if (isShared) {&#10;            kind = isManaged ? ComponentDescriptor.ComponentKind.SHARED_MANAGED : ComponentDescriptor.ComponentKind.SHARED_UNMANAGED;&#10;        } else {&#10;            kind = isManaged ? ComponentDescriptor.ComponentKind.INSTANCE_MANAGED : ComponentDescriptor.ComponentKind.INSTANCE_UNMANAGED;&#10;        }&#10;        return kind;&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;&#10;    // Try to load a generated meta class &lt;FQN&gt; + &quot;Meta&quot; exposing DESCRIPTOR field or descriptor() method.&#10;    private ComponentDescriptor tryLoadGeneratedDescriptor(Class&lt;?&gt; componentClass) {&#10;        String metaName = componentClass.getName() + &quot;Meta&quot;;&#10;        try {&#10;            Class&lt;?&gt; meta = Class.forName(metaName, false, componentClass.getClassLoader());&#10;            try {&#10;                java.lang.reflect.Field f = meta.getField(&quot;DESCRIPTOR&quot;);&#10;                Object v = f.get(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchFieldException ignored) { }&#10;            try {&#10;                java.lang.reflect.Method m = meta.getMethod(&quot;descriptor&quot;);&#10;                Object v = m.invoke(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchMethodException ignored) { }&#10;        } catch (Throwable ignored) {&#10;            // not generated/present&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Lightweight validation for shared component annotations.&#10;     * or setters (1-arg int/long, returns void).&#10;     */&#10;    private void validateSharedAnnotations(Class&lt;?&gt; cls) {&#10;        boolean hasShared = cls.isAnnotationPresent(Component.Shared.class);&#10;        boolean hasManaged = cls.isAnnotationPresent(Component.Managed.class);&#10;&#10;        if (!hasShared) return; // nothing to validate&#10;&#10;        // Managed-shared: @Shared + @Managed must be a class overriding equals/hashCode&#10;        if (hasManaged) {&#10;            if (cls.isInterface()) {&#10;                throw new IllegalArgumentException(&quot;@Shared (managed) must be placed on a class, not an interface: &quot; + cls.getName());&#10;            }&#10;            try {&#10;                Method eq = cls.getMethod(&quot;equals&quot;, Object.class);&#10;                if (eq.getDeclaringClass() == Object.class) throw new NoSuchMethodException();&#10;            } catch (NoSuchMethodException e) {&#10;                throw new IllegalArgumentException(&quot;Class &quot; + cls.getName() + &quot; is annotated @Shared but does not override equals(Object)&quot;);&#10;            }&#10;            try {&#10;                Method hc = cls.getMethod(&quot;hashCode&quot;);&#10;                if (hc.getDeclaringClass() == Object.class) throw new NoSuchMethodException();&#10;            } catch (NoSuchMethodException e) {&#10;                throw new IllegalArgumentException(&quot;Class &quot; + cls.getName() + &quot; is annotated @Shared but does not override hashCode()&quot;);&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Unmanaged-shared: @Shared without @Managed must be an class with at least one field (primitive types)&#10;        if (cls.isInterface()) {&#10;            throw new IllegalArgumentException(&quot;@Shared (unmanaged) must be placed on a class, not an interface: &quot; + cls.getName());&#10;        }&#10;        Field[] fields = cls.getDeclaredFields();&#10;        if (fields.length == 0) {&#10;            throw new IllegalArgumentException(&quot;Class &quot; + cls.getName() + &quot; is annotated @Shared but has no fields&quot;);&#10;        }&#10;&#10;        for( Field f : fields) {&#10;            Class&lt;?&gt; t = f.getType();&#10;            if (!(t == int.class || t == long.class || t == float.class || t == double.class || t == boolean.class)) {&#10;                throw new IllegalArgumentException(&quot;Field &quot; + f.getName() + &quot; in @Shared unmanaged component &quot; + cls.getName() +&#10;                    &quot; has unsupported type &quot; + t.getName() + &quot;. Only primitive types are allowed.&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Acquire a typed handle instance from the pool for the given component class.&#10;    public IBindableHandle acquireTypedHandle(Class&lt;?&gt; componentClass) {&#10;        HandlePool&lt;?&gt; pool = typedHandlePools.get(componentClass);&#10;        if (pool == null) {&#10;            throw new IllegalArgumentException(&quot;No typed handle pool registered for component: &quot; + componentClass.getName());&#10;        }&#10;        return pool.acquire();&#10;    }&#10;&#10;    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})&#10;    public void releaseTypedHandle(Class&lt;?&gt; componentClass, IBindableHandle handle) {&#10;        HandlePool pool = typedHandlePools.get(componentClass);&#10;        if (pool != null) {&#10;            pool.release(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Returns an unmodifiable view of the registered component-&gt;id mapping.&#10;     * This allows external clients (e.g., ArchetypeWorld) to resolve ids back to classes&#10;     * without duplicating ID ownership.&#10;     */&#10;    public Set&lt;Map.Entry&lt;Class&lt;?&gt;, Integer&gt;&gt; getRegisteredComponentIds() {&#10;        return componentTypeIds.entrySet();&#10;    }&#10;&#10;    /**&#10;     * Ly ComponentDescriptor trc tip bng Type ID (O(1)).&#10;     */&#10;    public ComponentDescriptor getDescriptor(int typeId) {&#10;        return idToDescriptorMap.get(typeId);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/SharedComponentStore.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/SharedComponentStore.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Objects;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;&#10;/**&#10; * Thread-safe store for de-duplicating managed shared component values.&#10; * It maps a value to a stable index with reference counting.&#10; */&#10;public final class SharedComponentStore {&#10;    private final ConcurrentHashMap&lt;Object, Integer&gt; valueToIndex = new ConcurrentHashMap&lt;&gt;();&#10;    private final ArrayList&lt;Object&gt; indexToValue = new ArrayList&lt;&gt;();&#10;    private volatile int[] refCounts = new int[16];&#10;    private final ConcurrentLinkedQueue&lt;Integer&gt; freeIndices = new ConcurrentLinkedQueue&lt;&gt;();&#10;&#10;    private final Object resizeLock = new Object();&#10;&#10;    /**&#10;     * Get or add an index for the provided value. If value already exists, its refCount is incremented atomically.&#10;     * If it's a new value, a new or recycled index is created, stored, and refCount set to 1.&#10;     */&#10;    public int getOrAddSharedIndex(Object value) {&#10;        Objects.requireNonNull(value, &quot;value&quot;);&#10;        return valueToIndex.compute(value, (k, existingIdx) -&gt; {&#10;            synchronized (resizeLock) {&#10;                if (existingIdx == null) {&#10;                    Integer reuse = freeIndices.poll();&#10;                    int index;&#10;                    if (reuse != null) {&#10;                        index = reuse;&#10;                        ensureRefCapacity(index + 1);&#10;                        if (index &lt; indexToValue.size()) {&#10;                            indexToValue.set(index, k);&#10;                        } else {&#10;                            while (indexToValue.size() &lt; index) indexToValue.add(null);&#10;                            indexToValue.add(k);&#10;                        }&#10;                    } else {&#10;                        index = indexToValue.size();&#10;                        indexToValue.add(k);&#10;                        ensureRefCapacity(index + 1);&#10;                    }&#10;                    refCounts[index] = 1;&#10;                    return index;&#10;                } else {&#10;                    int idx = existingIdx;&#10;                    ensureRefCapacity(idx + 1);&#10;                    refCounts[idx]++;&#10;                    return idx;&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Release a previously acquired shared index. When refCount reaches zero, the value is removed and index recycled.&#10;     */&#10;    public void releaseSharedIndex(int index) {&#10;        synchronized (resizeLock) {&#10;            if (index &lt; 0 || index &gt;= indexToValue.size()) return;&#10;            Object value = indexToValue.get(index);&#10;            if (value == null) return; // already removed&#10;            int rc = --refCounts[index];&#10;            if (rc &gt; 0) return;&#10;            // remove entry and mapping&#10;            indexToValue.set(index, null);&#10;            valueToIndex.remove(value, index);&#10;            // advertise recycled index&#10;            freeIndices.offer(index);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find existing index for a value without creating a new entry or changing ref counts. Returns -1 if absent.&#10;     */&#10;    public int findIndex(Object value) {&#10;        Integer idx = valueToIndex.get(value);&#10;        return idx != null ? idx : -1;&#10;    }&#10;&#10;    private void ensureRefCapacity(int min) {&#10;        int[] cur = refCounts;&#10;        if (min &lt;= cur.length) return;&#10;        int newLen = Math.max(min, Math.max(16, cur.length &lt;&lt; 1));&#10;        int[] next = new int[newLen];&#10;        System.arraycopy(cur, 0, next, 0, cur.length);&#10;        refCounts = next;&#10;    }&#10;&#10;    // Testing/helpers&#10;    public Object getValue(int index) {&#10;        synchronized (resizeLock) {&#10;            return (index &gt;= 0 &amp;&amp; index &lt; indexToValue.size()) ? indexToValue.get(index) : null;&#10;        }&#10;    }&#10;&#10;    public int getRefCount(int index) {&#10;        synchronized (resizeLock) {&#10;            return (index &gt;= 0 &amp;&amp; index &lt; indexToValue.size()) ? refCounts[index] : 0;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Objects;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;&#10;/**&#10; * Thread-safe store for de-duplicating managed shared component values.&#10; * It maps a value to a stable index with reference counting.&#10; */&#10;public final class SharedComponentStore {&#10;    private final ConcurrentHashMap&lt;Object, Integer&gt; valueToIndex = new ConcurrentHashMap&lt;&gt;();&#10;    private final ArrayList&lt;Object&gt; indexToValue = new ArrayList&lt;&gt;();&#10;    private volatile int[] refCounts = new int[16];&#10;    private final ConcurrentLinkedQueue&lt;Integer&gt; freeIndices = new ConcurrentLinkedQueue&lt;&gt;();&#10;&#10;    private final Object resizeLock = new Object();&#10;&#10;    /**&#10;     * Get or add an index for the provided value. If value already exists, its refCount is incremented atomically.&#10;     * If it's a new value, a new or recycled index is created, stored, and refCount set to 1.&#10;     */&#10;    public int getOrAddSharedIndex(Object value) {&#10;        Objects.requireNonNull(value, &quot;value&quot;);&#10;        return valueToIndex.compute(value, (k, existingIdx) -&gt; {&#10;            synchronized (resizeLock) {&#10;                if (existingIdx == null) {&#10;                    Integer reuse = freeIndices.poll();&#10;                    int index;&#10;                    if (reuse != null) {&#10;                        index = reuse;&#10;                        ensureRefCapacity(index + 1);&#10;                        if (index &lt; indexToValue.size()) {&#10;                            indexToValue.set(index, k);&#10;                        } else {&#10;                            while (indexToValue.size() &lt; index) indexToValue.add(null);&#10;                            indexToValue.add(k);&#10;                        }&#10;                    } else {&#10;                        index = indexToValue.size();&#10;                        indexToValue.add(k);&#10;                        ensureRefCapacity(index + 1);&#10;                    }&#10;                    refCounts[index] = 1;&#10;                    return index;&#10;                } else {&#10;                    int idx = existingIdx;&#10;                    ensureRefCapacity(idx + 1);&#10;                    refCounts[idx]++;&#10;                    return idx;&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Release a previously acquired shared index. When refCount reaches zero, the value is removed and index recycled.&#10;     */&#10;    public void releaseSharedIndex(int index) {&#10;        synchronized (resizeLock) {&#10;            if (index &lt; 0 || index &gt;= indexToValue.size()) return;&#10;            Object value = indexToValue.get(index);&#10;            if (value == null) return; // already removed&#10;            int rc = --refCounts[index];&#10;            if (rc &gt; 0) return;&#10;            // remove entry and mapping&#10;            indexToValue.set(index, null);&#10;            valueToIndex.remove(value, index);&#10;            // advertise recycled index&#10;            freeIndices.offer(index);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find existing index for a value without creating a new entry or changing ref counts. Returns -1 if absent.&#10;     */&#10;    public int findIndex(Object value) {&#10;        Integer idx = valueToIndex.get(value);&#10;        return idx != null ? idx : -1;&#10;    }&#10;&#10;    private void ensureRefCapacity(int min) {&#10;        int[] cur = refCounts;&#10;        if (min &lt;= cur.length) return;&#10;        int newLen = Math.max(min, Math.max(16, cur.length &lt;&lt; 1));&#10;        int[] next = new int[newLen];&#10;        System.arraycopy(cur, 0, next, 0, cur.length);&#10;        refCounts = next;&#10;    }&#10;&#10;    // Testing/helpers&#10;    public Object getValue(int index) {&#10;        synchronized (resizeLock) {&#10;            return (index &gt;= 0 &amp;&amp; index &lt; indexToValue.size()) ? indexToValue.get(index) : null;&#10;        }&#10;    }&#10;&#10;    public int getRefCount(int index) {&#10;        synchronized (resizeLock) {&#10;            return (index &gt;= 0 &amp;&amp; index &lt; indexToValue.size()) ? refCounts[index] : 0;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/SystemManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/SystemManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.system;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Manages ECS Systems and delegates dependency injection to generated code.&#10; * &lt;p&gt;&#10; * The SystemManager is responsible for:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Registering systems&lt;/li&gt;&#10; *   &lt;li&gt;Invoking the annotation-processor generated injector for each system&lt;/li&gt;&#10; *   &lt;li&gt;Relying solely on compile-time validated injection logic&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; * &lt;p&gt;&#10; * All legacy reflection/Proxy-based query injection has been removed in favor of&#10; * the AP-generated injectors (see {@code QueryProcessor}).&#10; */&#10;public class SystemManager {&#10;    private final ArchetypeWorld world;&#10;    private final List&lt;Object&gt; registeredSystems;&#10;&#10;    public SystemManager(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.registeredSystems = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    /**&#10;     * Register a system and inject its dependencies via the generated injector.&#10;     * &lt;p&gt;&#10;     * This will attempt to locate a class named&#10;     * {@code &lt;SystemBinaryName&gt;__QueryInjector} or&#10;     * {@code &lt;SystemPackage&gt;.&lt;SimpleName&gt;__QueryInjector} and invoke its static&#10;     * {@code inject(Object, ArchetypeWorld)} method.&#10;     */&#10;    public &lt;T&gt; T registerSystem(T system) {&#10;        if (system == null) {&#10;            throw new IllegalArgumentException(&quot;System cannot be null&quot;);&#10;        }&#10;        tryInvokeGeneratedInjector(system);&#10;        registeredSystems.add(system);&#10;        return system;&#10;    }&#10;&#10;    private void tryInvokeGeneratedInjector(Object system) {&#10;        Class&lt;?&gt; cls = system.getClass();&#10;        String injectorName1 = cls.getName() + &quot;__QueryInjector&quot;;&#10;        String injectorName2 = cls.getPackageName() + &quot;.&quot; + cls.getSimpleName() + &quot;__QueryInjector&quot;;&#10;        ReflectiveOperationException last = null;&#10;        for (String injectorName : new String[]{ injectorName1, injectorName2 }) {&#10;            try {&#10;                Class&lt;?&gt; inj = Class.forName(injectorName, false, cls.getClassLoader());&#10;                java.lang.reflect.Method m = inj.getMethod(&quot;inject&quot;, Object.class, com.ethnicthv.ecs.core.archetype.ArchetypeWorld.class);&#10;                m.invoke(null, system, world);&#10;                return; // success&#10;            } catch (ClassNotFoundException e) {&#10;                last = e; // try next variant&#10;            } catch (ReflectiveOperationException e) {&#10;                last = e;&#10;                break; // found class but failed to invoke&#10;            }&#10;        }&#10;        if (!(last instanceof ClassNotFoundException)) {&#10;            throw new IllegalStateException(&quot;Failed to invoke generated injector for &quot; + cls.getName(), last);&#10;        }&#10;        // If no injector class is found, we silently skip injection to keep&#10;        // non-annotated systems working.&#10;    }&#10;&#10;    public List&lt;Object&gt; getRegisteredSystems() {&#10;        return new ArrayList&lt;&gt;(registeredSystems);&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.system;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Manages ECS Systems and delegates dependency injection to generated code.&#10; * &lt;p&gt;&#10; * The SystemManager is responsible for:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Registering systems&lt;/li&gt;&#10; *   &lt;li&gt;Invoking the annotation-processor generated injector for each system&lt;/li&gt;&#10; *   &lt;li&gt;Relying solely on compile-time validated injection logic&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; * &lt;p&gt;&#10; * All legacy reflection/Proxy-based query injection has been removed in favor of&#10; * the AP-generated injectors (see {@code QueryProcessor}).&#10; */&#10;public class SystemManager {&#10;    private final ArchetypeWorld world;&#10;    private final List&lt;Object&gt; registeredSystems;&#10;&#10;    public SystemManager(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.registeredSystems = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    /**&#10;     * Register a system and inject its dependencies via the generated injector.&#10;     * &lt;p&gt;&#10;     * This will attempt to locate a class named&#10;     * {@code &lt;SystemBinaryName&gt;__QueryInjector} or&#10;     * {@code &lt;SystemPackage&gt;.&lt;SimpleName&gt;__QueryInjector} and invoke its static&#10;     * {@code inject(Object, ArchetypeWorld)} method.&#10;     */&#10;    public &lt;T&gt; T registerSystem(T system) {&#10;        if (system == null) {&#10;            throw new IllegalArgumentException(&quot;System cannot be null&quot;);&#10;        }&#10;        tryInvokeGeneratedInjector(system);&#10;        registeredSystems.add(system);&#10;        return system;&#10;    }&#10;&#10;    private void tryInvokeGeneratedInjector(Object system) {&#10;        Class&lt;?&gt; cls = system.getClass();&#10;        String injectorName1 = cls.getName() + &quot;__QueryInjector&quot;;&#10;        String injectorName2 = cls.getPackageName() + &quot;.&quot; + cls.getSimpleName() + &quot;__QueryInjector&quot;;&#10;        ReflectiveOperationException last = null;&#10;        for (String injectorName : new String[]{ injectorName1, injectorName2 }) {&#10;            try {&#10;                Class&lt;?&gt; inj = Class.forName(injectorName, false, cls.getClassLoader());&#10;                java.lang.reflect.Method m = inj.getMethod(&quot;inject&quot;, Object.class, com.ethnicthv.ecs.core.archetype.ArchetypeWorld.class);&#10;                m.invoke(null, system, world);&#10;                return; // success&#10;            } catch (ClassNotFoundException e) {&#10;                last = e; // try next variant&#10;            } catch (ReflectiveOperationException e) {&#10;                last = e;&#10;                break; // found class but failed to invoke&#10;            }&#10;        }&#10;        if (!(last instanceof ClassNotFoundException)) {&#10;            throw new IllegalStateException(&quot;Failed to invoke generated injector for &quot; + cls.getName(), last);&#10;        }&#10;        // If no injector class is found, we silently skip injection to keep&#10;        // non-annotated systems working.&#10;    }&#10;&#10;    public List&lt;Object&gt; getRegisteredSystems() {&#10;        return new ArrayList&lt;&gt;(registeredSystems);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/annotation/Id.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/annotation/Id.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.system.annotation;&#10;&#10;import java.lang.annotation.ElementType;&#10;import java.lang.annotation.Retention;&#10;import java.lang.annotation.RetentionPolicy;&#10;import java.lang.annotation.Target;&#10;&#10;/**&#10; * Marks a system field or parameter to receive the current entity id during a query run.&#10; * Constraints: at most one per @Query method and it must be of type int (or Integer for parameters).&#10; */&#10;@Retention(RetentionPolicy.RUNTIME)&#10;@Target({ElementType.FIELD, ElementType.PARAMETER})&#10;public @interface Id {&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.system.annotation;&#10;&#10;import java.lang.annotation.ElementType;&#10;import java.lang.annotation.Retention;&#10;import java.lang.annotation.RetentionPolicy;&#10;import java.lang.annotation.Target;&#10;&#10;/**&#10; * Marks a system field or parameter to receive the current entity id during a query run.&#10; * Constraints: at most one per @Query method and it must be of type int (or Integer for parameters).&#10; */&#10;@Retention(RetentionPolicy.RUNTIME)&#10;@Target({ElementType.FIELD, ElementType.PARAMETER})&#10;public @interface Id {&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeChunkTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeChunkTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Comprehensive tests for ArchetypeChunk&#10; */&#10;public class ArchetypeChunkTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private long[] elementSizes;&#10;    private static final int DEFAULT_CAPACITY = 64;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        elementSizes = new long[]{16, 8};&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        // Don't close shared arena - it may be used across tests&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testChunkInitialization() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(DEFAULT_CAPACITY, chunk.capacity());&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertTrue(chunk.hasFree());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateSingleSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertTrue(slot &gt;= 0 &amp;&amp; slot &lt; DEFAULT_CAPACITY);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.isEmpty());&#10;        assertEquals(100, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateMultipleSlots() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int slot = chunk.allocateSlot(1000 + i);&#10;            assertTrue(slot &gt;= 0);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slots should be unique&quot;);&#10;            assertEquals(1000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(10, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateUpToCapacity() {&#10;        int capacity = 16;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            int slot = chunk.allocateSlot(i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot &quot; + i);&#10;        }&#10;&#10;        assertEquals(capacity, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        // Try to allocate one more - should fail&#10;        int extraSlot = chunk.allocateSlot(999);&#10;        assertEquals(-1, extraSlot, &quot;Should not allocate beyond capacity&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testFreeSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertEquals(-1, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateFreeAllocate() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate&#10;        int slot1 = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        // Free&#10;        chunk.freeSlot(slot1);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Allocate again - might reuse same slot&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertTrue(slot2 &gt;= 0);&#10;        assertEquals(1, chunk.size());&#10;        assertEquals(200, chunk.getEntityId(slot2));&#10;    }&#10;&#10;    @Test&#10;    void testDoubleFree() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Double free should be safe&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testGetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Get component data for component 0&#10;        MemorySegment data = chunk.getComponentData(0, slot);&#10;        assertNotNull(data);&#10;        assertEquals(16, data.byteSize());&#10;&#10;        // Get component data for component 1&#10;        MemorySegment data2 = chunk.getComponentData(1, slot);&#10;        assertNotNull(data2);&#10;        assertEquals(8, data2.byteSize());&#10;    }&#10;&#10;    @Test&#10;    void testSetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Create test data&#10;        MemorySegment testData = arena.allocate(16);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 12345L);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 8, 67890L);&#10;&#10;        // Set component data&#10;        chunk.setComponentData(0, slot, testData);&#10;&#10;        // Retrieve and verify&#10;        MemorySegment retrieved = chunk.getComponentData(0, slot);&#10;        assertEquals(12345L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;        assertEquals(67890L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 8));&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate some slots&#10;        chunk.allocateSlot(100);&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;&#10;        // Find first occupied&#10;        int first = chunk.nextOccupiedIndex(0);&#10;        assertTrue(first &gt;= 0);&#10;        assertNotEquals(-1, chunk.getEntityId(first));&#10;&#10;        // Find next after first&#10;        int second = chunk.nextOccupiedIndex(first + 1);&#10;        assertTrue(second &gt; first);&#10;        assertNotEquals(-1, chunk.getEntityId(second));&#10;&#10;        // Count all occupied&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndexWithGaps() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate several slots&#10;        int[] slots = new int[5];&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            slots[i] = chunk.allocateSlot(100 + i);&#10;        }&#10;&#10;        // Free some to create gaps&#10;        chunk.freeSlot(slots[1]);&#10;        chunk.freeSlot(slots[3]);&#10;&#10;        // Count occupied (should be 3)&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            assertNotEquals(-1, chunk.getEntityId(idx), &quot;Occupied slot should have valid entity ID&quot;);&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testQueueingMechanism() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Initially not queued&#10;        assertTrue(chunk.tryMarkQueued());&#10;&#10;        // Should fail second time&#10;        assertFalse(chunk.tryMarkQueued());&#10;&#10;        // Mark dequeued&#10;        chunk.markDequeued();&#10;&#10;        // Should succeed again&#10;        assertTrue(chunk.tryMarkQueued());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations() throws InterruptedException {&#10;        int capacity = 128;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 4;&#10;        int allocationsPerThread = capacity / threads;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * allocationsPerThread;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; allocationsPerThread; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(10, TimeUnit.SECONDS), &quot;Timed out waiting for allocations to complete&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        assertEquals(capacity, successCount.get());&#10;        assertEquals(capacity, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocateAndFree() throws InterruptedException {&#10;        int capacity = 256;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int operations = 1000;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operations;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; operations; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                // Free every other allocation&#10;                                if (i % 2 == 0) {&#10;                                    chunk.freeSlot(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for concurrent operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        // Size should be reasonable (between 0 and capacity)&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity,&#10;                &quot;Final size &quot; + finalSize + &quot; should be in [0, &quot; + capacity + &quot;]&quot;);&#10;&#10;        // All occupied slots should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSlotDataIsZeroedOnAllocation() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate a slot and set some data&#10;        int slot1 = chunk.allocateSlot(100);&#10;        MemorySegment data1 = chunk.getComponentData(0, slot1);&#10;        data1.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 0xDEADBEEFL);&#10;&#10;        // Free the slot&#10;        chunk.freeSlot(slot1);&#10;&#10;        // Allocate again (might get the same slot)&#10;        int slot2 = chunk.allocateSlot(200);&#10;        MemorySegment data2 = chunk.getComponentData(0, slot2);&#10;&#10;        // Data should be zeroed&#10;        assertEquals(0L, data2.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidComponentIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(-1, slot));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(descriptors.length, slot));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidElementIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, -1));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, DEFAULT_CAPACITY));&#10;    }&#10;&#10;    @Test&#10;    void testZeroCapacityChunk() {&#10;        // Zero capacity should throw IllegalArgumentException because bytes = elementSize * 0 = 0&#10;        assertThrows(IllegalArgumentException.class, () -&gt;&#10;                new ArchetypeChunk(descriptors, elementSizes, 0, arena)&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testLargeScaleAllocations_1000Entities() {&#10;        int capacity = 1024;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        // Allocate 1000 entities&#10;        int entityCount = 1000;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            int slot = chunk.allocateSlot(10000 + i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot for entity &quot; + i);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slot should be unique&quot;);&#10;            assertEquals(10000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(entityCount, chunk.size());&#10;        assertEquals(entityCount, allocatedSlots.size());&#10;&#10;        // Verify all allocated entities are accessible&#10;        int verifiedCount = 0;&#10;        for (int slot : allocatedSlots) {&#10;            int entityId = chunk.getEntityId(slot);&#10;            assertTrue(entityId &gt;= 10000 &amp;&amp; entityId &lt; 10000 + entityCount);&#10;            verifiedCount++;&#10;        }&#10;        assertEquals(entityCount, verifiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScaleAllocationsAndFrees_5000Operations() {&#10;        int capacity = 2048;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        // Perform 5000 mixed allocate/free operations&#10;        Set&lt;Integer&gt; activeSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 5000; i++) {&#10;            if (i % 3 == 0 &amp;&amp; !activeSlots.isEmpty()) {&#10;                // Free a random slot&#10;                Integer slotToFree = activeSlots.iterator().next();&#10;                chunk.freeSlot(slotToFree);&#10;                activeSlots.remove(slotToFree);&#10;            } else {&#10;                // Allocate new slot&#10;                int slot = chunk.allocateSlot(20000 + i);&#10;                if (slot &gt;= 0) {&#10;                    activeSlots.add(slot);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Verify chunk consistency&#10;        assertEquals(activeSlots.size(), chunk.size());&#10;&#10;        // Verify all active slots have valid entity IDs&#10;        for (int slot : activeSlots) {&#10;            int entityId = chunk.getEntityId(slot);&#10;            assertNotEquals(-1, entityId, &quot;Active slot should have valid entity ID&quot;);&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations_10000Entities() throws InterruptedException {&#10;        int capacity = 10240;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int entitiesPerThread = 1250; // 8 * 1250 = 10000&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        Set&lt;Integer&gt; allEntityIds = ConcurrentHashMap.newKeySet();&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * entitiesPerThread + 30000;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; entitiesPerThread; i++) {&#10;                            int entityId = baseId + i;&#10;                            int slot = chunk.allocateSlot(entityId);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                                allEntityIds.add(entityId);&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for allocations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;        }&#10;&#10;        assertEquals(10000, successCount.get(), &quot;Should successfully allocate 10000 entities&quot;);&#10;        assertEquals(10000, allEntityIds.size(), &quot;All entity IDs should be unique&quot;);&#10;        assertEquals(10000, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentChurn_20000Operations() throws InterruptedException {&#10;        int capacity = 4096;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 10;&#10;        int operationsPerThread = 2000; // 10 * 2000 = 20000&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operationsPerThread + 40000;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        Set&lt;Integer&gt; mySlots = new HashSet&lt;&gt;();&#10;                        for (int i = 0; i &lt; operationsPerThread; i++) {&#10;                            if (i % 4 == 0 &amp;&amp; !mySlots.isEmpty()) {&#10;                                // Free one of our slots&#10;                                Integer slot = mySlots.iterator().next();&#10;                                chunk.freeSlot(slot);&#10;                                mySlots.remove(slot);&#10;                            } else {&#10;                                // Allocate new&#10;                                int slot = chunk.allocateSlot(baseId + i);&#10;                                if (slot &gt;= 0) {&#10;                                    mySlots.add(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                        // Clean up our remaining slots&#10;                        for (int slot : mySlots) {&#10;                            chunk.freeSlot(slot);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(60, TimeUnit.SECONDS), &quot;Timed out waiting for operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;        }&#10;&#10;        // After all threads clean up, chunk should be empty or have very few entities&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity);&#10;&#10;        // All slots marked as occupied should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSingleSlotCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, 1, arena);&#10;&#10;        assertEquals(1, chunk.capacity());&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(0, slot);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertEquals(-1, slot2);&#10;&#10;        chunk.freeSlot(slot);&#10;        assertTrue(chunk.hasFree());&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testArenaAccess() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertNotNull(chunk.getArena());&#10;        assertEquals(arena, chunk.getArena());&#10;    }&#10;&#10;    @Test&#10;    void testGetEntityCount() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(0, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;        assertEquals(3, chunk.getEntityCount());&#10;    }&#10;&#10;    @Test&#10;    void testGetCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertEquals(DEFAULT_CAPACITY, chunk.getCapacity());&#10;    }&#10;&#10;    // Test component classes&#10;    static final class TestComponent1 {&#10;    }&#10;&#10;    static final class TestComponent2 {&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Comprehensive tests for ArchetypeChunk&#10; */&#10;public class ArchetypeChunkTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private long[] elementSizes;&#10;    private static final int DEFAULT_CAPACITY = 64;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        elementSizes = new long[]{16, 8};&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        // Don't close shared arena - it may be used across tests&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testChunkInitialization() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(DEFAULT_CAPACITY, chunk.capacity());&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertTrue(chunk.hasFree());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateSingleSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertTrue(slot &gt;= 0 &amp;&amp; slot &lt; DEFAULT_CAPACITY);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.isEmpty());&#10;        assertEquals(100, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateMultipleSlots() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int slot = chunk.allocateSlot(1000 + i);&#10;            assertTrue(slot &gt;= 0);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slots should be unique&quot;);&#10;            assertEquals(1000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(10, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateUpToCapacity() {&#10;        int capacity = 16;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            int slot = chunk.allocateSlot(i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot &quot; + i);&#10;        }&#10;&#10;        assertEquals(capacity, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        // Try to allocate one more - should fail&#10;        int extraSlot = chunk.allocateSlot(999);&#10;        assertEquals(-1, extraSlot, &quot;Should not allocate beyond capacity&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testFreeSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertEquals(-1, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateFreeAllocate() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate&#10;        int slot1 = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        // Free&#10;        chunk.freeSlot(slot1);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Allocate again - might reuse same slot&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertTrue(slot2 &gt;= 0);&#10;        assertEquals(1, chunk.size());&#10;        assertEquals(200, chunk.getEntityId(slot2));&#10;    }&#10;&#10;    @Test&#10;    void testDoubleFree() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Double free should be safe&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testGetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Get component data for component 0&#10;        MemorySegment data = chunk.getComponentData(0, slot);&#10;        assertNotNull(data);&#10;        assertEquals(16, data.byteSize());&#10;&#10;        // Get component data for component 1&#10;        MemorySegment data2 = chunk.getComponentData(1, slot);&#10;        assertNotNull(data2);&#10;        assertEquals(8, data2.byteSize());&#10;    }&#10;&#10;    @Test&#10;    void testSetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Create test data&#10;        MemorySegment testData = arena.allocate(16);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 12345L);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 8, 67890L);&#10;&#10;        // Set component data&#10;        chunk.setComponentData(0, slot, testData);&#10;&#10;        // Retrieve and verify&#10;        MemorySegment retrieved = chunk.getComponentData(0, slot);&#10;        assertEquals(12345L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;        assertEquals(67890L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 8));&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate some slots&#10;        chunk.allocateSlot(100);&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;&#10;        // Find first occupied&#10;        int first = chunk.nextOccupiedIndex(0);&#10;        assertTrue(first &gt;= 0);&#10;        assertNotEquals(-1, chunk.getEntityId(first));&#10;&#10;        // Find next after first&#10;        int second = chunk.nextOccupiedIndex(first + 1);&#10;        assertTrue(second &gt; first);&#10;        assertNotEquals(-1, chunk.getEntityId(second));&#10;&#10;        // Count all occupied&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndexWithGaps() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate several slots&#10;        int[] slots = new int[5];&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            slots[i] = chunk.allocateSlot(100 + i);&#10;        }&#10;&#10;        // Free some to create gaps&#10;        chunk.freeSlot(slots[1]);&#10;        chunk.freeSlot(slots[3]);&#10;&#10;        // Count occupied (should be 3)&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            assertNotEquals(-1, chunk.getEntityId(idx), &quot;Occupied slot should have valid entity ID&quot;);&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testQueueingMechanism() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Initially not queued&#10;        assertTrue(chunk.tryMarkQueued());&#10;&#10;        // Should fail second time&#10;        assertFalse(chunk.tryMarkQueued());&#10;&#10;        // Mark dequeued&#10;        chunk.markDequeued();&#10;&#10;        // Should succeed again&#10;        assertTrue(chunk.tryMarkQueued());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations() throws InterruptedException {&#10;        int capacity = 128;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 4;&#10;        int allocationsPerThread = capacity / threads;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * allocationsPerThread;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; allocationsPerThread; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(10, TimeUnit.SECONDS), &quot;Timed out waiting for allocations to complete&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        assertEquals(capacity, successCount.get());&#10;        assertEquals(capacity, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocateAndFree() throws InterruptedException {&#10;        int capacity = 256;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int operations = 1000;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operations;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; operations; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                // Free every other allocation&#10;                                if (i % 2 == 0) {&#10;                                    chunk.freeSlot(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for concurrent operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        // Size should be reasonable (between 0 and capacity)&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity,&#10;                &quot;Final size &quot; + finalSize + &quot; should be in [0, &quot; + capacity + &quot;]&quot;);&#10;&#10;        // All occupied slots should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSlotDataIsZeroedOnAllocation() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate a slot and set some data&#10;        int slot1 = chunk.allocateSlot(100);&#10;        MemorySegment data1 = chunk.getComponentData(0, slot1);&#10;        data1.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 0xDEADBEEFL);&#10;&#10;        // Free the slot&#10;        chunk.freeSlot(slot1);&#10;&#10;        // Allocate again (might get the same slot)&#10;        int slot2 = chunk.allocateSlot(200);&#10;        MemorySegment data2 = chunk.getComponentData(0, slot2);&#10;&#10;        // Data should be zeroed&#10;        assertEquals(0L, data2.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidComponentIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(-1, slot));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(descriptors.length, slot));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidElementIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, -1));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, DEFAULT_CAPACITY));&#10;    }&#10;&#10;    @Test&#10;    void testZeroCapacityChunk() {&#10;        // Zero capacity should throw IllegalArgumentException because bytes = elementSize * 0 = 0&#10;        assertThrows(IllegalArgumentException.class, () -&gt;&#10;                new ArchetypeChunk(descriptors, elementSizes, 0, arena)&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testLargeScaleAllocations_1000Entities() {&#10;        int capacity = 1024;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        // Allocate 1000 entities&#10;        int entityCount = 1000;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            int slot = chunk.allocateSlot(10000 + i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot for entity &quot; + i);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slot should be unique&quot;);&#10;            assertEquals(10000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(entityCount, chunk.size());&#10;        assertEquals(entityCount, allocatedSlots.size());&#10;&#10;        // Verify all allocated entities are accessible&#10;        int verifiedCount = 0;&#10;        for (int slot : allocatedSlots) {&#10;            int entityId = chunk.getEntityId(slot);&#10;            assertTrue(entityId &gt;= 10000 &amp;&amp; entityId &lt; 10000 + entityCount);&#10;            verifiedCount++;&#10;        }&#10;        assertEquals(entityCount, verifiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScaleAllocationsAndFrees_5000Operations() {&#10;        int capacity = 2048;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        // Perform 5000 mixed allocate/free operations&#10;        Set&lt;Integer&gt; activeSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 5000; i++) {&#10;            if (i % 3 == 0 &amp;&amp; !activeSlots.isEmpty()) {&#10;                // Free a random slot&#10;                Integer slotToFree = activeSlots.iterator().next();&#10;                chunk.freeSlot(slotToFree);&#10;                activeSlots.remove(slotToFree);&#10;            } else {&#10;                // Allocate new slot&#10;                int slot = chunk.allocateSlot(20000 + i);&#10;                if (slot &gt;= 0) {&#10;                    activeSlots.add(slot);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Verify chunk consistency&#10;        assertEquals(activeSlots.size(), chunk.size());&#10;&#10;        // Verify all active slots have valid entity IDs&#10;        for (int slot : activeSlots) {&#10;            int entityId = chunk.getEntityId(slot);&#10;            assertNotEquals(-1, entityId, &quot;Active slot should have valid entity ID&quot;);&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations_10000Entities() throws InterruptedException {&#10;        int capacity = 10240;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int entitiesPerThread = 1250; // 8 * 1250 = 10000&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        Set&lt;Integer&gt; allEntityIds = ConcurrentHashMap.newKeySet();&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * entitiesPerThread + 30000;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; entitiesPerThread; i++) {&#10;                            int entityId = baseId + i;&#10;                            int slot = chunk.allocateSlot(entityId);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                                allEntityIds.add(entityId);&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for allocations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;        }&#10;&#10;        assertEquals(10000, successCount.get(), &quot;Should successfully allocate 10000 entities&quot;);&#10;        assertEquals(10000, allEntityIds.size(), &quot;All entity IDs should be unique&quot;);&#10;        assertEquals(10000, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentChurn_20000Operations() throws InterruptedException {&#10;        int capacity = 4096;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 10;&#10;        int operationsPerThread = 2000; // 10 * 2000 = 20000&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operationsPerThread + 40000;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        Set&lt;Integer&gt; mySlots = new HashSet&lt;&gt;();&#10;                        for (int i = 0; i &lt; operationsPerThread; i++) {&#10;                            if (i % 4 == 0 &amp;&amp; !mySlots.isEmpty()) {&#10;                                // Free one of our slots&#10;                                Integer slot = mySlots.iterator().next();&#10;                                chunk.freeSlot(slot);&#10;                                mySlots.remove(slot);&#10;                            } else {&#10;                                // Allocate new&#10;                                int slot = chunk.allocateSlot(baseId + i);&#10;                                if (slot &gt;= 0) {&#10;                                    mySlots.add(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                        // Clean up our remaining slots&#10;                        for (int slot : mySlots) {&#10;                            chunk.freeSlot(slot);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(60, TimeUnit.SECONDS), &quot;Timed out waiting for operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;        }&#10;&#10;        // After all threads clean up, chunk should be empty or have very few entities&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity);&#10;&#10;        // All slots marked as occupied should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSingleSlotCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, 1, arena);&#10;&#10;        assertEquals(1, chunk.capacity());&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(0, slot);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertEquals(-1, slot2);&#10;&#10;        chunk.freeSlot(slot);&#10;        assertTrue(chunk.hasFree());&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testArenaAccess() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertNotNull(chunk.getArena());&#10;        assertEquals(arena, chunk.getArena());&#10;    }&#10;&#10;    @Test&#10;    void testGetEntityCount() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(0, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;        assertEquals(3, chunk.getEntityCount());&#10;    }&#10;&#10;    @Test&#10;    void testGetCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertEquals(DEFAULT_CAPACITY, chunk.getCapacity());&#10;    }&#10;&#10;    // Test component classes&#10;    static final class TestComponent1 {&#10;    }&#10;&#10;    static final class TestComponent2 {&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeDataIntegrityTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeDataIntegrityTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * QA/QC Test Suite: Data Integrity v Consistency&#10; * m bo tnh ton vn d liu trong mi trng hp&#10; */&#10;@DisplayName(&quot;QA/QC: Data Integrity Tests&quot;)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class ArchetypeDataIntegrityTest {&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;TC-DI-001: Data persistence across operations&quot;)&#10;    void testDataPersistence() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities with specific data&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i * 1000);&#10;            data.set(ValueLayout.JAVA_LONG, 8, (long) i * 2000);&#10;        }&#10;&#10;        // Verify all data persists&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            assertEquals((long) i * 1000, value1,&#10;                    &quot;First value corrupted for entity &quot; + i);&#10;            assertEquals((long) i * 2000, value2,&#10;                    &quot;Second value corrupted for entity &quot; + i);&#10;        }&#10;&#10;        System.out.println(&quot; Data persistence verified for 100 entities&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;TC-DI-002: Data isolation between entities&quot;)&#10;    void testDataIsolationBetweenEntities() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities with unique values&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i);&#10;            data.set(ValueLayout.JAVA_LONG, 8, (long) i * 10);&#10;        }&#10;&#10;        // Modify every other entity&#10;        for (int i = 0; i &lt; 50; i += 2) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, 99999L);&#10;        }&#10;&#10;        // Verify unmodified entities are intact&#10;        for (int i = 1; i &lt; 50; i += 2) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            assertEquals((long) i, value1, &quot;Entity &quot; + i + &quot; was corrupted&quot;);&#10;            assertEquals((long) i * 10, value2, &quot;Entity &quot; + i + &quot; was corrupted&quot;);&#10;        }&#10;&#10;        System.out.println(&quot; Data isolation verified between entities&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;TC-DI-003: Data consistency after removal&quot;)&#10;    void testDataConsistencyAfterRemoval() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i);&#10;        }&#10;&#10;        // Remove middle entities&#10;        for (int i = 25; i &lt; 75; i++) {&#10;            archetype.removeEntity(locations.get(i));&#10;        }&#10;&#10;        // Verify remaining entities' data&#10;        for (int i = 0; i &lt; 25; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value = data.get(ValueLayout.JAVA_LONG, 0);&#10;            assertEquals((long) i, value, &quot;Entity &quot; + i + &quot; corrupted after removal&quot;);&#10;        }&#10;&#10;        for (int i = 75; i &lt; 100; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value = data.get(ValueLayout.JAVA_LONG, 0);&#10;            assertEquals((long) i, value, &quot;Entity &quot; + i + &quot; corrupted after removal&quot;);&#10;        }&#10;&#10;        System.out.println(&quot; Data consistency maintained after entity removal&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;TC-DI-004: Multi-component data consistency&quot;)&#10;    void testMultiComponentDataConsistency() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(Component1.class, 8),&#10;                makeDesc(Component2.class, 16),&#10;                makeDesc(Component3.class, 32)&#10;        };&#10;        int[] componentIds = new int[]{1, 2, 3};&#10;        ComponentMask mask = new ComponentMask();&#10;        for (int id : componentIds) {&#10;            mask = mask.set(id);&#10;        }&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities with data in all components&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data1 = archetype.getComponentData(loc, 0);&#10;            MemorySegment data2 = archetype.getComponentData(loc, 1);&#10;            MemorySegment data3 = archetype.getComponentData(loc, 2);&#10;&#10;            data1.set(ValueLayout.JAVA_LONG, 0, (long) i * 1);&#10;            data2.set(ValueLayout.JAVA_LONG, 0, (long) i * 2);&#10;            data2.set(ValueLayout.JAVA_LONG, 8, (long) i * 3);&#10;            data3.set(ValueLayout.JAVA_LONG, 0, (long) i * 4);&#10;            data3.set(ValueLayout.JAVA_LONG, 8, (long) i * 5);&#10;            data3.set(ValueLayout.JAVA_LONG, 16, (long) i * 6);&#10;            data3.set(ValueLayout.JAVA_LONG, 24, (long) i * 7);&#10;        }&#10;&#10;        // Verify all components maintain data correctly&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            MemorySegment data1 = archetype.getComponentData(locations.get(i), 0);&#10;            MemorySegment data2 = archetype.getComponentData(locations.get(i), 1);&#10;            MemorySegment data3 = archetype.getComponentData(locations.get(i), 2);&#10;&#10;            assertEquals((long) i * 1, data1.get(ValueLayout.JAVA_LONG, 0));&#10;            assertEquals((long) i * 2, data2.get(ValueLayout.JAVA_LONG, 0));&#10;            assertEquals((long) i * 3, data2.get(ValueLayout.JAVA_LONG, 8));&#10;            assertEquals((long) i * 4, data3.get(ValueLayout.JAVA_LONG, 0));&#10;            assertEquals((long) i * 5, data3.get(ValueLayout.JAVA_LONG, 8));&#10;            assertEquals((long) i * 6, data3.get(ValueLayout.JAVA_LONG, 16));&#10;            assertEquals((long) i * 7, data3.get(ValueLayout.JAVA_LONG, 24));&#10;        }&#10;&#10;        System.out.println(&quot; Multi-component data consistency verified&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;TC-DI-005: Cross-chunk data integrity&quot;)&#10;    void testCrossChunkDataIntegrity() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int entitiesPerChunk = archetype.getEntitiesPerChunk();&#10;&#10;        // Add entities across multiple chunks&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        int totalEntities = entitiesPerChunk * 3 + 50; // 3+ chunks&#10;&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i);&#10;            data.set(ValueLayout.JAVA_LONG, 8, (long) i * 100);&#10;        }&#10;&#10;        assertTrue(archetype.getChunkCount() &gt;= 3, &quot;Should span multiple chunks&quot;);&#10;&#10;        // Verify data across all chunks&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            assertEquals((long) i, value1, &quot;Cross-chunk data corrupted at &quot; + i);&#10;            assertEquals((long) i * 100, value2, &quot;Cross-chunk data corrupted at &quot; + i);&#10;        }&#10;&#10;        System.out.printf(&quot; Cross-chunk integrity verified across %d chunks%n&quot;,&#10;                archetype.getChunkCount());&#10;    }&#10;&#10;    @Test&#10;    @Order(6)&#10;    @DisplayName(&quot;TC-DI-006: Archetype mask integrity&quot;)&#10;    void testArchetypeMaskIntegrity() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16),&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{5, 10};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(5);&#10;        mask = mask.set(10);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add many entities&#10;        for (int i = 0; i &lt; 1000; i++) {&#10;            archetype.addEntity(i);&#10;        }&#10;&#10;        // Verify mask remains consistent&#10;        ComponentMask retrievedMask = archetype.getMask();&#10;        assertTrue(retrievedMask.has(5), &quot;Component 5 should be set&quot;);&#10;        assertTrue(retrievedMask.has(10), &quot;Component 10 should be set&quot;);&#10;        assertFalse(retrievedMask.has(1), &quot;Component 1 should not be set&quot;);&#10;&#10;        // Verify component IDs&#10;        assertArrayEquals(componentIds, archetype.getComponentIds());&#10;&#10;        System.out.println(&quot; Archetype mask integrity maintained&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(7)&#10;    @DisplayName(&quot;TC-DI-007: Entity count accuracy&quot;)&#10;    void testEntityCountAccuracy() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        assertEquals(0, archetype.getEntityCount(), &quot;Initial count should be 0&quot;);&#10;&#10;        // Add entities&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            locations.add(archetype.addEntity(i));&#10;            assertEquals(i + 1, archetype.getEntityCount(),&#10;                    &quot;Count should match after adding entity &quot; + i);&#10;        }&#10;&#10;        // Remove entities&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            archetype.removeEntity(locations.get(i));&#10;            assertEquals(100 - i - 1, archetype.getEntityCount(),&#10;                    &quot;Count should match after removing entity &quot; + i);&#10;        }&#10;&#10;        System.out.println(&quot; Entity count accuracy verified through operations&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(8)&#10;    @DisplayName(&quot;TC-DI-008: No data corruption under stress&quot;)&#10;    void testNoDataCorruptionUnderStress() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        int testSize = 1000;&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;&#10;        // Add entities with checksums&#10;        for (int i = 0; i &lt; testSize; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            long checksum = (long) i * 12345 + 67890;&#10;            data.set(ValueLayout.JAVA_LONG, 0, checksum);&#10;            data.set(ValueLayout.JAVA_LONG, 8, ~checksum); // Inverted checksum&#10;        }&#10;&#10;        // Perform random operations&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            int idx = i % testSize;&#10;            MemorySegment data = archetype.getComponentData(locations.get(idx), 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, data.get(ValueLayout.JAVA_LONG, 0) + 1);&#10;        }&#10;&#10;        // Verify checksums&#10;        int corruptedCount = 0;&#10;        for (int i = 0; i &lt; testSize; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            long expectedBase = (long) i * 12345 + 67890;&#10;&#10;            // Account for modifications&#10;            if (i &lt; 100 &amp;&amp; value1 != expectedBase + 1) {&#10;                corruptedCount++;&#10;            } else if (i &gt;= 100 &amp;&amp; value1 != expectedBase) {&#10;                corruptedCount++;&#10;            }&#10;        }&#10;&#10;        assertEquals(0, corruptedCount, &quot;No data should be corrupted&quot;);&#10;        System.out.println(&quot; No corruption detected under stress testing&quot;);&#10;    }&#10;&#10;    // Test component classes&#10;    static class TestComponent {&#10;        long value1;&#10;        long value2;&#10;    }&#10;&#10;    static class Component1 {&#10;        long value;&#10;    }&#10;&#10;    static class Component2 {&#10;        long value1, value2;&#10;    }&#10;&#10;    static class Component3 {&#10;        long value1, value2, value3, value4;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * QA/QC Test Suite: Data Integrity v Consistency&#10; * m bo tnh ton vn d liu trong mi trng hp&#10; */&#10;@DisplayName(&quot;QA/QC: Data Integrity Tests&quot;)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class ArchetypeDataIntegrityTest {&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;TC-DI-001: Data persistence across operations&quot;)&#10;    void testDataPersistence() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities with specific data&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i * 1000);&#10;            data.set(ValueLayout.JAVA_LONG, 8, (long) i * 2000);&#10;        }&#10;&#10;        // Verify all data persists&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            assertEquals((long) i * 1000, value1,&#10;                    &quot;First value corrupted for entity &quot; + i);&#10;            assertEquals((long) i * 2000, value2,&#10;                    &quot;Second value corrupted for entity &quot; + i);&#10;        }&#10;&#10;        System.out.println(&quot; Data persistence verified for 100 entities&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;TC-DI-002: Data isolation between entities&quot;)&#10;    void testDataIsolationBetweenEntities() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities with unique values&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i);&#10;            data.set(ValueLayout.JAVA_LONG, 8, (long) i * 10);&#10;        }&#10;&#10;        // Modify every other entity&#10;        for (int i = 0; i &lt; 50; i += 2) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, 99999L);&#10;        }&#10;&#10;        // Verify unmodified entities are intact&#10;        for (int i = 1; i &lt; 50; i += 2) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            assertEquals((long) i, value1, &quot;Entity &quot; + i + &quot; was corrupted&quot;);&#10;            assertEquals((long) i * 10, value2, &quot;Entity &quot; + i + &quot; was corrupted&quot;);&#10;        }&#10;&#10;        System.out.println(&quot; Data isolation verified between entities&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;TC-DI-003: Data consistency after removal&quot;)&#10;    void testDataConsistencyAfterRemoval() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i);&#10;        }&#10;&#10;        // Remove middle entities&#10;        for (int i = 25; i &lt; 75; i++) {&#10;            archetype.removeEntity(locations.get(i));&#10;        }&#10;&#10;        // Verify remaining entities' data&#10;        for (int i = 0; i &lt; 25; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value = data.get(ValueLayout.JAVA_LONG, 0);&#10;            assertEquals((long) i, value, &quot;Entity &quot; + i + &quot; corrupted after removal&quot;);&#10;        }&#10;&#10;        for (int i = 75; i &lt; 100; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value = data.get(ValueLayout.JAVA_LONG, 0);&#10;            assertEquals((long) i, value, &quot;Entity &quot; + i + &quot; corrupted after removal&quot;);&#10;        }&#10;&#10;        System.out.println(&quot; Data consistency maintained after entity removal&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;TC-DI-004: Multi-component data consistency&quot;)&#10;    void testMultiComponentDataConsistency() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(Component1.class, 8),&#10;                makeDesc(Component2.class, 16),&#10;                makeDesc(Component3.class, 32)&#10;        };&#10;        int[] componentIds = new int[]{1, 2, 3};&#10;        ComponentMask mask = new ComponentMask();&#10;        for (int id : componentIds) {&#10;            mask = mask.set(id);&#10;        }&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities with data in all components&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data1 = archetype.getComponentData(loc, 0);&#10;            MemorySegment data2 = archetype.getComponentData(loc, 1);&#10;            MemorySegment data3 = archetype.getComponentData(loc, 2);&#10;&#10;            data1.set(ValueLayout.JAVA_LONG, 0, (long) i * 1);&#10;            data2.set(ValueLayout.JAVA_LONG, 0, (long) i * 2);&#10;            data2.set(ValueLayout.JAVA_LONG, 8, (long) i * 3);&#10;            data3.set(ValueLayout.JAVA_LONG, 0, (long) i * 4);&#10;            data3.set(ValueLayout.JAVA_LONG, 8, (long) i * 5);&#10;            data3.set(ValueLayout.JAVA_LONG, 16, (long) i * 6);&#10;            data3.set(ValueLayout.JAVA_LONG, 24, (long) i * 7);&#10;        }&#10;&#10;        // Verify all components maintain data correctly&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            MemorySegment data1 = archetype.getComponentData(locations.get(i), 0);&#10;            MemorySegment data2 = archetype.getComponentData(locations.get(i), 1);&#10;            MemorySegment data3 = archetype.getComponentData(locations.get(i), 2);&#10;&#10;            assertEquals((long) i * 1, data1.get(ValueLayout.JAVA_LONG, 0));&#10;            assertEquals((long) i * 2, data2.get(ValueLayout.JAVA_LONG, 0));&#10;            assertEquals((long) i * 3, data2.get(ValueLayout.JAVA_LONG, 8));&#10;            assertEquals((long) i * 4, data3.get(ValueLayout.JAVA_LONG, 0));&#10;            assertEquals((long) i * 5, data3.get(ValueLayout.JAVA_LONG, 8));&#10;            assertEquals((long) i * 6, data3.get(ValueLayout.JAVA_LONG, 16));&#10;            assertEquals((long) i * 7, data3.get(ValueLayout.JAVA_LONG, 24));&#10;        }&#10;&#10;        System.out.println(&quot; Multi-component data consistency verified&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;TC-DI-005: Cross-chunk data integrity&quot;)&#10;    void testCrossChunkDataIntegrity() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int entitiesPerChunk = archetype.getEntitiesPerChunk();&#10;&#10;        // Add entities across multiple chunks&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        int totalEntities = entitiesPerChunk * 3 + 50; // 3+ chunks&#10;&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i);&#10;            data.set(ValueLayout.JAVA_LONG, 8, (long) i * 100);&#10;        }&#10;&#10;        assertTrue(archetype.getChunkCount() &gt;= 3, &quot;Should span multiple chunks&quot;);&#10;&#10;        // Verify data across all chunks&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            assertEquals((long) i, value1, &quot;Cross-chunk data corrupted at &quot; + i);&#10;            assertEquals((long) i * 100, value2, &quot;Cross-chunk data corrupted at &quot; + i);&#10;        }&#10;&#10;        System.out.printf(&quot; Cross-chunk integrity verified across %d chunks%n&quot;,&#10;                archetype.getChunkCount());&#10;    }&#10;&#10;    @Test&#10;    @Order(6)&#10;    @DisplayName(&quot;TC-DI-006: Archetype mask integrity&quot;)&#10;    void testArchetypeMaskIntegrity() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16),&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{5, 10};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(5);&#10;        mask = mask.set(10);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add many entities&#10;        for (int i = 0; i &lt; 1000; i++) {&#10;            archetype.addEntity(i);&#10;        }&#10;&#10;        // Verify mask remains consistent&#10;        ComponentMask retrievedMask = archetype.getMask();&#10;        assertTrue(retrievedMask.has(5), &quot;Component 5 should be set&quot;);&#10;        assertTrue(retrievedMask.has(10), &quot;Component 10 should be set&quot;);&#10;        assertFalse(retrievedMask.has(1), &quot;Component 1 should not be set&quot;);&#10;&#10;        // Verify component IDs&#10;        assertArrayEquals(componentIds, archetype.getComponentIds());&#10;&#10;        System.out.println(&quot; Archetype mask integrity maintained&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(7)&#10;    @DisplayName(&quot;TC-DI-007: Entity count accuracy&quot;)&#10;    void testEntityCountAccuracy() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        assertEquals(0, archetype.getEntityCount(), &quot;Initial count should be 0&quot;);&#10;&#10;        // Add entities&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            locations.add(archetype.addEntity(i));&#10;            assertEquals(i + 1, archetype.getEntityCount(),&#10;                    &quot;Count should match after adding entity &quot; + i);&#10;        }&#10;&#10;        // Remove entities&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            archetype.removeEntity(locations.get(i));&#10;            assertEquals(100 - i - 1, archetype.getEntityCount(),&#10;                    &quot;Count should match after removing entity &quot; + i);&#10;        }&#10;&#10;        System.out.println(&quot; Entity count accuracy verified through operations&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(8)&#10;    @DisplayName(&quot;TC-DI-008: No data corruption under stress&quot;)&#10;    void testNoDataCorruptionUnderStress() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        int testSize = 1000;&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;&#10;        // Add entities with checksums&#10;        for (int i = 0; i &lt; testSize; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            long checksum = (long) i * 12345 + 67890;&#10;            data.set(ValueLayout.JAVA_LONG, 0, checksum);&#10;            data.set(ValueLayout.JAVA_LONG, 8, ~checksum); // Inverted checksum&#10;        }&#10;&#10;        // Perform random operations&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            int idx = i % testSize;&#10;            MemorySegment data = archetype.getComponentData(locations.get(idx), 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, data.get(ValueLayout.JAVA_LONG, 0) + 1);&#10;        }&#10;&#10;        // Verify checksums&#10;        int corruptedCount = 0;&#10;        for (int i = 0; i &lt; testSize; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            long expectedBase = (long) i * 12345 + 67890;&#10;&#10;            // Account for modifications&#10;            if (i &lt; 100 &amp;&amp; value1 != expectedBase + 1) {&#10;                corruptedCount++;&#10;            } else if (i &gt;= 100 &amp;&amp; value1 != expectedBase) {&#10;                corruptedCount++;&#10;            }&#10;        }&#10;&#10;        assertEquals(0, corruptedCount, &quot;No data should be corrupted&quot;);&#10;        System.out.println(&quot; No corruption detected under stress testing&quot;);&#10;    }&#10;&#10;    // Test component classes&#10;    static class TestComponent {&#10;        long value1;&#10;        long value2;&#10;    }&#10;&#10;    static class Component1 {&#10;        long value;&#10;    }&#10;&#10;    static class Component2 {&#10;        long value1, value2;&#10;    }&#10;&#10;    static class Component3 {&#10;        long value1, value2, value3, value4;&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeEdgeCasesTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeEdgeCasesTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * QA/QC Test Suite: Edge Cases v Boundary Conditions&#10; * Kim tra cc trng hp bin, ngoi l v iu kin gii hn&#10; */&#10;@DisplayName(&quot;QA/QC: Edge Cases Tests&quot;)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class ArchetypeEdgeCasesTest {&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;TC-EC-001: Empty component mask handling&quot;)&#10;    void testEmptyComponentMask() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[0];&#10;        int[] componentIds = new int[0];&#10;        ComponentMask mask = new ComponentMask();&#10;&#10;        // System allows empty archetype - verify it's created successfully&#10;        Archetype archetype = assertDoesNotThrow(() -&gt; {&#10;            return new Archetype(mask, componentIds, descriptors, arena);&#10;        }, &quot;Empty archetype should be created successfully&quot;);&#10;&#10;        assertNotNull(archetype, &quot;Empty archetype should not be null&quot;);&#10;        assertEquals(0, archetype.getComponentIds().length, &quot;Should have 0 components&quot;);&#10;        assertEquals(0, archetype.getDescriptors().length, &quot;Should have 0 descriptors&quot;);&#10;&#10;        // Should be able to add entities even with no components&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(1);&#10;        assertNotNull(loc, &quot;Should be able to add entity to empty archetype&quot;);&#10;        assertEquals(1, archetype.getEntityCount(), &quot;Should have 1 entity&quot;);&#10;&#10;        System.out.println(&quot; Empty component mask handled correctly - system allows empty archetypes&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;TC-EC-002: Single component archetype&quot;)&#10;    void testSingleComponentArchetype() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(SingleComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            assertNotNull(loc);&#10;        }&#10;&#10;        assertEquals(100, archetype.getEntityCount());&#10;        System.out.println(&quot; Single component archetype works correctly&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;TC-EC-003: Maximum components per archetype&quot;)&#10;    void testMaximumComponents() {&#10;        Arena arena = Arena.ofShared();&#10;        int maxComponents = 32; // Reasonable limit&#10;&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[maxComponents];&#10;        int[] componentIds = new int[maxComponents];&#10;        ComponentMask mask = new ComponentMask();&#10;&#10;        for (int i = 0; i &lt; maxComponents; i++) {&#10;            descriptors[i] = makeDesc(TestComponent.class, 8);&#10;            componentIds[i] = i + 1;&#10;            mask = mask.set(i + 1);&#10;        }&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(1);&#10;        assertNotNull(loc);&#10;&#10;        System.out.printf(&quot; Archetype with %d components created successfully%n&quot;, maxComponents);&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;TC-EC-004: Component index boundary tests&quot;)&#10;    void testComponentIndexBoundaries() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8),&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1, 2};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;        mask = mask.set(2);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Valid indices&#10;        assertEquals(0, archetype.indexOfComponentType(1));&#10;        assertEquals(1, archetype.indexOfComponentType(2));&#10;&#10;        // Invalid index&#10;        assertEquals(-1, archetype.indexOfComponentType(999));&#10;        assertEquals(-1, archetype.indexOfComponentType(-1));&#10;        assertEquals(-1, archetype.indexOfComponentType(0));&#10;&#10;        System.out.println(&quot; Component index boundaries validated&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;TC-EC-005: Entity ID edge cases&quot;)&#10;    void testEntityIdEdgeCases() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Test various entity IDs&#10;        int[] testIds = {&#10;                0,                    // Zero&#10;                1,                    // Small positive&#10;                -1,                   // Negative&#10;                Integer.MAX_VALUE,    // Max int&#10;                Integer.MIN_VALUE     // Min int&#10;        };&#10;&#10;        for (int id : testIds) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(id);&#10;            assertNotNull(loc, &quot;Should handle entity ID: &quot; + id);&#10;        }&#10;&#10;        assertEquals(testIds.length, archetype.getEntityCount());&#10;        System.out.println(&quot; Entity ID edge cases handled correctly&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(6)&#10;    @DisplayName(&quot;TC-EC-006: Chunk capacity boundary&quot;)&#10;    void testChunkCapacityBoundary() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int entitiesPerChunk = archetype.getEntitiesPerChunk();&#10;        int initialChunkCount = archetype.getChunkCount();&#10;&#10;        // Add enough entities to exceed multiple chunks&#10;        int totalEntities = entitiesPerChunk * 3;&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            archetype.addEntity(i);&#10;        }&#10;&#10;        // Verify we have more chunks now&#10;        int finalChunkCount = archetype.getChunkCount();&#10;        assertTrue(finalChunkCount &gt; initialChunkCount,&#10;                &quot;Should have created additional chunks after adding &quot; + totalEntities + &quot; entities&quot;);&#10;        assertEquals(totalEntities, archetype.getEntityCount(),&#10;                &quot;Should have all entities added&quot;);&#10;&#10;        System.out.printf(&quot; Chunk capacity boundary tested: %d entities per chunk, created %d chunks for %d entities%n&quot;,&#10;                entitiesPerChunk, finalChunkCount, totalEntities);&#10;    }&#10;&#10;    @Test&#10;    @Order(7)&#10;    @DisplayName(&quot;TC-EC-007: Remove from invalid location&quot;)&#10;    void testRemoveInvalidLocation() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        archetype.addEntity(1);&#10;&#10;        // Try to remove from invalid locations&#10;        ArchetypeChunk.ChunkLocation invalidLoc1 = new ArchetypeChunk.ChunkLocation(-1, 0);&#10;        ArchetypeChunk.ChunkLocation invalidLoc2 = new ArchetypeChunk.ChunkLocation(0, -1);&#10;        ArchetypeChunk.ChunkLocation invalidLoc3 = new ArchetypeChunk.ChunkLocation(999, 0);&#10;&#10;        // Should handle gracefully&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(invalidLoc1));&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(invalidLoc2));&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(invalidLoc3));&#10;&#10;        System.out.println(&quot; Invalid remove locations handled gracefully&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(8)&#10;    @DisplayName(&quot;TC-EC-008: Duplicate entity addition&quot;)&#10;    void testDuplicateEntityAddition() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add same entity ID multiple times&#10;        ArchetypeChunk.ChunkLocation loc1 = archetype.addEntity(42);&#10;        ArchetypeChunk.ChunkLocation loc2 = archetype.addEntity(42);&#10;        ArchetypeChunk.ChunkLocation loc3 = archetype.addEntity(42);&#10;&#10;        assertNotNull(loc1);&#10;        assertNotNull(loc2);&#10;        assertNotNull(loc3);&#10;&#10;        // System allows duplicate entity IDs (by design or should be prevented?)&#10;        assertTrue(archetype.getEntityCount() &gt;= 1);&#10;&#10;        System.out.println(&quot; Duplicate entity addition behavior verified&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(9)&#10;    @DisplayName(&quot;TC-EC-009: Component type mismatch&quot;)&#10;    void testComponentTypeMismatch() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(1);&#10;&#10;        // Try to get component at invalid index&#10;        assertThrows(Exception.class, () -&gt; {&#10;            archetype.getComponentData(loc, 999);&#10;        }, &quot;Should throw exception for invalid component index&quot;);&#10;&#10;        System.out.println(&quot; Component type mismatch handled correctly&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(10)&#10;    @DisplayName(&quot;TC-EC-010: Rapid add-remove cycles&quot;)&#10;    void testRapidAddRemoveCycles() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Rapid cycles&#10;        for (int cycle = 0; cycle &lt; 10; cycle++) {&#10;            // Add&#10;            for (int i = 0; i &lt; 100; i++) {&#10;                archetype.addEntity(cycle * 100 + i);&#10;            }&#10;&#10;            // Remove all from first chunk&#10;            for (int i = 0; i &lt; Math.min(100, archetype.getEntitiesPerChunk()); i++) {&#10;                archetype.removeEntity(new ArchetypeChunk.ChunkLocation(0, i));&#10;            }&#10;        }&#10;&#10;        assertTrue(archetype.getEntityCount() &gt;= 0, &quot;Entity count should be valid&quot;);&#10;        System.out.printf(&quot; Survived 10 rapid add-remove cycles, final count: %d%n&quot;,&#10;                archetype.getEntityCount());&#10;    }&#10;&#10;    @Test&#10;    @Order(11)&#10;    @DisplayName(&quot;TC-EC-011: Component mask consistency&quot;)&#10;    void testComponentMaskConsistency() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8),&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{5, 10}; // Non-sequential IDs&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(5);&#10;        mask = mask.set(10);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Verify mask consistency&#10;        ComponentMask retrievedMask = archetype.getMask();&#10;        assertTrue(retrievedMask.has(5), &quot;Mask should have component 5&quot;);&#10;        assertTrue(retrievedMask.has(10), &quot;Mask should have component 10&quot;);&#10;        assertFalse(retrievedMask.has(1), &quot;Mask should not have component 1&quot;);&#10;        assertFalse(retrievedMask.has(15), &quot;Mask should not have component 15&quot;);&#10;&#10;        System.out.println(&quot; Component mask consistency verified&quot;);&#10;    }&#10;&#10;    // Test component classes&#10;    static class SingleComponent {&#10;        long value;&#10;    }&#10;&#10;    static class TestComponent {&#10;        long value1;&#10;        long value2;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * QA/QC Test Suite: Edge Cases v Boundary Conditions&#10; * Kim tra cc trng hp bin, ngoi l v iu kin gii hn&#10; */&#10;@DisplayName(&quot;QA/QC: Edge Cases Tests&quot;)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class ArchetypeEdgeCasesTest {&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;TC-EC-001: Empty component mask handling&quot;)&#10;    void testEmptyComponentMask() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[0];&#10;        int[] componentIds = new int[0];&#10;        ComponentMask mask = new ComponentMask();&#10;&#10;        // System allows empty archetype - verify it's created successfully&#10;        Archetype archetype = assertDoesNotThrow(() -&gt; {&#10;            return new Archetype(mask, componentIds, descriptors, arena);&#10;        }, &quot;Empty archetype should be created successfully&quot;);&#10;&#10;        assertNotNull(archetype, &quot;Empty archetype should not be null&quot;);&#10;        assertEquals(0, archetype.getComponentIds().length, &quot;Should have 0 components&quot;);&#10;        assertEquals(0, archetype.getDescriptors().length, &quot;Should have 0 descriptors&quot;);&#10;&#10;        // Should be able to add entities even with no components&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(1);&#10;        assertNotNull(loc, &quot;Should be able to add entity to empty archetype&quot;);&#10;        assertEquals(1, archetype.getEntityCount(), &quot;Should have 1 entity&quot;);&#10;&#10;        System.out.println(&quot; Empty component mask handled correctly - system allows empty archetypes&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;TC-EC-002: Single component archetype&quot;)&#10;    void testSingleComponentArchetype() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(SingleComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            assertNotNull(loc);&#10;        }&#10;&#10;        assertEquals(100, archetype.getEntityCount());&#10;        System.out.println(&quot; Single component archetype works correctly&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;TC-EC-003: Maximum components per archetype&quot;)&#10;    void testMaximumComponents() {&#10;        Arena arena = Arena.ofShared();&#10;        int maxComponents = 32; // Reasonable limit&#10;&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[maxComponents];&#10;        int[] componentIds = new int[maxComponents];&#10;        ComponentMask mask = new ComponentMask();&#10;&#10;        for (int i = 0; i &lt; maxComponents; i++) {&#10;            descriptors[i] = makeDesc(TestComponent.class, 8);&#10;            componentIds[i] = i + 1;&#10;            mask = mask.set(i + 1);&#10;        }&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(1);&#10;        assertNotNull(loc);&#10;&#10;        System.out.printf(&quot; Archetype with %d components created successfully%n&quot;, maxComponents);&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;TC-EC-004: Component index boundary tests&quot;)&#10;    void testComponentIndexBoundaries() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8),&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1, 2};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;        mask = mask.set(2);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Valid indices&#10;        assertEquals(0, archetype.indexOfComponentType(1));&#10;        assertEquals(1, archetype.indexOfComponentType(2));&#10;&#10;        // Invalid index&#10;        assertEquals(-1, archetype.indexOfComponentType(999));&#10;        assertEquals(-1, archetype.indexOfComponentType(-1));&#10;        assertEquals(-1, archetype.indexOfComponentType(0));&#10;&#10;        System.out.println(&quot; Component index boundaries validated&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;TC-EC-005: Entity ID edge cases&quot;)&#10;    void testEntityIdEdgeCases() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Test various entity IDs&#10;        int[] testIds = {&#10;                0,                    // Zero&#10;                1,                    // Small positive&#10;                -1,                   // Negative&#10;                Integer.MAX_VALUE,    // Max int&#10;                Integer.MIN_VALUE     // Min int&#10;        };&#10;&#10;        for (int id : testIds) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(id);&#10;            assertNotNull(loc, &quot;Should handle entity ID: &quot; + id);&#10;        }&#10;&#10;        assertEquals(testIds.length, archetype.getEntityCount());&#10;        System.out.println(&quot; Entity ID edge cases handled correctly&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(6)&#10;    @DisplayName(&quot;TC-EC-006: Chunk capacity boundary&quot;)&#10;    void testChunkCapacityBoundary() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int entitiesPerChunk = archetype.getEntitiesPerChunk();&#10;        int initialChunkCount = archetype.getChunkCount();&#10;&#10;        // Add enough entities to exceed multiple chunks&#10;        int totalEntities = entitiesPerChunk * 3;&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            archetype.addEntity(i);&#10;        }&#10;&#10;        // Verify we have more chunks now&#10;        int finalChunkCount = archetype.getChunkCount();&#10;        assertTrue(finalChunkCount &gt; initialChunkCount,&#10;                &quot;Should have created additional chunks after adding &quot; + totalEntities + &quot; entities&quot;);&#10;        assertEquals(totalEntities, archetype.getEntityCount(),&#10;                &quot;Should have all entities added&quot;);&#10;&#10;        System.out.printf(&quot; Chunk capacity boundary tested: %d entities per chunk, created %d chunks for %d entities%n&quot;,&#10;                entitiesPerChunk, finalChunkCount, totalEntities);&#10;    }&#10;&#10;    @Test&#10;    @Order(7)&#10;    @DisplayName(&quot;TC-EC-007: Remove from invalid location&quot;)&#10;    void testRemoveInvalidLocation() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        archetype.addEntity(1);&#10;&#10;        // Try to remove from invalid locations&#10;        ArchetypeChunk.ChunkLocation invalidLoc1 = new ArchetypeChunk.ChunkLocation(-1, 0);&#10;        ArchetypeChunk.ChunkLocation invalidLoc2 = new ArchetypeChunk.ChunkLocation(0, -1);&#10;        ArchetypeChunk.ChunkLocation invalidLoc3 = new ArchetypeChunk.ChunkLocation(999, 0);&#10;&#10;        // Should handle gracefully&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(invalidLoc1));&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(invalidLoc2));&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(invalidLoc3));&#10;&#10;        System.out.println(&quot; Invalid remove locations handled gracefully&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(8)&#10;    @DisplayName(&quot;TC-EC-008: Duplicate entity addition&quot;)&#10;    void testDuplicateEntityAddition() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add same entity ID multiple times&#10;        ArchetypeChunk.ChunkLocation loc1 = archetype.addEntity(42);&#10;        ArchetypeChunk.ChunkLocation loc2 = archetype.addEntity(42);&#10;        ArchetypeChunk.ChunkLocation loc3 = archetype.addEntity(42);&#10;&#10;        assertNotNull(loc1);&#10;        assertNotNull(loc2);&#10;        assertNotNull(loc3);&#10;&#10;        // System allows duplicate entity IDs (by design or should be prevented?)&#10;        assertTrue(archetype.getEntityCount() &gt;= 1);&#10;&#10;        System.out.println(&quot; Duplicate entity addition behavior verified&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(9)&#10;    @DisplayName(&quot;TC-EC-009: Component type mismatch&quot;)&#10;    void testComponentTypeMismatch() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(1);&#10;&#10;        // Try to get component at invalid index&#10;        assertThrows(Exception.class, () -&gt; {&#10;            archetype.getComponentData(loc, 999);&#10;        }, &quot;Should throw exception for invalid component index&quot;);&#10;&#10;        System.out.println(&quot; Component type mismatch handled correctly&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(10)&#10;    @DisplayName(&quot;TC-EC-010: Rapid add-remove cycles&quot;)&#10;    void testRapidAddRemoveCycles() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Rapid cycles&#10;        for (int cycle = 0; cycle &lt; 10; cycle++) {&#10;            // Add&#10;            for (int i = 0; i &lt; 100; i++) {&#10;                archetype.addEntity(cycle * 100 + i);&#10;            }&#10;&#10;            // Remove all from first chunk&#10;            for (int i = 0; i &lt; Math.min(100, archetype.getEntitiesPerChunk()); i++) {&#10;                archetype.removeEntity(new ArchetypeChunk.ChunkLocation(0, i));&#10;            }&#10;        }&#10;&#10;        assertTrue(archetype.getEntityCount() &gt;= 0, &quot;Entity count should be valid&quot;);&#10;        System.out.printf(&quot; Survived 10 rapid add-remove cycles, final count: %d%n&quot;,&#10;                archetype.getEntityCount());&#10;    }&#10;&#10;    @Test&#10;    @Order(11)&#10;    @DisplayName(&quot;TC-EC-011: Component mask consistency&quot;)&#10;    void testComponentMaskConsistency() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8),&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{5, 10}; // Non-sequential IDs&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(5);&#10;        mask = mask.set(10);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Verify mask consistency&#10;        ComponentMask retrievedMask = archetype.getMask();&#10;        assertTrue(retrievedMask.has(5), &quot;Mask should have component 5&quot;);&#10;        assertTrue(retrievedMask.has(10), &quot;Mask should have component 10&quot;);&#10;        assertFalse(retrievedMask.has(1), &quot;Mask should not have component 1&quot;);&#10;        assertFalse(retrievedMask.has(15), &quot;Mask should not have component 15&quot;);&#10;&#10;        System.out.println(&quot; Component mask consistency verified&quot;);&#10;    }&#10;&#10;    // Test component classes&#10;    static class SingleComponent {&#10;        long value;&#10;    }&#10;&#10;    static class TestComponent {&#10;        long value1;&#10;        long value2;&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeTestSuite.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeTestSuite.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import org.junit.platform.suite.api.SelectClasses;&#10;import org.junit.platform.suite.api.Suite;&#10;import org.junit.platform.suite.api.SuiteDisplayName;&#10;&#10;/**&#10; * Comprehensive test suite for all Archetype-related tests.&#10; * This suite runs all tests for ArchetypeChunk, Archetype, parallel query functionality,&#10; * the new System API with @Query annotation, and comprehensive QA/QC tests.&#10; * &#10; * QA/QC Test Categories:&#10; * - Thread Safety: Concurrent operations and race condition tests&#10; * - Memory Safety: Resource management and memory leak detection&#10; * - Edge Cases: Boundary conditions and exceptional scenarios&#10; * - Performance: Scalability and throughput benchmarks&#10; * - Data Integrity: Consistency and correctness validation&#10; */&#10;@Suite&#10;@SuiteDisplayName(&quot;ECS Comprehensive Test Suite&quot;)&#10;@SelectClasses({&#10;        // Core Functionality Tests&#10;        ArchetypeChunkTest.class,&#10;        ArchetypeTest.class,&#10;        LockFreeAllocatorTest.class,&#10;        ParallelQueryTest.class,&#10;        ManagedComponentStoreTest.class,&#10;        ManagedIntegrationTest.class,&#10;        MixedManagedUnmanagedRunnerTest.class,&#10;        &#10;        // QA/QC Professional Test Suites&#10;        ArchetypeThreadSafetyTest.class,&#10;        ArchetypeMemorySafetyTest.class,&#10;        ArchetypeEdgeCasesTest.class,&#10;        ArchetypePerformanceTest.class,&#10;        ArchetypeDataIntegrityTest.class&#10;})&#10;public class ArchetypeTestSuite {&#10;    // This class is used as a test suite runner&#10;    // No implementation needed - annotations define the suite&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import org.junit.platform.suite.api.SelectClasses;&#10;import org.junit.platform.suite.api.Suite;&#10;import org.junit.platform.suite.api.SuiteDisplayName;&#10;&#10;/**&#10; * Comprehensive test suite for all Archetype-related tests.&#10; * This suite runs all tests for ArchetypeChunk, Archetype, parallel query functionality,&#10; * the new System API with @Query annotation, and comprehensive QA/QC tests.&#10; * &#10; * QA/QC Test Categories:&#10; * - Thread Safety: Concurrent operations and race condition tests&#10; * - Memory Safety: Resource management and memory leak detection&#10; * - Edge Cases: Boundary conditions and exceptional scenarios&#10; * - Performance: Scalability and throughput benchmarks&#10; * - Data Integrity: Consistency and correctness validation&#10; */&#10;@Suite&#10;@SuiteDisplayName(&quot;ECS Comprehensive Test Suite&quot;)&#10;@SelectClasses({&#10;        // Core Functionality Tests&#10;        ArchetypeChunkTest.class,&#10;        ArchetypeTest.class,&#10;        LockFreeAllocatorTest.class,&#10;        ParallelQueryTest.class,&#10;        ManagedComponentStoreTest.class,&#10;        ManagedIntegrationTest.class,&#10;        MixedManagedUnmanagedRunnerTest.class,&#10;        &#10;        // QA/QC Professional Test Suites&#10;        ArchetypeThreadSafetyTest.class,&#10;        ArchetypeMemorySafetyTest.class,&#10;        ArchetypeEdgeCasesTest.class,&#10;        ArchetypePerformanceTest.class,&#10;        ArchetypeDataIntegrityTest.class&#10;})&#10;public class ArchetypeTestSuite {&#10;    // This class is used as a test suite runner&#10;    // No implementation needed - annotations define the suite&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeThreadSafetyTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeThreadSafetyTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;import java.util.concurrent.*;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * QA/QC Test Suite: Thread Safety v Concurrency&#10; * m bo h thng hot ng an ton trong mi trng a lung&#10; */&#10;@DisplayName(&quot;QA/QC: Thread Safety Tests&quot;)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class ArchetypeThreadSafetyTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private int[] componentIds;&#10;    private ComponentMask mask;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        componentIds = new int[]{1, 2};&#10;        mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;        mask = mask.set(2);&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;TC-TS-001: Concurrent entity additions should be thread-safe&quot;)&#10;    void testConcurrentEntityAdditions() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int threadCount = 10;&#10;        int entitiesPerThread = 100;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threadCount);&#10;        CountDownLatch latch = new CountDownLatch(threadCount);&#10;        ConcurrentHashMap&lt;Integer, ArchetypeChunk.ChunkLocation&gt; locations = new ConcurrentHashMap&lt;&gt;();&#10;        AtomicInteger errorCount = new AtomicInteger(0);&#10;&#10;        for (int t = 0; t &lt; threadCount; t++) {&#10;            final int threadId = t;&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int i = 0; i &lt; entitiesPerThread; i++) {&#10;                        int entityId = threadId * entitiesPerThread + i;&#10;                        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(entityId);&#10;                        assertNotNull(loc, &quot;Location should not be null for entity &quot; + entityId);&#10;&#10;                        ArchetypeChunk.ChunkLocation previous = locations.putIfAbsent(entityId, loc);&#10;                        if (previous != null) {&#10;                            errorCount.incrementAndGet();&#10;                            System.err.println(&quot;Duplicate entity location detected: &quot; + entityId);&#10;                        }&#10;                    }&#10;                } catch (Exception e) {&#10;                    errorCount.incrementAndGet();&#10;                    e.printStackTrace();&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(30, TimeUnit.SECONDS), &quot;Test timeout - threads did not complete&quot;);&#10;        executor.shutdown();&#10;        assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;&#10;        assertEquals(0, errorCount.get(), &quot;No errors should occur during concurrent additions&quot;);&#10;        assertEquals(threadCount * entitiesPerThread, locations.size(),&#10;                &quot;All entities should be added uniquely&quot;);&#10;&#10;        System.out.printf(&quot; Successfully added %d entities concurrently from %d threads%n&quot;,&#10;                threadCount * entitiesPerThread, threadCount);&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;TC-TS-002: Concurrent add and remove operations should maintain consistency&quot;)&#10;    void testConcurrentAddRemove() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int operations = 1000;&#10;        ExecutorService executor = Executors.newFixedThreadPool(4);&#10;        ConcurrentHashMap&lt;Integer, ArchetypeChunk.ChunkLocation&gt; activeEntities = new ConcurrentHashMap&lt;&gt;();&#10;        AtomicInteger entityIdCounter = new AtomicInteger(0);&#10;        AtomicInteger addCount = new AtomicInteger(0);&#10;        AtomicInteger removeCount = new AtomicInteger(0);&#10;&#10;        // Adder threads (2 threads)&#10;        for (int i = 0; i &lt; 2; i++) {&#10;            executor.submit(() -&gt; {&#10;                for (int j = 0; j &lt; operations; j++) {&#10;                    try {&#10;                        int entityId = entityIdCounter.incrementAndGet();&#10;                        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(entityId);&#10;                        activeEntities.put(entityId, loc);&#10;                        addCount.incrementAndGet();&#10;                    } catch (Exception e) {&#10;                        System.err.println(&quot;Error adding entity: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        // Remover threads (2 threads)&#10;        for (int i = 0; i &lt; 2; i++) {&#10;            executor.submit(() -&gt; {&#10;                for (int j = 0; j &lt; operations / 2; j++) {&#10;                    try {&#10;                        activeEntities.keySet().stream().findAny().ifPresent(entityId -&gt; {&#10;                            ArchetypeChunk.ChunkLocation loc = activeEntities.remove(entityId);&#10;                            if (loc != null) {&#10;                                try {&#10;                                    archetype.removeEntity(loc);&#10;                                    removeCount.incrementAndGet();&#10;                                } catch (Exception e) {&#10;                                    System.err.println(&quot;Error removing entity: &quot; + e.getMessage());&#10;                                }&#10;                            }&#10;                        });&#10;                        Thread.sleep(1);&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        executor.shutdown();&#10;        assertTrue(executor.awaitTermination(60, TimeUnit.SECONDS), &quot;Concurrent operations timeout&quot;);&#10;&#10;        System.out.printf(&quot; Concurrent operations completed: %d adds, %d removes%n&quot;,&#10;                addCount.get(), removeCount.get());&#10;        System.out.printf(&quot; Final state: %d active entities%n&quot;, activeEntities.size());&#10;&#10;        // Verify final consistency&#10;        assertTrue(activeEntities.size() &gt;= 0, &quot;Active entities count should be non-negative&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;TC-TS-003: Parallel chunk iteration should be consistent&quot;)&#10;    void testParallelChunkIteration() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Pre-populate with entities&#10;        for (int i = 0; i &lt; 1000; i++) {&#10;            archetype.addEntity(i);&#10;        }&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(5);&#10;        AtomicInteger totalIterations = new AtomicInteger(0);&#10;        CountDownLatch latch = new CountDownLatch(5);&#10;&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int j = 0; j &lt; 100; j++) {&#10;                        archetype.getChunks().forEach(chunk -&gt; {&#10;                            assertNotNull(chunk);&#10;                            totalIterations.incrementAndGet();&#10;                        });&#10;                    }&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(30, TimeUnit.SECONDS));&#10;        executor.shutdown();&#10;&#10;        System.out.printf(&quot; Completed %d parallel chunk iterations%n&quot;, totalIterations.get());&#10;        assertTrue(totalIterations.get() &gt; 0, &quot;Should have performed iterations&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;TC-TS-004: Race condition stress test&quot;)&#10;    void testRaceConditionStress() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int threadCount = 20;&#10;        int operationsPerThread = 500;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threadCount);&#10;        CountDownLatch latch = new CountDownLatch(threadCount);&#10;        AtomicInteger successfulOps = new AtomicInteger(0);&#10;        AtomicInteger failedOps = new AtomicInteger(0);&#10;&#10;        for (int t = 0; t &lt; threadCount; t++) {&#10;            final int threadId = t;&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int i = 0; i &lt; operationsPerThread; i++) {&#10;                        try {&#10;                            int entityId = threadId * operationsPerThread + i;&#10;                            archetype.addEntity(entityId);&#10;                            successfulOps.incrementAndGet();&#10;                        } catch (Exception e) {&#10;                            failedOps.incrementAndGet();&#10;                        }&#10;                    }&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(60, TimeUnit.SECONDS), &quot;Stress test timeout&quot;);&#10;        executor.shutdown();&#10;&#10;        int totalOps = threadCount * operationsPerThread;&#10;        System.out.printf(&quot; Stress test: %d successful, %d failed out of %d operations%n&quot;,&#10;                successfulOps.get(), failedOps.get(), totalOps);&#10;&#10;        assertTrue(successfulOps.get() &gt; 0, &quot;Should have some successful operations&quot;);&#10;        assertTrue((double) successfulOps.get() / totalOps &gt; 0.95,&#10;                &quot;Success rate should be &gt; 95%&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;TC-TS-005: Deadlock detection test&quot;)&#10;    @Timeout(value = 30, unit = TimeUnit.SECONDS)&#10;    void testNoDeadlock() throws InterruptedException {&#10;        Archetype archetype1 = new Archetype(mask, componentIds, descriptors, arena);&#10;        Archetype archetype2 = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(4);&#10;        CountDownLatch latch = new CountDownLatch(4);&#10;&#10;        // Thread 1: archetype1 -&gt; archetype2&#10;        executor.submit(() -&gt; {&#10;            try {&#10;                for (int i = 0; i &lt; 100; i++) {&#10;                    archetype1.addEntity(i);&#10;                    archetype2.addEntity(i + 1000);&#10;                }&#10;            } finally {&#10;                latch.countDown();&#10;            }&#10;        });&#10;&#10;        // Thread 2: archetype2 -&gt; archetype1&#10;        executor.submit(() -&gt; {&#10;            try {&#10;                for (int i = 0; i &lt; 100; i++) {&#10;                    archetype2.addEntity(i + 2000);&#10;                    archetype1.addEntity(i + 3000);&#10;                }&#10;            } finally {&#10;                latch.countDown();&#10;            }&#10;        });&#10;&#10;        // Thread 3 &amp; 4: Mixed operations&#10;        for (int t = 0; t &lt; 2; t++) {&#10;            final int offset = t * 4000;&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int i = 0; i &lt; 100; i++) {&#10;                        if (i % 2 == 0) {&#10;                            archetype1.addEntity(i + offset);&#10;                        } else {&#10;                            archetype2.addEntity(i + offset);&#10;                        }&#10;                    }&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(25, TimeUnit.SECONDS), &quot;Deadlock detected or timeout&quot;);&#10;        executor.shutdown();&#10;&#10;        System.out.println(&quot; No deadlock detected in cross-archetype operations&quot;);&#10;    }&#10;&#10;    // Test component classes&#10;    static class TestComponent1 {&#10;        long value1;&#10;        long value2;&#10;    }&#10;&#10;    static class TestComponent2 {&#10;        long value;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;import java.util.concurrent.*;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * QA/QC Test Suite: Thread Safety v Concurrency&#10; * m bo h thng hot ng an ton trong mi trng a lung&#10; */&#10;@DisplayName(&quot;QA/QC: Thread Safety Tests&quot;)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class ArchetypeThreadSafetyTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private int[] componentIds;&#10;    private ComponentMask mask;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        componentIds = new int[]{1, 2};&#10;        mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;        mask = mask.set(2);&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;TC-TS-001: Concurrent entity additions should be thread-safe&quot;)&#10;    void testConcurrentEntityAdditions() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int threadCount = 10;&#10;        int entitiesPerThread = 100;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threadCount);&#10;        CountDownLatch latch = new CountDownLatch(threadCount);&#10;        ConcurrentHashMap&lt;Integer, ArchetypeChunk.ChunkLocation&gt; locations = new ConcurrentHashMap&lt;&gt;();&#10;        AtomicInteger errorCount = new AtomicInteger(0);&#10;&#10;        for (int t = 0; t &lt; threadCount; t++) {&#10;            final int threadId = t;&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int i = 0; i &lt; entitiesPerThread; i++) {&#10;                        int entityId = threadId * entitiesPerThread + i;&#10;                        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(entityId);&#10;                        assertNotNull(loc, &quot;Location should not be null for entity &quot; + entityId);&#10;&#10;                        ArchetypeChunk.ChunkLocation previous = locations.putIfAbsent(entityId, loc);&#10;                        if (previous != null) {&#10;                            errorCount.incrementAndGet();&#10;                            System.err.println(&quot;Duplicate entity location detected: &quot; + entityId);&#10;                        }&#10;                    }&#10;                } catch (Exception e) {&#10;                    errorCount.incrementAndGet();&#10;                    e.printStackTrace();&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(30, TimeUnit.SECONDS), &quot;Test timeout - threads did not complete&quot;);&#10;        executor.shutdown();&#10;        assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;&#10;        assertEquals(0, errorCount.get(), &quot;No errors should occur during concurrent additions&quot;);&#10;        assertEquals(threadCount * entitiesPerThread, locations.size(),&#10;                &quot;All entities should be added uniquely&quot;);&#10;&#10;        System.out.printf(&quot; Successfully added %d entities concurrently from %d threads%n&quot;,&#10;                threadCount * entitiesPerThread, threadCount);&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;TC-TS-002: Concurrent add and remove operations should maintain consistency&quot;)&#10;    void testConcurrentAddRemove() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int operations = 1000;&#10;        ExecutorService executor = Executors.newFixedThreadPool(4);&#10;        ConcurrentHashMap&lt;Integer, ArchetypeChunk.ChunkLocation&gt; activeEntities = new ConcurrentHashMap&lt;&gt;();&#10;        AtomicInteger entityIdCounter = new AtomicInteger(0);&#10;        AtomicInteger addCount = new AtomicInteger(0);&#10;        AtomicInteger removeCount = new AtomicInteger(0);&#10;&#10;        // Adder threads (2 threads)&#10;        for (int i = 0; i &lt; 2; i++) {&#10;            executor.submit(() -&gt; {&#10;                for (int j = 0; j &lt; operations; j++) {&#10;                    try {&#10;                        int entityId = entityIdCounter.incrementAndGet();&#10;                        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(entityId);&#10;                        activeEntities.put(entityId, loc);&#10;                        addCount.incrementAndGet();&#10;                    } catch (Exception e) {&#10;                        System.err.println(&quot;Error adding entity: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        // Remover threads (2 threads)&#10;        for (int i = 0; i &lt; 2; i++) {&#10;            executor.submit(() -&gt; {&#10;                for (int j = 0; j &lt; operations / 2; j++) {&#10;                    try {&#10;                        activeEntities.keySet().stream().findAny().ifPresent(entityId -&gt; {&#10;                            ArchetypeChunk.ChunkLocation loc = activeEntities.remove(entityId);&#10;                            if (loc != null) {&#10;                                try {&#10;                                    archetype.removeEntity(loc);&#10;                                    removeCount.incrementAndGet();&#10;                                } catch (Exception e) {&#10;                                    System.err.println(&quot;Error removing entity: &quot; + e.getMessage());&#10;                                }&#10;                            }&#10;                        });&#10;                        Thread.sleep(1);&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        executor.shutdown();&#10;        assertTrue(executor.awaitTermination(60, TimeUnit.SECONDS), &quot;Concurrent operations timeout&quot;);&#10;&#10;        System.out.printf(&quot; Concurrent operations completed: %d adds, %d removes%n&quot;,&#10;                addCount.get(), removeCount.get());&#10;        System.out.printf(&quot; Final state: %d active entities%n&quot;, activeEntities.size());&#10;&#10;        // Verify final consistency&#10;        assertTrue(activeEntities.size() &gt;= 0, &quot;Active entities count should be non-negative&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;TC-TS-003: Parallel chunk iteration should be consistent&quot;)&#10;    void testParallelChunkIteration() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Pre-populate with entities&#10;        for (int i = 0; i &lt; 1000; i++) {&#10;            archetype.addEntity(i);&#10;        }&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(5);&#10;        AtomicInteger totalIterations = new AtomicInteger(0);&#10;        CountDownLatch latch = new CountDownLatch(5);&#10;&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int j = 0; j &lt; 100; j++) {&#10;                        archetype.getChunks().forEach(chunk -&gt; {&#10;                            assertNotNull(chunk);&#10;                            totalIterations.incrementAndGet();&#10;                        });&#10;                    }&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(30, TimeUnit.SECONDS));&#10;        executor.shutdown();&#10;&#10;        System.out.printf(&quot; Completed %d parallel chunk iterations%n&quot;, totalIterations.get());&#10;        assertTrue(totalIterations.get() &gt; 0, &quot;Should have performed iterations&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;TC-TS-004: Race condition stress test&quot;)&#10;    void testRaceConditionStress() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int threadCount = 20;&#10;        int operationsPerThread = 500;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threadCount);&#10;        CountDownLatch latch = new CountDownLatch(threadCount);&#10;        AtomicInteger successfulOps = new AtomicInteger(0);&#10;        AtomicInteger failedOps = new AtomicInteger(0);&#10;&#10;        for (int t = 0; t &lt; threadCount; t++) {&#10;            final int threadId = t;&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int i = 0; i &lt; operationsPerThread; i++) {&#10;                        try {&#10;                            int entityId = threadId * operationsPerThread + i;&#10;                            archetype.addEntity(entityId);&#10;                            successfulOps.incrementAndGet();&#10;                        } catch (Exception e) {&#10;                            failedOps.incrementAndGet();&#10;                        }&#10;                    }&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(60, TimeUnit.SECONDS), &quot;Stress test timeout&quot;);&#10;        executor.shutdown();&#10;&#10;        int totalOps = threadCount * operationsPerThread;&#10;        System.out.printf(&quot; Stress test: %d successful, %d failed out of %d operations%n&quot;,&#10;                successfulOps.get(), failedOps.get(), totalOps);&#10;&#10;        assertTrue(successfulOps.get() &gt; 0, &quot;Should have some successful operations&quot;);&#10;        assertTrue((double) successfulOps.get() / totalOps &gt; 0.95,&#10;                &quot;Success rate should be &gt; 95%&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;TC-TS-005: Deadlock detection test&quot;)&#10;    @Timeout(value = 30, unit = TimeUnit.SECONDS)&#10;    void testNoDeadlock() throws InterruptedException {&#10;        Archetype archetype1 = new Archetype(mask, componentIds, descriptors, arena);&#10;        Archetype archetype2 = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(4);&#10;        CountDownLatch latch = new CountDownLatch(4);&#10;&#10;        // Thread 1: archetype1 -&gt; archetype2&#10;        executor.submit(() -&gt; {&#10;            try {&#10;                for (int i = 0; i &lt; 100; i++) {&#10;                    archetype1.addEntity(i);&#10;                    archetype2.addEntity(i + 1000);&#10;                }&#10;            } finally {&#10;                latch.countDown();&#10;            }&#10;        });&#10;&#10;        // Thread 2: archetype2 -&gt; archetype1&#10;        executor.submit(() -&gt; {&#10;            try {&#10;                for (int i = 0; i &lt; 100; i++) {&#10;                    archetype2.addEntity(i + 2000);&#10;                    archetype1.addEntity(i + 3000);&#10;                }&#10;            } finally {&#10;                latch.countDown();&#10;            }&#10;        });&#10;&#10;        // Thread 3 &amp; 4: Mixed operations&#10;        for (int t = 0; t &lt; 2; t++) {&#10;            final int offset = t * 4000;&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int i = 0; i &lt; 100; i++) {&#10;                        if (i % 2 == 0) {&#10;                            archetype1.addEntity(i + offset);&#10;                        } else {&#10;                            archetype2.addEntity(i + offset);&#10;                        }&#10;                    }&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(25, TimeUnit.SECONDS), &quot;Deadlock detected or timeout&quot;);&#10;        executor.shutdown();&#10;&#10;        System.out.println(&quot; No deadlock detected in cross-archetype operations&quot;);&#10;    }&#10;&#10;    // Test component classes&#10;    static class TestComponent1 {&#10;        long value1;&#10;        long value2;&#10;    }&#10;&#10;    static class TestComponent2 {&#10;        long value;&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeWorldTypedHandleTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeWorldTypedHandleTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import com.ethnicthv.ecs.demo.PositionComponent;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * End-to-end test from ComponentProcessor -&gt; generated meta/handle -&gt; ArchetypeWorld.addComponent&#10; * using a simple test component and its generated typed handle.&#10; */&#10;public class ArchetypeWorldTypedHandleTest {&#10;&#10;    @Test&#10;    public void addComponent_initializer_writesDirectlyToChunkMemory() {&#10;        ComponentManager cm = new ComponentManager();&#10;        // Register descriptor + typed handle pool for PositionComponent and TestComponent1&#10;        cm.registerComponentWithHandle(PositionComponent.class, PositionComponentMeta.DESCRIPTOR, PositionComponentHandle::new);&#10;        cm.registerComponentWithHandle(TestComponent1.class, TestComponent1Meta.DESCRIPTOR, TestComponent1Handle::new);&#10;&#10;        ArchetypeWorld world = new ArchetypeWorld(cm);&#10;&#10;        world.registerComponent(PositionComponent.class);&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        int entityId = world.createEntity();&#10;&#10;        // Act: add TestComponent1 via typed handle initializer&#10;        world.addComponent(entityId, TestComponent1.class, (TestComponent1Handle h) -&gt; {&#10;            h.setValue(42);&#10;        });&#10;&#10;        assertTrue(world.hasComponent(entityId, TestComponent1.class));&#10;&#10;        var seg = world.getComponent(entityId, TestComponent1.class);&#10;        assertNotNull(seg, &quot;Component MemorySegment should not be null after addComponent initializer&quot;);&#10;&#10;        var rawHandle = cm.createHandle(TestComponent1.class, seg);&#10;        try {&#10;            TestComponent1Handle handle = new TestComponent1Handle();&#10;            handle.__bind(rawHandle);&#10;&#10;            int v = handle.getValue();&#10;            assertEquals(42, v);&#10;        } finally {&#10;            cm.releaseHandle(rawHandle);&#10;            world.close();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import com.ethnicthv.ecs.demo.PositionComponent;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * End-to-end test from ComponentProcessor -&gt; generated meta/handle -&gt; ArchetypeWorld.addComponent&#10; * using a simple test component and its generated typed handle.&#10; */&#10;public class ArchetypeWorldTypedHandleTest {&#10;&#10;    @Test&#10;    public void addComponent_initializer_writesDirectlyToChunkMemory() {&#10;        ComponentManager cm = new ComponentManager();&#10;        // Register descriptor + typed handle pool for PositionComponent and TestComponent1&#10;        cm.registerComponentWithHandle(PositionComponent.class, PositionComponentMeta.DESCRIPTOR, PositionComponentHandle::new);&#10;        cm.registerComponentWithHandle(TestComponent1.class, TestComponent1Meta.DESCRIPTOR, TestComponent1Handle::new);&#10;&#10;        ArchetypeWorld world = new ArchetypeWorld(cm);&#10;&#10;        world.registerComponent(PositionComponent.class);&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        int entityId = world.createEntity();&#10;&#10;        // Act: add TestComponent1 via typed handle initializer&#10;        world.addComponent(entityId, TestComponent1.class, (TestComponent1Handle h) -&gt; {&#10;            h.setValue(42);&#10;        });&#10;&#10;        assertTrue(world.hasComponent(entityId, TestComponent1.class));&#10;&#10;        var seg = world.getComponent(entityId, TestComponent1.class);&#10;        assertNotNull(seg, &quot;Component MemorySegment should not be null after addComponent initializer&quot;);&#10;&#10;        var rawHandle = cm.createHandle(TestComponent1.class, seg);&#10;        try {&#10;            TestComponent1Handle handle = new TestComponent1Handle();&#10;            handle.__bind(rawHandle);&#10;&#10;            int v = handle.getValue();&#10;            assertEquals(42, v);&#10;        } finally {&#10;            cm.releaseHandle(rawHandle);&#10;            world.close();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/LargeScaleTestSuite.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/LargeScaleTestSuite.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import org.junit.platform.suite.api.SelectClasses;&#10;import org.junit.platform.suite.api.Suite;&#10;import org.junit.platform.suite.api.SuiteDisplayName;&#10;&#10;/**&#10; * Comprehensive test suite for large-scale entity operations.&#10; * This suite runs all large-scale tests for ArchetypeChunk and LockFreeAllocator.&#10; */&#10;@Suite&#10;@SuiteDisplayName(&quot;Large Scale ECS Test Suite&quot;)&#10;@SelectClasses({&#10;    ArchetypeChunkTest.class,&#10;    LockFreeAllocatorTest.class,&#10;    ParallelQueryTest.class&#10;})&#10;public class LargeScaleTestSuite {&#10;    // This class remains empty, it is used only as a holder for the suite annotations&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import org.junit.platform.suite.api.SelectClasses;&#10;import org.junit.platform.suite.api.Suite;&#10;import org.junit.platform.suite.api.SuiteDisplayName;&#10;&#10;/**&#10; * Comprehensive test suite for large-scale entity operations.&#10; * This suite runs all large-scale tests for ArchetypeChunk and LockFreeAllocator.&#10; */&#10;@Suite&#10;@SuiteDisplayName(&quot;Large Scale ECS Test Suite&quot;)&#10;@SelectClasses({&#10;    ArchetypeChunkTest.class,&#10;    LockFreeAllocatorTest.class,&#10;    ParallelQueryTest.class&#10;})&#10;public class LargeScaleTestSuite {&#10;    // This class remains empty, it is used only as a holder for the suite annotations&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/LockFreeAllocatorTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/LockFreeAllocatorTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import org.junit.jupiter.api.AfterAll;&#10;import org.junit.jupiter.api.Assertions;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;public class LockFreeAllocatorTest {&#10;&#10;    static final Arena shared = Arena.ofShared();&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @AfterAll&#10;    static void tearDown() {&#10;        // do not close shared arena; it is shared across tests/world&#10;    }&#10;&#10;    @Test&#10;    void allocateUpToCapacityConcurrently() throws InterruptedException {&#10;        if (!Boolean.getBoolean(&quot;ecs.enableLockFreeAllocatorStress&quot;)) {&#10;            // Skip this stress-oriented test unless explicitly enabled via system property&#10;            return;&#10;        }&#10;        int capacity = 256;&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        long[] sizes = new long[] { 16, 8 };&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descs, sizes, capacity, shared);&#10;&#10;        int threads = 8;&#10;        int attemptsPerThread = 1000; // will saturate chunk multiple times&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * attemptsPerThread;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; attemptsPerThread; i++) {&#10;                        int eid = baseId + i;&#10;                        int idx = chunk.allocateSlot(eid);&#10;                        if (idx &gt;= 0) {&#10;                            // immediately free half of allocations to churn&#10;                            if ((eid &amp; 1) == 0) {&#10;                                chunk.freeSlot(idx);&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        done.await(30, TimeUnit.SECONDS);&#10;        pool.shutdownNow();&#10;&#10;        // size must be within [0, capacity]&#10;        var size = chunk.size();&#10;        Assertions.assertTrue(chunk.size() &gt;= 0, &quot;Chunk size should be non-negative&quot;);&#10;        Assertions.assertTrue(chunk.size() &lt;= capacity, &quot;Chunk size should not exceed capacity&quot;);&#10;&#10;        // All occupied slots must have a valid entity id != -1&#10;        int occupied = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            int eid = chunk.getEntityId(i);&#10;            if (eid != -1) occupied++;&#10;            else continue;&#10;        }&#10;        Assertions.assertEquals(chunk.size(), occupied);&#10;    }&#10;&#10;    @Test&#10;    void archetypeConcurrentAddsScaleAcrossChunks() throws InterruptedException {&#10;        // Small capacity to force multiple chunks&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 8;&#10;        int entities = 10_000;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        int perThread = entities / threads;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * perThread + 1;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; perThread; i++) {&#10;                        archetype.addEntity(baseId + i);&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        done.await(30, TimeUnit.SECONDS);&#10;        pool.shutdownNow();&#10;&#10;        // Count entities discovered by iteration; weakly consistent but should reach expected count&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(entities, count[0]);&#10;&#10;        // sanity: at least more than one chunk should exist&#10;        Assertions.assertTrue(archetype.getChunks().size() &gt;= 1);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScale_50000Entities() throws InterruptedException {&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 16;&#10;        int entities = 50_000;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        int perThread = entities / threads;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * perThread + 100_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; perThread; i++) {&#10;                        archetype.addEntity(baseId + i);&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(60, TimeUnit.SECONDS), &quot;Should complete within 60 seconds&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Count all entities&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(entities, count[0], &quot;All 50,000 entities should be present&quot;);&#10;&#10;        // Verify multiple chunks were created&#10;        Assertions.assertTrue(archetype.getChunks().size() &gt; 1, &quot;Should have created multiple chunks&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScale_100000EntitiesWithChurn() throws InterruptedException {&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 20;&#10;        int totalOperations = 100_000;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        int perThread = totalOperations / threads;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * perThread + 200_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; perThread; i++) {&#10;                        archetype.addEntity(baseId + i);&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(120, TimeUnit.SECONDS), &quot;Should complete within 120 seconds&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Verify entity count&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(totalOperations, count[0], &quot;All 100,000 entities should be present&quot;);&#10;&#10;        // Verify chunk distribution&#10;        int chunkCount = archetype.getChunks().size();&#10;        Assertions.assertTrue(chunkCount &gt; 1, &quot;Should have created multiple chunks for 100k entities&quot;);&#10;        System.out.println(&quot;Created &quot; + chunkCount + &quot; chunks for 100,000 entities&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testHighContentionScenario_10000Entities() throws InterruptedException {&#10;        int capacity = 128; // Small capacity to force more chunk allocations&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        long[] sizes = new long[] { 16, 8 };&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descs, sizes, capacity, shared);&#10;&#10;        int threads = 32; // High thread count for contention&#10;        int attemptsPerThread = 500;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        AtomicInteger successfulAllocs = new AtomicInteger(0);&#10;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * attemptsPerThread + 300_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; attemptsPerThread; i++) {&#10;                        int idx = chunk.allocateSlot(baseId + i);&#10;                        if (idx &gt;= 0) {&#10;                            successfulAllocs.incrementAndGet();&#10;                            // Free half immediately to create churn&#10;                            if (i % 2 == 0) {&#10;                                chunk.freeSlot(idx);&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(60, TimeUnit.SECONDS), &quot;High contention test should complete&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Verify chunk state is consistent&#10;        int finalSize = chunk.size();&#10;        Assertions.assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity, &quot;Size should be within bounds&quot;);&#10;&#10;        // Count actual occupied slots&#10;        int occupied = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) occupied++;&#10;        }&#10;        Assertions.assertEquals(finalSize, occupied, &quot;Occupied count should match size&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testMixedOperations_20000Cycles() throws InterruptedException {&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 10;&#10;        int cyclesPerThread = 2000; // Total 20,000 cycles&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * cyclesPerThread + 400_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; cyclesPerThread; i++) {&#10;                        // Add entity&#10;                        archetype.addEntity(baseId + i);&#10;&#10;                        // Simulate some processing time&#10;                        if (i % 100 == 0) {&#10;                            Thread.sleep(0, 1000); // 1 microsecond&#10;                        }&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(90, TimeUnit.SECONDS), &quot;Mixed operations should complete&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Final verification&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(threads * cyclesPerThread, count[0], &quot;All entities should be accounted for&quot;);&#10;    }&#10;&#10;    @Test&#10;    void allocateUpToCapacityConcurrently_manyRounds() throws InterruptedException {&#10;        // NOTE: This is a stress-only test and can be flaky when run with the full suite&#10;        // because it amplifies scheduler timing differences.&#10;        // Temporarily disabled to keep the main suite stable; re-enable when investigating&#10;        // allocator behavior in isolation.&#10;        if (Boolean.getBoolean(&quot;ecs.enableLockFreeAllocatorStress&quot;)) {&#10;            for (int i = 0; i &lt; 20; i++) {&#10;                allocateUpToCapacityConcurrently();&#10;            }&#10;        }&#10;    }&#10;&#10;    // Dummy component classes for descriptor construction&#10;    static final class DummyC1 {}&#10;    static final class DummyC2 {}&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import org.junit.jupiter.api.AfterAll;&#10;import org.junit.jupiter.api.Assertions;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;public class LockFreeAllocatorTest {&#10;&#10;    static final Arena shared = Arena.ofShared();&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @AfterAll&#10;    static void tearDown() {&#10;        // do not close shared arena; it is shared across tests/world&#10;    }&#10;&#10;    @Test&#10;    void allocateUpToCapacityConcurrently() throws InterruptedException {&#10;        if (!Boolean.getBoolean(&quot;ecs.enableLockFreeAllocatorStress&quot;)) {&#10;            // Skip this stress-oriented test unless explicitly enabled via system property&#10;            return;&#10;        }&#10;        int capacity = 256;&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        long[] sizes = new long[] { 16, 8 };&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descs, sizes, capacity, shared);&#10;&#10;        int threads = 8;&#10;        int attemptsPerThread = 1000; // will saturate chunk multiple times&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * attemptsPerThread;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; attemptsPerThread; i++) {&#10;                        int eid = baseId + i;&#10;                        int idx = chunk.allocateSlot(eid);&#10;                        if (idx &gt;= 0) {&#10;                            // immediately free half of allocations to churn&#10;                            if ((eid &amp; 1) == 0) {&#10;                                chunk.freeSlot(idx);&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        done.await(30, TimeUnit.SECONDS);&#10;        pool.shutdownNow();&#10;&#10;        // size must be within [0, capacity]&#10;        var size = chunk.size();&#10;        Assertions.assertTrue(chunk.size() &gt;= 0, &quot;Chunk size should be non-negative&quot;);&#10;        Assertions.assertTrue(chunk.size() &lt;= capacity, &quot;Chunk size should not exceed capacity&quot;);&#10;&#10;        // All occupied slots must have a valid entity id != -1&#10;        int occupied = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            int eid = chunk.getEntityId(i);&#10;            if (eid != -1) occupied++;&#10;            else continue;&#10;        }&#10;        Assertions.assertEquals(chunk.size(), occupied);&#10;    }&#10;&#10;    @Test&#10;    void archetypeConcurrentAddsScaleAcrossChunks() throws InterruptedException {&#10;        // Small capacity to force multiple chunks&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 8;&#10;        int entities = 10_000;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        int perThread = entities / threads;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * perThread + 1;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; perThread; i++) {&#10;                        archetype.addEntity(baseId + i);&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        done.await(30, TimeUnit.SECONDS);&#10;        pool.shutdownNow();&#10;&#10;        // Count entities discovered by iteration; weakly consistent but should reach expected count&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(entities, count[0]);&#10;&#10;        // sanity: at least more than one chunk should exist&#10;        Assertions.assertTrue(archetype.getChunks().size() &gt;= 1);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScale_50000Entities() throws InterruptedException {&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 16;&#10;        int entities = 50_000;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        int perThread = entities / threads;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * perThread + 100_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; perThread; i++) {&#10;                        archetype.addEntity(baseId + i);&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(60, TimeUnit.SECONDS), &quot;Should complete within 60 seconds&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Count all entities&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(entities, count[0], &quot;All 50,000 entities should be present&quot;);&#10;&#10;        // Verify multiple chunks were created&#10;        Assertions.assertTrue(archetype.getChunks().size() &gt; 1, &quot;Should have created multiple chunks&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScale_100000EntitiesWithChurn() throws InterruptedException {&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 20;&#10;        int totalOperations = 100_000;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        int perThread = totalOperations / threads;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * perThread + 200_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; perThread; i++) {&#10;                        archetype.addEntity(baseId + i);&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(120, TimeUnit.SECONDS), &quot;Should complete within 120 seconds&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Verify entity count&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(totalOperations, count[0], &quot;All 100,000 entities should be present&quot;);&#10;&#10;        // Verify chunk distribution&#10;        int chunkCount = archetype.getChunks().size();&#10;        Assertions.assertTrue(chunkCount &gt; 1, &quot;Should have created multiple chunks for 100k entities&quot;);&#10;        System.out.println(&quot;Created &quot; + chunkCount + &quot; chunks for 100,000 entities&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testHighContentionScenario_10000Entities() throws InterruptedException {&#10;        int capacity = 128; // Small capacity to force more chunk allocations&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        long[] sizes = new long[] { 16, 8 };&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descs, sizes, capacity, shared);&#10;&#10;        int threads = 32; // High thread count for contention&#10;        int attemptsPerThread = 500;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        AtomicInteger successfulAllocs = new AtomicInteger(0);&#10;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * attemptsPerThread + 300_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; attemptsPerThread; i++) {&#10;                        int idx = chunk.allocateSlot(baseId + i);&#10;                        if (idx &gt;= 0) {&#10;                            successfulAllocs.incrementAndGet();&#10;                            // Free half immediately to create churn&#10;                            if (i % 2 == 0) {&#10;                                chunk.freeSlot(idx);&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(60, TimeUnit.SECONDS), &quot;High contention test should complete&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Verify chunk state is consistent&#10;        int finalSize = chunk.size();&#10;        Assertions.assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity, &quot;Size should be within bounds&quot;);&#10;&#10;        // Count actual occupied slots&#10;        int occupied = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) occupied++;&#10;        }&#10;        Assertions.assertEquals(finalSize, occupied, &quot;Occupied count should match size&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testMixedOperations_20000Cycles() throws InterruptedException {&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 10;&#10;        int cyclesPerThread = 2000; // Total 20,000 cycles&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * cyclesPerThread + 400_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; cyclesPerThread; i++) {&#10;                        // Add entity&#10;                        archetype.addEntity(baseId + i);&#10;&#10;                        // Simulate some processing time&#10;                        if (i % 100 == 0) {&#10;                            Thread.sleep(0, 1000); // 1 microsecond&#10;                        }&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(90, TimeUnit.SECONDS), &quot;Mixed operations should complete&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Final verification&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(threads * cyclesPerThread, count[0], &quot;All entities should be accounted for&quot;);&#10;    }&#10;&#10;    @Test&#10;    void allocateUpToCapacityConcurrently_manyRounds() throws InterruptedException {&#10;        // NOTE: This is a stress-only test and can be flaky when run with the full suite&#10;        // because it amplifies scheduler timing differences.&#10;        // Temporarily disabled to keep the main suite stable; re-enable when investigating&#10;        // allocator behavior in isolation.&#10;        if (Boolean.getBoolean(&quot;ecs.enableLockFreeAllocatorStress&quot;)) {&#10;            for (int i = 0; i &lt; 20; i++) {&#10;                allocateUpToCapacityConcurrently();&#10;            }&#10;        }&#10;    }&#10;&#10;    // Dummy component classes for descriptor construction&#10;    static final class DummyC1 {}&#10;    static final class DummyC2 {}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ManagedComponentStoreTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ManagedComponentStoreTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.ManagedComponentStore;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;public class ManagedComponentStoreTest {&#10;&#10;    @Test&#10;    void storeGetRelease_basic() {&#10;        ManagedComponentStore store = new ManagedComponentStore(4);&#10;        int a = store.store(&quot;A&quot;);&#10;        int b = store.store(&quot;B&quot;);&#10;        assertNotEquals(a, b);&#10;        assertEquals(&quot;A&quot;, store.get(a));&#10;        assertEquals(&quot;B&quot;, store.get(b));&#10;        store.release(a);&#10;        assertNull(store.get(a));&#10;        int c = store.store(&quot;C&quot;);&#10;        // c can reuse 'a' slot&#10;        assertEquals(&quot;C&quot;, store.get(c));&#10;    }&#10;&#10;    @Test&#10;    void concurrent_store_and_release() throws InterruptedException {&#10;        ManagedComponentStore store = new ManagedComponentStore(8);&#10;        int threads = 8;&#10;        int ops = 1000;&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;        try (ExecutorService es = Executors.newFixedThreadPool(threads)) {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                es.submit(() -&gt; {&#10;                    try {&#10;                        start.await();&#10;                        List&lt;Integer&gt; tickets = new ArrayList&lt;&gt;();&#10;                        for (int i = 0; i &lt; ops; i++) {&#10;                            int id = store.store(&quot;x&quot; + i);&#10;                            tickets.add(id);&#10;                            if ((i &amp; 1) == 0) {&#10;                                // release half of them&#10;                                store.release(id);&#10;                            }&#10;                        }&#10;                        // release the rest&#10;                        for (int id : tickets) {&#10;                            store.release(id);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        done.countDown();&#10;                    }&#10;                });&#10;            }&#10;            start.countDown();&#10;            assertTrue(done.await(30, TimeUnit.SECONDS));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void deterministicReuse_smallCapacity() {&#10;        ManagedComponentStore store = new ManagedComponentStore(2);&#10;        int t0 = store.store(&quot;A&quot;);&#10;        int t1 = store.store(&quot;B&quot;);&#10;        assertNotEquals(t0, t1);&#10;        // Release first, it should be reused by next store&#10;        store.release(t0);&#10;        assertNull(store.get(t0));&#10;        int t2 = store.store(&quot;C&quot;);&#10;        assertEquals(t0, t2, &quot;Expected first released ticket to be reused&quot;);&#10;        // Release second, then reused&#10;        store.release(t1);&#10;        assertNull(store.get(t1));&#10;        int t3 = store.store(&quot;D&quot;);&#10;        assertEquals(t1, t3, &quot;Expected second released ticket to be reused&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.ManagedComponentStore;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;public class ManagedComponentStoreTest {&#10;&#10;    @Test&#10;    void storeGetRelease_basic() {&#10;        ManagedComponentStore store = new ManagedComponentStore(4);&#10;        int a = store.store(&quot;A&quot;);&#10;        int b = store.store(&quot;B&quot;);&#10;        assertNotEquals(a, b);&#10;        assertEquals(&quot;A&quot;, store.get(a));&#10;        assertEquals(&quot;B&quot;, store.get(b));&#10;        store.release(a);&#10;        assertNull(store.get(a));&#10;        int c = store.store(&quot;C&quot;);&#10;        // c can reuse 'a' slot&#10;        assertEquals(&quot;C&quot;, store.get(c));&#10;    }&#10;&#10;    @Test&#10;    void concurrent_store_and_release() throws InterruptedException {&#10;        ManagedComponentStore store = new ManagedComponentStore(8);&#10;        int threads = 8;&#10;        int ops = 1000;&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;        try (ExecutorService es = Executors.newFixedThreadPool(threads)) {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                es.submit(() -&gt; {&#10;                    try {&#10;                        start.await();&#10;                        List&lt;Integer&gt; tickets = new ArrayList&lt;&gt;();&#10;                        for (int i = 0; i &lt; ops; i++) {&#10;                            int id = store.store(&quot;x&quot; + i);&#10;                            tickets.add(id);&#10;                            if ((i &amp; 1) == 0) {&#10;                                // release half of them&#10;                                store.release(id);&#10;                            }&#10;                        }&#10;                        // release the rest&#10;                        for (int id : tickets) {&#10;                            store.release(id);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        done.countDown();&#10;                    }&#10;                });&#10;            }&#10;            start.countDown();&#10;            assertTrue(done.await(30, TimeUnit.SECONDS));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void deterministicReuse_smallCapacity() {&#10;        ManagedComponentStore store = new ManagedComponentStore(2);&#10;        int t0 = store.store(&quot;A&quot;);&#10;        int t1 = store.store(&quot;B&quot;);&#10;        assertNotEquals(t0, t1);&#10;        // Release first, it should be reused by next store&#10;        store.release(t0);&#10;        assertNull(store.get(t0));&#10;        int t2 = store.store(&quot;C&quot;);&#10;        assertEquals(t0, t2, &quot;Expected first released ticket to be reused&quot;);&#10;        // Release second, then reused&#10;        store.release(t1);&#10;        assertNull(store.get(t1));&#10;        int t3 = store.store(&quot;D&quot;);&#10;        assertEquals(t1, t3, &quot;Expected second released ticket to be reused&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ManagedIntegrationTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ManagedIntegrationTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;public class ManagedIntegrationTest {&#10;&#10;    @Component.Managed&#10;    static class PlayerName implements Component {&#10;        final String name;&#10;        PlayerName(String n) { this.name = n; }&#10;    }&#10;&#10;    @Test&#10;    void add_get_replace_remove_managed_component() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            world.registerComponent(PlayerName.class);&#10;            int e = world.createEntity();&#10;&#10;            // Add managed component instance&#10;            world.addComponent(e, new PlayerName(&quot;Ethnic&quot;));&#10;            PlayerName pn = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pn);&#10;            assertEquals(&quot;Ethnic&quot;, pn.name);&#10;&#10;            // Replace instance&#10;            world.setManagedComponent(e, new PlayerName(&quot;Neo&quot;));&#10;            PlayerName pn2 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pn2);&#10;            assertEquals(&quot;Neo&quot;, pn2.name);&#10;&#10;            // Remove&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;&#10;            // Destroy shouldn't throw&#10;            world.destroyEntity(e);&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void move_between_archetypes_preserves_managed_ticket_if_present() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            // Define an unmanaged component too&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class Dummy implements Component { @Component.Field int v; }&#10;            world.registerComponent(PlayerName.class);&#10;            world.registerComponent(Dummy.class);&#10;&#10;            int e = world.createEntity(Dummy.class);&#10;            world.addComponent(e, new PlayerName(&quot;A&quot;));&#10;            PlayerName p = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p);&#10;            assertEquals(&quot;A&quot;, p.name);&#10;&#10;            // Add another unmanaged component class to force move&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class Dummy2 implements Component { @Component.Field int x; }&#10;            world.registerComponent(Dummy2.class);&#10;&#10;            // Add Dummy2 -&gt; structural move; ticket should persist&#10;            world.addComponent(e, Dummy2.class, cm.allocate(Dummy2.class, java.lang.foreign.Arena.ofShared()));&#10;            PlayerName p2 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p2);&#10;            assertEquals(&quot;A&quot;, p2.name);&#10;&#10;            // Now remove PlayerName -&gt; should become null&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void interleave_managed_unmanaged_ops_no_ticket_leaks() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            // Define a couple unmanaged components&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class U1 implements Component { @Component.Field int a; }&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class U2 implements Component { @Component.Field int b; }&#10;&#10;            world.registerComponent(PlayerName.class);&#10;            world.registerComponent(U1.class);&#10;            world.registerComponent(U2.class);&#10;&#10;            int e = world.createEntity(U1.class);&#10;&#10;            // Add managed, then add another unmanaged -&gt; triggers move&#10;            world.addComponent(e, new PlayerName(&quot;P0&quot;));&#10;            world.addComponent(e, U2.class, cm.allocate(U2.class, java.lang.foreign.Arena.ofShared()));&#10;            PlayerName p0 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p0);&#10;            assertEquals(&quot;P0&quot;, p0.name);&#10;&#10;            // Remove unmanaged U1 -&gt; move&#10;            world.removeComponent(e, U1.class);&#10;            PlayerName pAfterMove = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pAfterMove);&#10;            assertEquals(&quot;P0&quot;, pAfterMove.name);&#10;&#10;            // Replace managed instance&#10;            world.setManagedComponent(e, new PlayerName(&quot;P1&quot;));&#10;            PlayerName p1 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p1);&#10;            assertEquals(&quot;P1&quot;, p1.name);&#10;&#10;            // Remove managed&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;&#10;            // Add again and then destroy entity -&gt; should release&#10;            world.addComponent(e, new PlayerName(&quot;P2&quot;));&#10;            assertNotNull(world.getManagedComponent(e, PlayerName.class));&#10;            world.destroyEntity(e);&#10;            // Entity gone; can't directly check store, but absence via accessor indicates ticket release or entity removal&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;public class ManagedIntegrationTest {&#10;&#10;    @Component.Managed&#10;    static class PlayerName implements Component {&#10;        final String name;&#10;        PlayerName(String n) { this.name = n; }&#10;    }&#10;&#10;    @Test&#10;    void add_get_replace_remove_managed_component() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            world.registerComponent(PlayerName.class);&#10;            int e = world.createEntity();&#10;&#10;            // Add managed component instance&#10;            world.addComponent(e, new PlayerName(&quot;Ethnic&quot;));&#10;            PlayerName pn = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pn);&#10;            assertEquals(&quot;Ethnic&quot;, pn.name);&#10;&#10;            // Replace instance&#10;            world.setManagedComponent(e, new PlayerName(&quot;Neo&quot;));&#10;            PlayerName pn2 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pn2);&#10;            assertEquals(&quot;Neo&quot;, pn2.name);&#10;&#10;            // Remove&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;&#10;            // Destroy shouldn't throw&#10;            world.destroyEntity(e);&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void move_between_archetypes_preserves_managed_ticket_if_present() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            // Define an unmanaged component too&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class Dummy implements Component { @Component.Field int v; }&#10;            world.registerComponent(PlayerName.class);&#10;            world.registerComponent(Dummy.class);&#10;&#10;            int e = world.createEntity(Dummy.class);&#10;            world.addComponent(e, new PlayerName(&quot;A&quot;));&#10;            PlayerName p = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p);&#10;            assertEquals(&quot;A&quot;, p.name);&#10;&#10;            // Add another unmanaged component class to force move&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class Dummy2 implements Component { @Component.Field int x; }&#10;            world.registerComponent(Dummy2.class);&#10;&#10;            // Add Dummy2 -&gt; structural move; ticket should persist&#10;            world.addComponent(e, Dummy2.class, cm.allocate(Dummy2.class, java.lang.foreign.Arena.ofShared()));&#10;            PlayerName p2 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p2);&#10;            assertEquals(&quot;A&quot;, p2.name);&#10;&#10;            // Now remove PlayerName -&gt; should become null&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void interleave_managed_unmanaged_ops_no_ticket_leaks() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            // Define a couple unmanaged components&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class U1 implements Component { @Component.Field int a; }&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class U2 implements Component { @Component.Field int b; }&#10;&#10;            world.registerComponent(PlayerName.class);&#10;            world.registerComponent(U1.class);&#10;            world.registerComponent(U2.class);&#10;&#10;            int e = world.createEntity(U1.class);&#10;&#10;            // Add managed, then add another unmanaged -&gt; triggers move&#10;            world.addComponent(e, new PlayerName(&quot;P0&quot;));&#10;            world.addComponent(e, U2.class, cm.allocate(U2.class, java.lang.foreign.Arena.ofShared()));&#10;            PlayerName p0 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p0);&#10;            assertEquals(&quot;P0&quot;, p0.name);&#10;&#10;            // Remove unmanaged U1 -&gt; move&#10;            world.removeComponent(e, U1.class);&#10;            PlayerName pAfterMove = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pAfterMove);&#10;            assertEquals(&quot;P0&quot;, pAfterMove.name);&#10;&#10;            // Replace managed instance&#10;            world.setManagedComponent(e, new PlayerName(&quot;P1&quot;));&#10;            PlayerName p1 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p1);&#10;            assertEquals(&quot;P1&quot;, p1.name);&#10;&#10;            // Remove managed&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;&#10;            // Add again and then destroy entity -&gt; should release&#10;            world.addComponent(e, new PlayerName(&quot;P2&quot;));&#10;            assertNotNull(world.getManagedComponent(e, PlayerName.class));&#10;            world.destroyEntity(e);&#10;            // Entity gone; can't directly check store, but absence via accessor indicates ticket release or entity removal&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/TestComponent1.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/TestComponent1.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;&#10;@Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;public final class TestComponent1 implements Component {&#10;    @Component.Field(offset = 0, size = 4, alignment = 4)&#10;    int value;&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;&#10;@Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;public final class TestComponent1 implements Component {&#10;    @Component.Field(offset = 0, size = 4, alignment = 4)&#10;    int value;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>