<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    id(&quot;java&quot;)&#10;    id(&quot;application&quot;)&#10;    `java-library`&#10;    id(&quot;me.champeau.jmh&quot;) version &quot;0.7.3&quot;&#10;}&#10;&#10;group = &quot;com.ethnicthv&quot;&#10;version = &quot;1.0-SNAPSHOT&quot;&#10;&#10;java {&#10;    toolchain {&#10;        languageVersion.set(JavaLanguageVersion.of(25))&#10;    }&#10;}&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    // Enable our annotation processor for compile&#10;    annotationProcessor(project(&quot;:ecs-processor&quot;))&#10;    // Enable it for tests as well&#10;    testAnnotationProcessor(project(&quot;:ecs-processor&quot;))&#10;&#10;    testImplementation(platform(&quot;org.junit:junit-bom:5.10.0&quot;))&#10;    testImplementation(&quot;org.junit.jupiter:junit-jupiter&quot;)&#10;    testImplementation(&quot;org.junit.platform:junit-platform-suite-api&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-launcher&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-suite-engine&quot;)&#10;&#10;    // JMH for benchmarking&#10;    implementation (&quot;org.openjdk.jmh:jmh-core:0.9&quot;)&#10;    annotationProcessor (&quot;org.openjdk.jmh:jmh-generator-annprocess:0.9&quot;)&#10;    // proc ('org.openjdk.jmh:jmh-generator-bytecode:0.9')&#10;&#10;    // Fix for &quot;NoClassDefFoundError: javax/annotation/Generated&quot; on JDK 9+&#10;    annotationProcessor(&quot;javax.annotation:javax.annotation-api:1.3.2&quot;)&#10;    implementation(&quot;javax.annotation:javax.annotation-api:1.3.2&quot;)&#10;}&#10;&#10;application {&#10;    // updated to use the demo package where the entry points were moved&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ECSDemo&quot;)&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;tasks.withType&lt;JavaCompile&gt; {&#10;    options.compilerArgs.addAll(listOf(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;    ))&#10;}&#10;&#10;tasks.withType&lt;Test&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.withType&lt;JavaExec&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the performance benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.PerformanceBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ComponentManager demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runImproved&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the improved demo with Query API and true SoA&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ImprovedDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the Archetype-based ECS demo&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Benchmark Archetype vs SparseSet ECS&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeVsSparseSetBenchmark&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeQueryDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ArchetypeQuery demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeQueryDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run Component Manager + Archetype ECS benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;,&#10;        &quot;-Xms2G&quot;,&#10;        &quot;-Xmx4G&quot;&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;    id(&quot;java&quot;)&#10;    id(&quot;application&quot;)&#10;    `java-library`&#10;    id(&quot;me.champeau.jmh&quot;) version &quot;0.7.3&quot;&#10;}&#10;&#10;group = &quot;com.ethnicthv&quot;&#10;version = &quot;1.0-SNAPSHOT&quot;&#10;&#10;java {&#10;    toolchain {&#10;        languageVersion.set(JavaLanguageVersion.of(25))&#10;    }&#10;}&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    // Enable our annotation processor for compile&#10;    annotationProcessor(project(&quot;:ecs-processor&quot;))&#10;    // Enable it for tests as well&#10;    testAnnotationProcessor(project(&quot;:ecs-processor&quot;))&#10;&#10;    testImplementation(platform(&quot;org.junit:junit-bom:5.10.0&quot;))&#10;    testImplementation(&quot;org.junit.jupiter:junit-jupiter&quot;)&#10;    testImplementation(&quot;org.junit.platform:junit-platform-suite-api&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-launcher&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-suite-engine&quot;)&#10;&#10;    // JMH for benchmarking&#10;    implementation (&quot;org.openjdk.jmh:jmh-core:0.9&quot;)&#10;    annotationProcessor (&quot;org.openjdk.jmh:jmh-generator-annprocess:0.9&quot;)&#10;    // proc ('org.openjdk.jmh:jmh-generator-bytecode:0.9')&#10;&#10;    // Fix for &quot;NoClassDefFoundError: javax/annotation/Generated&quot; on JDK 9+&#10;    annotationProcessor(&quot;javax.annotation:javax.annotation-api:1.3.2&quot;)&#10;    implementation(&quot;javax.annotation:javax.annotation-api:1.3.2&quot;)&#10;}&#10;&#10;application {&#10;    // updated to use the demo package where the entry points were moved&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ECSDemo&quot;)&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;tasks.withType&lt;JavaCompile&gt; {&#10;    options.compilerArgs.addAll(listOf(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;    ))&#10;}&#10;&#10;tasks.withType&lt;Test&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.withType&lt;JavaExec&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the performance benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.PerformanceBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ComponentManager demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runImproved&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the improved demo with Query API and true SoA&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ImprovedDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the Archetype-based ECS demo&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Benchmark Archetype vs SparseSet ECS&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeVsSparseSetBenchmark&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeQueryDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ArchetypeQuery demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeQueryDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run Component Manager + Archetype ECS benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;,&#10;        &quot;-Xms2G&quot;,&#10;        &quot;-Xmx4G&quot;&#10;    )&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ecs-processor/src/main/java/com/ethnicthv/ecs/processor/QueryProcessor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ecs-processor/src/main/java/com/ethnicthv/ecs/processor/QueryProcessor.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.processor;&#10;&#10;import javax.annotation.processing.*;&#10;import javax.lang.model.SourceVersion;&#10;import javax.lang.model.element.*;&#10;import javax.lang.model.util.Elements;&#10;import javax.tools.Diagnostic;&#10;import javax.tools.JavaFileObject;&#10;import java.io.IOException;&#10;import java.io.Writer;&#10;import java.util.*;&#10;&#10;@SupportedAnnotationTypes({&#10;    &quot;com.ethnicthv.ecs.core.system.annotation.Query&quot;&#10;})&#10;@SupportedSourceVersion(SourceVersion.RELEASE_25)&#10;public class QueryProcessor extends AbstractProcessor {&#10;    private Elements elementUtils;&#10;&#10;    @Override&#10;    public synchronized void init(ProcessingEnvironment processingEnv) {&#10;        super.init(processingEnv);&#10;        this.elementUtils = processingEnv.getElementUtils();&#10;    }&#10;&#10;    @Override&#10;    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {&#10;        TypeElement queryAnno = elementUtils.getTypeElement(&quot;com.ethnicthv.ecs.core.system.annotation.Query&quot;);&#10;        if (queryAnno == null) return false;&#10;&#10;        Map&lt;TypeElement, List&lt;ExecutableElement&gt;&gt; byClass = new LinkedHashMap&lt;&gt;();&#10;        for (Element e : roundEnv.getElementsAnnotatedWith(queryAnno)) {&#10;            if (e.getKind() != ElementKind.METHOD) {&#10;                error(&quot;@Query can only be placed on methods: %s&quot;, e);&#10;                continue;&#10;            }&#10;            ExecutableElement method = (ExecutableElement) e;&#10;            TypeElement owner = (TypeElement) method.getEnclosingElement();&#10;            byClass.computeIfAbsent(owner, k -&gt; new ArrayList&lt;&gt;()).add(method);&#10;        }&#10;&#10;        for (Map.Entry&lt;TypeElement, List&lt;ExecutableElement&gt;&gt; entry : byClass.entrySet()) {&#10;            TypeElement owner = entry.getKey();&#10;            List&lt;ExecutableElement&gt; methods = entry.getValue();&#10;            try {&#10;                generateInjector(owner, methods);&#10;                for (ExecutableElement m : methods) generateRunner(owner, m);&#10;            } catch (IOException ex) {&#10;                error(&quot;Failed to generate for %s: %s&quot;, owner.getQualifiedName(), ex.getMessage());&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    private void generateInjector(TypeElement owner, List&lt;ExecutableElement&gt; methods) throws IOException {&#10;        String pkg = elementUtils.getPackageOf(owner).getQualifiedName().toString();&#10;        String simple = owner.getSimpleName().toString();&#10;        String ownerQualified = owner.getQualifiedName().toString();&#10;        String name = simple + &quot;__QueryInjector&quot;;&#10;        String fqn = pkg.isEmpty() ? name : pkg + &quot;.&quot; + name;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn, owner);&#10;        try (Writer w = file.openWriter()) {&#10;            if (!pkg.isEmpty()) w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            w.write(&quot;public final class &quot; + name + &quot; {\n&quot;);&#10;            w.write(&quot;  private &quot; + name + &quot;(){}\n&quot;);&#10;            w.write(&quot;  public static void inject(Object system, com.ethnicthv.ecs.core.archetype.ArchetypeWorld world) {\n&quot;);&#10;            w.write(&quot;    &quot; + ownerQualified + &quot; self = (&quot; + ownerQualified + &quot;) system;\n&quot;);&#10;            for (ExecutableElement m : methods) {&#10;                AnnotationMirror q = getAnnotation(m, &quot;com.ethnicthv.ecs.core.system.annotation.Query&quot;);&#10;                String fieldInject = readString(q, &quot;fieldInject&quot;);&#10;                if (fieldInject == null || fieldInject.isEmpty()) {&#10;                    error(&quot;@Query on %s missing fieldInject&quot;, m);&#10;                    continue;&#10;                }&#10;                String runner = simple + &quot;__&quot; + m.getSimpleName() + &quot;__QueryRunner&quot;;&#10;                w.write(&quot;    try {\n&quot;);&#10;                w.write(&quot;      java.lang.reflect.Field f = &quot; + ownerQualified + &quot;.class.getDeclaredField(\&quot;&quot; + fieldInject + &quot;\&quot;);\n&quot;);&#10;                w.write(&quot;      f.setAccessible(true);\n&quot;);&#10;                w.write(&quot;      f.set(self, new &quot; + runner + &quot;(world, self));\n&quot;);&#10;                w.write(&quot;    } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;            }&#10;            w.write(&quot;  }\n&quot;);&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    private void generateRunner(TypeElement owner, ExecutableElement method) throws IOException {&#10;        String pkg = elementUtils.getPackageOf(owner).getQualifiedName().toString();&#10;        String simple = owner.getSimpleName().toString();&#10;        String ownerQualified = owner.getQualifiedName().toString();&#10;        String name = simple + &quot;__&quot; + method.getSimpleName() + &quot;__QueryRunner&quot;;&#10;        String fqn = pkg.isEmpty() ? name : pkg + &quot;.&quot; + name;&#10;&#10;        // Collect parameter component classes from @Component(type=...)&#10;        List&lt;String&gt; paramComponentClasses = new ArrayList&lt;&gt;();&#10;        for (VariableElement p : method.getParameters()) {&#10;            AnnotationMirror compAnno = getAnnotation(p, &quot;com.ethnicthv.ecs.core.system.annotation.Component&quot;);&#10;            if (compAnno == null) {&#10;                error(&quot;All parameters must be annotated with @com.ethnicthv.ecs.core.system.annotation.Component: %s&quot;, p);&#10;                continue;&#10;            }&#10;            String typeClass = readTypeClass(compAnno, &quot;type&quot;);&#10;            if (typeClass == null) {&#10;                error(&quot;@Component on %s must specify type()&quot;, p);&#10;                continue;&#10;            }&#10;            paramComponentClasses.add(typeClass);&#10;        }&#10;&#10;        // Read query filters (with/without/any)&#10;        AnnotationMirror q = getAnnotation(method, &quot;com.ethnicthv.ecs.core.system.annotation.Query&quot;);&#10;        List&lt;String&gt; withClasses = readTypeArray(q, &quot;with&quot;);&#10;        List&lt;String&gt; withoutClasses = readTypeArray(q, &quot;without&quot;);&#10;        List&lt;String&gt; anyClasses = readTypeArray(q, &quot;any&quot;);&#10;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn, owner);&#10;        try (Writer w = file.openWriter()) {&#10;            if (!pkg.isEmpty()) w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            w.write(&quot;public final class &quot; + name + &quot; implements com.ethnicthv.ecs.core.api.archetype.IQuery {\n&quot;);&#10;            w.write(&quot;  private final com.ethnicthv.ecs.core.archetype.ArchetypeWorld world;\n&quot;);&#10;            w.write(&quot;  private final &quot; + ownerQualified + &quot; system;\n&quot;);&#10;            w.write(&quot;  private final java.lang.invoke.MethodHandle mh;\n&quot;);&#10;            // Precompute param classes array&#10;            w.write(&quot;  private static final Class&lt;?&gt;[] PARAM_CLASSES = new Class&lt;?&gt;[]{&quot;);&#10;            for (int i = 0; i &lt; paramComponentClasses.size(); i++) {&#10;                w.write(paramComponentClasses.get(i) + &quot;.class&quot;);&#10;                if (i &lt; paramComponentClasses.size()-1) w.write(&quot;, &quot;);&#10;            }&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;  public &quot; + name + &quot;(com.ethnicthv.ecs.core.archetype.ArchetypeWorld w, &quot; + ownerQualified + &quot; s){ this.world=w; this.system=s; this.mh=createMH(); }\n&quot;);&#10;&#10;            // MH builder&#10;            w.write(&quot;  private java.lang.invoke.MethodHandle createMH(){\n&quot;);&#10;            w.write(&quot;    try {\n&quot;);&#10;            w.write(&quot;      var lookup = java.lang.invoke.MethodHandles.lookup();\n&quot;);&#10;            w.write(&quot;      var prv = java.lang.invoke.MethodHandles.privateLookupIn(&quot; + ownerQualified + &quot;.class, lookup);\n&quot;);&#10;            // Build MethodType: (ComponentHandle, ...)&#10;            w.write(&quot;      var mt = java.lang.invoke.MethodType.methodType(void.class&quot;);&#10;            for (int i = 0; i &lt; paramComponentClasses.size(); i++) {&#10;                w.write(&quot;, com.ethnicthv.ecs.core.components.ComponentHandle.class&quot;);&#10;            }&#10;            w.write(&quot;);\n&quot;);&#10;            w.write(&quot;      return prv.findVirtual(&quot; + ownerQualified + &quot;.class, \&quot;&quot; + method.getSimpleName() + &quot;\&quot;, mt);\n&quot;);&#10;            w.write(&quot;    } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;            w.write(&quot;  }\n&quot;);&#10;&#10;            // runQuery implementation - sequential&#10;            w.write(&quot;  @Override public void runQuery(){\n&quot;);&#10;            w.write(&quot;    final var cm = world.getComponentManager();\n&quot;);&#10;            // Build paramIds&#10;            w.write(&quot;    final int paramCount = PARAM_CLASSES.length;\n&quot;);&#10;            w.write(&quot;    final int[] paramIds = new int[paramCount];\n&quot;);&#10;            w.write(&quot;    for (int i = 0; i &lt; paramCount; i++) { Integer id = world.getComponentTypeId(PARAM_CLASSES[i]); if (id == null) throw new IllegalStateException(\&quot;Component not registered: \&quot; + PARAM_CLASSES[i]); paramIds[i] = id; }\n&quot;);&#10;            // Build filter ids arrays&#10;            w.write(&quot;    final int[] withIds = new int[]{&quot;);&#10;            for (int i = 0; i &lt; withClasses.size(); i++) {&#10;                w.write(&quot;java.util.Objects.requireNonNull(world.getComponentTypeId(&quot; + withClasses.get(i) + &quot;.class)).intValue()&quot;);&#10;                if (i &lt; withClasses.size()-1) w.write(&quot;,&quot;);&#10;            }&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;    final int[] withoutIds = new int[]{&quot;);&#10;            for (int i = 0; i &lt; withoutClasses.size(); i++) {&#10;                w.write(&quot;java.util.Objects.requireNonNull(world.getComponentTypeId(&quot; + withoutClasses.get(i) + &quot;.class)).intValue()&quot;);&#10;                if (i &lt; withoutClasses.size()-1) w.write(&quot;,&quot;);&#10;            }&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;    final int[] anyIds = new int[]{&quot;);&#10;            for (int i = 0; i &lt; anyClasses.size(); i++) {&#10;                w.write(&quot;java.util.Objects.requireNonNull(world.getComponentTypeId(&quot; + anyClasses.get(i) + &quot;.class)).intValue()&quot;);&#10;                if (i &lt; anyClasses.size()-1) w.write(&quot;,&quot;);&#10;            }&#10;            w.write(&quot;};\n&quot;);&#10;&#10;            // Iterate archetypes&#10;            w.write(&quot;    for (com.ethnicthv.ecs.core.archetype.Archetype archetype : world.getAllArchetypes()) {\n&quot;);&#10;            // Apply with/without/any filters by IDs&#10;            w.write(&quot;      boolean ok = true;\n&quot;);&#10;            w.write(&quot;      // WITH\n&quot;);&#10;            w.write(&quot;      for (int id : withIds) { if (archetype.indexOfComponentType(id) &lt; 0) { ok = false; break; } }\n&quot;);&#10;            w.write(&quot;      if (!ok) continue;\n&quot;);&#10;            w.write(&quot;      // WITHOUT\n&quot;);&#10;            w.write(&quot;      for (int id : withoutIds) { if (archetype.indexOfComponentType(id) &gt;= 0) { ok = false; break; } }\n&quot;);&#10;            w.write(&quot;      if (!ok) continue;\n&quot;);&#10;            w.write(&quot;      // ANY\n&quot;);&#10;            w.write(&quot;      if (anyIds.length &gt; 0) { boolean any=false; for (int id : anyIds) { if (archetype.indexOfComponentType(id) &gt;= 0) { any=true; break; } } if (!any) continue; }\n&quot;);&#10;&#10;            // Resolve component indices for parameters for this archetype&#10;            w.write(&quot;      final int[] compIdx = new int[paramCount];\n&quot;);&#10;            w.write(&quot;      for (int i = 0; i &lt; paramCount; i++) { compIdx[i] = archetype.indexOfComponentType(paramIds[i]); if (compIdx[i] &lt; 0) { ok=false; break; } }\n&quot;);&#10;            w.write(&quot;      if (!ok) continue;\n&quot;);&#10;&#10;            // Iterate chunks&#10;            w.write(&quot;      for (com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk ch : archetype.getChunks()) {\n&quot;);&#10;            w.write(&quot;        final int cap = ch.getCapacity();\n&quot;);&#10;            w.write(&quot;        for (int ei = 0; ei &lt; cap; ei++) { int eid = ch.getEntityId(ei); if (eid == -1) continue;\n&quot;);&#10;            // Acquire bound handles&#10;            w.write(&quot;          com.ethnicthv.ecs.core.components.ComponentManager.BoundHandle[] bound = new com.ethnicthv.ecs.core.components.ComponentManager.BoundHandle[paramCount];\n&quot;);&#10;            w.write(&quot;          try {\n&quot;);&#10;            w.write(&quot;            for (int k = 0; k &lt; paramCount; k++) { var seg = ch.getComponentData(compIdx[k], ei); bound[k] = cm.acquireBoundHandle(PARAM_CLASSES[k], seg); }\n&quot;);&#10;            // Build args and invoke mh&#10;            w.write(&quot;            Object[] args = new Object[paramCount + 1]; args[0] = system;\n&quot;);&#10;            w.write(&quot;            for (int k = 0; k &lt; paramCount; k++) args[k+1] = bound[k].handle();\n&quot;);&#10;            w.write(&quot;            mh.invokeWithArguments(java.util.Arrays.asList(args));\n&quot;);&#10;            w.write(&quot;          } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;            w.write(&quot;          finally { for (int k = 0; k &lt; paramCount; k++) { if (bound[k] != null) try { bound[k].close(); } catch (Exception ignore) {} } }\n&quot;);&#10;            w.write(&quot;        }\n&quot;);&#10;            w.write(&quot;      }\n&quot;);&#10;            w.write(&quot;    }\n&quot;);&#10;            w.write(&quot;  }\n&quot;);&#10;&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    private AnnotationMirror getAnnotation(Element e, String fqn) {&#10;        for (AnnotationMirror am : e.getAnnotationMirrors()) {&#10;            if (((TypeElement) am.getAnnotationType().asElement()).getQualifiedName().contentEquals(fqn)) return am;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private String readString(AnnotationMirror am, String name) {&#10;        if (am == null) return null;&#10;        for (Map.Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; e : am.getElementValues().entrySet()) {&#10;            if (e.getKey().getSimpleName().contentEquals(name)) return String.valueOf(e.getValue().getValue());&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private List&lt;String&gt; readTypeArray(AnnotationMirror am, String name) {&#10;        List&lt;String&gt; out = new ArrayList&lt;&gt;();&#10;        if (am == null) return out;&#10;        for (Map.Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; e : am.getElementValues().entrySet()) {&#10;            if (!e.getKey().getSimpleName().contentEquals(name)) continue;&#10;            Object v = e.getValue().getValue();&#10;            if (v instanceof List&lt;?&gt; list) {&#10;                for (Object o : list) {&#10;                    Object ev = ((AnnotationValue) o).getValue();&#10;                    out.add(ev.toString()); // returns class literal string like com.Foo.class&#10;                    // We need the class name without &quot;.class&quot;&#10;                    if (out.get(out.size()-1).endsWith(&quot;.class&quot;)) {&#10;                        String s = out.get(out.size()-1);&#10;                        out.set(out.size()-1, s.substring(0, s.length()-6));&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return out;&#10;    }&#10;&#10;    private String readTypeClass(AnnotationMirror am, String name) {&#10;        if (am == null) return null;&#10;        for (Map.Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; e : am.getElementValues().entrySet()) {&#10;            if (!e.getKey().getSimpleName().contentEquals(name)) continue;&#10;            String s = String.valueOf(e.getValue().getValue());&#10;            if (s.endsWith(&quot;.class&quot;)) return s.substring(0, s.length()-6);&#10;            return s;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private void error(String fmt, Object... args) {&#10;        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, String.format(java.util.Locale.ROOT, fmt, args));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.processor;&#10;&#10;import javax.annotation.processing.*;&#10;import javax.lang.model.SourceVersion;&#10;import javax.lang.model.element.*;&#10;import javax.lang.model.util.Elements;&#10;import javax.tools.Diagnostic;&#10;import javax.tools.JavaFileObject;&#10;import java.io.IOException;&#10;import java.io.Writer;&#10;import java.util.*;&#10;&#10;@SupportedAnnotationTypes({&#10;    &quot;com.ethnicthv.ecs.core.system.annotation.Query&quot;&#10;})&#10;@SupportedSourceVersion(SourceVersion.RELEASE_25)&#10;public class QueryProcessor extends AbstractProcessor {&#10;    private Elements elementUtils;&#10;&#10;    @Override&#10;    public synchronized void init(ProcessingEnvironment processingEnv) {&#10;        super.init(processingEnv);&#10;        this.elementUtils = processingEnv.getElementUtils();&#10;    }&#10;&#10;    @Override&#10;    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {&#10;        TypeElement queryAnno = elementUtils.getTypeElement(&quot;com.ethnicthv.ecs.core.system.annotation.Query&quot;);&#10;        if (queryAnno == null) return false;&#10;&#10;        Map&lt;TypeElement, List&lt;ExecutableElement&gt;&gt; byClass = new LinkedHashMap&lt;&gt;();&#10;        for (Element e : roundEnv.getElementsAnnotatedWith(queryAnno)) {&#10;            if (e.getKind() != ElementKind.METHOD) {&#10;                error(&quot;@Query can only be placed on methods: %s&quot;, e);&#10;                continue;&#10;            }&#10;            ExecutableElement method = (ExecutableElement) e;&#10;            TypeElement owner = (TypeElement) method.getEnclosingElement();&#10;            byClass.computeIfAbsent(owner, k -&gt; new ArrayList&lt;&gt;()).add(method);&#10;        }&#10;&#10;        for (Map.Entry&lt;TypeElement, List&lt;ExecutableElement&gt;&gt; entry : byClass.entrySet()) {&#10;            TypeElement owner = entry.getKey();&#10;            List&lt;ExecutableElement&gt; methods = entry.getValue();&#10;            try {&#10;                generateInjector(owner, methods);&#10;                for (ExecutableElement m : methods) generateRunner(owner, m);&#10;            } catch (IOException ex) {&#10;                error(&quot;Failed to generate for %s: %s&quot;, owner.getQualifiedName(), ex.getMessage());&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    private void generateInjector(TypeElement owner, List&lt;ExecutableElement&gt; methods) throws IOException {&#10;        String pkg = elementUtils.getPackageOf(owner).getQualifiedName().toString();&#10;        String simple = owner.getSimpleName().toString();&#10;        String ownerQualified = owner.getQualifiedName().toString();&#10;        String name = simple + &quot;__QueryInjector&quot;;&#10;        String fqn = pkg.isEmpty() ? name : pkg + &quot;.&quot; + name;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn, owner);&#10;        try (Writer w = file.openWriter()) {&#10;            if (!pkg.isEmpty()) w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            w.write(&quot;public final class &quot; + name + &quot; {\n&quot;);&#10;            w.write(&quot;  private &quot; + name + &quot;(){}\n&quot;);&#10;            w.write(&quot;  public static void inject(Object system, com.ethnicthv.ecs.core.archetype.ArchetypeWorld world) {\n&quot;);&#10;            w.write(&quot;    &quot; + ownerQualified + &quot; self = (&quot; + ownerQualified + &quot;) system;\n&quot;);&#10;            for (ExecutableElement m : methods) {&#10;                AnnotationMirror q = getAnnotation(m, &quot;com.ethnicthv.ecs.core.system.annotation.Query&quot;);&#10;                String fieldInject = readString(q, &quot;fieldInject&quot;);&#10;                if (fieldInject == null || fieldInject.isEmpty()) {&#10;                    error(&quot;@Query on %s missing fieldInject&quot;, m);&#10;                    continue;&#10;                }&#10;                String runner = simple + &quot;__&quot; + m.getSimpleName() + &quot;__QueryRunner&quot;;&#10;                w.write(&quot;    try {\n&quot;);&#10;                w.write(&quot;      java.lang.reflect.Field f = &quot; + ownerQualified + &quot;.class.getDeclaredField(\&quot;&quot; + fieldInject + &quot;\&quot;);\n&quot;);&#10;                w.write(&quot;      f.setAccessible(true);\n&quot;);&#10;                w.write(&quot;      f.set(self, new &quot; + runner + &quot;(world, self));\n&quot;);&#10;                w.write(&quot;    } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;            }&#10;            w.write(&quot;  }\n&quot;);&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    private void generateRunner(TypeElement owner, ExecutableElement method) throws IOException {&#10;        String pkg = elementUtils.getPackageOf(owner).getQualifiedName().toString();&#10;        String simple = owner.getSimpleName().toString();&#10;        String ownerQualified = owner.getQualifiedName().toString();&#10;        String name = simple + &quot;__&quot; + method.getSimpleName() + &quot;__QueryRunner&quot;;&#10;        String fqn = pkg.isEmpty() ? name : pkg + &quot;.&quot; + name;&#10;&#10;        // Collect parameter component classes from @Component(type=...)&#10;        List&lt;String&gt; paramComponentClasses = new ArrayList&lt;&gt;();&#10;        for (VariableElement p : method.getParameters()) {&#10;            AnnotationMirror compAnno = getAnnotation(p, &quot;com.ethnicthv.ecs.core.system.annotation.Component&quot;);&#10;            if (compAnno == null) {&#10;                error(&quot;All parameters must be annotated with @com.ethnicthv.ecs.core.system.annotation.Component: %s&quot;, p);&#10;                continue;&#10;            }&#10;            String typeClass = readTypeClass(compAnno, &quot;type&quot;);&#10;            if (typeClass == null) {&#10;                error(&quot;@Component on %s must specify type()&quot;, p);&#10;                continue;&#10;            }&#10;            paramComponentClasses.add(typeClass);&#10;        }&#10;&#10;        // Read query filters (with/without/any)&#10;        AnnotationMirror q = getAnnotation(method, &quot;com.ethnicthv.ecs.core.system.annotation.Query&quot;);&#10;        List&lt;String&gt; withClasses = readTypeArray(q, &quot;with&quot;);&#10;        List&lt;String&gt; withoutClasses = readTypeArray(q, &quot;without&quot;);&#10;        List&lt;String&gt; anyClasses = readTypeArray(q, &quot;any&quot;);&#10;&#10;        JavaFileObject file = processingEnv.getFiler().createSourceFile(fqn, owner);&#10;        try (Writer w = file.openWriter()) {&#10;            if (!pkg.isEmpty()) w.write(&quot;package &quot; + pkg + &quot;;\n\n&quot;);&#10;            w.write(&quot;@SuppressWarnings(\&quot;all\&quot;)\n&quot;);&#10;            w.write(&quot;public final class &quot; + name + &quot; implements com.ethnicthv.ecs.core.api.archetype.IQuery {\n&quot;);&#10;            w.write(&quot;  private final com.ethnicthv.ecs.core.archetype.ArchetypeWorld world;\n&quot;);&#10;            w.write(&quot;  private final &quot; + ownerQualified + &quot; system;\n&quot;);&#10;            w.write(&quot;  private final java.lang.invoke.MethodHandle mh;\n&quot;);&#10;            // Precompute param classes array&#10;            w.write(&quot;  private static final Class&lt;?&gt;[] PARAM_CLASSES = new Class&lt;?&gt;[]{&quot;);&#10;            for (int i = 0; i &lt; paramComponentClasses.size(); i++) {&#10;                w.write(paramComponentClasses.get(i) + &quot;.class&quot;);&#10;                if (i &lt; paramComponentClasses.size()-1) w.write(&quot;, &quot;);&#10;            }&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;  public &quot; + name + &quot;(com.ethnicthv.ecs.core.archetype.ArchetypeWorld w, &quot; + ownerQualified + &quot; s){ this.world=w; this.system=s; this.mh=createMH(); }\n&quot;);&#10;&#10;            // MH builder&#10;            w.write(&quot;  private java.lang.invoke.MethodHandle createMH(){\n&quot;);&#10;            w.write(&quot;    try {\n&quot;);&#10;            w.write(&quot;      var lookup = java.lang.invoke.MethodHandles.lookup();\n&quot;);&#10;            w.write(&quot;      var prv = java.lang.invoke.MethodHandles.privateLookupIn(&quot; + ownerQualified + &quot;.class, lookup);\n&quot;);&#10;            // Build MethodType: (ComponentHandle, ...)&#10;            w.write(&quot;      var mt = java.lang.invoke.MethodType.methodType(void.class&quot;);&#10;            for (int i = 0; i &lt; paramComponentClasses.size(); i++) {&#10;                w.write(&quot;, com.ethnicthv.ecs.core.components.ComponentHandle.class&quot;);&#10;            }&#10;            w.write(&quot;);\n&quot;);&#10;            w.write(&quot;      return prv.findVirtual(&quot; + ownerQualified + &quot;.class, \&quot;&quot; + method.getSimpleName() + &quot;\&quot;, mt);\n&quot;);&#10;            w.write(&quot;    } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;            w.write(&quot;  }\n&quot;);&#10;&#10;            // runQuery implementation - sequential&#10;            w.write(&quot;  @Override public void runQuery(){\n&quot;);&#10;            w.write(&quot;    final var cm = world.getComponentManager();\n&quot;);&#10;            // Build paramIds&#10;            w.write(&quot;    final int paramCount = PARAM_CLASSES.length;\n&quot;);&#10;            w.write(&quot;    final int[] paramIds = new int[paramCount];\n&quot;);&#10;            w.write(&quot;    for (int i = 0; i &lt; paramCount; i++) { Integer id = world.getComponentTypeId(PARAM_CLASSES[i]); if (id == null) throw new IllegalStateException(\&quot;Component not registered: \&quot; + PARAM_CLASSES[i]); paramIds[i] = id; }\n&quot;);&#10;            // Build filter ids arrays&#10;            w.write(&quot;    final int[] withIds = new int[]{&quot;);&#10;            for (int i = 0; i &lt; withClasses.size(); i++) {&#10;                w.write(&quot;java.util.Objects.requireNonNull(world.getComponentTypeId(&quot; + withClasses.get(i) + &quot;.class)).intValue()&quot;);&#10;                if (i &lt; withClasses.size()-1) w.write(&quot;,&quot;);&#10;            }&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;    final int[] withoutIds = new int[]{&quot;);&#10;            for (int i = 0; i &lt; withoutClasses.size(); i++) {&#10;                w.write(&quot;java.util.Objects.requireNonNull(world.getComponentTypeId(&quot; + withoutClasses.get(i) + &quot;.class)).intValue()&quot;);&#10;                if (i &lt; withoutClasses.size()-1) w.write(&quot;,&quot;);&#10;            }&#10;            w.write(&quot;};\n&quot;);&#10;            w.write(&quot;    final int[] anyIds = new int[]{&quot;);&#10;            for (int i = 0; i &lt; anyClasses.size(); i++) {&#10;                w.write(&quot;java.util.Objects.requireNonNull(world.getComponentTypeId(&quot; + anyClasses.get(i) + &quot;.class)).intValue()&quot;);&#10;                if (i &lt; anyClasses.size()-1) w.write(&quot;,&quot;);&#10;            }&#10;            w.write(&quot;};\n&quot;);&#10;&#10;            // Iterate archetypes&#10;            w.write(&quot;    for (com.ethnicthv.ecs.core.archetype.Archetype archetype : world.getAllArchetypes()) {\n&quot;);&#10;            // Apply with/without/any filters by IDs&#10;            w.write(&quot;      boolean ok = true;\n&quot;);&#10;            w.write(&quot;      // WITH\n&quot;);&#10;            w.write(&quot;      for (int id : withIds) { if (archetype.indexOfComponentType(id) &lt; 0) { ok = false; break; } }\n&quot;);&#10;            w.write(&quot;      if (!ok) continue;\n&quot;);&#10;            w.write(&quot;      // WITHOUT\n&quot;);&#10;            w.write(&quot;      for (int id : withoutIds) { if (archetype.indexOfComponentType(id) &gt;= 0) { ok = false; break; } }\n&quot;);&#10;            w.write(&quot;      if (!ok) continue;\n&quot;);&#10;            w.write(&quot;      // ANY\n&quot;);&#10;            w.write(&quot;      if (anyIds.length &gt; 0) { boolean any=false; for (int id : anyIds) { if (archetype.indexOfComponentType(id) &gt;= 0) { any=true; break; } } if (!any) continue; }\n&quot;);&#10;&#10;            // Resolve component indices for parameters for this archetype&#10;            w.write(&quot;      final int[] compIdx = new int[paramCount];\n&quot;);&#10;            w.write(&quot;      for (int i = 0; i &lt; paramCount; i++) { compIdx[i] = archetype.indexOfComponentType(paramIds[i]); if (compIdx[i] &lt; 0) { ok=false; break; } }\n&quot;);&#10;            w.write(&quot;      if (!ok) continue;\n&quot;);&#10;&#10;            // Iterate chunks&#10;            w.write(&quot;      for (com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk ch : archetype.getChunks()) {\n&quot;);&#10;            w.write(&quot;        final int cap = ch.getCapacity();\n&quot;);&#10;            w.write(&quot;        for (int ei = 0; ei &lt; cap; ei++) { int eid = ch.getEntityId(ei); if (eid == -1) continue;\n&quot;);&#10;            // Acquire bound handles&#10;            w.write(&quot;          com.ethnicthv.ecs.core.components.ComponentManager.BoundHandle[] bound = new com.ethnicthv.ecs.core.components.ComponentManager.BoundHandle[paramCount];\n&quot;);&#10;            w.write(&quot;          try {\n&quot;);&#10;            w.write(&quot;            for (int k = 0; k &lt; paramCount; k++) { var seg = ch.getComponentData(compIdx[k], ei); bound[k] = cm.acquireBoundHandle(PARAM_CLASSES[k], seg); }\n&quot;);&#10;            // Build args and invoke mh&#10;            w.write(&quot;            Object[] args = new Object[paramCount + 1]; args[0] = system;\n&quot;);&#10;            w.write(&quot;            for (int k = 0; k &lt; paramCount; k++) args[k+1] = bound[k].handle();\n&quot;);&#10;            w.write(&quot;            mh.invokeWithArguments(java.util.Arrays.asList(args));\n&quot;);&#10;            w.write(&quot;          } catch (Throwable t) { throw new RuntimeException(t); }\n&quot;);&#10;            w.write(&quot;          finally { for (int k = 0; k &lt; paramCount; k++) { if (bound[k] != null) try { bound[k].close(); } catch (Exception ignore) {} } }\n&quot;);&#10;            w.write(&quot;        }\n&quot;);&#10;            w.write(&quot;      }\n&quot;);&#10;            w.write(&quot;    }\n&quot;);&#10;            w.write(&quot;  }\n&quot;);&#10;&#10;            w.write(&quot;}\n&quot;);&#10;        }&#10;    }&#10;&#10;    private AnnotationMirror getAnnotation(Element e, String fqn) {&#10;        for (AnnotationMirror am : e.getAnnotationMirrors()) {&#10;            if (((TypeElement) am.getAnnotationType().asElement()).getQualifiedName().contentEquals(fqn)) return am;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private String readString(AnnotationMirror am, String name) {&#10;        if (am == null) return null;&#10;        for (Map.Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; e : am.getElementValues().entrySet()) {&#10;            if (e.getKey().getSimpleName().contentEquals(name)) return String.valueOf(e.getValue().getValue());&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private List&lt;String&gt; readTypeArray(AnnotationMirror am, String name) {&#10;        List&lt;String&gt; out = new ArrayList&lt;&gt;();&#10;        if (am == null) return out;&#10;        for (Map.Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; e : am.getElementValues().entrySet()) {&#10;            if (!e.getKey().getSimpleName().contentEquals(name)) continue;&#10;            Object v = e.getValue().getValue();&#10;            if (v instanceof List&lt;?&gt; list) {&#10;                for (Object o : list) {&#10;                    Object ev = ((AnnotationValue) o).getValue();&#10;                    out.add(ev.toString()); // returns class literal string like com.Foo.class&#10;                    // We need the class name without &quot;.class&quot;&#10;                    if (out.get(out.size()-1).endsWith(&quot;.class&quot;)) {&#10;                        String s = out.get(out.size()-1);&#10;                        out.set(out.size()-1, s.substring(0, s.length()-6));&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return out;&#10;    }&#10;&#10;    private String readTypeClass(AnnotationMirror am, String name) {&#10;        if (am == null) return null;&#10;        for (Map.Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; e : am.getElementValues().entrySet()) {&#10;            if (!e.getKey().getSimpleName().contentEquals(name)) continue;&#10;            String s = String.valueOf(e.getValue().getValue());&#10;            if (s.endsWith(&quot;.class&quot;)) return s.substring(0, s.length()-6);&#10;            return s;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private void error(String fmt, Object... args) {&#10;        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, String.format(java.util.Locale.ROOT, fmt, args));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/jmh/java/com/ethnicthv/ecs/benchmark/ComponentManagerBenchmark.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/jmh/java/com/ethnicthv/ecs/benchmark/ComponentManagerBenchmark.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.benchmark;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import com.ethnicthv.ecs.core.components.ComponentHandle;&#10;import com.ethnicthv.ecs.demo.HealthComponent;&#10;import com.ethnicthv.ecs.demo.PositionComponent;&#10;import com.ethnicthv.ecs.demo.TransformComponent;&#10;import com.ethnicthv.ecs.demo.VelocityComponent;&#10;import org.openjdk.jmh.annotations.*;&#10;import org.openjdk.jmh.infra.Blackhole;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Comprehensive benchmark for Component Manager + Archetype ECS system using JMH.&#10; */&#10;@BenchmarkMode(Mode.AverageTime)&#10;@OutputTimeUnit(TimeUnit.MILLISECONDS)&#10;@State(Scope.Benchmark)&#10;@Fork(value = 1, jvmArgs = {&quot;-Xms2G&quot;, &quot;-Xmx4G&quot;, &quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;})&#10;@Warmup(iterations = 3, time = 1)&#10;@Measurement(iterations = 5, time = 1)&#10;public class ComponentManagerBenchmark {&#10;&#10;    @State(Scope.Thread)&#10;    public static class BenchmarkState {&#10;        @Param({&quot;10&quot;, &quot;100&quot;, &quot;1000&quot;, &quot;10000&quot;, &quot;100000&quot;, &quot;1000000&quot;})&#10;        public int entityCount;&#10;&#10;        public ComponentManager manager;&#10;        public ArchetypeWorld world;&#10;        public Arena arena;&#10;&#10;        // For specific benchmarks&#10;        public int[] entities;&#10;        public int POS_X, POS_Y, VEL_VX, VEL_VY;&#10;&#10;&#10;        @Setup(Level.Invocation)&#10;        public void setupInvocation() {&#10;            manager = new ComponentManager();&#10;            world = new ArchetypeWorld(manager);&#10;            arena = Arena.ofConfined();&#10;&#10;            // Register common components&#10;            world.registerComponent(PositionComponent.class);&#10;            world.registerComponent(VelocityComponent.class);&#10;            world.registerComponent(TransformComponent.class);&#10;            world.registerComponent(HealthComponent.class);&#10;&#10;            // Resolve field indices&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;            VEL_VX = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vx&quot;);&#10;            VEL_VY = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vy&quot;);&#10;&#10;            // Pre-create entities for benchmarks that need them&#10;            entities = new int[entityCount];&#10;            for (int i = 0; i &lt; entityCount; i++) {&#10;                entities[i] = world.createEntity();&#10;            }&#10;        }&#10;&#10;        @TearDown(Level.Invocation)&#10;        public void teardownInvocation() {&#10;            world.close();&#10;            arena.close();&#10;            System.gc(); // Suggest GC between invocations&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void componentRegistration(Blackhole bh) {&#10;        ComponentManager manager = new ComponentManager();&#10;        bh.consume(manager.registerComponent(PositionComponent.class));&#10;        bh.consume(manager.registerComponent(VelocityComponent.class));&#10;        bh.consume(manager.registerComponent(TransformComponent.class));&#10;        bh.consume(manager.registerComponent(HealthComponent.class));&#10;    }&#10;&#10;    @Benchmark&#10;    public void entityCreation(BenchmarkState state, Blackhole bh) {&#10;        for (int i = 0; i &lt; state.entityCount; i++) {&#10;            bh.consume(state.world.createEntity());&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void componentAddition(BenchmarkState state) {&#10;        for (int i = 0; i &lt; state.entityCount; i++) {&#10;            MemorySegment pos = state.manager.allocate(PositionComponent.class, state.arena);&#10;            try (ComponentManager.BoundHandle h = state.manager.acquireBoundHandle(PositionComponent.class, pos)) {&#10;                h.handle().setFloat(state.POS_X, i);&#10;                h.handle().setFloat(state.POS_Y, i * 2);&#10;            }&#10;            state.world.addComponent(state.entities[i], PositionComponent.class, pos);&#10;        }&#10;    }&#10;&#10;    @State(Scope.Thread)&#10;    public static class QueryState {&#10;        @Param({&quot;10&quot;, &quot;100&quot;, &quot;1000&quot;, &quot;10000&quot;, &quot;100000&quot;, &quot;1000000&quot;})&#10;        public int entityCount;&#10;&#10;        public ComponentManager manager;&#10;        public ArchetypeWorld world;&#10;        public Arena arena;&#10;        public int POS_X, POS_Y, VEL_VX, VEL_VY;&#10;&#10;        @Setup(Level.Trial)&#10;        public void setupTrial() {&#10;            manager = new ComponentManager();&#10;            world = new ArchetypeWorld(manager);&#10;            arena = Arena.ofConfined();&#10;&#10;            world.registerComponent(PositionComponent.class);&#10;            world.registerComponent(VelocityComponent.class);&#10;&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;            VEL_VX = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vx&quot;);&#10;            VEL_VY = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vy&quot;);&#10;&#10;            // Setup entities&#10;            for (int i = 0; i &lt; entityCount; i++) {&#10;                int e = world.createEntity();&#10;&#10;                MemorySegment pos = manager.allocate(PositionComponent.class, arena);&#10;                try(var h = manager.acquireBoundHandle(PositionComponent.class, pos)) {&#10;                    h.handle().setFloat(POS_X, i);&#10;                    h.handle().setFloat(POS_Y, i * 2);&#10;                }&#10;                world.addComponent(e, PositionComponent.class, pos);&#10;&#10;                if (i % 2 == 0) { // 50% have velocity&#10;                    MemorySegment vel = manager.allocate(VelocityComponent.class, arena);&#10;                    try(var h = manager.acquireBoundHandle(VelocityComponent.class, vel)) {&#10;                        h.handle().setFloat(VEL_VX, 1.0f);&#10;                        h.handle().setFloat(VEL_VY, -1.0f);&#10;                    }&#10;                    world.addComponent(e, VelocityComponent.class, vel);&#10;                }&#10;            }&#10;        }&#10;&#10;        @TearDown(Level.Trial)&#10;        public void teardownTrial() {&#10;            world.close();&#10;            arena.close();&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void queryIteration_ReadWrite(QueryState state, Blackhole bh) {&#10;        final int[] count = {0};&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachEntity((_, handles, _) -&gt; {&#10;            float x = handles[0].getFloat(state.POS_X);&#10;            float y = handles[0].getFloat(state.POS_Y);&#10;            float vx = handles[1].getFloat(state.VEL_VX);&#10;            float vy = handles[1].getFloat(state.VEL_VY);&#10;            // Simple computation to prevent optimization&#10;            bh.consume(x + y + vx + vy);&#10;            count[0]++;&#10;        });&#10;        bh.consume(count[0]);&#10;    }&#10;&#10;    @Benchmark&#10;    public void queryIteration_Update(QueryState state) {&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachEntity((_, handles, _) -&gt; {&#10;            float x = handles[0].getFloat(state.POS_X);&#10;            float vx = handles[1].getFloat(state.VEL_VX);&#10;            handles[0].setFloat(state.POS_X, x + vx);&#10;        });&#10;    }&#10;&#10;&#10;    @State(Scope.Thread)&#10;    public static class HandleState {&#10;        public ComponentManager manager;&#10;        public Arena arena;&#10;        public MemorySegment segment;&#10;        public int POS_X, POS_Y;&#10;&#10;        @Setup(Level.Trial)&#10;        public void setup() {&#10;            manager = new ComponentManager();&#10;            manager.registerComponent(PositionComponent.class);&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;            arena = Arena.ofConfined();&#10;            segment = manager.allocate(PositionComponent.class, arena);&#10;        }&#10;&#10;        @TearDown(Level.Trial)&#10;        public void teardown() {&#10;            arena.close();&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void handlePooling_CreateRelease(HandleState state, Blackhole bh) {&#10;        ComponentHandle h = state.manager.createHandle(PositionComponent.class, state.segment);&#10;        h.setFloat(state.POS_X, 1f);&#10;        h.setFloat(state.POS_Y, 2f);&#10;        bh.consume(h.getFloat(state.POS_X));&#10;        state.manager.releaseHandle(h);&#10;    }&#10;&#10;    @Benchmark&#10;    public void handlePooling_BoundHandle(HandleState state, Blackhole bh) {&#10;        try (ComponentManager.BoundHandle h = state.manager.acquireBoundHandle(PositionComponent.class, state.segment)) {&#10;            h.handle().setFloat(state.POS_X, 1f);&#10;            h.handle().setFloat(state.POS_Y, 2f);&#10;            bh.consume(h.handle().getFloat(state.POS_X));&#10;        }&#10;    }&#10;&#10;    @State(Scope.Thread)&#10;    public static class MigrationState {&#10;        public ComponentManager manager;&#10;        public ArchetypeWorld world;&#10;        public Arena arena;&#10;        public int[] entities;&#10;        public int POS_X, POS_Y, VEL_VX, VEL_VY;&#10;        public final int MIGRATION_COUNT = 10_000;&#10;&#10;        @Setup(Level.Invocation) // Re-setup for each benchmark run&#10;        public void setup() {&#10;            manager = new ComponentManager();&#10;            world = new ArchetypeWorld(manager);&#10;            arena = Arena.ofConfined();&#10;            world.registerComponent(PositionComponent.class);&#10;            world.registerComponent(VelocityComponent.class);&#10;&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;            VEL_VX = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vx&quot;);&#10;            VEL_VY = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vy&quot;);&#10;&#10;            entities = new int[MIGRATION_COUNT];&#10;            for (int i = 0; i &lt; MIGRATION_COUNT; i++) {&#10;                entities[i] = world.createEntity();&#10;                MemorySegment pos = manager.allocate(PositionComponent.class, arena);&#10;                try(var h = manager.acquireBoundHandle(PositionComponent.class, pos)) {&#10;                    h.handle().setFloat(POS_X, i);&#10;                    h.handle().setFloat(POS_Y, i * 2);&#10;                }&#10;                world.addComponent(entities[i], PositionComponent.class, pos);&#10;            }&#10;        }&#10;&#10;        @TearDown(Level.Invocation)&#10;        public void teardown() {&#10;            world.close();&#10;            arena.close();&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void archetypeMigration(MigrationState state) {&#10;        for (int i = 0; i &lt; state.MIGRATION_COUNT; i++) {&#10;            MemorySegment vel = state.manager.allocate(VelocityComponent.class, state.arena);&#10;            try(var h = state.manager.acquireBoundHandle(VelocityComponent.class, vel)) {&#10;                h.handle().setFloat(state.VEL_VX, 1.0f);&#10;                h.handle().setFloat(state.VEL_VY, -1.0f);&#10;            }&#10;            state.world.addComponent(state.entities[i], VelocityComponent.class, vel);&#10;        }&#10;    }&#10;&#10;    // ========== Large Scale Benchmarks ==========&#10;&#10;    @State(Scope.Thread)&#10;    public static class LargeScaleState {&#10;        @Param({&quot;10&quot;, &quot;100&quot;, &quot;1000&quot;, &quot;10000&quot;, &quot;100000&quot;, &quot;1000000&quot;})&#10;        public int entityCount;&#10;&#10;        public ComponentManager manager;&#10;        public ArchetypeWorld world;&#10;        public Arena arena;&#10;        public int POS_X, POS_Y, VEL_VX, VEL_VY;&#10;&#10;        @Setup(Level.Trial)&#10;        public void setup() {&#10;            manager = new ComponentManager();&#10;            world = new ArchetypeWorld(manager);&#10;            arena = Arena.ofConfined();&#10;&#10;            world.registerComponent(PositionComponent.class);&#10;            world.registerComponent(VelocityComponent.class);&#10;            world.registerComponent(TransformComponent.class);&#10;            world.registerComponent(HealthComponent.class);&#10;&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;            VEL_VX = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vx&quot;);&#10;            VEL_VY = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vy&quot;);&#10;&#10;            // Create entities with different archetypes for realistic scenario&#10;            for (int i = 0; i &lt; entityCount; i++) {&#10;                int e = world.createEntity();&#10;&#10;                // All entities have position&#10;                MemorySegment pos = manager.allocate(PositionComponent.class, arena);&#10;                try(var h = manager.acquireBoundHandle(PositionComponent.class, pos)) {&#10;                    h.handle().setFloat(POS_X, i * 0.1f);&#10;                    h.handle().setFloat(POS_Y, i * 0.2f);&#10;                }&#10;                world.addComponent(e, PositionComponent.class, pos);&#10;&#10;                // 70% have velocity&#10;                if (i % 10 &lt; 7) {&#10;                    MemorySegment vel = manager.allocate(VelocityComponent.class, arena);&#10;                    try(var h = manager.acquireBoundHandle(VelocityComponent.class, vel)) {&#10;                        h.handle().setFloat(VEL_VX, (i % 3 - 1) * 0.5f);&#10;                        h.handle().setFloat(VEL_VY, (i % 5 - 2) * 0.3f);&#10;                    }&#10;                    world.addComponent(e, VelocityComponent.class, vel);&#10;                }&#10;&#10;                // 30% have health&#10;                if (i % 10 &lt; 3) {&#10;                    MemorySegment health = manager.allocate(HealthComponent.class, arena);&#10;                    world.addComponent(e, HealthComponent.class, health);&#10;                }&#10;            }&#10;        }&#10;&#10;        @TearDown(Level.Trial)&#10;        public void teardown() {&#10;            world.close();&#10;            arena.close();&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void largeScale_SequentialQuery(LargeScaleState state, Blackhole bh) {&#10;        final int[] count = {0};&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachEntity((_, handles, _) -&gt; {&#10;                    float x = handles[0].getFloat(state.POS_X);&#10;                    float vx = handles[1].getFloat(state.VEL_VX);&#10;                    handles[0].setFloat(state.POS_X, x + vx * 0.016f);&#10;                    count[0]++;&#10;                });&#10;        bh.consume(count[0]);&#10;    }&#10;&#10;    @Benchmark&#10;    public void largeScale_ParallelQuery(LargeScaleState state, Blackhole bh) {&#10;        final int[] count = {0};&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachParallel((_, handles, _) -&gt; {&#10;                    float x = handles[0].getFloat(state.POS_X);&#10;                    float vx = handles[1].getFloat(state.VEL_VX);&#10;                    handles[0].setFloat(state.POS_X, x + vx * 0.016f);&#10;                    synchronized (count) {&#10;                        count[0]++;&#10;                    }&#10;                });&#10;        bh.consume(count[0]);&#10;    }&#10;&#10;    @Benchmark&#10;    public void largeScale_MultipleQueries(LargeScaleState state, Blackhole bh) {&#10;        // Simulate multiple systems running different queries&#10;        final int[] total = {0};&#10;&#10;        // Query 1: Position + Velocity (movement system)&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachEntity((_, handles, _) -&gt; {&#10;                    float x = handles[0].getFloat(state.POS_X);&#10;                    float vx = handles[1].getFloat(state.VEL_VX);&#10;                    handles[0].setFloat(state.POS_X, x + vx * 0.016f);&#10;                    total[0]++;&#10;                });&#10;&#10;        // Query 2: Position only (render system)&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .forEachEntity((_, handles, _) -&gt; {&#10;                    float x = handles[0].getFloat(state.POS_X);&#10;                    float y = handles[0].getFloat(state.POS_Y);&#10;                    bh.consume(x * x + y * y); // Distance calculation&#10;                    total[0]++;&#10;                });&#10;&#10;        bh.consume(total[0]);&#10;    }&#10;&#10;    @State(Scope.Thread)&#10;    public static class MemoryPressureState {&#10;        @Param({&quot;1000&quot;, &quot;10000&quot;, &quot;100000&quot;})&#10;        public int entityCount;&#10;&#10;        public ComponentManager manager;&#10;        public ArchetypeWorld world;&#10;        public Arena arena;&#10;        public int POS_X, POS_Y;&#10;&#10;        @Setup(Level.Invocation)&#10;        public void setup() {&#10;            manager = new ComponentManager();&#10;            world = new ArchetypeWorld(manager);&#10;            arena = Arena.ofConfined();&#10;&#10;            world.registerComponent(PositionComponent.class);&#10;            world.registerComponent(VelocityComponent.class);&#10;            world.registerComponent(TransformComponent.class);&#10;&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;        }&#10;&#10;        @TearDown(Level.Invocation)&#10;        public void teardown() {&#10;            world.close();&#10;            arena.close();&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void memoryPressure_CreateAndDestroy(MemoryPressureState state) {&#10;        // Create entities&#10;        int[] entities = new int[state.entityCount];&#10;        for (int i = 0; i &lt; state.entityCount; i++) {&#10;            entities[i] = state.world.createEntity();&#10;            MemorySegment pos = state.manager.allocate(PositionComponent.class, state.arena);&#10;            try(var h = state.manager.acquireBoundHandle(PositionComponent.class, pos)) {&#10;                h.handle().setFloat(state.POS_X, i * 0.1f);&#10;                h.handle().setFloat(state.POS_Y, i * 0.2f);&#10;            }&#10;            state.world.addComponent(entities[i], PositionComponent.class, pos);&#10;        }&#10;&#10;        // Destroy half&#10;        for (int i = 0; i &lt; state.entityCount / 2; i++) {&#10;            state.world.destroyEntity(entities[i]);&#10;        }&#10;    }&#10;&#10;    @State(Scope.Thread)&#10;    public static class ThroughputState {&#10;        @Param({&quot;100000&quot;, &quot;1000000&quot;})&#10;        public int entityCount;&#10;&#10;        public ComponentManager manager;&#10;        public ArchetypeWorld world;&#10;        public Arena arena;&#10;        public int POS_X, POS_Y, VEL_VX, VEL_VY;&#10;&#10;        @Setup(Level.Trial)&#10;        public void setup() {&#10;            manager = new ComponentManager();&#10;            world = new ArchetypeWorld(manager);&#10;            arena = Arena.ofConfined();&#10;&#10;            world.registerComponent(PositionComponent.class);&#10;            world.registerComponent(VelocityComponent.class);&#10;&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;            VEL_VX = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vx&quot;);&#10;            VEL_VY = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vy&quot;);&#10;&#10;            // Setup entities for throughput test&#10;            for (int i = 0; i &lt; entityCount; i++) {&#10;                int e = world.createEntity();&#10;&#10;                MemorySegment pos = manager.allocate(PositionComponent.class, arena);&#10;                try(var h = manager.acquireBoundHandle(PositionComponent.class, pos)) {&#10;                    h.handle().setFloat(POS_X, i * 0.1f);&#10;                    h.handle().setFloat(POS_Y, i * 0.2f);&#10;                }&#10;                world.addComponent(e, PositionComponent.class, pos);&#10;&#10;                MemorySegment vel = manager.allocate(VelocityComponent.class, arena);&#10;                try(var h = manager.acquireBoundHandle(VelocityComponent.class, vel)) {&#10;                    h.handle().setFloat(VEL_VX, 1.0f);&#10;                    h.handle().setFloat(VEL_VY, -1.0f);&#10;                }&#10;                world.addComponent(e, VelocityComponent.class, vel);&#10;            }&#10;        }&#10;&#10;        @TearDown(Level.Trial)&#10;        public void teardown() {&#10;            world.close();&#10;            arena.close();&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void throughput_MaximalIteration(ThroughputState state, Blackhole bh) {&#10;        // Measure raw iteration throughput&#10;        long sum = 0;&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachEntity((eid, handles, _) -&gt; {&#10;                    bh.consume(eid);&#10;                });&#10;    }&#10;&#10;    @Benchmark&#10;    @BenchmarkMode(Mode.Throughput)&#10;    @OutputTimeUnit(TimeUnit.SECONDS)&#10;    public void throughput_EntitiesPerSecond(ThroughputState state) {&#10;        // Measure entities processed per second&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachEntity((_, handles, _) -&gt; {&#10;                    float x = handles[0].getFloat(state.POS_X);&#10;                    float y = handles[0].getFloat(state.POS_Y);&#10;                    float vx = handles[1].getFloat(state.VEL_VX);&#10;                    float vy = handles[1].getFloat(state.VEL_VY);&#10;                    handles[0].setFloat(state.POS_X, x + vx);&#10;                    handles[0].setFloat(state.POS_Y, y + vy);&#10;                });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.benchmark;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import com.ethnicthv.ecs.core.components.ComponentHandle;&#10;import com.ethnicthv.ecs.demo.HealthComponent;&#10;import com.ethnicthv.ecs.demo.PositionComponent;&#10;import com.ethnicthv.ecs.demo.TransformComponent;&#10;import com.ethnicthv.ecs.demo.VelocityComponent;&#10;import org.openjdk.jmh.annotations.*;&#10;import org.openjdk.jmh.infra.Blackhole;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Comprehensive benchmark for Component Manager + Archetype ECS system using JMH.&#10; */&#10;@BenchmarkMode(Mode.AverageTime)&#10;@OutputTimeUnit(TimeUnit.MILLISECONDS)&#10;@State(Scope.Benchmark)&#10;@Fork(value = 1, jvmArgs = {&quot;-Xms2G&quot;, &quot;-Xmx4G&quot;, &quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;})&#10;@Warmup(iterations = 3, time = 1)&#10;@Measurement(iterations = 5, time = 1)&#10;public class ComponentManagerBenchmark {&#10;&#10;    @State(Scope.Thread)&#10;    public static class BenchmarkState {&#10;        @Param({&quot;10&quot;, &quot;100&quot;, &quot;1000&quot;, &quot;10000&quot;, &quot;100000&quot;, &quot;1000000&quot;})&#10;        public int entityCount;&#10;&#10;        public ComponentManager manager;&#10;        public ArchetypeWorld world;&#10;        public Arena arena;&#10;&#10;        // For specific benchmarks&#10;        public int[] entities;&#10;        public int POS_X, POS_Y, VEL_VX, VEL_VY;&#10;&#10;&#10;        @Setup(Level.Invocation)&#10;        public void setupInvocation() {&#10;            manager = new ComponentManager();&#10;            world = new ArchetypeWorld(manager);&#10;            arena = Arena.ofConfined();&#10;&#10;            // Register common components&#10;            world.registerComponent(PositionComponent.class);&#10;            world.registerComponent(VelocityComponent.class);&#10;            world.registerComponent(TransformComponent.class);&#10;            world.registerComponent(HealthComponent.class);&#10;&#10;            // Resolve field indices&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;            VEL_VX = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vx&quot;);&#10;            VEL_VY = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vy&quot;);&#10;&#10;            // Pre-create entities for benchmarks that need them&#10;            entities = new int[entityCount];&#10;            for (int i = 0; i &lt; entityCount; i++) {&#10;                entities[i] = world.createEntity();&#10;            }&#10;        }&#10;&#10;        @TearDown(Level.Invocation)&#10;        public void teardownInvocation() {&#10;            world.close();&#10;            arena.close();&#10;            System.gc(); // Suggest GC between invocations&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void componentRegistration(Blackhole bh) {&#10;        ComponentManager manager = new ComponentManager();&#10;        bh.consume(manager.registerComponent(PositionComponent.class));&#10;        bh.consume(manager.registerComponent(VelocityComponent.class));&#10;        bh.consume(manager.registerComponent(TransformComponent.class));&#10;        bh.consume(manager.registerComponent(HealthComponent.class));&#10;    }&#10;&#10;    @Benchmark&#10;    public void entityCreation(BenchmarkState state, Blackhole bh) {&#10;        for (int i = 0; i &lt; state.entityCount; i++) {&#10;            bh.consume(state.world.createEntity());&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void componentAddition(BenchmarkState state) {&#10;        for (int i = 0; i &lt; state.entityCount; i++) {&#10;            MemorySegment pos = state.manager.allocate(PositionComponent.class, state.arena);&#10;            try (ComponentManager.BoundHandle h = state.manager.acquireBoundHandle(PositionComponent.class, pos)) {&#10;                h.handle().setFloat(state.POS_X, i);&#10;                h.handle().setFloat(state.POS_Y, i * 2);&#10;            }&#10;            state.world.addComponent(state.entities[i], PositionComponent.class, pos);&#10;        }&#10;    }&#10;&#10;    @State(Scope.Thread)&#10;    public static class QueryState {&#10;        @Param({&quot;10&quot;, &quot;100&quot;, &quot;1000&quot;, &quot;10000&quot;, &quot;100000&quot;, &quot;1000000&quot;})&#10;        public int entityCount;&#10;&#10;        public ComponentManager manager;&#10;        public ArchetypeWorld world;&#10;        public Arena arena;&#10;        public int POS_X, POS_Y, VEL_VX, VEL_VY;&#10;&#10;        @Setup(Level.Trial)&#10;        public void setupTrial() {&#10;            manager = new ComponentManager();&#10;            world = new ArchetypeWorld(manager);&#10;            arena = Arena.ofConfined();&#10;&#10;            world.registerComponent(PositionComponent.class);&#10;            world.registerComponent(VelocityComponent.class);&#10;&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;            VEL_VX = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vx&quot;);&#10;            VEL_VY = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vy&quot;);&#10;&#10;            // Setup entities&#10;            for (int i = 0; i &lt; entityCount; i++) {&#10;                int e = world.createEntity();&#10;&#10;                MemorySegment pos = manager.allocate(PositionComponent.class, arena);&#10;                try(var h = manager.acquireBoundHandle(PositionComponent.class, pos)) {&#10;                    h.handle().setFloat(POS_X, i);&#10;                    h.handle().setFloat(POS_Y, i * 2);&#10;                }&#10;                world.addComponent(e, PositionComponent.class, pos);&#10;&#10;                if (i % 2 == 0) { // 50% have velocity&#10;                    MemorySegment vel = manager.allocate(VelocityComponent.class, arena);&#10;                    try(var h = manager.acquireBoundHandle(VelocityComponent.class, vel)) {&#10;                        h.handle().setFloat(VEL_VX, 1.0f);&#10;                        h.handle().setFloat(VEL_VY, -1.0f);&#10;                    }&#10;                    world.addComponent(e, VelocityComponent.class, vel);&#10;                }&#10;            }&#10;        }&#10;&#10;        @TearDown(Level.Trial)&#10;        public void teardownTrial() {&#10;            world.close();&#10;            arena.close();&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void queryIteration_ReadWrite(QueryState state, Blackhole bh) {&#10;        final int[] count = {0};&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachEntity((_, handles, _) -&gt; {&#10;            float x = handles[0].getFloat(state.POS_X);&#10;            float y = handles[0].getFloat(state.POS_Y);&#10;            float vx = handles[1].getFloat(state.VEL_VX);&#10;            float vy = handles[1].getFloat(state.VEL_VY);&#10;            // Simple computation to prevent optimization&#10;            bh.consume(x + y + vx + vy);&#10;            count[0]++;&#10;        });&#10;        bh.consume(count[0]);&#10;    }&#10;&#10;    @Benchmark&#10;    public void queryIteration_Update(QueryState state) {&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachEntity((_, handles, _) -&gt; {&#10;            float x = handles[0].getFloat(state.POS_X);&#10;            float vx = handles[1].getFloat(state.VEL_VX);&#10;            handles[0].setFloat(state.POS_X, x + vx);&#10;        });&#10;    }&#10;&#10;&#10;    @State(Scope.Thread)&#10;    public static class HandleState {&#10;        public ComponentManager manager;&#10;        public Arena arena;&#10;        public MemorySegment segment;&#10;        public int POS_X, POS_Y;&#10;&#10;        @Setup(Level.Trial)&#10;        public void setup() {&#10;            manager = new ComponentManager();&#10;            manager.registerComponent(PositionComponent.class);&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;            arena = Arena.ofConfined();&#10;            segment = manager.allocate(PositionComponent.class, arena);&#10;        }&#10;&#10;        @TearDown(Level.Trial)&#10;        public void teardown() {&#10;            arena.close();&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void handlePooling_CreateRelease(HandleState state, Blackhole bh) {&#10;        ComponentHandle h = state.manager.createHandle(PositionComponent.class, state.segment);&#10;        h.setFloat(state.POS_X, 1f);&#10;        h.setFloat(state.POS_Y, 2f);&#10;        bh.consume(h.getFloat(state.POS_X));&#10;        state.manager.releaseHandle(h);&#10;    }&#10;&#10;    @Benchmark&#10;    public void handlePooling_BoundHandle(HandleState state, Blackhole bh) {&#10;        try (ComponentManager.BoundHandle h = state.manager.acquireBoundHandle(PositionComponent.class, state.segment)) {&#10;            h.handle().setFloat(state.POS_X, 1f);&#10;            h.handle().setFloat(state.POS_Y, 2f);&#10;            bh.consume(h.handle().getFloat(state.POS_X));&#10;        }&#10;    }&#10;&#10;    @State(Scope.Thread)&#10;    public static class MigrationState {&#10;        public ComponentManager manager;&#10;        public ArchetypeWorld world;&#10;        public Arena arena;&#10;        public int[] entities;&#10;        public int POS_X, POS_Y, VEL_VX, VEL_VY;&#10;        public final int MIGRATION_COUNT = 10_000;&#10;&#10;        @Setup(Level.Invocation) // Re-setup for each benchmark run&#10;        public void setup() {&#10;            manager = new ComponentManager();&#10;            world = new ArchetypeWorld(manager);&#10;            arena = Arena.ofConfined();&#10;            world.registerComponent(PositionComponent.class);&#10;            world.registerComponent(VelocityComponent.class);&#10;&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;            VEL_VX = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vx&quot;);&#10;            VEL_VY = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vy&quot;);&#10;&#10;            entities = new int[MIGRATION_COUNT];&#10;            for (int i = 0; i &lt; MIGRATION_COUNT; i++) {&#10;                entities[i] = world.createEntity();&#10;                MemorySegment pos = manager.allocate(PositionComponent.class, arena);&#10;                try(var h = manager.acquireBoundHandle(PositionComponent.class, pos)) {&#10;                    h.handle().setFloat(POS_X, i);&#10;                    h.handle().setFloat(POS_Y, i * 2);&#10;                }&#10;                world.addComponent(entities[i], PositionComponent.class, pos);&#10;            }&#10;        }&#10;&#10;        @TearDown(Level.Invocation)&#10;        public void teardown() {&#10;            world.close();&#10;            arena.close();&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void archetypeMigration(MigrationState state) {&#10;        for (int i = 0; i &lt; state.MIGRATION_COUNT; i++) {&#10;            MemorySegment vel = state.manager.allocate(VelocityComponent.class, state.arena);&#10;            try(var h = state.manager.acquireBoundHandle(VelocityComponent.class, vel)) {&#10;                h.handle().setFloat(state.VEL_VX, 1.0f);&#10;                h.handle().setFloat(state.VEL_VY, -1.0f);&#10;            }&#10;            state.world.addComponent(state.entities[i], VelocityComponent.class, vel);&#10;        }&#10;    }&#10;&#10;    // ========== Large Scale Benchmarks ==========&#10;&#10;    @State(Scope.Thread)&#10;    public static class LargeScaleState {&#10;        @Param({&quot;10&quot;, &quot;100&quot;, &quot;1000&quot;, &quot;10000&quot;, &quot;100000&quot;, &quot;1000000&quot;})&#10;        public int entityCount;&#10;&#10;        public ComponentManager manager;&#10;        public ArchetypeWorld world;&#10;        public Arena arena;&#10;        public int POS_X, POS_Y, VEL_VX, VEL_VY;&#10;&#10;        @Setup(Level.Trial)&#10;        public void setup() {&#10;            manager = new ComponentManager();&#10;            world = new ArchetypeWorld(manager);&#10;            arena = Arena.ofConfined();&#10;&#10;            world.registerComponent(PositionComponent.class);&#10;            world.registerComponent(VelocityComponent.class);&#10;            world.registerComponent(TransformComponent.class);&#10;            world.registerComponent(HealthComponent.class);&#10;&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;            VEL_VX = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vx&quot;);&#10;            VEL_VY = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vy&quot;);&#10;&#10;            // Create entities with different archetypes for realistic scenario&#10;            for (int i = 0; i &lt; entityCount; i++) {&#10;                int e = world.createEntity();&#10;&#10;                // All entities have position&#10;                MemorySegment pos = manager.allocate(PositionComponent.class, arena);&#10;                try(var h = manager.acquireBoundHandle(PositionComponent.class, pos)) {&#10;                    h.handle().setFloat(POS_X, i * 0.1f);&#10;                    h.handle().setFloat(POS_Y, i * 0.2f);&#10;                }&#10;                world.addComponent(e, PositionComponent.class, pos);&#10;&#10;                // 70% have velocity&#10;                if (i % 10 &lt; 7) {&#10;                    MemorySegment vel = manager.allocate(VelocityComponent.class, arena);&#10;                    try(var h = manager.acquireBoundHandle(VelocityComponent.class, vel)) {&#10;                        h.handle().setFloat(VEL_VX, (i % 3 - 1) * 0.5f);&#10;                        h.handle().setFloat(VEL_VY, (i % 5 - 2) * 0.3f);&#10;                    }&#10;                    world.addComponent(e, VelocityComponent.class, vel);&#10;                }&#10;&#10;                // 30% have health&#10;                if (i % 10 &lt; 3) {&#10;                    MemorySegment health = manager.allocate(HealthComponent.class, arena);&#10;                    world.addComponent(e, HealthComponent.class, health);&#10;                }&#10;            }&#10;        }&#10;&#10;        @TearDown(Level.Trial)&#10;        public void teardown() {&#10;            world.close();&#10;            arena.close();&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void largeScale_SequentialQuery(LargeScaleState state, Blackhole bh) {&#10;        final int[] count = {0};&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachEntity((_, handles, _) -&gt; {&#10;                    float x = handles[0].getFloat(state.POS_X);&#10;                    float vx = handles[1].getFloat(state.VEL_VX);&#10;                    handles[0].setFloat(state.POS_X, x + vx * 0.016f);&#10;                    count[0]++;&#10;                });&#10;        bh.consume(count[0]);&#10;    }&#10;&#10;    @Benchmark&#10;    public void largeScale_ParallelQuery(LargeScaleState state, Blackhole bh) {&#10;        final int[] count = {0};&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachParallel((_, handles, _) -&gt; {&#10;                    float x = handles[0].getFloat(state.POS_X);&#10;                    float vx = handles[1].getFloat(state.VEL_VX);&#10;                    handles[0].setFloat(state.POS_X, x + vx * 0.016f);&#10;                    synchronized (count) {&#10;                        count[0]++;&#10;                    }&#10;                });&#10;        bh.consume(count[0]);&#10;    }&#10;&#10;    @Benchmark&#10;    public void largeScale_MultipleQueries(LargeScaleState state, Blackhole bh) {&#10;        // Simulate multiple systems running different queries&#10;        final int[] total = {0};&#10;&#10;        // Query 1: Position + Velocity (movement system)&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachEntity((_, handles, _) -&gt; {&#10;                    float x = handles[0].getFloat(state.POS_X);&#10;                    float vx = handles[1].getFloat(state.VEL_VX);&#10;                    handles[0].setFloat(state.POS_X, x + vx * 0.016f);&#10;                    total[0]++;&#10;                });&#10;&#10;        // Query 2: Position only (render system)&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .forEachEntity((_, handles, _) -&gt; {&#10;                    float x = handles[0].getFloat(state.POS_X);&#10;                    float y = handles[0].getFloat(state.POS_Y);&#10;                    bh.consume(x * x + y * y); // Distance calculation&#10;                    total[0]++;&#10;                });&#10;&#10;        bh.consume(total[0]);&#10;    }&#10;&#10;    @State(Scope.Thread)&#10;    public static class MemoryPressureState {&#10;        @Param({&quot;1000&quot;, &quot;10000&quot;, &quot;100000&quot;})&#10;        public int entityCount;&#10;&#10;        public ComponentManager manager;&#10;        public ArchetypeWorld world;&#10;        public Arena arena;&#10;        public int POS_X, POS_Y;&#10;&#10;        @Setup(Level.Invocation)&#10;        public void setup() {&#10;            manager = new ComponentManager();&#10;            world = new ArchetypeWorld(manager);&#10;            arena = Arena.ofConfined();&#10;&#10;            world.registerComponent(PositionComponent.class);&#10;            world.registerComponent(VelocityComponent.class);&#10;            world.registerComponent(TransformComponent.class);&#10;&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;        }&#10;&#10;        @TearDown(Level.Invocation)&#10;        public void teardown() {&#10;            world.close();&#10;            arena.close();&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void memoryPressure_CreateAndDestroy(MemoryPressureState state) {&#10;        // Create entities&#10;        int[] entities = new int[state.entityCount];&#10;        for (int i = 0; i &lt; state.entityCount; i++) {&#10;            entities[i] = state.world.createEntity();&#10;            MemorySegment pos = state.manager.allocate(PositionComponent.class, state.arena);&#10;            try(var h = state.manager.acquireBoundHandle(PositionComponent.class, pos)) {&#10;                h.handle().setFloat(state.POS_X, i * 0.1f);&#10;                h.handle().setFloat(state.POS_Y, i * 0.2f);&#10;            }&#10;            state.world.addComponent(entities[i], PositionComponent.class, pos);&#10;        }&#10;&#10;        // Destroy half&#10;        for (int i = 0; i &lt; state.entityCount / 2; i++) {&#10;            state.world.destroyEntity(entities[i]);&#10;        }&#10;    }&#10;&#10;    @State(Scope.Thread)&#10;    public static class ThroughputState {&#10;        @Param({&quot;100000&quot;, &quot;1000000&quot;})&#10;        public int entityCount;&#10;&#10;        public ComponentManager manager;&#10;        public ArchetypeWorld world;&#10;        public Arena arena;&#10;        public int POS_X, POS_Y, VEL_VX, VEL_VY;&#10;&#10;        @Setup(Level.Trial)&#10;        public void setup() {&#10;            manager = new ComponentManager();&#10;            world = new ArchetypeWorld(manager);&#10;            arena = Arena.ofConfined();&#10;&#10;            world.registerComponent(PositionComponent.class);&#10;            world.registerComponent(VelocityComponent.class);&#10;&#10;            POS_X = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;x&quot;);&#10;            POS_Y = manager.getDescriptor(PositionComponent.class).getFieldIndex(&quot;y&quot;);&#10;            VEL_VX = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vx&quot;);&#10;            VEL_VY = manager.getDescriptor(VelocityComponent.class).getFieldIndex(&quot;vy&quot;);&#10;&#10;            // Setup entities for throughput test&#10;            for (int i = 0; i &lt; entityCount; i++) {&#10;                int e = world.createEntity();&#10;&#10;                MemorySegment pos = manager.allocate(PositionComponent.class, arena);&#10;                try(var h = manager.acquireBoundHandle(PositionComponent.class, pos)) {&#10;                    h.handle().setFloat(POS_X, i * 0.1f);&#10;                    h.handle().setFloat(POS_Y, i * 0.2f);&#10;                }&#10;                world.addComponent(e, PositionComponent.class, pos);&#10;&#10;                MemorySegment vel = manager.allocate(VelocityComponent.class, arena);&#10;                try(var h = manager.acquireBoundHandle(VelocityComponent.class, vel)) {&#10;                    h.handle().setFloat(VEL_VX, 1.0f);&#10;                    h.handle().setFloat(VEL_VY, -1.0f);&#10;                }&#10;                world.addComponent(e, VelocityComponent.class, vel);&#10;            }&#10;        }&#10;&#10;        @TearDown(Level.Trial)&#10;        public void teardown() {&#10;            world.close();&#10;            arena.close();&#10;        }&#10;    }&#10;&#10;    @Benchmark&#10;    public void throughput_MaximalIteration(ThroughputState state, Blackhole bh) {&#10;        // Measure raw iteration throughput&#10;        long sum = 0;&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachEntity((eid, handles, _) -&gt; {&#10;                    bh.consume(eid);&#10;                });&#10;    }&#10;&#10;    @Benchmark&#10;    @BenchmarkMode(Mode.Throughput)&#10;    @OutputTimeUnit(TimeUnit.SECONDS)&#10;    public void throughput_EntitiesPerSecond(ThroughputState state) {&#10;        // Measure entities processed per second&#10;        state.world.query()&#10;                .with(PositionComponent.class)&#10;                .with(VelocityComponent.class)&#10;                .forEachEntity((_, handles, _) -&gt; {&#10;                    float x = handles[0].getFloat(state.POS_X);&#10;                    float y = handles[0].getFloat(state.POS_Y);&#10;                    float vx = handles[1].getFloat(state.VEL_VX);&#10;                    float vy = handles[1].getFloat(state.VEL_VY);&#10;                    handles[0].setFloat(state.POS_X, x + vx);&#10;                    handles[0].setFloat(state.POS_Y, y + vy);&#10;                });&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeChunk.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeChunk.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk {&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                size.incrementAndGet();&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                size.decrementAndGet();&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk {&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                size.incrementAndGet();&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                size.decrementAndGet();&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] componentIds = m.toComponentIdArray();&#10;            ComponentDescriptor[] descriptors = new ComponentDescriptor[componentIds.length];&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                var meta = metadataProvider.apply(componentIds[i]);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + componentIds[i]);&#10;                }&#10;                descriptors[i] = componentManager.getDescriptor(meta.type());&#10;            }&#10;            return new Archetype(m, componentIds, descriptors, arena);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] componentIds = m.toComponentIdArray();&#10;            ComponentDescriptor[] descriptors = new ComponentDescriptor[componentIds.length];&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                var meta = metadataProvider.apply(componentIds[i]);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + componentIds[i]);&#10;                }&#10;                descriptors[i] = componentManager.getDescriptor(meta.type());&#10;            }&#10;            return new Archetype(m, componentIds, descriptors, arena);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeQuery.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeQuery.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentHandle;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (ArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                consumer.accept(entityId, location, chunk, archetype);&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities, providing pooled ComponentHandles for the requested component classes.&#10;     * The consumer receives an array of bound ComponentHandle (same order as componentClasses). The handles are released&#10;     * back to the manager after the consumer returns. This is intended for synchronous, short-lived access inside the consumer.&#10;     */&#10;    public void forEachEntityWith(EntityWithHandlesConsumer consumer, Class&lt;?&gt;... componentClasses) {&#10;        // Resolve component type IDs for requested classes&#10;        int[] reqTypeIds = new int[componentClasses.length];&#10;        for (int i = 0; i &lt; componentClasses.length; i++) {&#10;            Integer tid = world.getComponentTypeId(componentClasses[i]);&#10;            if (tid == null) {&#10;                // If a requested component class is not registered, no entity will match; return early&#10;                return;&#10;            }&#10;            reqTypeIds[i] = tid;&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            int[] compIndices = new int[reqTypeIds.length];&#10;            for (int i = 0; i &lt; reqTypeIds.length; i++) {&#10;                int idx = archetype.indexOfComponentType(reqTypeIds[i]);&#10;                if (idx &lt; 0) {&#10;                    // archetype missing at least one required component; skip it&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;&#10;            // Iterate entities in archetype&#10;            final int[] useIdx = compIndices; // capture&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; useIdx.length; k++) {&#10;                        int compIdx = useIdx[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, location, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeConsumer {&#10;        void accept(Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ChunkConsumer {&#10;        void accept(ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityConsumer {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityWithHandlesConsumer {&#10;        void accept(int entityId, ComponentHandle[] handles, ArchetypeChunk.ChunkLocation location, Archetype archetype);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentHandle;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (ArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                consumer.accept(entityId, location, chunk, archetype);&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities, providing pooled ComponentHandles for the requested component classes.&#10;     * The consumer receives an array of bound ComponentHandle (same order as componentClasses). The handles are released&#10;     * back to the manager after the consumer returns. This is intended for synchronous, short-lived access inside the consumer.&#10;     */&#10;    public void forEachEntityWith(EntityWithHandlesConsumer consumer, Class&lt;?&gt;... componentClasses) {&#10;        // Resolve component type IDs for requested classes&#10;        int[] reqTypeIds = new int[componentClasses.length];&#10;        for (int i = 0; i &lt; componentClasses.length; i++) {&#10;            Integer tid = world.getComponentTypeId(componentClasses[i]);&#10;            if (tid == null) {&#10;                // If a requested component class is not registered, no entity will match; return early&#10;                return;&#10;            }&#10;            reqTypeIds[i] = tid;&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            int[] compIndices = new int[reqTypeIds.length];&#10;            for (int i = 0; i &lt; reqTypeIds.length; i++) {&#10;                int idx = archetype.indexOfComponentType(reqTypeIds[i]);&#10;                if (idx &lt; 0) {&#10;                    // archetype missing at least one required component; skip it&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;&#10;            // Iterate entities in archetype&#10;            final int[] useIdx = compIndices; // capture&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; useIdx.length; k++) {&#10;                        int compIdx = useIdx[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, location, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeConsumer {&#10;        void accept(Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ChunkConsumer {&#10;        void accept(ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityConsumer {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityWithHandlesConsumer {&#10;        void accept(int entityId, ComponentHandle[] handles, ArchetypeChunk.ChunkLocation location, Archetype archetype);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeWorld.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeWorld.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ComponentManager componentManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    private final AtomicInteger nextComponentTypeId = new AtomicInteger(0);&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentMetadata = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentTypeIds.computeIfAbsent(componentClass, cls -&gt; {&#10;            int tid = componentManager.registerComponent(cls);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(cls);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, cls, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id atomically&#10;            nextComponentTypeId.updateAndGet(prev -&gt; Math.max(prev, tid + 1));&#10;            return tid;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query for entities matching component requirements&#10;     */&#10;    public ArchetypeQuery query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Delegate archetype construction to ArchetypeManager&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;&#10;        // Copy existing component data (only components present in both)&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;        int[] componentIds = newMask.toComponentIdArray();&#10;        for (int componentTypeId : componentIds) {&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ComponentManager componentManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    private final AtomicInteger nextComponentTypeId = new AtomicInteger(0);&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentMetadata = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentTypeIds.computeIfAbsent(componentClass, cls -&gt; {&#10;            int tid = componentManager.registerComponent(cls);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(cls);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, cls, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id atomically&#10;            nextComponentTypeId.updateAndGet(prev -&gt; Math.max(prev, tid + 1));&#10;            return tid;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query for entities matching component requirements&#10;     */&#10;    public ArchetypeQuery query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Delegate archetype construction to ArchetypeManager&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;&#10;        // Copy existing component data (only components present in both)&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;        int[] componentIds = newMask.toComponentIdArray();&#10;        for (int componentTypeId : componentIds) {&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ComponentMask.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ComponentMask.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import java.util.BitSet;&#10;&#10;/**&#10; * Represents a unique signature of components that an entity possesses.&#10; * Used to identify and group entities with the same component composition.&#10; */&#10;public final class ComponentMask {&#10;    private final BitSet mask;&#10;    private final int hashCode;&#10;&#10;    public ComponentMask() {&#10;        this.mask = new BitSet();&#10;        this.hashCode = 0;&#10;    }&#10;&#10;    private ComponentMask(BitSet mask) {&#10;        this.mask = (BitSet) mask.clone();&#10;        this.hashCode = mask.hashCode();&#10;    }&#10;&#10;    /**&#10;     * Set a component bit in the mask&#10;     */&#10;    public ComponentMask set(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.set(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Clear a component bit from the mask&#10;     */&#10;    public ComponentMask clear(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.clear(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Check if a component is present in the mask&#10;     */&#10;    public boolean has(int componentId) {&#10;        return mask.get(componentId);&#10;    }&#10;&#10;    /**&#10;     * Check if this mask contains all components from another mask&#10;     */&#10;    public boolean contains(ComponentMask other) {&#10;        BitSet intersection = (BitSet) mask.clone();&#10;        intersection.and(other.mask);&#10;        return intersection.equals(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask is a superset of other (WITH semantics).&#10;     */&#10;    public boolean containsAll(ComponentMask other) {&#10;        // other - this == empty ?&#10;        BitSet diff = (BitSet) other.mask.clone();&#10;        diff.andNot(this.mask);&#10;        return diff.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask shares at least one bit with other (ANY semantics).&#10;     */&#10;    public boolean intersects(ComponentMask other) {&#10;        return this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask has no bits in common with other (WITHOUT semantics).&#10;     */&#10;    public boolean containsNone(ComponentMask other) {&#10;        return !this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Get the number of components in this mask&#10;     */&#10;    public int cardinality() {&#10;        return mask.cardinality();&#10;    }&#10;&#10;    /**&#10;     * Return all set component IDs in ascending order.&#10;     */&#10;    public int[] toComponentIdArray() {&#10;        int count = mask.cardinality();&#10;        int[] ids = new int[count];&#10;        int idx = 0;&#10;        for (int bit = mask.nextSetBit(0); bit &gt;= 0; bit = mask.nextSetBit(bit + 1)) {&#10;            ids[idx++] = bit;&#10;        }&#10;        return ids;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        ComponentMask that = (ComponentMask) o;&#10;        return mask.equals(that.mask);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return hashCode;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;ComponentMask{&quot; + mask + '}';&#10;    }&#10;&#10;    /**&#10;     * Create a builder for fluent API&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    public static class Builder {&#10;        private final BitSet mask = new BitSet();&#10;&#10;        public Builder with(int componentId) {&#10;            mask.set(componentId);&#10;            return this;&#10;        }&#10;&#10;        public ComponentMask build() {&#10;            return new ComponentMask(mask);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import java.util.BitSet;&#10;&#10;/**&#10; * Represents a unique signature of components that an entity possesses.&#10; * Used to identify and group entities with the same component composition.&#10; */&#10;public final class ComponentMask {&#10;    private final BitSet mask;&#10;    private final int hashCode;&#10;&#10;    public ComponentMask() {&#10;        this.mask = new BitSet();&#10;        this.hashCode = 0;&#10;    }&#10;&#10;    private ComponentMask(BitSet mask) {&#10;        this.mask = (BitSet) mask.clone();&#10;        this.hashCode = mask.hashCode();&#10;    }&#10;&#10;    /**&#10;     * Set a component bit in the mask&#10;     */&#10;    public ComponentMask set(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.set(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Clear a component bit from the mask&#10;     */&#10;    public ComponentMask clear(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.clear(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Check if a component is present in the mask&#10;     */&#10;    public boolean has(int componentId) {&#10;        return mask.get(componentId);&#10;    }&#10;&#10;    /**&#10;     * Check if this mask contains all components from another mask&#10;     */&#10;    public boolean contains(ComponentMask other) {&#10;        BitSet intersection = (BitSet) mask.clone();&#10;        intersection.and(other.mask);&#10;        return intersection.equals(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask is a superset of other (WITH semantics).&#10;     */&#10;    public boolean containsAll(ComponentMask other) {&#10;        // other - this == empty ?&#10;        BitSet diff = (BitSet) other.mask.clone();&#10;        diff.andNot(this.mask);&#10;        return diff.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask shares at least one bit with other (ANY semantics).&#10;     */&#10;    public boolean intersects(ComponentMask other) {&#10;        return this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask has no bits in common with other (WITHOUT semantics).&#10;     */&#10;    public boolean containsNone(ComponentMask other) {&#10;        return !this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Get the number of components in this mask&#10;     */&#10;    public int cardinality() {&#10;        return mask.cardinality();&#10;    }&#10;&#10;    /**&#10;     * Return all set component IDs in ascending order.&#10;     */&#10;    public int[] toComponentIdArray() {&#10;        int count = mask.cardinality();&#10;        int[] ids = new int[count];&#10;        int idx = 0;&#10;        for (int bit = mask.nextSetBit(0); bit &gt;= 0; bit = mask.nextSetBit(bit + 1)) {&#10;            ids[idx++] = bit;&#10;        }&#10;        return ids;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        ComponentMask that = (ComponentMask) o;&#10;        return mask.equals(that.mask);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return hashCode;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;ComponentMask{&quot; + mask + '}';&#10;    }&#10;&#10;    /**&#10;     * Create a builder for fluent API&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    public static class Builder {&#10;        private final BitSet mask = new BitSet();&#10;&#10;        public Builder with(int componentId) {&#10;            mask.set(componentId);&#10;            return this;&#10;        }&#10;&#10;        public ComponentMask build() {&#10;            return new ComponentMask(mask);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/system/ArchetypeMovementSystem.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/system/ArchetypeMovementSystem.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype.system;&#10;&#10;import com.ethnicthv.ecs.archetype.Archetype;&#10;import com.ethnicthv.ecs.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.components.PositionComponent;&#10;import com.ethnicthv.ecs.components.VelocityComponent;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Movement system optimized for Archetype-based ECS.&#10; * Processes entities in cache-friendly chunks.&#10; */&#10;public final class ArchetypeMovementSystem {&#10;    private final ArchetypeWorld world;&#10;    private final int positionTypeId;&#10;    private final int velocityTypeId;&#10;&#10;    public ArchetypeMovementSystem(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.positionTypeId = world.getComponentTypeId(PositionComponent.class);&#10;        this.velocityTypeId = world.getComponentTypeId(VelocityComponent.class);&#10;    }&#10;&#10;    /**&#10;     * Update all entities that have both Position and Velocity&#10;     */&#10;    public void update(float deltaTime) {&#10;        world.query()&#10;            .with(PositionComponent.class)&#10;            .with(VelocityComponent.class)&#10;            .forEachChunk((chunk, archetype) -&gt; {&#10;                updateChunk(chunk, archetype, deltaTime);&#10;            });&#10;    }&#10;&#10;    private void updateChunk(ArchetypeChunk chunk, Archetype archetype, float deltaTime) {&#10;        int size = chunk.size();&#10;&#10;        // Get component indices in this archetype&#10;        int posIndex = getComponentIndex(archetype, positionTypeId);&#10;        int velIndex = getComponentIndex(archetype, velocityTypeId);&#10;&#10;        // Process each entity in the chunk&#10;        for (int i = 0; i &lt; size; i++) {&#10;            MemorySegment posData = chunk.getComponentData(posIndex, i);&#10;            MemorySegment velData = chunk.getComponentData(velIndex, i);&#10;&#10;            if (posData != null &amp;&amp; velData != null) {&#10;                // Read velocity&#10;                float vx = velData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float vy = velData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Read position&#10;                float x = posData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float y = posData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Update position&#10;                x += vx * deltaTime;&#10;                y += vy * deltaTime;&#10;&#10;                // Write back&#10;                posData.set(ValueLayout.JAVA_FLOAT, 0, x);&#10;                posData.set(ValueLayout.JAVA_FLOAT, 4, y);&#10;            }&#10;        }&#10;    }&#10;&#10;    private int getComponentIndex(Archetype archetype, int componentTypeId) {&#10;        int index = 0;&#10;        ComponentMask mask = archetype.getMask();&#10;        for (int i = 0; i &lt; componentTypeId; i++) {&#10;            if (mask.has(i)) {&#10;                index++;&#10;            }&#10;        }&#10;        return index;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype.system;&#10;&#10;import com.ethnicthv.ecs.archetype.Archetype;&#10;import com.ethnicthv.ecs.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.components.PositionComponent;&#10;import com.ethnicthv.ecs.components.VelocityComponent;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Movement system optimized for Archetype-based ECS.&#10; * Processes entities in cache-friendly chunks.&#10; */&#10;public final class ArchetypeMovementSystem {&#10;    private final ArchetypeWorld world;&#10;    private final int positionTypeId;&#10;    private final int velocityTypeId;&#10;&#10;    public ArchetypeMovementSystem(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.positionTypeId = world.getComponentTypeId(PositionComponent.class);&#10;        this.velocityTypeId = world.getComponentTypeId(VelocityComponent.class);&#10;    }&#10;&#10;    /**&#10;     * Update all entities that have both Position and Velocity&#10;     */&#10;    public void update(float deltaTime) {&#10;        world.query()&#10;            .with(PositionComponent.class)&#10;            .with(VelocityComponent.class)&#10;            .forEachChunk((chunk, archetype) -&gt; {&#10;                updateChunk(chunk, archetype, deltaTime);&#10;            });&#10;    }&#10;&#10;    private void updateChunk(ArchetypeChunk chunk, Archetype archetype, float deltaTime) {&#10;        int size = chunk.size();&#10;&#10;        // Get component indices in this archetype&#10;        int posIndex = getComponentIndex(archetype, positionTypeId);&#10;        int velIndex = getComponentIndex(archetype, velocityTypeId);&#10;&#10;        // Process each entity in the chunk&#10;        for (int i = 0; i &lt; size; i++) {&#10;            MemorySegment posData = chunk.getComponentData(posIndex, i);&#10;            MemorySegment velData = chunk.getComponentData(velIndex, i);&#10;&#10;            if (posData != null &amp;&amp; velData != null) {&#10;                // Read velocity&#10;                float vx = velData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float vy = velData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Read position&#10;                float x = posData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float y = posData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Update position&#10;                x += vx * deltaTime;&#10;                y += vy * deltaTime;&#10;&#10;                // Write back&#10;                posData.set(ValueLayout.JAVA_FLOAT, 0, x);&#10;                posData.set(ValueLayout.JAVA_FLOAT, 4, y);&#10;            }&#10;        }&#10;    }&#10;&#10;    private int getComponentIndex(Archetype archetype, int componentTypeId) {&#10;        int index = 0;&#10;        ComponentMask mask = archetype.getMask();&#10;        for (int i = 0; i &lt; componentTypeId; i++) {&#10;            if (mask.has(i)) {&#10;                index++;&#10;            }&#10;        }&#10;        return index;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentHandle.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentHandle.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a field value by name&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a field value by name&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    private final Map&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new HashMap&lt;&gt;();&#10;    private int nextTypeId = 0;&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        if (componentTypeIds.containsKey(componentClass)) {&#10;            return componentTypeIds.get(componentClass);&#10;        }&#10;&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Build descriptor through reflection&#10;        ComponentDescriptor descriptor = buildDescriptor(componentClass);&#10;        descriptors.put(componentClass, descriptor);&#10;&#10;        int typeId = nextTypeId++;&#10;        componentTypeIds.put(componentClass, typeId);&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    private final Map&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new HashMap&lt;&gt;();&#10;    private int nextTypeId = 0;&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        if (componentTypeIds.containsKey(componentClass)) {&#10;            return componentTypeIds.get(componentClass);&#10;        }&#10;&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Build descriptor through reflection&#10;        ComponentDescriptor descriptor = buildDescriptor(componentClass);&#10;        descriptors.put(componentClass, descriptor);&#10;&#10;        int typeId = nextTypeId++;&#10;        componentTypeIds.put(componentClass, typeId);&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/api/IWorld.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/api/IWorld.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.api;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;&#10;/**&#10; * Public API for the ECS world, providing safe access to entity and component management.&#10; * &lt;p&gt;&#10; * This interface exposes the core functionality of the Archetype-based ECS system&#10; * without revealing internal implementation details.&#10; */&#10;public interface IWorld extends AutoCloseable {&#10;    /**&#10;     * Register a component type in the world.&#10;     *&#10;     * @param componentClass The component class to register.&#10;     * @return The unique type ID assigned to this component.&#10;     */&#10;    &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass);&#10;&#10;    /**&#10;     * Create a new entity with no components.&#10;     *&#10;     * @return The unique ID of the newly created entity.&#10;     */&#10;    int createEntity();&#10;&#10;    /**&#10;     * Create a new entity with the specified component types.&#10;     * Components are initialized with default (zeroed) values.&#10;     *&#10;     * @param componentClasses The component classes to add to the entity.&#10;     * @return The unique ID of the newly created entity.&#10;     */&#10;    int createEntity(Class&lt;?&gt;... componentClasses);&#10;&#10;    /**&#10;     * Check if an entity has a specific component.&#10;     *&#10;     * @param entityId The entity ID.&#10;     * @param componentClass The component class to check for.&#10;     * @return True if the entity has the component, false otherwise.&#10;     */&#10;    &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass);&#10;&#10;    /**&#10;     * Destroy an entity and remove it from the world.&#10;     *&#10;     * @param entityId The ID of the entity to destroy.&#10;     */&#10;    void destroyEntity(int entityId);&#10;&#10;    /**&#10;     * Create a query builder for filtering entities based on component requirements.&#10;     *&#10;     * @return A new query builder instance.&#10;     */&#10;    IQueryBuilder query();&#10;&#10;    /**&#10;     * Get the total number of entities currently in the world.&#10;     *&#10;     * @return The entity count.&#10;     */&#10;    int getEntityCount();&#10;&#10;    /**&#10;     * Get the component type ID for a registered component class.&#10;     *&#10;     * @param componentClass The component class.&#10;     * @return The type ID, or null if not registered.&#10;     */&#10;    Integer getComponentTypeId(Class&lt;?&gt; componentClass);&#10;&#10;    /**&#10;     * Close the world and release all associated resources.&#10;     */&#10;    @Override&#10;    void close();&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.api;&#13;&#10;&#13;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#13;&#10;&#13;&#10;/**&#13;&#10; * Public API for the ECS world, providing safe access to entity and component management.&#13;&#10; * &lt;p&gt;&#13;&#10; * This interface exposes the core functionality of the Archetype-based ECS system&#13;&#10; * without revealing internal implementation details.&#13;&#10; */&#13;&#10;public interface IWorld extends AutoCloseable {&#13;&#10;    /**&#13;&#10;     * Register a component type in the world.&#13;&#10;     *&#13;&#10;     * @param componentClass The component class to register.&#13;&#10;     * @return The unique type ID assigned to this component.&#13;&#10;     */&#13;&#10;    &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create a new entity with no components.&#13;&#10;     *&#13;&#10;     * @return The unique ID of the newly created entity.&#13;&#10;     */&#13;&#10;    int createEntity();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create a new entity with the specified component types.&#13;&#10;     * Components are initialized with default (zeroed) values.&#13;&#10;     *&#13;&#10;     * @param componentClasses The component classes to add to the entity.&#13;&#10;     * @return The unique ID of the newly created entity.&#13;&#10;     */&#13;&#10;    int createEntity(Class&lt;?&gt;... componentClasses);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Check if an entity has a specific component.&#13;&#10;     *&#13;&#10;     * @param entityId The entity ID.&#13;&#10;     * @param componentClass The component class to check for.&#13;&#10;     * @return True if the entity has the component, false otherwise.&#13;&#10;     */&#13;&#10;    &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Destroy an entity and remove it from the world.&#13;&#10;     *&#13;&#10;     * @param entityId The ID of the entity to destroy.&#13;&#10;     */&#13;&#10;    void destroyEntity(int entityId);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create a query builder for filtering entities based on component requirements.&#13;&#10;     *&#13;&#10;     * @return A new query builder instance.&#13;&#10;     */&#13;&#10;    IQueryBuilder query();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get the total number of entities currently in the world.&#13;&#10;     *&#13;&#10;     * @return The entity count.&#13;&#10;     */&#13;&#10;    int getEntityCount();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get the component type ID for a registered component class.&#13;&#10;     *&#13;&#10;     * @param componentClass The component class.&#13;&#10;     * @return The type ID, or null if not registered.&#13;&#10;     */&#13;&#10;    Integer getComponentTypeId(Class&lt;?&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Close the world and release all associated resources.&#13;&#10;     */&#13;&#10;    @Override&#13;&#10;    void close();&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/Archetype.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/Archetype.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;import java.util.concurrent.atomic.AtomicBoolean;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;/**&#10; * Archetype groups entities that share the same set of components.&#10; * It stores component descriptors and manages a list of chunks.&#10; */&#10;public final class Archetype implements IArchetype {&#10;&#10;    private final int[] componentIds;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] componentElementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final ComponentMask mask; // cached mask&#10;    private final Arena arena; // arena for new chunk allocations&#10;&#10;    // Optional: full component ids including managed (only set by managed-aware ctor)&#10;    private final int[] allComponentTypeIds;&#10;    // Managed component state (only used when managed types are present)&#10;    private final int[] managedTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; managedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // Cache-friendly chunk storage&#10;    private volatile ArchetypeChunk[] chunks;&#10;    private final AtomicInteger chunkCount = new AtomicInteger(0); // also acts as publish barrier&#10;    private final ReentrantLock resizeLock = new ReentrantLock();&#10;&#10;    // Queue of chunk indices that currently have at least one free slot&#10;    private final ConcurrentLinkedQueue&lt;Integer&gt; availableChunks = new ConcurrentLinkedQueue&lt;&gt;();&#10;    // Approximate count of available chunks in the queue (kept exact via ticket discipline)&#10;    private final AtomicInteger availableCount = new AtomicInteger(0);&#10;&#10;    // Lock-free provisioning control: at most one provisioner at a time&#10;    private final AtomicBoolean provisioning = new AtomicBoolean(false);&#10;    private static final int PROVISION_THRESHOLD = 2; // when below, proactively create one more chunk&#10;    // Spin attempts to bridge provisioning without blocking. Tuned to balance latency and CPU burn.&#10;    private static final int SPIN_WAIT_ITERATIONS = 32;&#10;&#10;    // Choose a chunk byte budget (tunable)&#10;    private static final int CHUNK_SIZE = 16 * 1024;&#10;    private static final int DEFAULT_ENTITIES_PER_CHUNK = 64; // when descriptors report 0 size&#10;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; componentIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    public Archetype(ComponentMask mask, int[] componentIds, ComponentDescriptor[] descriptors, Arena arena) {&#10;        if (componentIds.length != descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;componentIds/descriptors length mismatch&quot;);&#10;        }&#10;        this.componentIds = componentIds;&#10;        this.descriptors = descriptors;&#10;        this.componentElementSizes = new long[descriptors.length];&#10;        this.mask = mask; // store provided mask&#10;        this.arena = arena;&#10;        this.allComponentTypeIds = null; // unmanaged-only ctor&#10;        this.managedTypeIds = new int[0];&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long s = descriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;&#10;        if (totalPerEntity &lt;= 0) {&#10;            this.entitiesPerChunk = DEFAULT_ENTITIES_PER_CHUNK;&#10;        } else {&#10;            this.entitiesPerChunk = Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        }&#10;&#10;        // init chunk array&#10;        this.chunks = new ArchetypeChunk[Math.max(4, 1)];&#10;        // Remove precomputed typeIndex; use computeIfAbsent in indexOfComponentType instead&#10;        // Create initial chunk at index 0&#10;        ArchetypeChunk first = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena);&#10;        this.chunks[0] = first;&#10;        chunkCount.set(1);&#10;        // initial chunk has all slots free; enqueue its index (0) with ticket&#10;        if (first.tryMarkQueued()) {&#10;            this.availableChunks.add(0);&#10;            this.availableCount.incrementAndGet();&#10;        }&#10;    }&#10;&#10;    // Managed-aware constructor: descriptors contain ONLY unmanaged components, managedTypeIds are separate; allComponentTypeIds includes both&#10;    public Archetype(ComponentMask mask, int[] allComponentTypeIds, ComponentDescriptor[] unmanagedDescriptors, int[] managedTypeIds, Arena arena) {&#10;        this.mask = mask;&#10;        this.allComponentTypeIds = allComponentTypeIds;&#10;        this.managedTypeIds = managedTypeIds != null ? managedTypeIds.clone() : new int[0];&#10;        this.componentIds = new int[unmanagedDescriptors.length]; // will be populated via setUnmanagedTypeIds&#10;        this.descriptors = unmanagedDescriptors;&#10;        this.componentElementSizes = new long[unmanagedDescriptors.length];&#10;        this.arena = arena;&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; unmanagedDescriptors.length; i++) {&#10;            long s = unmanagedDescriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        this.entitiesPerChunk = (totalPerEntity &lt;= 0) ? DEFAULT_ENTITIES_PER_CHUNK : Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;&#10;        this.chunks = new ArchetypeChunk[Math.max(4, 1)];&#10;        ArchetypeChunk first = new ArchetypeChunk(unmanagedDescriptors, componentElementSizes, entitiesPerChunk, arena, this.managedTypeIds.length);&#10;        this.chunks[0] = first;&#10;        chunkCount.set(1);&#10;        if (first.tryMarkQueued()) {&#10;            this.availableChunks.add(0);&#10;            this.availableCount.incrementAndGet();&#10;        }&#10;    }&#10;&#10;    // Internal helper to set unmanaged type ids after construction (used by ArchetypeManager)&#10;    void setUnmanagedTypeIds(int[] unmanagedTypeIds) {&#10;        if (unmanagedTypeIds == null || unmanagedTypeIds.length != this.descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;unmanagedTypeIds length mismatch&quot;);&#10;        }&#10;        System.arraycopy(unmanagedTypeIds, 0, this.componentIds, 0, unmanagedTypeIds.length);&#10;    }&#10;&#10;    /**&#10;     * Get component mask (cached)&#10;     */&#10;    public ComponentMask getMask() { return mask; }&#10;&#10;    public int[] getComponentIds() { return componentIds; }&#10;&#10;    @Override&#10;    public int[] getComponentTypeIds() {&#10;        return allComponentTypeIds != null ? allComponentTypeIds : getComponentIds();&#10;    }&#10;&#10;    public ComponentDescriptor[] getDescriptors() { return descriptors; }&#10;&#10;    public int getEntitiesPerChunk() { return entitiesPerChunk; }&#10;&#10;    /**&#10;     * Return a snapshot list of chunks. Order is physical array order.&#10;     */&#10;    @Override&#10;    public List&lt;IArchetypeChunk&gt; getChunks() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        List&lt;IArchetypeChunk&gt; list = new ArrayList&lt;&gt;(count);&#10;        for (int i = 0; i &lt; count; i++) list.add(snap[i]);&#10;        return list;&#10;    }&#10;&#10;    /**&#10;     * Get a direct reference to the current chunks array.&#10;     * &lt;p&gt;&#10;     * This method provides thread-safe access to the chunks array for parallel iteration.&#10;     * Since the 'chunks' field is declared as volatile, reading it guarantees visibility&#10;     * of the most recent array reference. The array itself may be replaced during resize&#10;     * operations, but the reference returned here is stable for the duration of its use.&#10;     * &lt;p&gt;&#10;     * This is primarily intended for parallel processing where multiple threads need to&#10;     * iterate over chunks concurrently without creating defensive copies.&#10;     *&#10;     * @return A reference to the current chunks array. The caller should also read&#10;     *         {@link #chunkCount()} to determine how many valid entries exist.&#10;     */&#10;    public ArchetypeChunk[] getChunksSnapshot() {&#10;        return this.chunks;&#10;    }&#10;&#10;    public ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        // Structured, non-recursive allocation loop&#10;        while (true) {&#10;            // 1) Try fast-path: consume available chunk(s)&#10;            ArchetypeChunk.ChunkLocation loc = tryFastPathAllocate(entityId);&#10;            if (loc != null) return loc;&#10;&#10;            // 2) If queue empty, attempt to become the provisioner (lock-free CAS)&#10;            if (provisioning.compareAndSet(false, true)) {&#10;                try {&#10;                    // Double-check fast-path in case capacity was added while acquiring provisioning&#10;                    loc = tryFastPathAllocate(entityId);&#10;                    if (loc != null) return loc;&#10;                    // Create exactly one new chunk and allocate from it&#10;                    return createChunkAndAllocate(entityId);&#10;                } finally {&#10;                    provisioning.set(false);&#10;                }&#10;            }&#10;&#10;            // 3) Someone else is provisioning. Spin briefly and retry.&#10;            for (int i = 0; i &lt; SPIN_WAIT_ITERATIONS; i++) {&#10;                loc = tryFastPathAllocate(entityId);&#10;                if (loc != null) return loc;&#10;                Thread.onSpinWait();&#10;            }&#10;            // Loop and try again&#10;        }&#10;    }&#10;&#10;    // Fast-path allocation from availableChunks; returns null if none succeed&#10;    private ArchetypeChunk.ChunkLocation tryFastPathAllocate(int entityId) {&#10;        Integer idxChunk;&#10;        while ((idxChunk = availableChunks.poll()) != null) {&#10;            availableCount.decrementAndGet();&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idxChunk];&#10;            if (chunk == null) continue;&#10;            chunk.markDequeued();&#10;            int slot = chunk.allocateSlot(entityId);&#10;            if (slot &gt;= 0) {&#10;                // Opportunistic replenishment when running low&#10;                maybeProvision();&#10;                if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;                    availableChunks.offer(idxChunk);&#10;                    availableCount.incrementAndGet();&#10;                }&#10;                return new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;            }&#10;            // If full now, do not requeue; proceed to next&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // Create one chunk, append into array, allocate a slot in it, and enqueue if it still has free capacity&#10;    private ArchetypeChunk.ChunkLocation createChunkAndAllocate(int entityId) {&#10;        ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena, managedTypeIds.length);&#10;        int newIndex = appendChunk(newChunk);&#10;        int slot = newChunk.allocateSlot(entityId);&#10;        if (newChunk.hasFree() &amp;&amp; newChunk.tryMarkQueued()) {&#10;            availableChunks.offer(newIndex);&#10;            availableCount.incrementAndGet();&#10;        }&#10;        return new ArchetypeChunk.ChunkLocation(newIndex, slot);&#10;    }&#10;&#10;    private int appendChunk(ArchetypeChunk newChunk) {&#10;        resizeLock.lock();&#10;        try {&#10;            ArchetypeChunk[] arr = this.chunks;&#10;            int idx = chunkCount.get();&#10;            if (idx &lt; arr.length) {&#10;                arr[idx] = newChunk;&#10;                // publish via chunkCount volatile increment&#10;                chunkCount.incrementAndGet();&#10;                return idx;&#10;            }&#10;            // resize: double capacity&#10;            int newCap = Math.max(4, arr.length &lt;&lt; 1);&#10;            ArchetypeChunk[] newArr = new ArchetypeChunk[newCap];&#10;            System.arraycopy(arr, 0, newArr, 0, idx);&#10;            newArr[idx] = newChunk;&#10;            // publish new array first&#10;            this.chunks = newArr;&#10;            // then publish count&#10;            chunkCount.incrementAndGet();&#10;            return idx;&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;    }&#10;&#10;    private void maybeProvision() {&#10;        if (availableCount.get() &lt; PROVISION_THRESHOLD &amp;&amp; provisioning.compareAndSet(false, true)) {&#10;            try {&#10;                ArchetypeChunk extra = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena, managedTypeIds.length);&#10;                int id = appendChunk(extra);&#10;                if (extra.tryMarkQueued()) {&#10;                    availableChunks.offer(id);&#10;                    availableCount.incrementAndGet();&#10;                }&#10;            } finally {&#10;                provisioning.set(false);&#10;            }&#10;        }&#10;    }&#10;&#10;    public void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        int idx = location.chunkIndex;&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        if (idx &lt; 0 || idx &gt;= chunkCount.get()) return;&#10;        ArchetypeChunk chunk = snap[idx];&#10;        if (chunk == null) return;&#10;        chunk.freeSlot(location.indexInChunk);&#10;        if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;            availableChunks.offer(idx);&#10;            availableCount.incrementAndGet();&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        if (chunkIndex &lt; 0 || chunkIndex &gt;= count) throw new IndexOutOfBoundsException();&#10;        return snap[chunkIndex];&#10;    }&#10;&#10;    public int chunkCount() { return this.chunkCount.get(); }&#10;&#10;    @Override&#10;    public int getChunkCount() {&#10;        return chunkCount();&#10;    }&#10;&#10;    @Override&#10;    public int getEntityCount() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        int total = 0;&#10;        for (int i = 0; i &lt; count; i++) total += snap[i].size();&#10;        return total;&#10;    }&#10;&#10;    /**&#10;     * Iterate over all entities in this archetype.&#10;     * Weakly consistent: concurrent adds/removes may or may not be observed by this traversal,&#10;     * and an entity may be skipped or visited once depending on timing. The traversal never throws&#10;     * due to concurrent modification and aims to be cache-friendly.&#10;     */&#10;    public void forEach(ArchetypeIterator iterator) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        for (int chunkId = 0; chunkId &lt; count; chunkId++) {&#10;            ArchetypeChunk chunk = snap[chunkId];&#10;            int i = chunk.nextOccupiedIndex(0);&#10;            while (i != -1) {&#10;                int eid = chunk.getEntityId(i);&#10;                if (eid != -1) iterator.accept(eid, new ArchetypeChunk.ChunkLocation(chunkId, i), chunk);&#10;                i = chunk.nextOccupiedIndex(i + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public MemorySegment getComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        return snap[location.chunkIndex].getComponentData(componentIndex, location.indexInChunk);&#10;    }&#10;&#10;    /**&#10;     * Set component data for an entity&#10;     */&#10;    public void setComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex, MemorySegment data) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        snap[location.chunkIndex].setComponentData(componentIndex, location.indexInChunk, data);&#10;    }&#10;&#10;    /**&#10;     * Get the index of a component type ID within this archetype's component arrays, or -1 if absent.&#10;     * Uses a thread-safe lazy cache to compute the mapping at most once per component type id.&#10;     */&#10;    public int indexOfComponentType(int componentTypeId) {&#10;        return componentIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                if (componentIds[i] == tid) {&#10;                    return i;&#10;                }&#10;            }&#10;            return -1; // not present in this archetype or is managed-only&#10;        });&#10;    }&#10;&#10;    // Managed helpers&#10;    public int getManagedTypeIndex(int componentTypeId) {&#10;        if (managedTypeIds.length == 0) return -1;&#10;        return managedIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; managedTypeIds.length; i++) if (managedTypeIds[i] == tid) return i;&#10;            return -1;&#10;        });&#10;    }&#10;&#10;    public int[] getManagedTypeIds() { return managedTypeIds; }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;import java.util.concurrent.atomic.AtomicBoolean;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;/**&#10; * Archetype groups entities that share the same set of components.&#10; * It stores component descriptors and manages a list of chunks.&#10; */&#10;public final class Archetype implements IArchetype {&#10;&#10;    private final int[] componentIds;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] componentElementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final ComponentMask mask; // cached mask&#10;    private final Arena arena; // arena for new chunk allocations&#10;&#10;    // Optional: full component ids including managed (only set by managed-aware ctor)&#10;    private final int[] allComponentTypeIds;&#10;    // Managed component state (only used when managed types are present)&#10;    private final int[] managedTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; managedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // Cache-friendly chunk storage&#10;    private volatile ArchetypeChunk[] chunks;&#10;    private final AtomicInteger chunkCount = new AtomicInteger(0); // also acts as publish barrier&#10;    private final ReentrantLock resizeLock = new ReentrantLock();&#10;&#10;    // Queue of chunk indices that currently have at least one free slot&#10;    private final ConcurrentLinkedQueue&lt;Integer&gt; availableChunks = new ConcurrentLinkedQueue&lt;&gt;();&#10;    // Approximate count of available chunks in the queue (kept exact via ticket discipline)&#10;    private final AtomicInteger availableCount = new AtomicInteger(0);&#10;&#10;    // Lock-free provisioning control: at most one provisioner at a time&#10;    private final AtomicBoolean provisioning = new AtomicBoolean(false);&#10;    private static final int PROVISION_THRESHOLD = 2; // when below, proactively create one more chunk&#10;    // Spin attempts to bridge provisioning without blocking. Tuned to balance latency and CPU burn.&#10;    private static final int SPIN_WAIT_ITERATIONS = 32;&#10;&#10;    // Choose a chunk byte budget (tunable)&#10;    private static final int CHUNK_SIZE = 16 * 1024;&#10;    private static final int DEFAULT_ENTITIES_PER_CHUNK = 64; // when descriptors report 0 size&#10;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; componentIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    public Archetype(ComponentMask mask, int[] componentIds, ComponentDescriptor[] descriptors, Arena arena) {&#10;        if (componentIds.length != descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;componentIds/descriptors length mismatch&quot;);&#10;        }&#10;        this.componentIds = componentIds;&#10;        this.descriptors = descriptors;&#10;        this.componentElementSizes = new long[descriptors.length];&#10;        this.mask = mask; // store provided mask&#10;        this.arena = arena;&#10;        this.allComponentTypeIds = null; // unmanaged-only ctor&#10;        this.managedTypeIds = new int[0];&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long s = descriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;&#10;        if (totalPerEntity &lt;= 0) {&#10;            this.entitiesPerChunk = DEFAULT_ENTITIES_PER_CHUNK;&#10;        } else {&#10;            this.entitiesPerChunk = Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        }&#10;&#10;        // init chunk array&#10;        this.chunks = new ArchetypeChunk[Math.max(4, 1)];&#10;        // Remove precomputed typeIndex; use computeIfAbsent in indexOfComponentType instead&#10;        // Create initial chunk at index 0&#10;        ArchetypeChunk first = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena);&#10;        this.chunks[0] = first;&#10;        chunkCount.set(1);&#10;        // initial chunk has all slots free; enqueue its index (0) with ticket&#10;        if (first.tryMarkQueued()) {&#10;            this.availableChunks.add(0);&#10;            this.availableCount.incrementAndGet();&#10;        }&#10;    }&#10;&#10;    // Managed-aware constructor: descriptors contain ONLY unmanaged components, managedTypeIds are separate; allComponentTypeIds includes both&#10;    public Archetype(ComponentMask mask, int[] allComponentTypeIds, ComponentDescriptor[] unmanagedDescriptors, int[] managedTypeIds, Arena arena) {&#10;        this.mask = mask;&#10;        this.allComponentTypeIds = allComponentTypeIds;&#10;        this.managedTypeIds = managedTypeIds != null ? managedTypeIds.clone() : new int[0];&#10;        this.componentIds = new int[unmanagedDescriptors.length]; // will be populated via setUnmanagedTypeIds&#10;        this.descriptors = unmanagedDescriptors;&#10;        this.componentElementSizes = new long[unmanagedDescriptors.length];&#10;        this.arena = arena;&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; unmanagedDescriptors.length; i++) {&#10;            long s = unmanagedDescriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        this.entitiesPerChunk = (totalPerEntity &lt;= 0) ? DEFAULT_ENTITIES_PER_CHUNK : Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;&#10;        this.chunks = new ArchetypeChunk[Math.max(4, 1)];&#10;        ArchetypeChunk first = new ArchetypeChunk(unmanagedDescriptors, componentElementSizes, entitiesPerChunk, arena, this.managedTypeIds.length);&#10;        this.chunks[0] = first;&#10;        chunkCount.set(1);&#10;        if (first.tryMarkQueued()) {&#10;            this.availableChunks.add(0);&#10;            this.availableCount.incrementAndGet();&#10;        }&#10;    }&#10;&#10;    // Internal helper to set unmanaged type ids after construction (used by ArchetypeManager)&#10;    void setUnmanagedTypeIds(int[] unmanagedTypeIds) {&#10;        if (unmanagedTypeIds == null || unmanagedTypeIds.length != this.descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;unmanagedTypeIds length mismatch&quot;);&#10;        }&#10;        System.arraycopy(unmanagedTypeIds, 0, this.componentIds, 0, unmanagedTypeIds.length);&#10;    }&#10;&#10;    /**&#10;     * Get component mask (cached)&#10;     */&#10;    public ComponentMask getMask() { return mask; }&#10;&#10;    public int[] getComponentIds() { return componentIds; }&#10;&#10;    @Override&#10;    public int[] getComponentTypeIds() {&#10;        return allComponentTypeIds != null ? allComponentTypeIds : getComponentIds();&#10;    }&#10;&#10;    public ComponentDescriptor[] getDescriptors() { return descriptors; }&#10;&#10;    public int getEntitiesPerChunk() { return entitiesPerChunk; }&#10;&#10;    /**&#10;     * Return a snapshot list of chunks. Order is physical array order.&#10;     */&#10;    @Override&#10;    public List&lt;IArchetypeChunk&gt; getChunks() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        List&lt;IArchetypeChunk&gt; list = new ArrayList&lt;&gt;(count);&#10;        for (int i = 0; i &lt; count; i++) list.add(snap[i]);&#10;        return list;&#10;    }&#10;&#10;    /**&#10;     * Get a direct reference to the current chunks array.&#10;     * &lt;p&gt;&#10;     * This method provides thread-safe access to the chunks array for parallel iteration.&#10;     * Since the 'chunks' field is declared as volatile, reading it guarantees visibility&#10;     * of the most recent array reference. The array itself may be replaced during resize&#10;     * operations, but the reference returned here is stable for the duration of its use.&#10;     * &lt;p&gt;&#10;     * This is primarily intended for parallel processing where multiple threads need to&#10;     * iterate over chunks concurrently without creating defensive copies.&#10;     *&#10;     * @return A reference to the current chunks array. The caller should also read&#10;     *         {@link #chunkCount()} to determine how many valid entries exist.&#10;     */&#10;    public ArchetypeChunk[] getChunksSnapshot() {&#10;        return this.chunks;&#10;    }&#10;&#10;    public ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        // Structured, non-recursive allocation loop&#10;        while (true) {&#10;            // 1) Try fast-path: consume available chunk(s)&#10;            ArchetypeChunk.ChunkLocation loc = tryFastPathAllocate(entityId);&#10;            if (loc != null) return loc;&#10;&#10;            // 2) If queue empty, attempt to become the provisioner (lock-free CAS)&#10;            if (provisioning.compareAndSet(false, true)) {&#10;                try {&#10;                    // Double-check fast-path in case capacity was added while acquiring provisioning&#10;                    loc = tryFastPathAllocate(entityId);&#10;                    if (loc != null) return loc;&#10;                    // Create exactly one new chunk and allocate from it&#10;                    return createChunkAndAllocate(entityId);&#10;                } finally {&#10;                    provisioning.set(false);&#10;                }&#10;            }&#10;&#10;            // 3) Someone else is provisioning. Spin briefly and retry.&#10;            for (int i = 0; i &lt; SPIN_WAIT_ITERATIONS; i++) {&#10;                loc = tryFastPathAllocate(entityId);&#10;                if (loc != null) return loc;&#10;                Thread.onSpinWait();&#10;            }&#10;            // Loop and try again&#10;        }&#10;    }&#10;&#10;    // Fast-path allocation from availableChunks; returns null if none succeed&#10;    private ArchetypeChunk.ChunkLocation tryFastPathAllocate(int entityId) {&#10;        Integer idxChunk;&#10;        while ((idxChunk = availableChunks.poll()) != null) {&#10;            availableCount.decrementAndGet();&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idxChunk];&#10;            if (chunk == null) continue;&#10;            chunk.markDequeued();&#10;            int slot = chunk.allocateSlot(entityId);&#10;            if (slot &gt;= 0) {&#10;                // Opportunistic replenishment when running low&#10;                maybeProvision();&#10;                if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;                    availableChunks.offer(idxChunk);&#10;                    availableCount.incrementAndGet();&#10;                }&#10;                return new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;            }&#10;            // If full now, do not requeue; proceed to next&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // Create one chunk, append into array, allocate a slot in it, and enqueue if it still has free capacity&#10;    private ArchetypeChunk.ChunkLocation createChunkAndAllocate(int entityId) {&#10;        ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena, managedTypeIds.length);&#10;        int newIndex = appendChunk(newChunk);&#10;        int slot = newChunk.allocateSlot(entityId);&#10;        if (newChunk.hasFree() &amp;&amp; newChunk.tryMarkQueued()) {&#10;            availableChunks.offer(newIndex);&#10;            availableCount.incrementAndGet();&#10;        }&#10;        return new ArchetypeChunk.ChunkLocation(newIndex, slot);&#10;    }&#10;&#10;    private int appendChunk(ArchetypeChunk newChunk) {&#10;        resizeLock.lock();&#10;        try {&#10;            ArchetypeChunk[] arr = this.chunks;&#10;            int idx = chunkCount.get();&#10;            if (idx &lt; arr.length) {&#10;                arr[idx] = newChunk;&#10;                // publish via chunkCount volatile increment&#10;                chunkCount.incrementAndGet();&#10;                return idx;&#10;            }&#10;            // resize: double capacity&#10;            int newCap = Math.max(4, arr.length &lt;&lt; 1);&#10;            ArchetypeChunk[] newArr = new ArchetypeChunk[newCap];&#10;            System.arraycopy(arr, 0, newArr, 0, idx);&#10;            newArr[idx] = newChunk;&#10;            // publish new array first&#10;            this.chunks = newArr;&#10;            // then publish count&#10;            chunkCount.incrementAndGet();&#10;            return idx;&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;    }&#10;&#10;    private void maybeProvision() {&#10;        if (availableCount.get() &lt; PROVISION_THRESHOLD &amp;&amp; provisioning.compareAndSet(false, true)) {&#10;            try {&#10;                ArchetypeChunk extra = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena, managedTypeIds.length);&#10;                int id = appendChunk(extra);&#10;                if (extra.tryMarkQueued()) {&#10;                    availableChunks.offer(id);&#10;                    availableCount.incrementAndGet();&#10;                }&#10;            } finally {&#10;                provisioning.set(false);&#10;            }&#10;        }&#10;    }&#10;&#10;    public void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        int idx = location.chunkIndex;&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        if (idx &lt; 0 || idx &gt;= chunkCount.get()) return;&#10;        ArchetypeChunk chunk = snap[idx];&#10;        if (chunk == null) return;&#10;        chunk.freeSlot(location.indexInChunk);&#10;        if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;            availableChunks.offer(idx);&#10;            availableCount.incrementAndGet();&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        if (chunkIndex &lt; 0 || chunkIndex &gt;= count) throw new IndexOutOfBoundsException();&#10;        return snap[chunkIndex];&#10;    }&#10;&#10;    public int chunkCount() { return this.chunkCount.get(); }&#10;&#10;    @Override&#10;    public int getChunkCount() {&#10;        return chunkCount();&#10;    }&#10;&#10;    @Override&#10;    public int getEntityCount() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        int total = 0;&#10;        for (int i = 0; i &lt; count; i++) total += snap[i].size();&#10;        return total;&#10;    }&#10;&#10;    /**&#10;     * Iterate over all entities in this archetype.&#10;     * Weakly consistent: concurrent adds/removes may or may not be observed by this traversal,&#10;     * and an entity may be skipped or visited once depending on timing. The traversal never throws&#10;     * due to concurrent modification and aims to be cache-friendly.&#10;     */&#10;    public void forEach(ArchetypeIterator iterator) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        for (int chunkId = 0; chunkId &lt; count; chunkId++) {&#10;            ArchetypeChunk chunk = snap[chunkId];&#10;            int i = chunk.nextOccupiedIndex(0);&#10;            while (i != -1) {&#10;                int eid = chunk.getEntityId(i);&#10;                if (eid != -1) iterator.accept(eid, new ArchetypeChunk.ChunkLocation(chunkId, i), chunk);&#10;                i = chunk.nextOccupiedIndex(i + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public MemorySegment getComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        return snap[location.chunkIndex].getComponentData(componentIndex, location.indexInChunk);&#10;    }&#10;&#10;    /**&#10;     * Set component data for an entity&#10;     */&#10;    public void setComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex, MemorySegment data) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        snap[location.chunkIndex].setComponentData(componentIndex, location.indexInChunk, data);&#10;    }&#10;&#10;    /**&#10;     * Get the index of a component type ID within this archetype's component arrays, or -1 if absent.&#10;     * Uses a thread-safe lazy cache to compute the mapping at most once per component type id.&#10;     */&#10;    public int indexOfComponentType(int componentTypeId) {&#10;        return componentIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                if (componentIds[i] == tid) {&#10;                    return i;&#10;                }&#10;            }&#10;            return -1; // not present in this archetype or is managed-only&#10;        });&#10;    }&#10;&#10;    // Managed helpers&#10;    public int getManagedTypeIndex(int componentTypeId) {&#10;        if (managedTypeIds.length == 0) return -1;&#10;        return managedIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; managedTypeIds.length; i++) if (managedTypeIds[i] == tid) return i;&#10;            return -1;&#10;        });&#10;    }&#10;&#10;    public int[] getManagedTypeIds() { return managedTypeIds; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeChunk.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeChunk.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.exception.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;import java.util.Arrays;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk implements IArchetypeChunk {&#10;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    // New: per-managed-type ticket arrays; may be empty if no managed types&#10;    private final int[][] managedComponentIndexArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    // Backwards-compatible constructor (no managed types)&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this(descriptors, elementSizes, capacity, arena, 0);&#10;    }&#10;&#10;    // New constructor supporting managed types&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena, int managedTypeCount) {&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // Initialize managed ticket arrays (filled with -1 indicating empty)&#10;        if (managedTypeCount &gt; 0) {&#10;            this.managedComponentIndexArrays = new int[managedTypeCount][];&#10;            for (int i = 0; i &lt; managedTypeCount; i++) {&#10;                int[] arr = new int[capacity];&#10;                Arrays.fill(arr, -1);&#10;                this.managedComponentIndexArrays[i] = arr;&#10;            }&#10;        } else {&#10;            this.managedComponentIndexArrays = new int[0][];&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                size.incrementAndGet();&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                size.decrementAndGet();&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;        // Reset managed tickets to -1 for this slot&#10;        for (int i = 0; i &lt; managedComponentIndexArrays.length; i++) {&#10;            managedComponentIndexArrays[i][idx] = -1;&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    @Override&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    @Override&#10;    public int getCapacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    @Override&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    @Override&#10;    public int getEntityCount() {&#10;        return size();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;&#10;    // ===== Managed component ticket accessors =====&#10;&#10;    public int[] getManagedIndexArray(int managedTypeIndex) {&#10;        return managedComponentIndexArrays[managedTypeIndex];&#10;    }&#10;&#10;    public int getManagedTicket(int managedTypeIndex, int elementIndex) {&#10;        if (managedTypeIndex &lt; 0 || managedTypeIndex &gt;= managedComponentIndexArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;managedTypeIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        return managedComponentIndexArrays[managedTypeIndex][elementIndex];&#10;    }&#10;&#10;    public void setManagedTicket(int managedTypeIndex, int elementIndex, int ticket) {&#10;        if (managedTypeIndex &lt; 0 || managedTypeIndex &gt;= managedComponentIndexArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;managedTypeIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        managedComponentIndexArrays[managedTypeIndex][elementIndex] = ticket;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.exception.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;import java.util.Arrays;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk implements IArchetypeChunk {&#10;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    // New: per-managed-type ticket arrays; may be empty if no managed types&#10;    private final int[][] managedComponentIndexArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    // Backwards-compatible constructor (no managed types)&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this(descriptors, elementSizes, capacity, arena, 0);&#10;    }&#10;&#10;    // New constructor supporting managed types&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena, int managedTypeCount) {&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // Initialize managed ticket arrays (filled with -1 indicating empty)&#10;        if (managedTypeCount &gt; 0) {&#10;            this.managedComponentIndexArrays = new int[managedTypeCount][];&#10;            for (int i = 0; i &lt; managedTypeCount; i++) {&#10;                int[] arr = new int[capacity];&#10;                Arrays.fill(arr, -1);&#10;                this.managedComponentIndexArrays[i] = arr;&#10;            }&#10;        } else {&#10;            this.managedComponentIndexArrays = new int[0][];&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                size.incrementAndGet();&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                size.decrementAndGet();&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;        // Reset managed tickets to -1 for this slot&#10;        for (int i = 0; i &lt; managedComponentIndexArrays.length; i++) {&#10;            managedComponentIndexArrays[i][idx] = -1;&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    @Override&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    @Override&#10;    public int getCapacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    @Override&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    @Override&#10;    public int getEntityCount() {&#10;        return size();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;&#10;    // ===== Managed component ticket accessors =====&#10;&#10;    public int[] getManagedIndexArray(int managedTypeIndex) {&#10;        return managedComponentIndexArrays[managedTypeIndex];&#10;    }&#10;&#10;    public int getManagedTicket(int managedTypeIndex, int elementIndex) {&#10;        if (managedTypeIndex &lt; 0 || managedTypeIndex &gt;= managedComponentIndexArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;managedTypeIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        return managedComponentIndexArrays[managedTypeIndex][elementIndex];&#10;    }&#10;&#10;    public void setManagedTicket(int managedTypeIndex, int elementIndex, int ticket) {&#10;        if (managedTypeIndex &lt; 0 || managedTypeIndex &gt;= managedComponentIndexArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;managedTypeIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        managedComponentIndexArrays[managedTypeIndex][elementIndex] = ticket;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] allTypeIds = m.toComponentIdArray();&#10;            // Split into unmanaged and managed&#10;            List&lt;ComponentDescriptor&gt; unmanagedDescs = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; unmanagedIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; managedIds = new ArrayList&lt;&gt;();&#10;            for (int typeId : allTypeIds) {&#10;                var meta = metadataProvider.apply(typeId);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + typeId);&#10;                }&#10;                ComponentDescriptor desc = componentManager.getDescriptor(meta.type());&#10;                if (desc == null) {&#10;                    throw new IllegalStateException(&quot;Descriptor missing for component &quot; + meta.type().getName());&#10;                }&#10;                if (desc.isManaged()) {&#10;                    managedIds.add(typeId);&#10;                } else {&#10;                    unmanagedIds.add(typeId);&#10;                    unmanagedDescs.add(desc);&#10;                }&#10;            }&#10;            ComponentDescriptor[] unmanagedArray = unmanagedDescs.toArray(new ComponentDescriptor[0]);&#10;            int[] unmanagedIdsArray = unmanagedIds.stream().mapToInt(Integer::intValue).toArray();&#10;            int[] managedIdsArray = managedIds.stream().mapToInt(Integer::intValue).toArray();&#10;&#10;            Archetype archetype = new Archetype(m, allTypeIds, unmanagedArray, managedIdsArray, arena);&#10;            // Provide the mapping for unmanaged type ids order used in this archetype&#10;            archetype.setUnmanagedTypeIds(unmanagedIdsArray);&#10;            return archetype;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#13;&#10;&#13;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#13;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#13;&#10;&#13;&#10;import java.lang.foreign.Arena;&#13;&#10;import java.util.ArrayList;&#13;&#10;import java.util.List;&#13;&#10;import java.util.concurrent.ConcurrentHashMap;&#13;&#10;import java.util.function.IntFunction;&#13;&#10;&#13;&#10;/**&#13;&#10; * Manages all archetypes in the ECS world.&#13;&#10; * Creates and retrieves archetypes based on component masks.&#13;&#10; */&#13;&#10;public final class ArchetypeManager {&#13;&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#13;&#10;    private final Arena arena;&#13;&#10;    private final ComponentManager componentManager;&#13;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#13;&#10;&#13;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#13;&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#13;&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#13;&#10;        this.arena = arena;&#13;&#10;        this.componentManager = componentManager;&#13;&#10;        this.metadataProvider = metadataProvider;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get or create an archetype for the given component mask.&#13;&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#13;&#10;     * This overload derives componentIds and descriptors internally from the mask.&#13;&#10;     */&#13;&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#13;&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#13;&#10;            int[] allTypeIds = m.toComponentIdArray();&#13;&#10;            // Split into unmanaged and managed&#13;&#10;            List&lt;ComponentDescriptor&gt; unmanagedDescs = new ArrayList&lt;&gt;();&#13;&#10;            List&lt;Integer&gt; unmanagedIds = new ArrayList&lt;&gt;();&#13;&#10;            List&lt;Integer&gt; managedIds = new ArrayList&lt;&gt;();&#13;&#10;            for (int typeId : allTypeIds) {&#13;&#10;                var meta = metadataProvider.apply(typeId);&#13;&#10;                if (meta == null) {&#13;&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + typeId);&#13;&#10;                }&#13;&#10;                ComponentDescriptor desc = componentManager.getDescriptor(meta.type());&#13;&#10;                if (desc == null) {&#13;&#10;                    throw new IllegalStateException(&quot;Descriptor missing for component &quot; + meta.type().getName());&#13;&#10;                }&#13;&#10;                if (desc.isManaged()) {&#13;&#10;                    managedIds.add(typeId);&#13;&#10;                } else {&#13;&#10;                    unmanagedIds.add(typeId);&#13;&#10;                    unmanagedDescs.add(desc);&#13;&#10;                }&#13;&#10;            }&#13;&#10;            ComponentDescriptor[] unmanagedArray = unmanagedDescs.toArray(new ComponentDescriptor[0]);&#13;&#10;            int[] unmanagedIdsArray = unmanagedIds.stream().mapToInt(Integer::intValue).toArray();&#13;&#10;            int[] managedIdsArray = managedIds.stream().mapToInt(Integer::intValue).toArray();&#13;&#10;&#13;&#10;            Archetype archetype = new Archetype(m, allTypeIds, unmanagedArray, managedIdsArray, arena);&#13;&#10;            // Provide the mapping for unmanaged type ids order used in this archetype&#13;&#10;            archetype.setUnmanagedTypeIds(unmanagedIdsArray);&#13;&#10;            return archetype;&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get an existing archetype or null if it doesn't exist&#13;&#10;     */&#13;&#10;    public Archetype getArchetype(ComponentMask mask) {&#13;&#10;        return archetypes.get(mask);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#13;&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#13;&#10;     */&#13;&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#13;&#10;        return archetypes.values();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get total entity count across all archetypes&#13;&#10;     */&#13;&#10;    public int getTotalEntityCount() {&#13;&#10;        return archetypes.values().stream()&#13;&#10;            .mapToInt(Archetype::getEntityCount)&#13;&#10;            .sum();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Clear all archetypes&#13;&#10;     */&#13;&#10;    public void clear() {&#13;&#10;        archetypes.clear();&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeQuery.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeQuery.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQuery;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentHandle;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * This class implements both {@link IQueryBuilder} (for configuration) and&#10; * {@link IQuery} (for execution). Once {@link #build()} is called, it returns&#10; * an immutable snapshot of the query configuration.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery implements IQueryBuilder, IQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    private final List&lt;Class&lt;?&gt;&gt; compList = new ArrayList&lt;&gt;();&#10;    private final List&lt;Integer&gt; compIdxList = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        compList.add(componentClass);&#10;        compIdxList.add(componentTypeId);&#10;&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    @Override&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Build an immutable query from this builder's configuration.&#10;     * &lt;p&gt;&#10;     * This method creates a snapshot of the current query configuration.&#10;     * The returned {@link IQuery} is immutable and thread-safe.&#10;     * &lt;p&gt;&#10;     * Note: Since ArchetypeQuery implements both IQueryBuilder and IQuery,&#10;     * this method simply returns itself. However, callers should treat the&#10;     * returned reference as immutable and not call builder methods on it.&#10;     *&#10;     * @return an immutable query instance&#10;     */&#10;    @Override&#10;    public IQuery build() {&#10;        // For now, we return this instance&#10;        // In a more sophisticated implementation, we could create&#10;        // a truly immutable wrapper or snapshot&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    @Override&#10;    public void forEach(IQuery.ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    @Override&#10;    public void forEachChunk(IQuery.ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (IArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    @Override&#10;    public void forEachEntity(IQuery.EntityConsumer consumer) {&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;            for (int i = 0; i &lt; compList.size(); i++) {&#10;                componentClasses[i] = compList.get(i);&#10;            }&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) {&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; compIndices.length; k++) {&#10;                        int compIdx = compIndices[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    @Override&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    /**&#10;     * Execute the query and process matching entities in parallel across multiple CPU cores.&#10;     * &lt;p&gt;&#10;     * This method leverages Java's parallel streams to distribute entity processing across&#10;     * available CPU cores. The processing is done at the chunk level - each chunk is processed&#10;     * by a single thread, but different chunks may be processed concurrently.&#10;     * &lt;p&gt;&#10;     * &lt;strong&gt;THREAD SAFETY REQUIREMENTS:&lt;/strong&gt;&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;The provided {@code EntityConsumer} MUST be thread-safe&lt;/li&gt;&#10;     *   &lt;li&gt;Any shared state accessed or modified by the consumer must be properly synchronized&lt;/li&gt;&#10;     *   &lt;li&gt;The consumer may be called concurrently from multiple threads&lt;/li&gt;&#10;     *   &lt;li&gt;There are no ordering guarantees - entities may be processed in any order&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     * &lt;p&gt;&#10;     * Performance considerations:&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;Best suited for CPU-intensive operations on large entity sets&lt;/li&gt;&#10;     *   &lt;li&gt;Overhead of parallelization may not be worth it for very small entity counts&lt;/li&gt;&#10;     *   &lt;li&gt;The actual parallelism depends on the ForkJoinPool common pool size&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     *&#10;     * @param consumer A thread-safe callback that processes each matching entity.&#10;     *                 Called with (entityId, handles, archetype) for each entity.&#10;     * @throws NullPointerException if consumer is null&#10;     *&#10;     * @see #forEachEntity(EntityConsumer) for sequential processing&#10;     */&#10;    @Override&#10;    public void forEachParallel(IQuery.EntityConsumer consumer) {&#10;        if (consumer == null) {&#10;            throw new NullPointerException(&quot;EntityConsumer must not be null&quot;);&#10;        }&#10;&#10;        record WorkItem(IArchetype archetype, ArchetypeChunk chunk, int entityId, int elementIndex) {}&#10;&#10;        List&lt;WorkItem&gt; tasks = new ArrayList&lt;&gt;();&#10;&#10;        // Build flat list of work items across all matching chunks&#10;        forEachChunk((ichunk, archetype) -&gt; {&#10;            // Cast to concrete chunk to leverage fast occupied-iteration helpers&#10;            ArchetypeChunk chunk = (ArchetypeChunk) ichunk;&#10;            int idx = chunk.nextOccupiedIndex(0);&#10;            while (idx &gt;= 0) {&#10;                int entityId = chunk.getEntityId(idx);&#10;                tasks.add(new WorkItem(archetype, chunk, entityId, idx));&#10;                idx = chunk.nextOccupiedIndex(idx + 1);&#10;            }&#10;        });&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;        Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;        for (int i = 0; i &lt; compList.size(); i++) {&#10;            componentClasses[i] = compList.get(i);&#10;        }&#10;&#10;        tasks.parallelStream().forEach(item -&gt; {&#10;            ArchetypeChunk chunk = item.chunk();&#10;            int elementIndex = item.elementIndex();&#10;&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = item.archetype().indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) {&#10;                    return; // Component not found in this archetype&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;&#10;            ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;            ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;            try {&#10;                for (int k = 0; k &lt; compIndices.length; k++) {&#10;                    int compIdx = compIndices[k];&#10;                    var seg = chunk.getComponentData(compIdx, elementIndex);&#10;                    bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                    handles[k] = bound[k].handle();&#10;                }&#10;                consumer.accept(item.entityId(), handles, item.archetype());&#10;            } finally {&#10;                for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                    if (boundHandle != null) {&#10;                        try { boundHandle.close(); } catch (Exception ignored) {}&#10;                    }&#10;                }&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQuery;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentHandle;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * This class implements both {@link IQueryBuilder} (for configuration) and&#10; * {@link IQuery} (for execution). Once {@link #build()} is called, it returns&#10; * an immutable snapshot of the query configuration.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery implements IQueryBuilder, IQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    private final List&lt;Class&lt;?&gt;&gt; compList = new ArrayList&lt;&gt;();&#10;    private final List&lt;Integer&gt; compIdxList = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        compList.add(componentClass);&#10;        compIdxList.add(componentTypeId);&#10;&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    @Override&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Build an immutable query from this builder's configuration.&#10;     * &lt;p&gt;&#10;     * This method creates a snapshot of the current query configuration.&#10;     * The returned {@link IQuery} is immutable and thread-safe.&#10;     * &lt;p&gt;&#10;     * Note: Since ArchetypeQuery implements both IQueryBuilder and IQuery,&#10;     * this method simply returns itself. However, callers should treat the&#10;     * returned reference as immutable and not call builder methods on it.&#10;     *&#10;     * @return an immutable query instance&#10;     */&#10;    @Override&#10;    public IQuery build() {&#10;        // For now, we return this instance&#10;        // In a more sophisticated implementation, we could create&#10;        // a truly immutable wrapper or snapshot&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    @Override&#10;    public void forEach(IQuery.ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    @Override&#10;    public void forEachChunk(IQuery.ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (IArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    @Override&#10;    public void forEachEntity(IQuery.EntityConsumer consumer) {&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;            for (int i = 0; i &lt; compList.size(); i++) {&#10;                componentClasses[i] = compList.get(i);&#10;            }&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) {&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; compIndices.length; k++) {&#10;                        int compIdx = compIndices[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    @Override&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    /**&#10;     * Execute the query and process matching entities in parallel across multiple CPU cores.&#10;     * &lt;p&gt;&#10;     * This method leverages Java's parallel streams to distribute entity processing across&#10;     * available CPU cores. The processing is done at the chunk level - each chunk is processed&#10;     * by a single thread, but different chunks may be processed concurrently.&#10;     * &lt;p&gt;&#10;     * &lt;strong&gt;THREAD SAFETY REQUIREMENTS:&lt;/strong&gt;&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;The provided {@code EntityConsumer} MUST be thread-safe&lt;/li&gt;&#10;     *   &lt;li&gt;Any shared state accessed or modified by the consumer must be properly synchronized&lt;/li&gt;&#10;     *   &lt;li&gt;The consumer may be called concurrently from multiple threads&lt;/li&gt;&#10;     *   &lt;li&gt;There are no ordering guarantees - entities may be processed in any order&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     * &lt;p&gt;&#10;     * Performance considerations:&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;Best suited for CPU-intensive operations on large entity sets&lt;/li&gt;&#10;     *   &lt;li&gt;Overhead of parallelization may not be worth it for very small entity counts&lt;/li&gt;&#10;     *   &lt;li&gt;The actual parallelism depends on the ForkJoinPool common pool size&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     *&#10;     * @param consumer A thread-safe callback that processes each matching entity.&#10;     *                 Called with (entityId, handles, archetype) for each entity.&#10;     * @throws NullPointerException if consumer is null&#10;     *&#10;     * @see #forEachEntity(EntityConsumer) for sequential processing&#10;     */&#10;    @Override&#10;    public void forEachParallel(IQuery.EntityConsumer consumer) {&#10;        if (consumer == null) {&#10;            throw new NullPointerException(&quot;EntityConsumer must not be null&quot;);&#10;        }&#10;&#10;        record WorkItem(IArchetype archetype, ArchetypeChunk chunk, int entityId, int elementIndex) {}&#10;&#10;        List&lt;WorkItem&gt; tasks = new ArrayList&lt;&gt;();&#10;&#10;        // Build flat list of work items across all matching chunks&#10;        forEachChunk((ichunk, archetype) -&gt; {&#10;            // Cast to concrete chunk to leverage fast occupied-iteration helpers&#10;            ArchetypeChunk chunk = (ArchetypeChunk) ichunk;&#10;            int idx = chunk.nextOccupiedIndex(0);&#10;            while (idx &gt;= 0) {&#10;                int entityId = chunk.getEntityId(idx);&#10;                tasks.add(new WorkItem(archetype, chunk, entityId, idx));&#10;                idx = chunk.nextOccupiedIndex(idx + 1);&#10;            }&#10;        });&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;        Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;        for (int i = 0; i &lt; compList.size(); i++) {&#10;            componentClasses[i] = compList.get(i);&#10;        }&#10;&#10;        tasks.parallelStream().forEach(item -&gt; {&#10;            ArchetypeChunk chunk = item.chunk();&#10;            int elementIndex = item.elementIndex();&#10;&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = item.archetype().indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) {&#10;                    return; // Component not found in this archetype&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;&#10;            ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;            ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;            try {&#10;                for (int k = 0; k &lt; compIndices.length; k++) {&#10;                    int compIdx = compIndices[k];&#10;                    var seg = chunk.getComponentData(compIdx, elementIndex);&#10;                    bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                    handles[k] = bound[k].handle();&#10;                }&#10;                consumer.accept(item.entityId(), handles, item.archetype());&#10;            } finally {&#10;                for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                    if (boundHandle != null) {&#10;                        try { boundHandle.close(); } catch (Exception ignored) {}&#10;                    }&#10;                }&#10;            }&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeWorld.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeWorld.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import com.ethnicthv.ecs.core.components.ManagedComponentStore;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ComponentManager componentManager;&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    private final AtomicInteger nextComponentTypeId = new AtomicInteger(0);&#10;    // New: global store for managed components&#10;    private final ManagedComponentStore managedStore = new ManagedComponentStore();&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentMetadata = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;    @Override&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentTypeIds.computeIfAbsent(componentClass, cls -&gt; {&#10;            int tid = componentManager.registerComponent(cls);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(cls);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, cls, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id atomically&#10;            nextComponentTypeId.updateAndGet(prev -&gt; Math.max(prev, tid + 1));&#10;            return tid;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;    @Override&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * The components will be initialized with default (zeroed) values.&#10;     *&#10;     * @param c1 The first component class to add.&#10;     * @return The ID of the newly created entity.&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1) {&#10;        return createEntityWithComponents(c1);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2) {&#10;        return createEntityWithComponents(c1, c2);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3) {&#10;        return createEntityWithComponents(c1, c2, c3);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3, Class&lt;?&gt; c4) {&#10;        return createEntityWithComponents(c1, c2, c3, c4);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3, Class&lt;?&gt; c4, Class&lt;?&gt; c5) {&#10;        return createEntityWithComponents(c1, c2, c3, c4, c5);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3, Class&lt;?&gt; c4, Class&lt;?&gt; c5, Class&lt;?&gt; c6) {&#10;        return createEntityWithComponents(c1, c2, c3, c4, c5, c6);&#10;    }&#10;&#10;    private int createEntityWithComponents(Class&lt;?&gt;... componentClasses) {&#10;        // 1. Create the entity ID&#10;        int entityId = nextEntityId.getAndIncrement();&#10;&#10;        // 2. Build the component mask&#10;        ComponentMask mask = new ComponentMask();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = componentTypeIds.get(componentClass);&#10;            if (componentTypeId == null) {&#10;                throw new IllegalArgumentException(&quot;Component type &quot; + componentClass.getName() + &quot; is not registered.&quot;);&#10;            }&#10;            mask = mask.set(componentTypeId);&#10;        }&#10;&#10;        // 3. Get or create the target archetype&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(mask);&#10;&#10;        // 4. Add the entity to the archetype and store its record&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, mask));&#10;&#10;        // 5. Allocate and assign default (zeroed) memory for each unmanaged component&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;                if (desc != null &amp;&amp; !desc.isManaged()) {&#10;                    MemorySegment data = componentManager.allocate(componentClass, arena); // Zeroed by default&#10;                    int componentIndex = archetype.indexOfComponentType(componentTypeId);&#10;                    if (componentIndex &gt;= 0) {&#10;                        archetype.setComponentData(location, componentIndex, data);&#10;                    }&#10;                }&#10;                // For managed components, default ticket remains -1 until user provides an instance&#10;            }&#10;        }&#10;&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity (unmanaged path: memory segment).&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc != null &amp;&amp; desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;addComponent(entityId, Class, MemorySegment) not valid for managed component &quot; + componentClass.getName());&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Add a managed component instance to an entity. The instance is stored in the ManagedComponentStore&#10;     * and the ticket is placed into the chunk's managed index array.&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, T componentInstance) {&#10;        if (componentInstance == null) throw new IllegalArgumentException(&quot;componentInstance must not be null&quot;);&#10;        Class&lt;?&gt; componentClass = componentInstance.getClass();&#10;&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc == null || !desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass.getName() + &quot; is not marked @Component.Managed&quot;);&#10;        }&#10;&#10;        // 1) Store managed instance and get ticket&#10;        int ticket = managedStore.store(componentInstance);&#10;&#10;        // 2) Structural change: move entity to new archetype that includes this component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // 3) Wire ticket into the new chunk's managed index array&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int managedTypeIndex = newRecord.archetype.getManagedTypeIndex(componentTypeId);&#10;        if (managedTypeIndex &lt; 0) {&#10;            // Should not happen if descriptor is managed and mask includes it&#10;            throw new IllegalStateException(&quot;Managed type index not found for component id=&quot; + componentTypeId);&#10;        }&#10;        ArchetypeChunk chunk = newRecord.archetype.getChunk(newRecord.location.chunkIndex);&#10;        chunk.setManagedTicket(managedTypeIndex, newRecord.location.indexInChunk, ticket);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity. For managed components, release the stored object.&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // If managed, release the ticket before moving&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc != null &amp;&amp; desc.isManaged()) {&#10;            int managedIdx = record.archetype.getManagedTypeIndex(componentTypeId);&#10;            if (managedIdx &gt;= 0) {&#10;                ArchetypeChunk chunk = record.archetype.getChunk(record.location.chunkIndex);&#10;                int ticket = chunk.getManagedTicket(managedIdx, record.location.indexInChunk);&#10;                if (ticket &gt;= 0) {&#10;                    managedStore.release(ticket);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            // Release all managed tickets for this entity before removing&#10;            int[] managedIds = record.archetype.getManagedTypeIds();&#10;            if (managedIds != null &amp;&amp; managedIds.length &gt; 0) {&#10;                ArchetypeChunk chunk = record.archetype.getChunk(record.location.chunkIndex);&#10;                for (int i = 0; i &lt; managedIds.length; i++) {&#10;                    int ticket = chunk.getManagedTicket(i, record.location.indexInChunk);&#10;                    if (ticket &gt;= 0) managedStore.release(ticket);&#10;                }&#10;            }&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query builder for entities matching component requirements.&#10;     * &lt;p&gt;&#10;     * Returns a builder that can be configured with component requirements,&#10;     * then built into an immutable {@link com.ethnicthv.ecs.core.api.archetype.IQuery}.&#10;     *&#10;     * @return a new query builder&#10;     */&#10;    public IQueryBuilder query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    /**&#10;     * Retrieve a managed component instance for an entity, or null if absent.&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getManagedComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) return null;&#10;        Integer typeId = componentTypeIds.get(componentClass);&#10;        if (typeId == null || !record.mask.has(typeId)) return null;&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc == null || !desc.isManaged()) return null;&#10;        int mIdx = record.archetype.getManagedTypeIndex(typeId);&#10;        if (mIdx &lt; 0) return null;&#10;        ArchetypeChunk chunk = record.archetype.getChunk(record.location.chunkIndex);&#10;        int ticket = chunk.getManagedTicket(mIdx, record.location.indexInChunk);&#10;        if (ticket &lt; 0) return null;&#10;        Object obj = managedStore.get(ticket);&#10;        return (T) obj;&#10;    }&#10;&#10;    /**&#10;     * Replace or set a managed component instance for an entity.&#10;     * If an old instance exists, its ticket is released; the new instance is stored and wired.&#10;     */&#10;    public &lt;T&gt; void setManagedComponent(int entityId, T newInstance) {&#10;        if (newInstance == null) throw new IllegalArgumentException(&quot;newInstance must not be null&quot;);&#10;        Class&lt;?&gt; componentClass = newInstance.getClass();&#10;        Integer typeId = componentTypeIds.get(componentClass);&#10;        if (typeId == null) throw new IllegalArgumentException(&quot;Component type not registered: &quot; + componentClass.getName());&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc == null || !desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;Component is not managed: &quot; + componentClass.getName());&#10;        }&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null || !record.mask.has(typeId)) {&#10;            // If not present, this behaves like addComponent(entityId, instance)&#10;            addComponent(entityId, newInstance);&#10;            return;&#10;        }&#10;        // Release old ticket (if any)&#10;        int mIdx = record.archetype.getManagedTypeIndex(typeId);&#10;        ArchetypeChunk chunk = record.archetype.getChunk(record.location.chunkIndex);&#10;        int oldTicket = chunk.getManagedTicket(mIdx, record.location.indexInChunk);&#10;        if (oldTicket &gt;= 0) managedStore.release(oldTicket);&#10;        // Store new instance and set ticket&#10;        int newTicket = managedStore.store(newInstance);&#10;        chunk.setManagedTicket(mIdx, record.location.indexInChunk, newTicket);&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Delegate archetype construction to ArchetypeManager&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;&#10;        // Copy existing unmanaged component data (only components present in both)&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;        int[] componentIds = newMask.toComponentIdArray();&#10;        for (int componentTypeId : componentIds) {&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Transfer managed tickets for intersection of managed types&#10;        int[] oldManaged = oldRecord.archetype.getManagedTypeIds();&#10;        int[] newManaged = newArchetype.getManagedTypeIds();&#10;        if (oldManaged != null &amp;&amp; newManaged != null &amp;&amp; oldManaged.length &gt; 0 &amp;&amp; newManaged.length &gt; 0) {&#10;            ArchetypeChunk oldChunk = oldRecord.archetype.getChunk(oldRecord.location.chunkIndex);&#10;            ArchetypeChunk newChunk = newArchetype.getChunk(newLocation.chunkIndex);&#10;            for (int tid : oldManaged) {&#10;                // If this managed component remains present in new archetype&#10;                // We check presence via getManagedTypeIndex&#10;                int oldMIdx = oldRecord.archetype.getManagedTypeIndex(tid);&#10;                int newMIdx = newArchetype.getManagedTypeIndex(tid);&#10;                if (oldMIdx &gt;= 0 &amp;&amp; newMIdx &gt;= 0) {&#10;                    int ticket = oldChunk.getManagedTicket(oldMIdx, oldRecord.location.indexInChunk);&#10;                    if (ticket &gt;= 0) {&#10;                        newChunk.setManagedTicket(newMIdx, newLocation.indexInChunk, ticket);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype (also clears managed tickets via zeroing)&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import com.ethnicthv.ecs.core.components.ManagedComponentStore;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ComponentManager componentManager;&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    private final AtomicInteger nextComponentTypeId = new AtomicInteger(0);&#10;    // New: global store for managed components&#10;    private final ManagedComponentStore managedStore = new ManagedComponentStore();&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentMetadata = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;    @Override&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentTypeIds.computeIfAbsent(componentClass, cls -&gt; {&#10;            int tid = componentManager.registerComponent(cls);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(cls);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, cls, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id atomically&#10;            nextComponentTypeId.updateAndGet(prev -&gt; Math.max(prev, tid + 1));&#10;            return tid;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;    @Override&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * The components will be initialized with default (zeroed) values.&#10;     *&#10;     * @param c1 The first component class to add.&#10;     * @return The ID of the newly created entity.&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1) {&#10;        return createEntityWithComponents(c1);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2) {&#10;        return createEntityWithComponents(c1, c2);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3) {&#10;        return createEntityWithComponents(c1, c2, c3);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3, Class&lt;?&gt; c4) {&#10;        return createEntityWithComponents(c1, c2, c3, c4);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3, Class&lt;?&gt; c4, Class&lt;?&gt; c5) {&#10;        return createEntityWithComponents(c1, c2, c3, c4, c5);&#10;    }&#10;&#10;    /**&#10;     * Creates a new entity with the specified components.&#10;     * @see #createEntity(Class)&#10;     */&#10;    public int createEntity(Class&lt;?&gt; c1, Class&lt;?&gt; c2, Class&lt;?&gt; c3, Class&lt;?&gt; c4, Class&lt;?&gt; c5, Class&lt;?&gt; c6) {&#10;        return createEntityWithComponents(c1, c2, c3, c4, c5, c6);&#10;    }&#10;&#10;    private int createEntityWithComponents(Class&lt;?&gt;... componentClasses) {&#10;        // 1. Create the entity ID&#10;        int entityId = nextEntityId.getAndIncrement();&#10;&#10;        // 2. Build the component mask&#10;        ComponentMask mask = new ComponentMask();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = componentTypeIds.get(componentClass);&#10;            if (componentTypeId == null) {&#10;                throw new IllegalArgumentException(&quot;Component type &quot; + componentClass.getName() + &quot; is not registered.&quot;);&#10;            }&#10;            mask = mask.set(componentTypeId);&#10;        }&#10;&#10;        // 3. Get or create the target archetype&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(mask);&#10;&#10;        // 4. Add the entity to the archetype and store its record&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, mask));&#10;&#10;        // 5. Allocate and assign default (zeroed) memory for each unmanaged component&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;                if (desc != null &amp;&amp; !desc.isManaged()) {&#10;                    MemorySegment data = componentManager.allocate(componentClass, arena); // Zeroed by default&#10;                    int componentIndex = archetype.indexOfComponentType(componentTypeId);&#10;                    if (componentIndex &gt;= 0) {&#10;                        archetype.setComponentData(location, componentIndex, data);&#10;                    }&#10;                }&#10;                // For managed components, default ticket remains -1 until user provides an instance&#10;            }&#10;        }&#10;&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity (unmanaged path: memory segment).&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc != null &amp;&amp; desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;addComponent(entityId, Class, MemorySegment) not valid for managed component &quot; + componentClass.getName());&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Add a managed component instance to an entity. The instance is stored in the ManagedComponentStore&#10;     * and the ticket is placed into the chunk's managed index array.&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, T componentInstance) {&#10;        if (componentInstance == null) throw new IllegalArgumentException(&quot;componentInstance must not be null&quot;);&#10;        Class&lt;?&gt; componentClass = componentInstance.getClass();&#10;&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc == null || !desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass.getName() + &quot; is not marked @Component.Managed&quot;);&#10;        }&#10;&#10;        // 1) Store managed instance and get ticket&#10;        int ticket = managedStore.store(componentInstance);&#10;&#10;        // 2) Structural change: move entity to new archetype that includes this component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // 3) Wire ticket into the new chunk's managed index array&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int managedTypeIndex = newRecord.archetype.getManagedTypeIndex(componentTypeId);&#10;        if (managedTypeIndex &lt; 0) {&#10;            // Should not happen if descriptor is managed and mask includes it&#10;            throw new IllegalStateException(&quot;Managed type index not found for component id=&quot; + componentTypeId);&#10;        }&#10;        ArchetypeChunk chunk = newRecord.archetype.getChunk(newRecord.location.chunkIndex);&#10;        chunk.setManagedTicket(managedTypeIndex, newRecord.location.indexInChunk, ticket);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity. For managed components, release the stored object.&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // If managed, release the ticket before moving&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc != null &amp;&amp; desc.isManaged()) {&#10;            int managedIdx = record.archetype.getManagedTypeIndex(componentTypeId);&#10;            if (managedIdx &gt;= 0) {&#10;                ArchetypeChunk chunk = record.archetype.getChunk(record.location.chunkIndex);&#10;                int ticket = chunk.getManagedTicket(managedIdx, record.location.indexInChunk);&#10;                if (ticket &gt;= 0) {&#10;                    managedStore.release(ticket);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            // Release all managed tickets for this entity before removing&#10;            int[] managedIds = record.archetype.getManagedTypeIds();&#10;            if (managedIds != null &amp;&amp; managedIds.length &gt; 0) {&#10;                ArchetypeChunk chunk = record.archetype.getChunk(record.location.chunkIndex);&#10;                for (int i = 0; i &lt; managedIds.length; i++) {&#10;                    int ticket = chunk.getManagedTicket(i, record.location.indexInChunk);&#10;                    if (ticket &gt;= 0) managedStore.release(ticket);&#10;                }&#10;            }&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query builder for entities matching component requirements.&#10;     * &lt;p&gt;&#10;     * Returns a builder that can be configured with component requirements,&#10;     * then built into an immutable {@link com.ethnicthv.ecs.core.api.archetype.IQuery}.&#10;     *&#10;     * @return a new query builder&#10;     */&#10;    public IQueryBuilder query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    /**&#10;     * Retrieve a managed component instance for an entity, or null if absent.&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getManagedComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) return null;&#10;        Integer typeId = componentTypeIds.get(componentClass);&#10;        if (typeId == null || !record.mask.has(typeId)) return null;&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc == null || !desc.isManaged()) return null;&#10;        int mIdx = record.archetype.getManagedTypeIndex(typeId);&#10;        if (mIdx &lt; 0) return null;&#10;        ArchetypeChunk chunk = record.archetype.getChunk(record.location.chunkIndex);&#10;        int ticket = chunk.getManagedTicket(mIdx, record.location.indexInChunk);&#10;        if (ticket &lt; 0) return null;&#10;        Object obj = managedStore.get(ticket);&#10;        return (T) obj;&#10;    }&#10;&#10;    /**&#10;     * Replace or set a managed component instance for an entity.&#10;     * If an old instance exists, its ticket is released; the new instance is stored and wired.&#10;     */&#10;    public &lt;T&gt; void setManagedComponent(int entityId, T newInstance) {&#10;        if (newInstance == null) throw new IllegalArgumentException(&quot;newInstance must not be null&quot;);&#10;        Class&lt;?&gt; componentClass = newInstance.getClass();&#10;        Integer typeId = componentTypeIds.get(componentClass);&#10;        if (typeId == null) throw new IllegalArgumentException(&quot;Component type not registered: &quot; + componentClass.getName());&#10;        ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;        if (desc == null || !desc.isManaged()) {&#10;            throw new IllegalArgumentException(&quot;Component is not managed: &quot; + componentClass.getName());&#10;        }&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null || !record.mask.has(typeId)) {&#10;            // If not present, this behaves like addComponent(entityId, instance)&#10;            addComponent(entityId, newInstance);&#10;            return;&#10;        }&#10;        // Release old ticket (if any)&#10;        int mIdx = record.archetype.getManagedTypeIndex(typeId);&#10;        ArchetypeChunk chunk = record.archetype.getChunk(record.location.chunkIndex);&#10;        int oldTicket = chunk.getManagedTicket(mIdx, record.location.indexInChunk);&#10;        if (oldTicket &gt;= 0) managedStore.release(oldTicket);&#10;        // Store new instance and set ticket&#10;        int newTicket = managedStore.store(newInstance);&#10;        chunk.setManagedTicket(mIdx, record.location.indexInChunk, newTicket);&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Delegate archetype construction to ArchetypeManager&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;&#10;        // Copy existing unmanaged component data (only components present in both)&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;        int[] componentIds = newMask.toComponentIdArray();&#10;        for (int componentTypeId : componentIds) {&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Transfer managed tickets for intersection of managed types&#10;        int[] oldManaged = oldRecord.archetype.getManagedTypeIds();&#10;        int[] newManaged = newArchetype.getManagedTypeIds();&#10;        if (oldManaged != null &amp;&amp; newManaged != null &amp;&amp; oldManaged.length &gt; 0 &amp;&amp; newManaged.length &gt; 0) {&#10;            ArchetypeChunk oldChunk = oldRecord.archetype.getChunk(oldRecord.location.chunkIndex);&#10;            ArchetypeChunk newChunk = newArchetype.getChunk(newLocation.chunkIndex);&#10;            for (int tid : oldManaged) {&#10;                // If this managed component remains present in new archetype&#10;                // We check presence via getManagedTypeIndex&#10;                int oldMIdx = oldRecord.archetype.getManagedTypeIndex(tid);&#10;                int newMIdx = newArchetype.getManagedTypeIndex(tid);&#10;                if (oldMIdx &gt;= 0 &amp;&amp; newMIdx &gt;= 0) {&#10;                    int ticket = oldChunk.getManagedTicket(oldMIdx, oldRecord.location.indexInChunk);&#10;                    if (ticket &gt;= 0) {&#10;                        newChunk.setManagedTicket(newMIdx, newLocation.indexInChunk, ticket);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype (also clears managed tickets via zeroing)&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentDescriptor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentDescriptor.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.util.*;&#10;&#10;/**&#10; * Descriptor containing metadata about a component's memory layout&#10; * Generated by ComponentManager through reflection&#10; */&#10;public class ComponentDescriptor {&#10;    private final Class&lt;?&gt; componentClass;&#10;    private final long totalSize;&#10;    private final Map&lt;String, FieldDescriptor&gt; fields; // legacy name-&gt;descriptor&#10;    private final List&lt;FieldDescriptor&gt; fieldList;     // legacy ordered list (immutable)&#10;    private final FieldDescriptor[] fieldArray;        // fast array for index-based access&#10;    private final Map&lt;String, Integer&gt; fieldIndexMap;  // name -&gt; index (immutable)&#10;    private final Component.LayoutType layoutType;&#10;    // New: whether this component is managed (@Component.Managed) or unmanaged (default/@Unmanaged)&#10;    private final boolean managed;&#10;&#10;    public ComponentDescriptor(Class&lt;?&gt; componentClass, long totalSize,&#10;                              List&lt;FieldDescriptor&gt; fields, Component.LayoutType layoutType) {&#10;        this.componentClass = componentClass;&#10;        this.totalSize = totalSize;&#10;        this.fieldList = Collections.unmodifiableList(new ArrayList&lt;&gt;(fields));&#10;        this.fields = new HashMap&lt;&gt;();&#10;        for (FieldDescriptor field : fields) {&#10;            this.fields.put(field.name(), field);&#10;        }&#10;        // Build fast structures&#10;        this.fieldArray = this.fieldList.toArray(new FieldDescriptor[0]);&#10;        Map&lt;String, Integer&gt; indexMap = new HashMap&lt;&gt;(fieldArray.length);&#10;        for (int i = 0; i &lt; fieldArray.length; i++) {&#10;            indexMap.put(fieldArray[i].name(), i);&#10;        }&#10;        this.fieldIndexMap = Collections.unmodifiableMap(indexMap);&#10;&#10;        this.layoutType = layoutType;&#10;        // Determine managed kind from annotation on the component type&#10;        this.managed = componentClass.isAnnotationPresent(Component.Managed.class);&#10;    }&#10;&#10;    public Class&lt;?&gt; getComponentClass() {&#10;        return componentClass;&#10;    }&#10;&#10;    public long getTotalSize() {&#10;        return totalSize;&#10;    }&#10;&#10;    // Legacy name-based lookup (setup-time, not hot-path)&#10;    public FieldDescriptor getField(String name) {&#10;        return fields.get(name);&#10;    }&#10;&#10;    // New: O(1) index-based access&#10;    public int getFieldIndex(String fieldName) {&#10;        Integer idx = fieldIndexMap.get(fieldName);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public FieldDescriptor getField(int index) {&#10;        return fieldArray[index];&#10;    }&#10;&#10;    public int fieldCount() {&#10;        return fieldArray.length;&#10;    }&#10;&#10;    public List&lt;FieldDescriptor&gt; getFields() {&#10;        return fieldList;&#10;    }&#10;&#10;    public Component.LayoutType getLayoutType() {&#10;        return layoutType;&#10;    }&#10;&#10;    // New: managed flag&#10;    public boolean isManaged() { return managed; }&#10;&#10;    /**&#10;     * Field descriptor with type and layout information&#10;     */&#10;    public record FieldDescriptor(&#10;        String name,&#10;        FieldType type,&#10;        long offset,&#10;        long size,&#10;        int alignment&#10;    ) {}&#10;&#10;    /**&#10;     * Supported field types&#10;     */&#10;    public enum FieldType {&#10;        BYTE(1, 1),&#10;        SHORT(2, 2),&#10;        INT(4, 4),&#10;        LONG(8, 8),&#10;        FLOAT(4, 4),&#10;        DOUBLE(8, 8),&#10;        BOOLEAN(1, 1),&#10;        CHAR(2, 2);&#10;&#10;        private final long size;&#10;        private final int naturalAlignment;&#10;&#10;        FieldType(long size, int naturalAlignment) {&#10;            this.size = size;&#10;            this.naturalAlignment = naturalAlignment;&#10;        }&#10;&#10;        public long getSize() {&#10;            return size;&#10;        }&#10;&#10;        public int getNaturalAlignment() {&#10;            return naturalAlignment;&#10;        }&#10;&#10;        public static FieldType fromJavaType(Class&lt;?&gt; type) {&#10;            if (type == byte.class || type == Byte.class) return BYTE;&#10;            if (type == short.class || type == Short.class) return SHORT;&#10;            if (type == int.class || type == Integer.class) return INT;&#10;            if (type == long.class || type == Long.class) return LONG;&#10;            if (type == float.class || type == Float.class) return FLOAT;&#10;            if (type == double.class || type == Double.class) return DOUBLE;&#10;            if (type == boolean.class || type == Boolean.class) return BOOLEAN;&#10;            if (type == char.class || type == Character.class) return CHAR;&#10;            throw new IllegalArgumentException(&quot;Unsupported field type: &quot; + type);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;ComponentDescriptor[&quot;)&#10;          .append(componentClass.getSimpleName())&#10;          .append(&quot;, size=&quot;).append(totalSize)&#10;          .append(&quot;, layout=&quot;).append(layoutType)&#10;          .append(&quot;, managed=&quot;).append(managed)&#10;          .append(&quot;, fields=[\n&quot;);&#10;        for (FieldDescriptor field : fieldList) {&#10;            sb.append(&quot;  &quot;).append(field.name())&#10;              .append(&quot;: &quot;).append(field.type())&#10;              .append(&quot; @&quot;).append(field.offset())&#10;              .append(&quot; (size=&quot;).append(field.size())&#10;              .append(&quot;, align=&quot;).append(field.alignment())&#10;              .append(&quot;)\n&quot;);&#10;        }&#10;        sb.append(&quot;]] &quot;);&#10;        return sb.toString();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.util.*;&#10;&#10;/**&#10; * Descriptor containing metadata about a component's memory layout&#10; * Generated by ComponentManager through reflection&#10; */&#10;public class ComponentDescriptor {&#10;    private final Class&lt;?&gt; componentClass;&#10;    private final long totalSize;&#10;    private final Map&lt;String, FieldDescriptor&gt; fields; // legacy name-&gt;descriptor&#10;    private final List&lt;FieldDescriptor&gt; fieldList;     // legacy ordered list (immutable)&#10;    private final FieldDescriptor[] fieldArray;        // fast array for index-based access&#10;    private final Map&lt;String, Integer&gt; fieldIndexMap;  // name -&gt; index (immutable)&#10;    private final Component.LayoutType layoutType;&#10;    // New: whether this component is managed (@Component.Managed) or unmanaged (default/@Unmanaged)&#10;    private final boolean managed;&#10;&#10;    public ComponentDescriptor(Class&lt;?&gt; componentClass, long totalSize,&#10;                              List&lt;FieldDescriptor&gt; fields, Component.LayoutType layoutType) {&#10;        this.componentClass = componentClass;&#10;        this.totalSize = totalSize;&#10;        this.fieldList = Collections.unmodifiableList(new ArrayList&lt;&gt;(fields));&#10;        this.fields = new HashMap&lt;&gt;();&#10;        for (FieldDescriptor field : fields) {&#10;            this.fields.put(field.name(), field);&#10;        }&#10;        // Build fast structures&#10;        this.fieldArray = this.fieldList.toArray(new FieldDescriptor[0]);&#10;        Map&lt;String, Integer&gt; indexMap = new HashMap&lt;&gt;(fieldArray.length);&#10;        for (int i = 0; i &lt; fieldArray.length; i++) {&#10;            indexMap.put(fieldArray[i].name(), i);&#10;        }&#10;        this.fieldIndexMap = Collections.unmodifiableMap(indexMap);&#10;&#10;        this.layoutType = layoutType;&#10;        // Determine managed kind from annotation on the component type&#10;        this.managed = componentClass.isAnnotationPresent(Component.Managed.class);&#10;    }&#10;&#10;    public Class&lt;?&gt; getComponentClass() {&#10;        return componentClass;&#10;    }&#10;&#10;    public long getTotalSize() {&#10;        return totalSize;&#10;    }&#10;&#10;    // Legacy name-based lookup (setup-time, not hot-path)&#10;    public FieldDescriptor getField(String name) {&#10;        return fields.get(name);&#10;    }&#10;&#10;    // New: O(1) index-based access&#10;    public int getFieldIndex(String fieldName) {&#10;        Integer idx = fieldIndexMap.get(fieldName);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public FieldDescriptor getField(int index) {&#10;        return fieldArray[index];&#10;    }&#10;&#10;    public int fieldCount() {&#10;        return fieldArray.length;&#10;    }&#10;&#10;    public List&lt;FieldDescriptor&gt; getFields() {&#10;        return fieldList;&#10;    }&#10;&#10;    public Component.LayoutType getLayoutType() {&#10;        return layoutType;&#10;    }&#10;&#10;    // New: managed flag&#10;    public boolean isManaged() { return managed; }&#10;&#10;    /**&#10;     * Field descriptor with type and layout information&#10;     */&#10;    public record FieldDescriptor(&#10;        String name,&#10;        FieldType type,&#10;        long offset,&#10;        long size,&#10;        int alignment&#10;    ) {}&#10;&#10;    /**&#10;     * Supported field types&#10;     */&#10;    public enum FieldType {&#10;        BYTE(1, 1),&#10;        SHORT(2, 2),&#10;        INT(4, 4),&#10;        LONG(8, 8),&#10;        FLOAT(4, 4),&#10;        DOUBLE(8, 8),&#10;        BOOLEAN(1, 1),&#10;        CHAR(2, 2);&#10;&#10;        private final long size;&#10;        private final int naturalAlignment;&#10;&#10;        FieldType(long size, int naturalAlignment) {&#10;            this.size = size;&#10;            this.naturalAlignment = naturalAlignment;&#10;        }&#10;&#10;        public long getSize() {&#10;            return size;&#10;        }&#10;&#10;        public int getNaturalAlignment() {&#10;            return naturalAlignment;&#10;        }&#10;&#10;        public static FieldType fromJavaType(Class&lt;?&gt; type) {&#10;            if (type == byte.class || type == Byte.class) return BYTE;&#10;            if (type == short.class || type == Short.class) return SHORT;&#10;            if (type == int.class || type == Integer.class) return INT;&#10;            if (type == long.class || type == Long.class) return LONG;&#10;            if (type == float.class || type == Float.class) return FLOAT;&#10;            if (type == double.class || type == Double.class) return DOUBLE;&#10;            if (type == boolean.class || type == Boolean.class) return BOOLEAN;&#10;            if (type == char.class || type == Character.class) return CHAR;&#10;            throw new IllegalArgumentException(&quot;Unsupported field type: &quot; + type);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;ComponentDescriptor[&quot;)&#10;          .append(componentClass.getSimpleName())&#10;          .append(&quot;, size=&quot;).append(totalSize)&#10;          .append(&quot;, layout=&quot;).append(layoutType)&#10;          .append(&quot;, managed=&quot;).append(managed)&#10;          .append(&quot;, fields=[\n&quot;);&#10;        for (FieldDescriptor field : fieldList) {&#10;            sb.append(&quot;  &quot;).append(field.name())&#10;              .append(&quot;: &quot;).append(field.type())&#10;              .append(&quot; @&quot;).append(field.offset())&#10;              .append(&quot; (size=&quot;).append(field.size())&#10;              .append(&quot;, align=&quot;).append(field.alignment())&#10;              .append(&quot;)\n&quot;);&#10;        }&#10;        sb.append(&quot;]] &quot;);&#10;        return sb.toString();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    // Thread-safe registries&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;    private final AtomicInteger nextTypeId = new AtomicInteger(0);&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Assign a stable type id exactly once, even under races&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;&#10;        // Prefer generated descriptor if present; else build via reflection&#10;        descriptors.computeIfAbsent(componentClass, cls -&gt; {&#10;            ComponentDescriptor gen = tryLoadGeneratedDescriptor(cls);&#10;            return gen != null ? gen : buildDescriptor(cls);&#10;        });&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Register a component class with a prebuilt descriptor (e.g., from generated meta).&#10;     * Thread-safe and idempotent: type id is assigned once; descriptor installed if absent.&#10;     */&#10;    public &lt;T&gt; int registerComponentWithDescriptor(Class&lt;T&gt; componentClass, ComponentDescriptor descriptor) {&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;descriptor must not be null for &quot; + componentClass.getName());&#10;        }&#10;        descriptors.putIfAbsent(componentClass, descriptor);&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;&#10;    // Try to load a generated meta class &lt;FQN&gt; + &quot;Meta&quot; exposing DESCRIPTOR field or descriptor() method.&#10;    private ComponentDescriptor tryLoadGeneratedDescriptor(Class&lt;?&gt; componentClass) {&#10;        String metaName = componentClass.getName() + &quot;Meta&quot;;&#10;        try {&#10;            Class&lt;?&gt; meta = Class.forName(metaName, false, componentClass.getClassLoader());&#10;            try {&#10;                java.lang.reflect.Field f = meta.getField(&quot;DESCRIPTOR&quot;);&#10;                Object v = f.get(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchFieldException ignored) { }&#10;            try {&#10;                java.lang.reflect.Method m = meta.getMethod(&quot;descriptor&quot;);&#10;                Object v = m.invoke(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchMethodException ignored) { }&#10;        } catch (Throwable ignored) {&#10;            // not generated/present&#10;        }&#10;        return null;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    // Thread-safe registries&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;    private final AtomicInteger nextTypeId = new AtomicInteger(0);&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Assign a stable type id exactly once, even under races&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;&#10;        // Prefer generated descriptor if present; else build via reflection&#10;        descriptors.computeIfAbsent(componentClass, cls -&gt; {&#10;            ComponentDescriptor gen = tryLoadGeneratedDescriptor(cls);&#10;            return gen != null ? gen : buildDescriptor(cls);&#10;        });&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Register a component class with a prebuilt descriptor (e.g., from generated meta).&#10;     * Thread-safe and idempotent: type id is assigned once; descriptor installed if absent.&#10;     */&#10;    public &lt;T&gt; int registerComponentWithDescriptor(Class&lt;T&gt; componentClass, ComponentDescriptor descriptor) {&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;descriptor must not be null for &quot; + componentClass.getName());&#10;        }&#10;        descriptors.putIfAbsent(componentClass, descriptor);&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;&#10;    // Try to load a generated meta class &lt;FQN&gt; + &quot;Meta&quot; exposing DESCRIPTOR field or descriptor() method.&#10;    private ComponentDescriptor tryLoadGeneratedDescriptor(Class&lt;?&gt; componentClass) {&#10;        String metaName = componentClass.getName() + &quot;Meta&quot;;&#10;        try {&#10;            Class&lt;?&gt; meta = Class.forName(metaName, false, componentClass.getClassLoader());&#10;            try {&#10;                java.lang.reflect.Field f = meta.getField(&quot;DESCRIPTOR&quot;);&#10;                Object v = f.get(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchFieldException ignored) { }&#10;            try {&#10;                java.lang.reflect.Method m = meta.getMethod(&quot;descriptor&quot;);&#10;                Object v = m.invoke(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchMethodException ignored) { }&#10;        } catch (Throwable ignored) {&#10;            // not generated/present&#10;        }&#10;        return null;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/SystemManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/SystemManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.system;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQuery;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.system.annotation.Query;&#10;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.InvocationHandler;&#10;import java.lang.reflect.Method;&#10;import java.lang.reflect.Proxy;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Manages ECS Systems and handles dependency injection of queries.&#10; * &lt;p&gt;&#10; * The SystemManager is responsible for:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Registering systems&lt;/li&gt;&#10; *   &lt;li&gt;Injecting immutable {@link IQuery} instances into {@link Query} annotated fields&lt;/li&gt;&#10; *   &lt;li&gt;Automatically configuring parallel execution based on {@link ExecutionMode}&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; * &lt;p&gt;&#10; * Injected queries are immutable and thread-safe. They cannot be modified after injection,&#10; * ensuring that the query configuration defined in annotations remains consistent.&#10; */&#10;public class SystemManager {&#10;    private final ArchetypeWorld world;&#10;    private final List&lt;Object&gt; registeredSystems;&#10;&#10;    public SystemManager(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.registeredSystems = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    /**&#10;     * Register a system and inject its dependencies.&#10;     * &lt;p&gt;&#10;     * This method will:&#10;     * &lt;ol&gt;&#10;     *   &lt;li&gt;Scan all fields annotated with {@link Query}&lt;/li&gt;&#10;     *   &lt;li&gt;Build immutable {@link IQuery} instances based on annotation parameters&lt;/li&gt;&#10;     *   &lt;li&gt;Wrap queries in parallel-executing proxies if mode is PARALLEL&lt;/li&gt;&#10;     *   &lt;li&gt;Inject the immutable queries into the system's fields&lt;/li&gt;&#10;     * &lt;/ol&gt;&#10;     * &lt;p&gt;&#10;     * The injected queries are immutable - calling builder methods like {@code with()}&#10;     * or {@code without()} on them will have no effect and may throw exceptions.&#10;     */&#10;    public &lt;T&gt; T registerSystem(T system) {&#10;        if (system == null) {&#10;            throw new IllegalArgumentException(&quot;System cannot be null&quot;);&#10;        }&#10;        // Prefer generated injector if present&#10;        tryInvokeGeneratedInjector(system);&#10;        // Fallback to legacy reflection-based injection (field-level) if applicable&#10;        injectDependencies(system);&#10;        registeredSystems.add(system);&#10;        return system;&#10;    }&#10;&#10;    private void tryInvokeGeneratedInjector(Object system) {&#10;        Class&lt;?&gt; cls = system.getClass();&#10;        String injectorName = cls.getName() + &quot;__QueryInjector&quot;;&#10;        try {&#10;            Class&lt;?&gt; inj = Class.forName(injectorName, false, cls.getClassLoader());&#10;            java.lang.reflect.Method m = inj.getMethod(&quot;inject&quot;, Object.class, com.ethnicthv.ecs.core.archetype.ArchetypeWorld.class);&#10;            m.invoke(null, system, world);&#10;        } catch (ClassNotFoundException e) {&#10;            // No generated injector; ignore&#10;        } catch (ReflectiveOperationException e) {&#10;            throw new IllegalStateException(&quot;Failed to invoke generated injector &quot; + injectorName, e);&#10;        }&#10;    }&#10;&#10;    public List&lt;Object&gt; getRegisteredSystems() {&#10;        return new ArrayList&lt;&gt;(registeredSystems);&#10;    }&#10;&#10;    private void injectDependencies(Object system) {&#10;        Class&lt;?&gt; systemClass = system.getClass();&#10;        for (Field field : systemClass.getDeclaredFields()) {&#10;            if (field.isAnnotationPresent(Query.class)) {&#10;                injectQueryField(system, field);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void injectQueryField(Object system, Field field) {&#10;        Query queryAnnotation = field.getAnnotation(Query.class);&#10;&#10;        // Field must be IQuery (immutable)&#10;        if (!IQuery.class.isAssignableFrom(field.getType())) {&#10;            throw new IllegalArgumentException(&#10;                &quot;Field &quot; + field.getName() + &quot; in &quot; + system.getClass().getName() +&#10;                &quot; annotated with @Query must be of type IQuery (immutable)&quot;&#10;            );&#10;        }&#10;&#10;        try {&#10;            IQuery immutableQuery = buildQuery(queryAnnotation);&#10;            IQuery injectedQuery = queryAnnotation.mode() == ExecutionMode.PARALLEL&#10;                ? createParallelProxy(immutableQuery)&#10;                : immutableQuery;&#10;&#10;            field.setAccessible(true);&#10;            field.set(system, injectedQuery);&#10;        } catch (IllegalAccessException e) {&#10;            throw new IllegalArgumentException(&#10;                &quot;Failed to inject query into field &quot; + field.getName() +&#10;                &quot; in &quot; + system.getClass().getName(), e&#10;            );&#10;        }&#10;    }&#10;&#10;    private IQuery buildQuery(Query annotation) {&#10;        IQueryBuilder builder = world.query();&#10;        for (Class&lt;?&gt; componentClass : annotation.with()) builder.with(componentClass);&#10;        for (Class&lt;?&gt; componentClass : annotation.without()) builder.without(componentClass);&#10;        if (annotation.any().length &gt; 0) builder.any(annotation.any());&#10;        return builder.build();&#10;    }&#10;&#10;    private IQuery createParallelProxy(final IQuery baseQuery) {&#10;        return (IQuery) Proxy.newProxyInstance(&#10;            IQuery.class.getClassLoader(),&#10;            new Class&lt;?&gt;[]{ IQuery.class },&#10;            new ParallelQueryInvocationHandler(baseQuery)&#10;        );&#10;    }&#10;&#10;    private record ParallelQueryInvocationHandler(IQuery baseQuery) implements InvocationHandler {&#10;        @Override&#10;        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {&#10;            // Compare Method objects directly for speed and safety&#10;            if (method.equals(QueryMethods.FOR_EACH_ENTITY)) {&#10;                return QueryMethods.FOR_EACH_PARALLEL.invoke(baseQuery, args);&#10;            }&#10;            return method.invoke(baseQuery, args);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.system;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQuery;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.system.annotation.Query;&#10;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.InvocationHandler;&#10;import java.lang.reflect.Method;&#10;import java.lang.reflect.Proxy;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Manages ECS Systems and handles dependency injection of queries.&#10; * &lt;p&gt;&#10; * The SystemManager is responsible for:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Registering systems&lt;/li&gt;&#10; *   &lt;li&gt;Injecting immutable {@link IQuery} instances into {@link Query} annotated fields&lt;/li&gt;&#10; *   &lt;li&gt;Automatically configuring parallel execution based on {@link ExecutionMode}&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; * &lt;p&gt;&#10; * Injected queries are immutable and thread-safe. They cannot be modified after injection,&#10; * ensuring that the query configuration defined in annotations remains consistent.&#10; */&#10;public class SystemManager {&#10;    private final ArchetypeWorld world;&#10;    private final List&lt;Object&gt; registeredSystems;&#10;&#10;    public SystemManager(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.registeredSystems = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    /**&#10;     * Register a system and inject its dependencies.&#10;     * &lt;p&gt;&#10;     * This method will:&#10;     * &lt;ol&gt;&#10;     *   &lt;li&gt;Scan all fields annotated with {@link Query}&lt;/li&gt;&#10;     *   &lt;li&gt;Build immutable {@link IQuery} instances based on annotation parameters&lt;/li&gt;&#10;     *   &lt;li&gt;Wrap queries in parallel-executing proxies if mode is PARALLEL&lt;/li&gt;&#10;     *   &lt;li&gt;Inject the immutable queries into the system's fields&lt;/li&gt;&#10;     * &lt;/ol&gt;&#10;     * &lt;p&gt;&#10;     * The injected queries are immutable - calling builder methods like {@code with()}&#10;     * or {@code without()} on them will have no effect and may throw exceptions.&#10;     */&#10;    public &lt;T&gt; T registerSystem(T system) {&#10;        if (system == null) {&#10;            throw new IllegalArgumentException(&quot;System cannot be null&quot;);&#10;        }&#10;        // Prefer generated injector if present&#10;        tryInvokeGeneratedInjector(system);&#10;        // Fallback to legacy reflection-based injection (field-level) if applicable&#10;        injectDependencies(system);&#10;        registeredSystems.add(system);&#10;        return system;&#10;    }&#10;&#10;    private void tryInvokeGeneratedInjector(Object system) {&#10;        Class&lt;?&gt; cls = system.getClass();&#10;        String injectorName = cls.getName() + &quot;__QueryInjector&quot;;&#10;        try {&#10;            Class&lt;?&gt; inj = Class.forName(injectorName, false, cls.getClassLoader());&#10;            java.lang.reflect.Method m = inj.getMethod(&quot;inject&quot;, Object.class, com.ethnicthv.ecs.core.archetype.ArchetypeWorld.class);&#10;            m.invoke(null, system, world);&#10;        } catch (ClassNotFoundException e) {&#10;            // No generated injector; ignore&#10;        } catch (ReflectiveOperationException e) {&#10;            throw new IllegalStateException(&quot;Failed to invoke generated injector &quot; + injectorName, e);&#10;        }&#10;    }&#10;&#10;    public List&lt;Object&gt; getRegisteredSystems() {&#10;        return new ArrayList&lt;&gt;(registeredSystems);&#10;    }&#10;&#10;    private void injectDependencies(Object system) {&#10;        Class&lt;?&gt; systemClass = system.getClass();&#10;        for (Field field : systemClass.getDeclaredFields()) {&#10;            if (field.isAnnotationPresent(Query.class)) {&#10;                injectQueryField(system, field);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void injectQueryField(Object system, Field field) {&#10;        Query queryAnnotation = field.getAnnotation(Query.class);&#10;&#10;        // Field must be IQuery (immutable)&#10;        if (!IQuery.class.isAssignableFrom(field.getType())) {&#10;            throw new IllegalArgumentException(&#10;                &quot;Field &quot; + field.getName() + &quot; in &quot; + system.getClass().getName() +&#10;                &quot; annotated with @Query must be of type IQuery (immutable)&quot;&#10;            );&#10;        }&#10;&#10;        try {&#10;            IQuery immutableQuery = buildQuery(queryAnnotation);&#10;            IQuery injectedQuery = queryAnnotation.mode() == ExecutionMode.PARALLEL&#10;                ? createParallelProxy(immutableQuery)&#10;                : immutableQuery;&#10;&#10;            field.setAccessible(true);&#10;            field.set(system, injectedQuery);&#10;        } catch (IllegalAccessException e) {&#10;            throw new IllegalArgumentException(&#10;                &quot;Failed to inject query into field &quot; + field.getName() +&#10;                &quot; in &quot; + system.getClass().getName(), e&#10;            );&#10;        }&#10;    }&#10;&#10;    private IQuery buildQuery(Query annotation) {&#10;        IQueryBuilder builder = world.query();&#10;        for (Class&lt;?&gt; componentClass : annotation.with()) builder.with(componentClass);&#10;        for (Class&lt;?&gt; componentClass : annotation.without()) builder.without(componentClass);&#10;        if (annotation.any().length &gt; 0) builder.any(annotation.any());&#10;        return builder.build();&#10;    }&#10;&#10;    private IQuery createParallelProxy(final IQuery baseQuery) {&#10;        return (IQuery) Proxy.newProxyInstance(&#10;            IQuery.class.getClassLoader(),&#10;            new Class&lt;?&gt;[]{ IQuery.class },&#10;            new ParallelQueryInvocationHandler(baseQuery)&#10;        );&#10;    }&#10;&#10;    private record ParallelQueryInvocationHandler(IQuery baseQuery) implements InvocationHandler {&#10;        @Override&#10;        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {&#10;            // Compare Method objects directly for speed and safety&#10;            if (method.equals(QueryMethods.FOR_EACH_ENTITY)) {&#10;                return QueryMethods.FOR_EACH_PARALLEL.invoke(baseQuery, args);&#10;            }&#10;            return method.invoke(baseQuery, args);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/demo/SystemAPIDemo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/demo/SystemAPIDemo.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.demo;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQuery;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.ComponentHandle;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import com.ethnicthv.ecs.core.system.ExecutionMode;&#10;import com.ethnicthv.ecs.core.system.annotation.Component;&#10;import com.ethnicthv.ecs.core.system.annotation.Query;&#10;import com.ethnicthv.ecs.core.system.SystemManager;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Demo showing the new System API with @Query annotation and automatic parallel execution.&#10; * &lt;p&gt;&#10; * This example demonstrates:&#10; * - Declarative query definition with @Query annotation&#10; * - Automatic injection by SystemManager&#10; * - Sequential vs Parallel execution modes&#10; * - Transparent parallel execution when mode = PARALLEL&#10; */&#10;public class SystemAPIDemo {&#10;&#10;    public static void main(String[] args) {&#10;        // Setup&#10;        ComponentManager componentManager = new ComponentManager();&#10;        ArchetypeWorld world = new ArchetypeWorld(componentManager);&#10;        SystemManager systemManager = new SystemManager(world);&#10;&#10;        // Register components&#10;        world.registerComponent(PositionComponent.class);&#10;        world.registerComponent(VelocityComponent.class);&#10;        world.registerComponent(HealthComponent.class);&#10;&#10;        // Create entities&#10;        System.out.println(&quot;Creating 10,000 entities...&quot;);&#10;        for (int i = 0; i &lt; 10000; i++) {&#10;            int entityId = world.createEntity(PositionComponent.class, VelocityComponent.class);&#10;&#10;            // Initialize with some data&#10;            MemorySegment velocity = world.getComponent(entityId, VelocityComponent.class);&#10;            if (velocity != null) {&#10;                velocity.set(ValueLayout.JAVA_FLOAT, 0, (float) Math.random() * 10);&#10;                velocity.set(ValueLayout.JAVA_FLOAT, 4, (float) Math.random() * 10);&#10;            }&#10;        }&#10;&#10;        // Create and register systems&#10;        MovementSystem movementSystem = new MovementSystem();&#10;        systemManager.registerSystem(movementSystem);&#10;&#10;        HealthRegenerationSystem healthSystem = new HealthRegenerationSystem();&#10;        systemManager.registerSystem(healthSystem);&#10;&#10;        System.out.println(&quot;\n=== Running Systems ===\n&quot;);&#10;&#10;        // Run movement system (PARALLEL)&#10;        long startTime = System.nanoTime();&#10;        movementSystem.update(); // 60 FPS&#10;        long movementTime = System.nanoTime() - startTime;&#10;        System.out.printf(&quot;MovementSystem (PARALLEL): %.2f ms%n&quot;, movementTime / 1_000_000.0);&#10;&#10;        // Run health system (SEQUENTIAL)&#10;        startTime = System.nanoTime();&#10;        healthSystem.update();&#10;        long healthTime = System.nanoTime() - startTime;&#10;        System.out.printf(&quot;HealthRegenerationSystem (SEQUENTIAL): %.2f ms%n&quot;, healthTime / 1_000_000.0);&#10;&#10;        System.out.println(&quot;\n=== Demo Complete ===&quot;);&#10;&#10;        world.close();&#10;    }&#10;&#10;    /**&#10;     * Movement system using PARALLEL execution mode.&#10;     * Processes entities with Position and Velocity components in parallel.&#10;     */&#10;    static class MovementSystem {&#10;        // This query will execute in PARALLEL automatically!&#10;        public IQuery movingEntities;&#10;&#10;        void update() {&#10;            // New API: single entrypoint&#10;            movingEntities.runQuery();&#10;        }&#10;&#10;        @Query(&#10;                fieldInject = &quot;movingEntities&quot;,&#10;                mode = ExecutionMode.SEQUENTIAL, // Explicit but could be omitted (it's default)&#10;                with = HealthComponent.class&#10;        )&#10;        private void query(&#10;                @Component(type = VelocityComponent.class) ComponentHandle velocityHandle,&#10;                @Component(type = PositionComponent.class) ComponentHandle locationHandle&#10;        ) {&#10;            float vx = VelocityComponentAccess.getVx(velocityHandle);&#10;            float vy = VelocityComponentAccess.getVy(velocityHandle);&#10;&#10;            float x = PositionComponentAccess.getX(locationHandle);&#10;            float y = PositionComponentAccess.getY(locationHandle);&#10;&#10;            x += vx * 0.1f;&#10;            y += vy * 0.1f;&#10;&#10;            // Write back&#10;            PositionComponentAccess.setX(locationHandle, x);&#10;            PositionComponentAccess.setY(locationHandle, y);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Health regeneration system using SEQUENTIAL execution.&#10;     * Demonstrates that SEQUENTIAL is still the default and works as expected.&#10;     */&#10;    static class HealthRegenerationSystem {&#10;        private IQuery healthyEntities;&#10;&#10;        void update() {&#10;            healthyEntities.runQuery();&#10;        }&#10;&#10;        @Query(&#10;                fieldInject = &quot;healthyEntities&quot;,&#10;                mode = ExecutionMode.SEQUENTIAL, // Explicit but could be omitted (it's default)&#10;                with = HealthComponent.class&#10;        )&#10;        private void query(&#10;                @Component(type = HealthComponent.class) ComponentHandle healthHandle&#10;        ) {&#10;            int health = HealthComponentAccess.getCurrentHealth(healthHandle);&#10;            int maxHealth = HealthComponentAccess.getMaxHealth(healthHandle);&#10;&#10;            if (health &lt; maxHealth) {&#10;                health = Math.min(maxHealth, health + (int) (10 * 0.1f));&#10;                HealthComponentAccess.setCurrentHealth(healthHandle, health);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.demo;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQuery;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.ComponentHandle;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import com.ethnicthv.ecs.core.system.ExecutionMode;&#10;import com.ethnicthv.ecs.core.system.annotation.Component;&#10;import com.ethnicthv.ecs.core.system.annotation.Query;&#10;import com.ethnicthv.ecs.core.system.SystemManager;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Demo showing the new System API with @Query annotation and automatic parallel execution.&#10; * &lt;p&gt;&#10; * This example demonstrates:&#10; * - Declarative query definition with @Query annotation&#10; * - Automatic injection by SystemManager&#10; * - Sequential vs Parallel execution modes&#10; * - Transparent parallel execution when mode = PARALLEL&#10; */&#10;public class SystemAPIDemo {&#10;&#10;    public static void main(String[] args) {&#10;        // Setup&#10;        ComponentManager componentManager = new ComponentManager();&#10;        ArchetypeWorld world = new ArchetypeWorld(componentManager);&#10;        SystemManager systemManager = new SystemManager(world);&#10;&#10;        // Register components&#10;        world.registerComponent(PositionComponent.class);&#10;        world.registerComponent(VelocityComponent.class);&#10;        world.registerComponent(HealthComponent.class);&#10;&#10;        // Create entities&#10;        System.out.println(&quot;Creating 10,000 entities...&quot;);&#10;        for (int i = 0; i &lt; 10000; i++) {&#10;            int entityId = world.createEntity(PositionComponent.class, VelocityComponent.class);&#10;&#10;            // Initialize with some data&#10;            MemorySegment velocity = world.getComponent(entityId, VelocityComponent.class);&#10;            if (velocity != null) {&#10;                velocity.set(ValueLayout.JAVA_FLOAT, 0, (float) Math.random() * 10);&#10;                velocity.set(ValueLayout.JAVA_FLOAT, 4, (float) Math.random() * 10);&#10;            }&#10;        }&#10;&#10;        // Create and register systems&#10;        MovementSystem movementSystem = new MovementSystem();&#10;        systemManager.registerSystem(movementSystem);&#10;&#10;        HealthRegenerationSystem healthSystem = new HealthRegenerationSystem();&#10;        systemManager.registerSystem(healthSystem);&#10;&#10;        System.out.println(&quot;\n=== Running Systems ===\n&quot;);&#10;&#10;        // Run movement system (PARALLEL)&#10;        long startTime = System.nanoTime();&#10;        movementSystem.update(); // 60 FPS&#10;        long movementTime = System.nanoTime() - startTime;&#10;        System.out.printf(&quot;MovementSystem (PARALLEL): %.2f ms%n&quot;, movementTime / 1_000_000.0);&#10;&#10;        // Run health system (SEQUENTIAL)&#10;        startTime = System.nanoTime();&#10;        healthSystem.update();&#10;        long healthTime = System.nanoTime() - startTime;&#10;        System.out.printf(&quot;HealthRegenerationSystem (SEQUENTIAL): %.2f ms%n&quot;, healthTime / 1_000_000.0);&#10;&#10;        System.out.println(&quot;\n=== Demo Complete ===&quot;);&#10;&#10;        world.close();&#10;    }&#10;&#10;    /**&#10;     * Movement system using PARALLEL execution mode.&#10;     * Processes entities with Position and Velocity components in parallel.&#10;     */&#10;    static class MovementSystem {&#10;        // This query will execute in PARALLEL automatically!&#10;        public IQuery movingEntities;&#10;&#10;        void update() {&#10;            // New API: single entrypoint&#10;            movingEntities.runQuery();&#10;        }&#10;&#10;        @Query(&#10;                fieldInject = &quot;movingEntities&quot;,&#10;                mode = ExecutionMode.SEQUENTIAL, // Explicit but could be omitted (it's default)&#10;                with = HealthComponent.class&#10;        )&#10;        private void query(&#10;                @Component(type = VelocityComponent.class) ComponentHandle velocityHandle,&#10;                @Component(type = PositionComponent.class) ComponentHandle locationHandle&#10;        ) {&#10;            float vx = VelocityComponentAccess.getVx(velocityHandle);&#10;            float vy = VelocityComponentAccess.getVy(velocityHandle);&#10;&#10;            float x = PositionComponentAccess.getX(locationHandle);&#10;            float y = PositionComponentAccess.getY(locationHandle);&#10;&#10;            x += vx * 0.1f;&#10;            y += vy * 0.1f;&#10;&#10;            // Write back&#10;            PositionComponentAccess.setX(locationHandle, x);&#10;            PositionComponentAccess.setY(locationHandle, y);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Health regeneration system using SEQUENTIAL execution.&#10;     * Demonstrates that SEQUENTIAL is still the default and works as expected.&#10;     */&#10;    static class HealthRegenerationSystem {&#10;        private IQuery healthyEntities;&#10;&#10;        void update() {&#10;            healthyEntities.runQuery();&#10;        }&#10;&#10;        @Query(&#10;                fieldInject = &quot;healthyEntities&quot;,&#10;                mode = ExecutionMode.SEQUENTIAL, // Explicit but could be omitted (it's default)&#10;                with = HealthComponent.class&#10;        )&#10;        private void query(&#10;                @Component(type = HealthComponent.class) ComponentHandle healthHandle&#10;        ) {&#10;            int health = HealthComponentAccess.getCurrentHealth(healthHandle);&#10;            int maxHealth = HealthComponentAccess.getMaxHealth(healthHandle);&#10;&#10;            if (health &lt; maxHealth) {&#10;                health = Math.min(maxHealth, health + (int) (10 * 0.1f));&#10;                HealthComponentAccess.setCurrentHealth(healthHandle, health);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeChunkTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeChunkTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Comprehensive tests for ArchetypeChunk&#10; */&#10;public class ArchetypeChunkTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private long[] elementSizes;&#10;    private static final int DEFAULT_CAPACITY = 64;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        elementSizes = new long[]{16, 8};&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        // Don't close shared arena - it may be used across tests&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testChunkInitialization() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(DEFAULT_CAPACITY, chunk.capacity());&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertTrue(chunk.hasFree());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateSingleSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertTrue(slot &gt;= 0 &amp;&amp; slot &lt; DEFAULT_CAPACITY);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.isEmpty());&#10;        assertEquals(100, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateMultipleSlots() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int slot = chunk.allocateSlot(1000 + i);&#10;            assertTrue(slot &gt;= 0);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slots should be unique&quot;);&#10;            assertEquals(1000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(10, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateUpToCapacity() {&#10;        int capacity = 16;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            int slot = chunk.allocateSlot(i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot &quot; + i);&#10;        }&#10;&#10;        assertEquals(capacity, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        // Try to allocate one more - should fail&#10;        int extraSlot = chunk.allocateSlot(999);&#10;        assertEquals(-1, extraSlot, &quot;Should not allocate beyond capacity&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testFreeSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertEquals(-1, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateFreeAllocate() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate&#10;        int slot1 = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        // Free&#10;        chunk.freeSlot(slot1);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Allocate again - might reuse same slot&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertTrue(slot2 &gt;= 0);&#10;        assertEquals(1, chunk.size());&#10;        assertEquals(200, chunk.getEntityId(slot2));&#10;    }&#10;&#10;    @Test&#10;    void testDoubleFree() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Double free should be safe&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testGetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Get component data for component 0&#10;        MemorySegment data = chunk.getComponentData(0, slot);&#10;        assertNotNull(data);&#10;        assertEquals(16, data.byteSize());&#10;&#10;        // Get component data for component 1&#10;        MemorySegment data2 = chunk.getComponentData(1, slot);&#10;        assertNotNull(data2);&#10;        assertEquals(8, data2.byteSize());&#10;    }&#10;&#10;    @Test&#10;    void testSetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Create test data&#10;        MemorySegment testData = arena.allocate(16);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 12345L);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 8, 67890L);&#10;&#10;        // Set component data&#10;        chunk.setComponentData(0, slot, testData);&#10;&#10;        // Retrieve and verify&#10;        MemorySegment retrieved = chunk.getComponentData(0, slot);&#10;        assertEquals(12345L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;        assertEquals(67890L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 8));&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate some slots&#10;        chunk.allocateSlot(100);&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;&#10;        // Find first occupied&#10;        int first = chunk.nextOccupiedIndex(0);&#10;        assertTrue(first &gt;= 0);&#10;        assertNotEquals(-1, chunk.getEntityId(first));&#10;&#10;        // Find next after first&#10;        int second = chunk.nextOccupiedIndex(first + 1);&#10;        assertTrue(second &gt; first);&#10;        assertNotEquals(-1, chunk.getEntityId(second));&#10;&#10;        // Count all occupied&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndexWithGaps() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate several slots&#10;        int[] slots = new int[5];&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            slots[i] = chunk.allocateSlot(100 + i);&#10;        }&#10;&#10;        // Free some to create gaps&#10;        chunk.freeSlot(slots[1]);&#10;        chunk.freeSlot(slots[3]);&#10;&#10;        // Count occupied (should be 3)&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            assertNotEquals(-1, chunk.getEntityId(idx), &quot;Occupied slot should have valid entity ID&quot;);&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testQueueingMechanism() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Initially not queued&#10;        assertTrue(chunk.tryMarkQueued());&#10;&#10;        // Should fail second time&#10;        assertFalse(chunk.tryMarkQueued());&#10;&#10;        // Mark dequeued&#10;        chunk.markDequeued();&#10;&#10;        // Should succeed again&#10;        assertTrue(chunk.tryMarkQueued());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations() throws InterruptedException {&#10;        int capacity = 128;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 4;&#10;        int allocationsPerThread = capacity / threads;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * allocationsPerThread;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; allocationsPerThread; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(10, TimeUnit.SECONDS), &quot;Timed out waiting for allocations to complete&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        assertEquals(capacity, successCount.get());&#10;        assertEquals(capacity, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocateAndFree() throws InterruptedException {&#10;        int capacity = 256;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int operations = 1000;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operations;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; operations; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                // Free every other allocation&#10;                                if (i % 2 == 0) {&#10;                                    chunk.freeSlot(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for concurrent operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        // Size should be reasonable (between 0 and capacity)&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity,&#10;                &quot;Final size &quot; + finalSize + &quot; should be in [0, &quot; + capacity + &quot;]&quot;);&#10;&#10;        // All occupied slots should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSlotDataIsZeroedOnAllocation() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate a slot and set some data&#10;        int slot1 = chunk.allocateSlot(100);&#10;        MemorySegment data1 = chunk.getComponentData(0, slot1);&#10;        data1.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 0xDEADBEEFL);&#10;&#10;        // Free the slot&#10;        chunk.freeSlot(slot1);&#10;&#10;        // Allocate again (might get the same slot)&#10;        int slot2 = chunk.allocateSlot(200);&#10;        MemorySegment data2 = chunk.getComponentData(0, slot2);&#10;&#10;        // Data should be zeroed&#10;        assertEquals(0L, data2.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidComponentIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(-1, slot));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(descriptors.length, slot));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidElementIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, -1));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, DEFAULT_CAPACITY));&#10;    }&#10;&#10;    @Test&#10;    void testZeroCapacityChunk() {&#10;        // Zero capacity should throw IllegalArgumentException because bytes = elementSize * 0 = 0&#10;        assertThrows(IllegalArgumentException.class, () -&gt;&#10;                new ArchetypeChunk(descriptors, elementSizes, 0, arena)&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testLargeScaleAllocations_1000Entities() {&#10;        int capacity = 1024;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        // Allocate 1000 entities&#10;        int entityCount = 1000;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            int slot = chunk.allocateSlot(10000 + i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot for entity &quot; + i);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slot should be unique&quot;);&#10;            assertEquals(10000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(entityCount, chunk.size());&#10;        assertEquals(entityCount, allocatedSlots.size());&#10;&#10;        // Verify all allocated entities are accessible&#10;        int verifiedCount = 0;&#10;        for (int slot : allocatedSlots) {&#10;            int entityId = chunk.getEntityId(slot);&#10;            assertTrue(entityId &gt;= 10000 &amp;&amp; entityId &lt; 10000 + entityCount);&#10;            verifiedCount++;&#10;        }&#10;        assertEquals(entityCount, verifiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScaleAllocationsAndFrees_5000Operations() {&#10;        int capacity = 2048;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        // Perform 5000 mixed allocate/free operations&#10;        Set&lt;Integer&gt; activeSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 5000; i++) {&#10;            if (i % 3 == 0 &amp;&amp; !activeSlots.isEmpty()) {&#10;                // Free a random slot&#10;                Integer slotToFree = activeSlots.iterator().next();&#10;                chunk.freeSlot(slotToFree);&#10;                activeSlots.remove(slotToFree);&#10;            } else {&#10;                // Allocate new slot&#10;                int slot = chunk.allocateSlot(20000 + i);&#10;                if (slot &gt;= 0) {&#10;                    activeSlots.add(slot);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Verify chunk consistency&#10;        assertEquals(activeSlots.size(), chunk.size());&#10;&#10;        // Verify all active slots have valid entity IDs&#10;        for (int slot : activeSlots) {&#10;            int entityId = chunk.getEntityId(slot);&#10;            assertNotEquals(-1, entityId, &quot;Active slot should have valid entity ID&quot;);&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations_10000Entities() throws InterruptedException {&#10;        int capacity = 10240;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int entitiesPerThread = 1250; // 8 * 1250 = 10000&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        Set&lt;Integer&gt; allEntityIds = ConcurrentHashMap.newKeySet();&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * entitiesPerThread + 30000;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; entitiesPerThread; i++) {&#10;                            int entityId = baseId + i;&#10;                            int slot = chunk.allocateSlot(entityId);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                                allEntityIds.add(entityId);&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for allocations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;        }&#10;&#10;        assertEquals(10000, successCount.get(), &quot;Should successfully allocate 10000 entities&quot;);&#10;        assertEquals(10000, allEntityIds.size(), &quot;All entity IDs should be unique&quot;);&#10;        assertEquals(10000, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentChurn_20000Operations() throws InterruptedException {&#10;        int capacity = 4096;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 10;&#10;        int operationsPerThread = 2000; // 10 * 2000 = 20000&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operationsPerThread + 40000;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        Set&lt;Integer&gt; mySlots = new HashSet&lt;&gt;();&#10;                        for (int i = 0; i &lt; operationsPerThread; i++) {&#10;                            if (i % 4 == 0 &amp;&amp; !mySlots.isEmpty()) {&#10;                                // Free one of our slots&#10;                                Integer slot = mySlots.iterator().next();&#10;                                chunk.freeSlot(slot);&#10;                                mySlots.remove(slot);&#10;                            } else {&#10;                                // Allocate new&#10;                                int slot = chunk.allocateSlot(baseId + i);&#10;                                if (slot &gt;= 0) {&#10;                                    mySlots.add(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                        // Clean up our remaining slots&#10;                        for (int slot : mySlots) {&#10;                            chunk.freeSlot(slot);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(60, TimeUnit.SECONDS), &quot;Timed out waiting for operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;        }&#10;&#10;        // After all threads clean up, chunk should be empty or have very few entities&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity);&#10;&#10;        // All slots marked as occupied should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSingleSlotCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, 1, arena);&#10;&#10;        assertEquals(1, chunk.capacity());&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(0, slot);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertEquals(-1, slot2);&#10;&#10;        chunk.freeSlot(slot);&#10;        assertTrue(chunk.hasFree());&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testArenaAccess() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertNotNull(chunk.getArena());&#10;        assertEquals(arena, chunk.getArena());&#10;    }&#10;&#10;    @Test&#10;    void testGetEntityCount() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(0, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;        assertEquals(3, chunk.getEntityCount());&#10;    }&#10;&#10;    @Test&#10;    void testGetCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertEquals(DEFAULT_CAPACITY, chunk.getCapacity());&#10;    }&#10;&#10;    // Test component classes&#10;    static final class TestComponent1 {&#10;    }&#10;&#10;    static final class TestComponent2 {&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Comprehensive tests for ArchetypeChunk&#10; */&#10;public class ArchetypeChunkTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private long[] elementSizes;&#10;    private static final int DEFAULT_CAPACITY = 64;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        elementSizes = new long[]{16, 8};&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        // Don't close shared arena - it may be used across tests&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testChunkInitialization() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(DEFAULT_CAPACITY, chunk.capacity());&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertTrue(chunk.hasFree());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateSingleSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertTrue(slot &gt;= 0 &amp;&amp; slot &lt; DEFAULT_CAPACITY);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.isEmpty());&#10;        assertEquals(100, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateMultipleSlots() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int slot = chunk.allocateSlot(1000 + i);&#10;            assertTrue(slot &gt;= 0);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slots should be unique&quot;);&#10;            assertEquals(1000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(10, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateUpToCapacity() {&#10;        int capacity = 16;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            int slot = chunk.allocateSlot(i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot &quot; + i);&#10;        }&#10;&#10;        assertEquals(capacity, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        // Try to allocate one more - should fail&#10;        int extraSlot = chunk.allocateSlot(999);&#10;        assertEquals(-1, extraSlot, &quot;Should not allocate beyond capacity&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testFreeSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertEquals(-1, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateFreeAllocate() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate&#10;        int slot1 = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        // Free&#10;        chunk.freeSlot(slot1);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Allocate again - might reuse same slot&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertTrue(slot2 &gt;= 0);&#10;        assertEquals(1, chunk.size());&#10;        assertEquals(200, chunk.getEntityId(slot2));&#10;    }&#10;&#10;    @Test&#10;    void testDoubleFree() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Double free should be safe&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testGetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Get component data for component 0&#10;        MemorySegment data = chunk.getComponentData(0, slot);&#10;        assertNotNull(data);&#10;        assertEquals(16, data.byteSize());&#10;&#10;        // Get component data for component 1&#10;        MemorySegment data2 = chunk.getComponentData(1, slot);&#10;        assertNotNull(data2);&#10;        assertEquals(8, data2.byteSize());&#10;    }&#10;&#10;    @Test&#10;    void testSetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Create test data&#10;        MemorySegment testData = arena.allocate(16);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 12345L);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 8, 67890L);&#10;&#10;        // Set component data&#10;        chunk.setComponentData(0, slot, testData);&#10;&#10;        // Retrieve and verify&#10;        MemorySegment retrieved = chunk.getComponentData(0, slot);&#10;        assertEquals(12345L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;        assertEquals(67890L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 8));&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate some slots&#10;        chunk.allocateSlot(100);&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;&#10;        // Find first occupied&#10;        int first = chunk.nextOccupiedIndex(0);&#10;        assertTrue(first &gt;= 0);&#10;        assertNotEquals(-1, chunk.getEntityId(first));&#10;&#10;        // Find next after first&#10;        int second = chunk.nextOccupiedIndex(first + 1);&#10;        assertTrue(second &gt; first);&#10;        assertNotEquals(-1, chunk.getEntityId(second));&#10;&#10;        // Count all occupied&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndexWithGaps() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate several slots&#10;        int[] slots = new int[5];&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            slots[i] = chunk.allocateSlot(100 + i);&#10;        }&#10;&#10;        // Free some to create gaps&#10;        chunk.freeSlot(slots[1]);&#10;        chunk.freeSlot(slots[3]);&#10;&#10;        // Count occupied (should be 3)&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            assertNotEquals(-1, chunk.getEntityId(idx), &quot;Occupied slot should have valid entity ID&quot;);&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testQueueingMechanism() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Initially not queued&#10;        assertTrue(chunk.tryMarkQueued());&#10;&#10;        // Should fail second time&#10;        assertFalse(chunk.tryMarkQueued());&#10;&#10;        // Mark dequeued&#10;        chunk.markDequeued();&#10;&#10;        // Should succeed again&#10;        assertTrue(chunk.tryMarkQueued());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations() throws InterruptedException {&#10;        int capacity = 128;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 4;&#10;        int allocationsPerThread = capacity / threads;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * allocationsPerThread;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; allocationsPerThread; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(10, TimeUnit.SECONDS), &quot;Timed out waiting for allocations to complete&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        assertEquals(capacity, successCount.get());&#10;        assertEquals(capacity, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocateAndFree() throws InterruptedException {&#10;        int capacity = 256;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int operations = 1000;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operations;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; operations; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                // Free every other allocation&#10;                                if (i % 2 == 0) {&#10;                                    chunk.freeSlot(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for concurrent operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        // Size should be reasonable (between 0 and capacity)&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity,&#10;                &quot;Final size &quot; + finalSize + &quot; should be in [0, &quot; + capacity + &quot;]&quot;);&#10;&#10;        // All occupied slots should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSlotDataIsZeroedOnAllocation() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate a slot and set some data&#10;        int slot1 = chunk.allocateSlot(100);&#10;        MemorySegment data1 = chunk.getComponentData(0, slot1);&#10;        data1.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 0xDEADBEEFL);&#10;&#10;        // Free the slot&#10;        chunk.freeSlot(slot1);&#10;&#10;        // Allocate again (might get the same slot)&#10;        int slot2 = chunk.allocateSlot(200);&#10;        MemorySegment data2 = chunk.getComponentData(0, slot2);&#10;&#10;        // Data should be zeroed&#10;        assertEquals(0L, data2.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidComponentIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(-1, slot));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(descriptors.length, slot));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidElementIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, -1));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, DEFAULT_CAPACITY));&#10;    }&#10;&#10;    @Test&#10;    void testZeroCapacityChunk() {&#10;        // Zero capacity should throw IllegalArgumentException because bytes = elementSize * 0 = 0&#10;        assertThrows(IllegalArgumentException.class, () -&gt;&#10;                new ArchetypeChunk(descriptors, elementSizes, 0, arena)&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testLargeScaleAllocations_1000Entities() {&#10;        int capacity = 1024;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        // Allocate 1000 entities&#10;        int entityCount = 1000;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            int slot = chunk.allocateSlot(10000 + i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot for entity &quot; + i);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slot should be unique&quot;);&#10;            assertEquals(10000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(entityCount, chunk.size());&#10;        assertEquals(entityCount, allocatedSlots.size());&#10;&#10;        // Verify all allocated entities are accessible&#10;        int verifiedCount = 0;&#10;        for (int slot : allocatedSlots) {&#10;            int entityId = chunk.getEntityId(slot);&#10;            assertTrue(entityId &gt;= 10000 &amp;&amp; entityId &lt; 10000 + entityCount);&#10;            verifiedCount++;&#10;        }&#10;        assertEquals(entityCount, verifiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScaleAllocationsAndFrees_5000Operations() {&#10;        int capacity = 2048;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        // Perform 5000 mixed allocate/free operations&#10;        Set&lt;Integer&gt; activeSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 5000; i++) {&#10;            if (i % 3 == 0 &amp;&amp; !activeSlots.isEmpty()) {&#10;                // Free a random slot&#10;                Integer slotToFree = activeSlots.iterator().next();&#10;                chunk.freeSlot(slotToFree);&#10;                activeSlots.remove(slotToFree);&#10;            } else {&#10;                // Allocate new slot&#10;                int slot = chunk.allocateSlot(20000 + i);&#10;                if (slot &gt;= 0) {&#10;                    activeSlots.add(slot);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Verify chunk consistency&#10;        assertEquals(activeSlots.size(), chunk.size());&#10;&#10;        // Verify all active slots have valid entity IDs&#10;        for (int slot : activeSlots) {&#10;            int entityId = chunk.getEntityId(slot);&#10;            assertNotEquals(-1, entityId, &quot;Active slot should have valid entity ID&quot;);&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations_10000Entities() throws InterruptedException {&#10;        int capacity = 10240;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int entitiesPerThread = 1250; // 8 * 1250 = 10000&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        Set&lt;Integer&gt; allEntityIds = ConcurrentHashMap.newKeySet();&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * entitiesPerThread + 30000;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; entitiesPerThread; i++) {&#10;                            int entityId = baseId + i;&#10;                            int slot = chunk.allocateSlot(entityId);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                                allEntityIds.add(entityId);&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for allocations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;        }&#10;&#10;        assertEquals(10000, successCount.get(), &quot;Should successfully allocate 10000 entities&quot;);&#10;        assertEquals(10000, allEntityIds.size(), &quot;All entity IDs should be unique&quot;);&#10;        assertEquals(10000, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentChurn_20000Operations() throws InterruptedException {&#10;        int capacity = 4096;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 10;&#10;        int operationsPerThread = 2000; // 10 * 2000 = 20000&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operationsPerThread + 40000;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        Set&lt;Integer&gt; mySlots = new HashSet&lt;&gt;();&#10;                        for (int i = 0; i &lt; operationsPerThread; i++) {&#10;                            if (i % 4 == 0 &amp;&amp; !mySlots.isEmpty()) {&#10;                                // Free one of our slots&#10;                                Integer slot = mySlots.iterator().next();&#10;                                chunk.freeSlot(slot);&#10;                                mySlots.remove(slot);&#10;                            } else {&#10;                                // Allocate new&#10;                                int slot = chunk.allocateSlot(baseId + i);&#10;                                if (slot &gt;= 0) {&#10;                                    mySlots.add(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                        // Clean up our remaining slots&#10;                        for (int slot : mySlots) {&#10;                            chunk.freeSlot(slot);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(60, TimeUnit.SECONDS), &quot;Timed out waiting for operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;        }&#10;&#10;        // After all threads clean up, chunk should be empty or have very few entities&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity);&#10;&#10;        // All slots marked as occupied should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSingleSlotCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, 1, arena);&#10;&#10;        assertEquals(1, chunk.capacity());&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(0, slot);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertEquals(-1, slot2);&#10;&#10;        chunk.freeSlot(slot);&#10;        assertTrue(chunk.hasFree());&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testArenaAccess() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertNotNull(chunk.getArena());&#10;        assertEquals(arena, chunk.getArena());&#10;    }&#10;&#10;    @Test&#10;    void testGetEntityCount() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(0, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;        assertEquals(3, chunk.getEntityCount());&#10;    }&#10;&#10;    @Test&#10;    void testGetCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertEquals(DEFAULT_CAPACITY, chunk.getCapacity());&#10;    }&#10;&#10;    // Test component classes&#10;    static final class TestComponent1 {&#10;    }&#10;&#10;    static final class TestComponent2 {&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/LargeScaleTestSuite.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/LargeScaleTestSuite.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import org.junit.platform.suite.api.SelectClasses;&#10;import org.junit.platform.suite.api.Suite;&#10;import org.junit.platform.suite.api.SuiteDisplayName;&#10;&#10;/**&#10; * Comprehensive test suite for large-scale entity operations.&#10; * This suite runs all large-scale tests for ArchetypeChunk and LockFreeAllocator.&#10; */&#10;@Suite&#10;@SuiteDisplayName(&quot;Large Scale ECS Test Suite&quot;)&#10;@SelectClasses({&#10;    ArchetypeChunkTest.class,&#10;    LockFreeAllocatorTest.class,&#10;    ParallelQueryTest.class&#10;})&#10;public class LargeScaleTestSuite {&#10;    // This class remains empty, it is used only as a holder for the suite annotations&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import org.junit.platform.suite.api.SelectClasses;&#10;import org.junit.platform.suite.api.Suite;&#10;import org.junit.platform.suite.api.SuiteDisplayName;&#10;&#10;/**&#10; * Comprehensive test suite for large-scale entity operations.&#10; * This suite runs all large-scale tests for ArchetypeChunk and LockFreeAllocator.&#10; */&#10;@Suite&#10;@SuiteDisplayName(&quot;Large Scale ECS Test Suite&quot;)&#10;@SelectClasses({&#10;    ArchetypeChunkTest.class,&#10;    LockFreeAllocatorTest.class,&#10;    ParallelQueryTest.class&#10;})&#10;public class LargeScaleTestSuite {&#10;    // This class remains empty, it is used only as a holder for the suite annotations&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ManagedComponentStoreTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ManagedComponentStoreTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.ManagedComponentStore;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;public class ManagedComponentStoreTest {&#10;&#10;    @Test&#10;    void storeGetRelease_basic() {&#10;        ManagedComponentStore store = new ManagedComponentStore(4);&#10;        int a = store.store(&quot;A&quot;);&#10;        int b = store.store(&quot;B&quot;);&#10;        assertNotEquals(a, b);&#10;        assertEquals(&quot;A&quot;, store.get(a));&#10;        assertEquals(&quot;B&quot;, store.get(b));&#10;        store.release(a);&#10;        assertNull(store.get(a));&#10;        int c = store.store(&quot;C&quot;);&#10;        // c can reuse 'a' slot&#10;        assertEquals(&quot;C&quot;, store.get(c));&#10;    }&#10;&#10;    @Test&#10;    void concurrent_store_and_release() throws InterruptedException {&#10;        ManagedComponentStore store = new ManagedComponentStore(8);&#10;        int threads = 8;&#10;        int ops = 1000;&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;        try (ExecutorService es = Executors.newFixedThreadPool(threads)) {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                es.submit(() -&gt; {&#10;                    try {&#10;                        start.await();&#10;                        List&lt;Integer&gt; tickets = new ArrayList&lt;&gt;();&#10;                        for (int i = 0; i &lt; ops; i++) {&#10;                            int id = store.store(&quot;x&quot; + i);&#10;                            tickets.add(id);&#10;                            if ((i &amp; 1) == 0) {&#10;                                // release half of them&#10;                                store.release(id);&#10;                            }&#10;                        }&#10;                        // release the rest&#10;                        for (int id : tickets) {&#10;                            store.release(id);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        done.countDown();&#10;                    }&#10;                });&#10;            }&#10;            start.countDown();&#10;            assertTrue(done.await(30, TimeUnit.SECONDS));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void deterministicReuse_smallCapacity() {&#10;        ManagedComponentStore store = new ManagedComponentStore(2);&#10;        int t0 = store.store(&quot;A&quot;);&#10;        int t1 = store.store(&quot;B&quot;);&#10;        assertNotEquals(t0, t1);&#10;        // Release first, it should be reused by next store&#10;        store.release(t0);&#10;        assertNull(store.get(t0));&#10;        int t2 = store.store(&quot;C&quot;);&#10;        assertEquals(t0, t2, &quot;Expected first released ticket to be reused&quot;);&#10;        // Release second, then reused&#10;        store.release(t1);&#10;        assertNull(store.get(t1));&#10;        int t3 = store.store(&quot;D&quot;);&#10;        assertEquals(t1, t3, &quot;Expected second released ticket to be reused&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.ManagedComponentStore;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;public class ManagedComponentStoreTest {&#10;&#10;    @Test&#10;    void storeGetRelease_basic() {&#10;        ManagedComponentStore store = new ManagedComponentStore(4);&#10;        int a = store.store(&quot;A&quot;);&#10;        int b = store.store(&quot;B&quot;);&#10;        assertNotEquals(a, b);&#10;        assertEquals(&quot;A&quot;, store.get(a));&#10;        assertEquals(&quot;B&quot;, store.get(b));&#10;        store.release(a);&#10;        assertNull(store.get(a));&#10;        int c = store.store(&quot;C&quot;);&#10;        // c can reuse 'a' slot&#10;        assertEquals(&quot;C&quot;, store.get(c));&#10;    }&#10;&#10;    @Test&#10;    void concurrent_store_and_release() throws InterruptedException {&#10;        ManagedComponentStore store = new ManagedComponentStore(8);&#10;        int threads = 8;&#10;        int ops = 1000;&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;        try (ExecutorService es = Executors.newFixedThreadPool(threads)) {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                es.submit(() -&gt; {&#10;                    try {&#10;                        start.await();&#10;                        List&lt;Integer&gt; tickets = new ArrayList&lt;&gt;();&#10;                        for (int i = 0; i &lt; ops; i++) {&#10;                            int id = store.store(&quot;x&quot; + i);&#10;                            tickets.add(id);&#10;                            if ((i &amp; 1) == 0) {&#10;                                // release half of them&#10;                                store.release(id);&#10;                            }&#10;                        }&#10;                        // release the rest&#10;                        for (int id : tickets) {&#10;                            store.release(id);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        done.countDown();&#10;                    }&#10;                });&#10;            }&#10;            start.countDown();&#10;            assertTrue(done.await(30, TimeUnit.SECONDS));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void deterministicReuse_smallCapacity() {&#10;        ManagedComponentStore store = new ManagedComponentStore(2);&#10;        int t0 = store.store(&quot;A&quot;);&#10;        int t1 = store.store(&quot;B&quot;);&#10;        assertNotEquals(t0, t1);&#10;        // Release first, it should be reused by next store&#10;        store.release(t0);&#10;        assertNull(store.get(t0));&#10;        int t2 = store.store(&quot;C&quot;);&#10;        assertEquals(t0, t2, &quot;Expected first released ticket to be reused&quot;);&#10;        // Release second, then reused&#10;        store.release(t1);&#10;        assertNull(store.get(t1));&#10;        int t3 = store.store(&quot;D&quot;);&#10;        assertEquals(t1, t3, &quot;Expected second released ticket to be reused&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ManagedIntegrationTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ManagedIntegrationTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;public class ManagedIntegrationTest {&#10;&#10;    @Component.Managed&#10;    static class PlayerName implements Component {&#10;        final String name;&#10;        PlayerName(String n) { this.name = n; }&#10;    }&#10;&#10;    @Test&#10;    void add_get_replace_remove_managed_component() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            world.registerComponent(PlayerName.class);&#10;            int e = world.createEntity();&#10;&#10;            // Add managed component instance&#10;            world.addComponent(e, new PlayerName(&quot;Ethnic&quot;));&#10;            PlayerName pn = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pn);&#10;            assertEquals(&quot;Ethnic&quot;, pn.name);&#10;&#10;            // Replace instance&#10;            world.setManagedComponent(e, new PlayerName(&quot;Neo&quot;));&#10;            PlayerName pn2 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pn2);&#10;            assertEquals(&quot;Neo&quot;, pn2.name);&#10;&#10;            // Remove&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;&#10;            // Destroy shouldn't throw&#10;            world.destroyEntity(e);&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void move_between_archetypes_preserves_managed_ticket_if_present() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            // Define an unmanaged component too&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class Dummy implements Component { @Component.Field int v; }&#10;            world.registerComponent(PlayerName.class);&#10;            world.registerComponent(Dummy.class);&#10;&#10;            int e = world.createEntity(Dummy.class);&#10;            world.addComponent(e, new PlayerName(&quot;A&quot;));&#10;            PlayerName p = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p);&#10;            assertEquals(&quot;A&quot;, p.name);&#10;&#10;            // Add another unmanaged component class to force move&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class Dummy2 implements Component { @Component.Field int x; }&#10;            world.registerComponent(Dummy2.class);&#10;&#10;            // Add Dummy2 -&gt; structural move; ticket should persist&#10;            world.addComponent(e, Dummy2.class, cm.allocate(Dummy2.class, java.lang.foreign.Arena.ofShared()));&#10;            PlayerName p2 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p2);&#10;            assertEquals(&quot;A&quot;, p2.name);&#10;&#10;            // Now remove PlayerName -&gt; should become null&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void interleave_managed_unmanaged_ops_no_ticket_leaks() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            // Define a couple unmanaged components&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class U1 implements Component { @Component.Field int a; }&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class U2 implements Component { @Component.Field int b; }&#10;&#10;            world.registerComponent(PlayerName.class);&#10;            world.registerComponent(U1.class);&#10;            world.registerComponent(U2.class);&#10;&#10;            int e = world.createEntity(U1.class);&#10;&#10;            // Add managed, then add another unmanaged -&gt; triggers move&#10;            world.addComponent(e, new PlayerName(&quot;P0&quot;));&#10;            world.addComponent(e, U2.class, cm.allocate(U2.class, java.lang.foreign.Arena.ofShared()));&#10;            PlayerName p0 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p0);&#10;            assertEquals(&quot;P0&quot;, p0.name);&#10;&#10;            // Remove unmanaged U1 -&gt; move&#10;            world.removeComponent(e, U1.class);&#10;            PlayerName pAfterMove = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pAfterMove);&#10;            assertEquals(&quot;P0&quot;, pAfterMove.name);&#10;&#10;            // Replace managed instance&#10;            world.setManagedComponent(e, new PlayerName(&quot;P1&quot;));&#10;            PlayerName p1 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p1);&#10;            assertEquals(&quot;P1&quot;, p1.name);&#10;&#10;            // Remove managed&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;&#10;            // Add again and then destroy entity -&gt; should release&#10;            world.addComponent(e, new PlayerName(&quot;P2&quot;));&#10;            assertNotNull(world.getManagedComponent(e, PlayerName.class));&#10;            world.destroyEntity(e);&#10;            // Entity gone; can't directly check store, but absence via accessor indicates ticket release or entity removal&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;public class ManagedIntegrationTest {&#10;&#10;    @Component.Managed&#10;    static class PlayerName implements Component {&#10;        final String name;&#10;        PlayerName(String n) { this.name = n; }&#10;    }&#10;&#10;    @Test&#10;    void add_get_replace_remove_managed_component() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            world.registerComponent(PlayerName.class);&#10;            int e = world.createEntity();&#10;&#10;            // Add managed component instance&#10;            world.addComponent(e, new PlayerName(&quot;Ethnic&quot;));&#10;            PlayerName pn = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pn);&#10;            assertEquals(&quot;Ethnic&quot;, pn.name);&#10;&#10;            // Replace instance&#10;            world.setManagedComponent(e, new PlayerName(&quot;Neo&quot;));&#10;            PlayerName pn2 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pn2);&#10;            assertEquals(&quot;Neo&quot;, pn2.name);&#10;&#10;            // Remove&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;&#10;            // Destroy shouldn't throw&#10;            world.destroyEntity(e);&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void move_between_archetypes_preserves_managed_ticket_if_present() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            // Define an unmanaged component too&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class Dummy implements Component { @Component.Field int v; }&#10;            world.registerComponent(PlayerName.class);&#10;            world.registerComponent(Dummy.class);&#10;&#10;            int e = world.createEntity(Dummy.class);&#10;            world.addComponent(e, new PlayerName(&quot;A&quot;));&#10;            PlayerName p = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p);&#10;            assertEquals(&quot;A&quot;, p.name);&#10;&#10;            // Add another unmanaged component class to force move&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class Dummy2 implements Component { @Component.Field int x; }&#10;            world.registerComponent(Dummy2.class);&#10;&#10;            // Add Dummy2 -&gt; structural move; ticket should persist&#10;            world.addComponent(e, Dummy2.class, cm.allocate(Dummy2.class, java.lang.foreign.Arena.ofShared()));&#10;            PlayerName p2 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p2);&#10;            assertEquals(&quot;A&quot;, p2.name);&#10;&#10;            // Now remove PlayerName -&gt; should become null&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void interleave_managed_unmanaged_ops_no_ticket_leaks() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            // Define a couple unmanaged components&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class U1 implements Component { @Component.Field int a; }&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class U2 implements Component { @Component.Field int b; }&#10;&#10;            world.registerComponent(PlayerName.class);&#10;            world.registerComponent(U1.class);&#10;            world.registerComponent(U2.class);&#10;&#10;            int e = world.createEntity(U1.class);&#10;&#10;            // Add managed, then add another unmanaged -&gt; triggers move&#10;            world.addComponent(e, new PlayerName(&quot;P0&quot;));&#10;            world.addComponent(e, U2.class, cm.allocate(U2.class, java.lang.foreign.Arena.ofShared()));&#10;            PlayerName p0 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p0);&#10;            assertEquals(&quot;P0&quot;, p0.name);&#10;&#10;            // Remove unmanaged U1 -&gt; move&#10;            world.removeComponent(e, U1.class);&#10;            PlayerName pAfterMove = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pAfterMove);&#10;            assertEquals(&quot;P0&quot;, pAfterMove.name);&#10;&#10;            // Replace managed instance&#10;            world.setManagedComponent(e, new PlayerName(&quot;P1&quot;));&#10;            PlayerName p1 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p1);&#10;            assertEquals(&quot;P1&quot;, p1.name);&#10;&#10;            // Remove managed&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;&#10;            // Add again and then destroy entity -&gt; should release&#10;            world.addComponent(e, new PlayerName(&quot;P2&quot;));&#10;            assertNotNull(world.getManagedComponent(e, PlayerName.class));&#10;            world.destroyEntity(e);&#10;            // Entity gone; can't directly check store, but absence via accessor indicates ticket release or entity removal&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>