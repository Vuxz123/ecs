<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    id(&quot;java&quot;)&#10;    id(&quot;application&quot;)&#10;    `java-library`&#10;    id(&quot;me.champeau.jmh&quot;) version &quot;0.7.3&quot;&#10;}&#10;&#10;group = &quot;com.ethnicthv&quot;&#10;version = &quot;1.0-SNAPSHOT&quot;&#10;&#10;java {&#10;    toolchain {&#10;        languageVersion.set(JavaLanguageVersion.of(25))&#10;    }&#10;}&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    // Enable our annotation processor for compile&#10;    annotationProcessor(project(&quot;:ecs-processor&quot;))&#10;    // Enable it for tests as well&#10;    testAnnotationProcessor(project(&quot;:ecs-processor&quot;))&#10;&#10;    testImplementation(platform(&quot;org.junit:junit-bom:5.10.0&quot;))&#10;    testImplementation(&quot;org.junit.jupiter:junit-jupiter&quot;)&#10;    testImplementation(&quot;org.junit.platform:junit-platform-suite-api&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-launcher&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-suite-engine&quot;)&#10;&#10;    // JMH for benchmarking&#10;    implementation (&quot;org.openjdk.jmh:jmh-core:0.9&quot;)&#10;    annotationProcessor (&quot;org.openjdk.jmh:jmh-generator-annprocess:0.9&quot;)&#10;    // proc ('org.openjdk.jmh:jmh-generator-bytecode:0.9')&#10;&#10;    // Fix for &quot;NoClassDefFoundError: javax/annotation/Generated&quot; on JDK 9+&#10;    annotationProcessor(&quot;javax.annotation:javax.annotation-api:1.3.2&quot;)&#10;    implementation(&quot;javax.annotation:javax.annotation-api:1.3.2&quot;)&#10;}&#10;&#10;application {&#10;    // updated to use the demo package where the entry points were moved&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ECSDemo&quot;)&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;tasks.withType&lt;JavaCompile&gt; {&#10;    options.compilerArgs.addAll(listOf(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;    ))&#10;}&#10;&#10;tasks.withType&lt;Test&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.withType&lt;JavaExec&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the performance benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.PerformanceBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ComponentManager demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runImproved&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the improved demo with Query API and true SoA&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ImprovedDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the Archetype-based ECS demo&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Benchmark Archetype vs SparseSet ECS&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeVsSparseSetBenchmark&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeQueryDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ArchetypeQuery demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeQueryDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run Component Manager + Archetype ECS benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;,&#10;        &quot;-Xms2G&quot;,&#10;        &quot;-Xmx4G&quot;&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;    id(&quot;java&quot;)&#10;    id(&quot;application&quot;)&#10;    `java-library`&#10;    id(&quot;me.champeau.jmh&quot;) version &quot;0.7.3&quot;&#10;}&#10;&#10;group = &quot;com.ethnicthv&quot;&#10;version = &quot;1.0-SNAPSHOT&quot;&#10;&#10;java {&#10;    toolchain {&#10;        languageVersion.set(JavaLanguageVersion.of(25))&#10;    }&#10;}&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    // Enable our annotation processor for compile&#10;    annotationProcessor(project(&quot;:ecs-processor&quot;))&#10;    // Enable it for tests as well&#10;    testAnnotationProcessor(project(&quot;:ecs-processor&quot;))&#10;&#10;    testImplementation(platform(&quot;org.junit:junit-bom:5.10.0&quot;))&#10;    testImplementation(&quot;org.junit.jupiter:junit-jupiter&quot;)&#10;    testImplementation(&quot;org.junit.platform:junit-platform-suite-api&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-launcher&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-suite-engine&quot;)&#10;&#10;    // JMH for benchmarking&#10;    implementation (&quot;org.openjdk.jmh:jmh-core:0.9&quot;)&#10;    annotationProcessor (&quot;org.openjdk.jmh:jmh-generator-annprocess:0.9&quot;)&#10;    // proc ('org.openjdk.jmh:jmh-generator-bytecode:0.9')&#10;&#10;    // Fix for &quot;NoClassDefFoundError: javax/annotation/Generated&quot; on JDK 9+&#10;    annotationProcessor(&quot;javax.annotation:javax.annotation-api:1.3.2&quot;)&#10;    implementation(&quot;javax.annotation:javax.annotation-api:1.3.2&quot;)&#10;}&#10;&#10;application {&#10;    // updated to use the demo package where the entry points were moved&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ECSDemo&quot;)&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;tasks.withType&lt;JavaCompile&gt; {&#10;    options.compilerArgs.addAll(listOf(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;    ))&#10;}&#10;&#10;tasks.withType&lt;Test&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.withType&lt;JavaExec&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the performance benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.PerformanceBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ComponentManager demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runImproved&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the improved demo with Query API and true SoA&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ImprovedDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the Archetype-based ECS demo&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Benchmark Archetype vs SparseSet ECS&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeVsSparseSetBenchmark&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeQueryDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ArchetypeQuery demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeQueryDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run Component Manager + Archetype ECS benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;,&#10;        &quot;-Xms2G&quot;,&#10;        &quot;-Xmx4G&quot;&#10;    )&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeChunk.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeChunk.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk {&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                size.incrementAndGet();&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                size.decrementAndGet();&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk {&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                size.incrementAndGet();&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                size.decrementAndGet();&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] componentIds = m.toComponentIdArray();&#10;            ComponentDescriptor[] descriptors = new ComponentDescriptor[componentIds.length];&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                var meta = metadataProvider.apply(componentIds[i]);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + componentIds[i]);&#10;                }&#10;                descriptors[i] = componentManager.getDescriptor(meta.type());&#10;            }&#10;            return new Archetype(m, componentIds, descriptors, arena);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] componentIds = m.toComponentIdArray();&#10;            ComponentDescriptor[] descriptors = new ComponentDescriptor[componentIds.length];&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                var meta = metadataProvider.apply(componentIds[i]);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + componentIds[i]);&#10;                }&#10;                descriptors[i] = componentManager.getDescriptor(meta.type());&#10;            }&#10;            return new Archetype(m, componentIds, descriptors, arena);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeQuery.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeQuery.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentHandle;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (ArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                consumer.accept(entityId, location, chunk, archetype);&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities, providing pooled ComponentHandles for the requested component classes.&#10;     * The consumer receives an array of bound ComponentHandle (same order as componentClasses). The handles are released&#10;     * back to the manager after the consumer returns. This is intended for synchronous, short-lived access inside the consumer.&#10;     */&#10;    public void forEachEntityWith(EntityWithHandlesConsumer consumer, Class&lt;?&gt;... componentClasses) {&#10;        // Resolve component type IDs for requested classes&#10;        int[] reqTypeIds = new int[componentClasses.length];&#10;        for (int i = 0; i &lt; componentClasses.length; i++) {&#10;            Integer tid = world.getComponentTypeId(componentClasses[i]);&#10;            if (tid == null) {&#10;                // If a requested component class is not registered, no entity will match; return early&#10;                return;&#10;            }&#10;            reqTypeIds[i] = tid;&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            int[] compIndices = new int[reqTypeIds.length];&#10;            for (int i = 0; i &lt; reqTypeIds.length; i++) {&#10;                int idx = archetype.indexOfComponentType(reqTypeIds[i]);&#10;                if (idx &lt; 0) {&#10;                    // archetype missing at least one required component; skip it&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;&#10;            // Iterate entities in archetype&#10;            final int[] useIdx = compIndices; // capture&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; useIdx.length; k++) {&#10;                        int compIdx = useIdx[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, location, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeConsumer {&#10;        void accept(Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ChunkConsumer {&#10;        void accept(ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityConsumer {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityWithHandlesConsumer {&#10;        void accept(int entityId, ComponentHandle[] handles, ArchetypeChunk.ChunkLocation location, Archetype archetype);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentHandle;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (ArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                consumer.accept(entityId, location, chunk, archetype);&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities, providing pooled ComponentHandles for the requested component classes.&#10;     * The consumer receives an array of bound ComponentHandle (same order as componentClasses). The handles are released&#10;     * back to the manager after the consumer returns. This is intended for synchronous, short-lived access inside the consumer.&#10;     */&#10;    public void forEachEntityWith(EntityWithHandlesConsumer consumer, Class&lt;?&gt;... componentClasses) {&#10;        // Resolve component type IDs for requested classes&#10;        int[] reqTypeIds = new int[componentClasses.length];&#10;        for (int i = 0; i &lt; componentClasses.length; i++) {&#10;            Integer tid = world.getComponentTypeId(componentClasses[i]);&#10;            if (tid == null) {&#10;                // If a requested component class is not registered, no entity will match; return early&#10;                return;&#10;            }&#10;            reqTypeIds[i] = tid;&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            int[] compIndices = new int[reqTypeIds.length];&#10;            for (int i = 0; i &lt; reqTypeIds.length; i++) {&#10;                int idx = archetype.indexOfComponentType(reqTypeIds[i]);&#10;                if (idx &lt; 0) {&#10;                    // archetype missing at least one required component; skip it&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;&#10;            // Iterate entities in archetype&#10;            final int[] useIdx = compIndices; // capture&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; useIdx.length; k++) {&#10;                        int compIdx = useIdx[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, location, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeConsumer {&#10;        void accept(Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ChunkConsumer {&#10;        void accept(ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityConsumer {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityWithHandlesConsumer {&#10;        void accept(int entityId, ComponentHandle[] handles, ArchetypeChunk.ChunkLocation location, Archetype archetype);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeWorld.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeWorld.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ComponentManager componentManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    private final AtomicInteger nextComponentTypeId = new AtomicInteger(0);&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentMetadata = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentTypeIds.computeIfAbsent(componentClass, cls -&gt; {&#10;            int tid = componentManager.registerComponent(cls);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(cls);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, cls, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id atomically&#10;            nextComponentTypeId.updateAndGet(prev -&gt; Math.max(prev, tid + 1));&#10;            return tid;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query for entities matching component requirements&#10;     */&#10;    public ArchetypeQuery query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Delegate archetype construction to ArchetypeManager&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;&#10;        // Copy existing component data (only components present in both)&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;        int[] componentIds = newMask.toComponentIdArray();&#10;        for (int componentTypeId : componentIds) {&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ComponentManager componentManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    private final AtomicInteger nextComponentTypeId = new AtomicInteger(0);&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentMetadata = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentTypeIds.computeIfAbsent(componentClass, cls -&gt; {&#10;            int tid = componentManager.registerComponent(cls);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(cls);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, cls, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id atomically&#10;            nextComponentTypeId.updateAndGet(prev -&gt; Math.max(prev, tid + 1));&#10;            return tid;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query for entities matching component requirements&#10;     */&#10;    public ArchetypeQuery query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Delegate archetype construction to ArchetypeManager&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;&#10;        // Copy existing component data (only components present in both)&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;        int[] componentIds = newMask.toComponentIdArray();&#10;        for (int componentTypeId : componentIds) {&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ComponentMask.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ComponentMask.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import java.util.BitSet;&#10;&#10;/**&#10; * Represents a unique signature of components that an entity possesses.&#10; * Used to identify and group entities with the same component composition.&#10; */&#10;public final class ComponentMask {&#10;    private final BitSet mask;&#10;    private final int hashCode;&#10;&#10;    public ComponentMask() {&#10;        this.mask = new BitSet();&#10;        this.hashCode = 0;&#10;    }&#10;&#10;    private ComponentMask(BitSet mask) {&#10;        this.mask = (BitSet) mask.clone();&#10;        this.hashCode = mask.hashCode();&#10;    }&#10;&#10;    /**&#10;     * Set a component bit in the mask&#10;     */&#10;    public ComponentMask set(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.set(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Clear a component bit from the mask&#10;     */&#10;    public ComponentMask clear(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.clear(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Check if a component is present in the mask&#10;     */&#10;    public boolean has(int componentId) {&#10;        return mask.get(componentId);&#10;    }&#10;&#10;    /**&#10;     * Check if this mask contains all components from another mask&#10;     */&#10;    public boolean contains(ComponentMask other) {&#10;        BitSet intersection = (BitSet) mask.clone();&#10;        intersection.and(other.mask);&#10;        return intersection.equals(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask is a superset of other (WITH semantics).&#10;     */&#10;    public boolean containsAll(ComponentMask other) {&#10;        // other - this == empty ?&#10;        BitSet diff = (BitSet) other.mask.clone();&#10;        diff.andNot(this.mask);&#10;        return diff.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask shares at least one bit with other (ANY semantics).&#10;     */&#10;    public boolean intersects(ComponentMask other) {&#10;        return this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask has no bits in common with other (WITHOUT semantics).&#10;     */&#10;    public boolean containsNone(ComponentMask other) {&#10;        return !this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Get the number of components in this mask&#10;     */&#10;    public int cardinality() {&#10;        return mask.cardinality();&#10;    }&#10;&#10;    /**&#10;     * Return all set component IDs in ascending order.&#10;     */&#10;    public int[] toComponentIdArray() {&#10;        int count = mask.cardinality();&#10;        int[] ids = new int[count];&#10;        int idx = 0;&#10;        for (int bit = mask.nextSetBit(0); bit &gt;= 0; bit = mask.nextSetBit(bit + 1)) {&#10;            ids[idx++] = bit;&#10;        }&#10;        return ids;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        ComponentMask that = (ComponentMask) o;&#10;        return mask.equals(that.mask);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return hashCode;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;ComponentMask{&quot; + mask + '}';&#10;    }&#10;&#10;    /**&#10;     * Create a builder for fluent API&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    public static class Builder {&#10;        private final BitSet mask = new BitSet();&#10;&#10;        public Builder with(int componentId) {&#10;            mask.set(componentId);&#10;            return this;&#10;        }&#10;&#10;        public ComponentMask build() {&#10;            return new ComponentMask(mask);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import java.util.BitSet;&#10;&#10;/**&#10; * Represents a unique signature of components that an entity possesses.&#10; * Used to identify and group entities with the same component composition.&#10; */&#10;public final class ComponentMask {&#10;    private final BitSet mask;&#10;    private final int hashCode;&#10;&#10;    public ComponentMask() {&#10;        this.mask = new BitSet();&#10;        this.hashCode = 0;&#10;    }&#10;&#10;    private ComponentMask(BitSet mask) {&#10;        this.mask = (BitSet) mask.clone();&#10;        this.hashCode = mask.hashCode();&#10;    }&#10;&#10;    /**&#10;     * Set a component bit in the mask&#10;     */&#10;    public ComponentMask set(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.set(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Clear a component bit from the mask&#10;     */&#10;    public ComponentMask clear(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.clear(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Check if a component is present in the mask&#10;     */&#10;    public boolean has(int componentId) {&#10;        return mask.get(componentId);&#10;    }&#10;&#10;    /**&#10;     * Check if this mask contains all components from another mask&#10;     */&#10;    public boolean contains(ComponentMask other) {&#10;        BitSet intersection = (BitSet) mask.clone();&#10;        intersection.and(other.mask);&#10;        return intersection.equals(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask is a superset of other (WITH semantics).&#10;     */&#10;    public boolean containsAll(ComponentMask other) {&#10;        // other - this == empty ?&#10;        BitSet diff = (BitSet) other.mask.clone();&#10;        diff.andNot(this.mask);&#10;        return diff.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask shares at least one bit with other (ANY semantics).&#10;     */&#10;    public boolean intersects(ComponentMask other) {&#10;        return this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask has no bits in common with other (WITHOUT semantics).&#10;     */&#10;    public boolean containsNone(ComponentMask other) {&#10;        return !this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Get the number of components in this mask&#10;     */&#10;    public int cardinality() {&#10;        return mask.cardinality();&#10;    }&#10;&#10;    /**&#10;     * Return all set component IDs in ascending order.&#10;     */&#10;    public int[] toComponentIdArray() {&#10;        int count = mask.cardinality();&#10;        int[] ids = new int[count];&#10;        int idx = 0;&#10;        for (int bit = mask.nextSetBit(0); bit &gt;= 0; bit = mask.nextSetBit(bit + 1)) {&#10;            ids[idx++] = bit;&#10;        }&#10;        return ids;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        ComponentMask that = (ComponentMask) o;&#10;        return mask.equals(that.mask);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return hashCode;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;ComponentMask{&quot; + mask + '}';&#10;    }&#10;&#10;    /**&#10;     * Create a builder for fluent API&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    public static class Builder {&#10;        private final BitSet mask = new BitSet();&#10;&#10;        public Builder with(int componentId) {&#10;            mask.set(componentId);&#10;            return this;&#10;        }&#10;&#10;        public ComponentMask build() {&#10;            return new ComponentMask(mask);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/system/ArchetypeMovementSystem.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/system/ArchetypeMovementSystem.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype.system;&#10;&#10;import com.ethnicthv.ecs.archetype.Archetype;&#10;import com.ethnicthv.ecs.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.components.PositionComponent;&#10;import com.ethnicthv.ecs.components.VelocityComponent;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Movement system optimized for Archetype-based ECS.&#10; * Processes entities in cache-friendly chunks.&#10; */&#10;public final class ArchetypeMovementSystem {&#10;    private final ArchetypeWorld world;&#10;    private final int positionTypeId;&#10;    private final int velocityTypeId;&#10;&#10;    public ArchetypeMovementSystem(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.positionTypeId = world.getComponentTypeId(PositionComponent.class);&#10;        this.velocityTypeId = world.getComponentTypeId(VelocityComponent.class);&#10;    }&#10;&#10;    /**&#10;     * Update all entities that have both Position and Velocity&#10;     */&#10;    public void update(float deltaTime) {&#10;        world.query()&#10;            .with(PositionComponent.class)&#10;            .with(VelocityComponent.class)&#10;            .forEachChunk((chunk, archetype) -&gt; {&#10;                updateChunk(chunk, archetype, deltaTime);&#10;            });&#10;    }&#10;&#10;    private void updateChunk(ArchetypeChunk chunk, Archetype archetype, float deltaTime) {&#10;        int size = chunk.size();&#10;&#10;        // Get component indices in this archetype&#10;        int posIndex = getComponentIndex(archetype, positionTypeId);&#10;        int velIndex = getComponentIndex(archetype, velocityTypeId);&#10;&#10;        // Process each entity in the chunk&#10;        for (int i = 0; i &lt; size; i++) {&#10;            MemorySegment posData = chunk.getComponentData(posIndex, i);&#10;            MemorySegment velData = chunk.getComponentData(velIndex, i);&#10;&#10;            if (posData != null &amp;&amp; velData != null) {&#10;                // Read velocity&#10;                float vx = velData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float vy = velData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Read position&#10;                float x = posData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float y = posData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Update position&#10;                x += vx * deltaTime;&#10;                y += vy * deltaTime;&#10;&#10;                // Write back&#10;                posData.set(ValueLayout.JAVA_FLOAT, 0, x);&#10;                posData.set(ValueLayout.JAVA_FLOAT, 4, y);&#10;            }&#10;        }&#10;    }&#10;&#10;    private int getComponentIndex(Archetype archetype, int componentTypeId) {&#10;        int index = 0;&#10;        ComponentMask mask = archetype.getMask();&#10;        for (int i = 0; i &lt; componentTypeId; i++) {&#10;            if (mask.has(i)) {&#10;                index++;&#10;            }&#10;        }&#10;        return index;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype.system;&#10;&#10;import com.ethnicthv.ecs.archetype.Archetype;&#10;import com.ethnicthv.ecs.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.components.PositionComponent;&#10;import com.ethnicthv.ecs.components.VelocityComponent;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Movement system optimized for Archetype-based ECS.&#10; * Processes entities in cache-friendly chunks.&#10; */&#10;public final class ArchetypeMovementSystem {&#10;    private final ArchetypeWorld world;&#10;    private final int positionTypeId;&#10;    private final int velocityTypeId;&#10;&#10;    public ArchetypeMovementSystem(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.positionTypeId = world.getComponentTypeId(PositionComponent.class);&#10;        this.velocityTypeId = world.getComponentTypeId(VelocityComponent.class);&#10;    }&#10;&#10;    /**&#10;     * Update all entities that have both Position and Velocity&#10;     */&#10;    public void update(float deltaTime) {&#10;        world.query()&#10;            .with(PositionComponent.class)&#10;            .with(VelocityComponent.class)&#10;            .forEachChunk((chunk, archetype) -&gt; {&#10;                updateChunk(chunk, archetype, deltaTime);&#10;            });&#10;    }&#10;&#10;    private void updateChunk(ArchetypeChunk chunk, Archetype archetype, float deltaTime) {&#10;        int size = chunk.size();&#10;&#10;        // Get component indices in this archetype&#10;        int posIndex = getComponentIndex(archetype, positionTypeId);&#10;        int velIndex = getComponentIndex(archetype, velocityTypeId);&#10;&#10;        // Process each entity in the chunk&#10;        for (int i = 0; i &lt; size; i++) {&#10;            MemorySegment posData = chunk.getComponentData(posIndex, i);&#10;            MemorySegment velData = chunk.getComponentData(velIndex, i);&#10;&#10;            if (posData != null &amp;&amp; velData != null) {&#10;                // Read velocity&#10;                float vx = velData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float vy = velData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Read position&#10;                float x = posData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float y = posData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Update position&#10;                x += vx * deltaTime;&#10;                y += vy * deltaTime;&#10;&#10;                // Write back&#10;                posData.set(ValueLayout.JAVA_FLOAT, 0, x);&#10;                posData.set(ValueLayout.JAVA_FLOAT, 4, y);&#10;            }&#10;        }&#10;    }&#10;&#10;    private int getComponentIndex(Archetype archetype, int componentTypeId) {&#10;        int index = 0;&#10;        ComponentMask mask = archetype.getMask();&#10;        for (int i = 0; i &lt; componentTypeId; i++) {&#10;            if (mask.has(i)) {&#10;                index++;&#10;            }&#10;        }&#10;        return index;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentHandle.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentHandle.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a field value by name&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a field value by name&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    private final Map&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new HashMap&lt;&gt;();&#10;    private int nextTypeId = 0;&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        if (componentTypeIds.containsKey(componentClass)) {&#10;            return componentTypeIds.get(componentClass);&#10;        }&#10;&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Build descriptor through reflection&#10;        ComponentDescriptor descriptor = buildDescriptor(componentClass);&#10;        descriptors.put(componentClass, descriptor);&#10;&#10;        int typeId = nextTypeId++;&#10;        componentTypeIds.put(componentClass, typeId);&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    private final Map&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new HashMap&lt;&gt;();&#10;    private int nextTypeId = 0;&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        if (componentTypeIds.containsKey(componentClass)) {&#10;            return componentTypeIds.get(componentClass);&#10;        }&#10;&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Build descriptor through reflection&#10;        ComponentDescriptor descriptor = buildDescriptor(componentClass);&#10;        descriptors.put(componentClass, descriptor);&#10;&#10;        int typeId = nextTypeId++;&#10;        componentTypeIds.put(componentClass, typeId);&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/Archetype.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/Archetype.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;import java.util.concurrent.atomic.AtomicBoolean;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;/**&#10; * Archetype groups entities that share the same set of components.&#10; * It stores component descriptors and manages a list of chunks.&#10; */&#10;public final class Archetype implements IArchetype {&#10;&#10;    private final int[] componentIds;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] componentElementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final ComponentMask mask; // cached mask&#10;    private final Arena arena; // arena for new chunk allocations&#10;&#10;    // Cache-friendly chunk storage&#10;    private volatile ArchetypeChunk[] chunks;&#10;    private final AtomicInteger chunkCount = new AtomicInteger(0); // also acts as publish barrier&#10;    private final ReentrantLock resizeLock = new ReentrantLock();&#10;&#10;    // Queue of chunk indices that currently have at least one free slot&#10;    private final ConcurrentLinkedQueue&lt;Integer&gt; availableChunks = new ConcurrentLinkedQueue&lt;&gt;();&#10;    // Approximate count of available chunks in the queue (kept exact via ticket discipline)&#10;    private final AtomicInteger availableCount = new AtomicInteger(0);&#10;&#10;    // Lock-free provisioning control: at most one provisioner at a time&#10;    private final AtomicBoolean provisioning = new AtomicBoolean(false);&#10;    private static final int PROVISION_THRESHOLD = 2; // when below, proactively create one more chunk&#10;    // Spin attempts to bridge provisioning without blocking. Tuned to balance latency and CPU burn.&#10;    private static final int SPIN_WAIT_ITERATIONS = 32;&#10;&#10;    // Choose a chunk byte budget (tunable)&#10;    private static final int CHUNK_SIZE = 16 * 1024;&#10;    private static final int DEFAULT_ENTITIES_PER_CHUNK = 64; // when descriptors report 0 size&#10;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; componentIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    public Archetype(ComponentMask mask, int[] componentIds, ComponentDescriptor[] descriptors, Arena arena) {&#10;        if (componentIds.length != descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;componentIds/descriptors length mismatch&quot;);&#10;        }&#10;        this.componentIds = componentIds;&#10;        this.descriptors = descriptors;&#10;        this.componentElementSizes = new long[descriptors.length];&#10;        this.mask = mask; // store provided mask&#10;        this.arena = arena;&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long s = descriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;&#10;        if (totalPerEntity &lt;= 0) {&#10;            this.entitiesPerChunk = DEFAULT_ENTITIES_PER_CHUNK;&#10;        } else {&#10;            this.entitiesPerChunk = Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        }&#10;&#10;        // init chunk array&#10;        this.chunks = new ArchetypeChunk[Math.max(4, 1)];&#10;        // Remove precomputed typeIndex; use computeIfAbsent in indexOfComponentType instead&#10;        // Create initial chunk at index 0&#10;        ArchetypeChunk first = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena);&#10;        this.chunks[0] = first;&#10;        chunkCount.set(1);&#10;        // initial chunk has all slots free; enqueue its index (0) with ticket&#10;        if (first.tryMarkQueued()) {&#10;            this.availableChunks.add(0);&#10;            this.availableCount.incrementAndGet();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get component mask (cached)&#10;     */&#10;    public ComponentMask getMask() { return mask; }&#10;&#10;    public int[] getComponentIds() { return componentIds; }&#10;&#10;    @Override&#10;    public int[] getComponentTypeIds() {&#10;        return getComponentIds();&#10;    }&#10;&#10;    public ComponentDescriptor[] getDescriptors() { return descriptors; }&#10;&#10;    public int getEntitiesPerChunk() { return entitiesPerChunk; }&#10;&#10;    /**&#10;     * Return a snapshot list of chunks. Order is physical array order.&#10;     */&#10;    @Override&#10;    public List&lt;IArchetypeChunk&gt; getChunks() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        List&lt;IArchetypeChunk&gt; list = new ArrayList&lt;&gt;(count);&#10;        for (int i = 0; i &lt; count; i++) {&#10;            list.add(snap[i]);&#10;        }&#10;        return list;&#10;    }&#10;&#10;    /**&#10;     * Get a direct reference to the current chunks array.&#10;     * &lt;p&gt;&#10;     * This method provides thread-safe access to the chunks array for parallel iteration.&#10;     * Since the 'chunks' field is declared as volatile, reading it guarantees visibility&#10;     * of the most recent array reference. The array itself may be replaced during resize&#10;     * operations, but the reference returned here is stable for the duration of its use.&#10;     * &lt;p&gt;&#10;     * This is primarily intended for parallel processing where multiple threads need to&#10;     * iterate over chunks concurrently without creating defensive copies.&#10;     *&#10;     * @return A reference to the current chunks array. The caller should also read&#10;     *         {@link #chunkCount()} to determine how many valid entries exist.&#10;     */&#10;    public ArchetypeChunk[] getChunksSnapshot() {&#10;        return this.chunks;&#10;    }&#10;&#10;    public ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        // Structured, non-recursive allocation loop&#10;        while (true) {&#10;            // 1) Try fast-path: consume available chunk(s)&#10;            ArchetypeChunk.ChunkLocation loc = tryFastPathAllocate(entityId);&#10;            if (loc != null) return loc;&#10;&#10;            // 2) If queue empty, attempt to become the provisioner (lock-free CAS)&#10;            if (provisioning.compareAndSet(false, true)) {&#10;                try {&#10;                    // Double-check fast-path in case capacity was added while acquiring provisioning&#10;                    loc = tryFastPathAllocate(entityId);&#10;                    if (loc != null) return loc;&#10;                    // Create exactly one new chunk and allocate from it&#10;                    return createChunkAndAllocate(entityId);&#10;                } finally {&#10;                    provisioning.set(false);&#10;                }&#10;            }&#10;&#10;            // 3) Someone else is provisioning. Spin briefly and retry.&#10;            for (int i = 0; i &lt; SPIN_WAIT_ITERATIONS; i++) {&#10;                loc = tryFastPathAllocate(entityId);&#10;                if (loc != null) return loc;&#10;                Thread.onSpinWait();&#10;            }&#10;            // Loop and try again&#10;        }&#10;    }&#10;&#10;    // Fast-path allocation from availableChunks; returns null if none succeed&#10;    private ArchetypeChunk.ChunkLocation tryFastPathAllocate(int entityId) {&#10;        Integer idxChunk;&#10;        while ((idxChunk = availableChunks.poll()) != null) {&#10;            availableCount.decrementAndGet();&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idxChunk];&#10;            if (chunk == null) continue;&#10;            chunk.markDequeued();&#10;            int slot = chunk.allocateSlot(entityId);&#10;            if (slot &gt;= 0) {&#10;                // Opportunistic replenishment when running low&#10;                maybeProvision();&#10;                if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;                    availableChunks.offer(idxChunk);&#10;                    availableCount.incrementAndGet();&#10;                }&#10;                return new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;            }&#10;            // If full now, do not requeue; proceed to next&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // Create one chunk, append into array, allocate a slot in it, and enqueue if it still has free capacity&#10;    private ArchetypeChunk.ChunkLocation createChunkAndAllocate(int entityId) {&#10;        ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena);&#10;        int newIndex = appendChunk(newChunk);&#10;        int slot = newChunk.allocateSlot(entityId);&#10;        if (newChunk.hasFree() &amp;&amp; newChunk.tryMarkQueued()) {&#10;            availableChunks.offer(newIndex);&#10;            availableCount.incrementAndGet();&#10;        }&#10;        return new ArchetypeChunk.ChunkLocation(newIndex, slot);&#10;    }&#10;&#10;    private int appendChunk(ArchetypeChunk newChunk) {&#10;        resizeLock.lock();&#10;        try {&#10;            ArchetypeChunk[] arr = this.chunks;&#10;            int idx = chunkCount.get();&#10;            if (idx &lt; arr.length) {&#10;                arr[idx] = newChunk;&#10;                // publish via chunkCount volatile increment&#10;                chunkCount.incrementAndGet();&#10;                return idx;&#10;            }&#10;            // resize: double capacity&#10;            int newCap = Math.max(4, arr.length &lt;&lt; 1);&#10;            ArchetypeChunk[] newArr = new ArchetypeChunk[newCap];&#10;            System.arraycopy(arr, 0, newArr, 0, idx);&#10;            newArr[idx] = newChunk;&#10;            // publish new array first&#10;            this.chunks = newArr;&#10;            // then publish count&#10;            chunkCount.incrementAndGet();&#10;            return idx;&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;    }&#10;&#10;    private void maybeProvision() {&#10;        if (availableCount.get() &lt; PROVISION_THRESHOLD &amp;&amp; provisioning.compareAndSet(false, true)) {&#10;            try {&#10;                ArchetypeChunk extra = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena);&#10;                int id = appendChunk(extra);&#10;                if (extra.tryMarkQueued()) {&#10;                    availableChunks.offer(id);&#10;                    availableCount.incrementAndGet();&#10;                }&#10;            } finally {&#10;                provisioning.set(false);&#10;            }&#10;        }&#10;    }&#10;&#10;    public void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        int idx = location.chunkIndex;&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        if (idx &lt; 0 || idx &gt;= chunkCount.get()) return;&#10;        ArchetypeChunk chunk = snap[idx];&#10;        if (chunk == null) return;&#10;        chunk.freeSlot(location.indexInChunk);&#10;        if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;            availableChunks.offer(idx);&#10;            availableCount.incrementAndGet();&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        if (chunkIndex &lt; 0 || chunkIndex &gt;= count) throw new IndexOutOfBoundsException();&#10;        return snap[chunkIndex];&#10;    }&#10;&#10;    public int chunkCount() { return this.chunkCount.get(); }&#10;&#10;    @Override&#10;    public int getChunkCount() {&#10;        return chunkCount();&#10;    }&#10;&#10;    @Override&#10;    public int getEntityCount() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        int total = 0;&#10;        for (int i = 0; i &lt; count; i++) total += snap[i].size();&#10;        return total;&#10;    }&#10;&#10;    /**&#10;     * Iterate over all entities in this archetype.&#10;     * Weakly consistent: concurrent adds/removes may or may not be observed by this traversal,&#10;     * and an entity may be skipped or visited once depending on timing. The traversal never throws&#10;     * due to concurrent modification and aims to be cache-friendly.&#10;     */&#10;    public void forEach(ArchetypeIterator iterator) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        for (int chunkId = 0; chunkId &lt; count; chunkId++) {&#10;            ArchetypeChunk chunk = snap[chunkId];&#10;            int i = chunk.nextOccupiedIndex(0);&#10;            while (i != -1) {&#10;                int eid = chunk.getEntityId(i);&#10;                if (eid != -1) iterator.accept(eid, new ArchetypeChunk.ChunkLocation(chunkId, i), chunk);&#10;                i = chunk.nextOccupiedIndex(i + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public MemorySegment getComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        return snap[location.chunkIndex].getComponentData(componentIndex, location.indexInChunk);&#10;    }&#10;&#10;    /**&#10;     * Set component data for an entity&#10;     */&#10;    public void setComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex, MemorySegment data) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        snap[location.chunkIndex].setComponentData(componentIndex, location.indexInChunk, data);&#10;    }&#10;&#10;    /**&#10;     * Get the index of a component type ID within this archetype's component arrays, or -1 if absent.&#10;     * Uses a thread-safe lazy cache to compute the mapping at most once per component type id.&#10;     */&#10;    public int indexOfComponentType(int componentTypeId) {&#10;        return componentIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                if (componentIds[i] == tid) {&#10;                    return i;&#10;                }&#10;            }&#10;            return -1; // not present in this archetype&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;import java.util.concurrent.atomic.AtomicBoolean;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;/**&#10; * Archetype groups entities that share the same set of components.&#10; * It stores component descriptors and manages a list of chunks.&#10; */&#10;public final class Archetype implements IArchetype {&#10;&#10;    private final int[] componentIds;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] componentElementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final ComponentMask mask; // cached mask&#10;    private final Arena arena; // arena for new chunk allocations&#10;&#10;    // Cache-friendly chunk storage&#10;    private volatile ArchetypeChunk[] chunks;&#10;    private final AtomicInteger chunkCount = new AtomicInteger(0); // also acts as publish barrier&#10;    private final ReentrantLock resizeLock = new ReentrantLock();&#10;&#10;    // Queue of chunk indices that currently have at least one free slot&#10;    private final ConcurrentLinkedQueue&lt;Integer&gt; availableChunks = new ConcurrentLinkedQueue&lt;&gt;();&#10;    // Approximate count of available chunks in the queue (kept exact via ticket discipline)&#10;    private final AtomicInteger availableCount = new AtomicInteger(0);&#10;&#10;    // Lock-free provisioning control: at most one provisioner at a time&#10;    private final AtomicBoolean provisioning = new AtomicBoolean(false);&#10;    private static final int PROVISION_THRESHOLD = 2; // when below, proactively create one more chunk&#10;    // Spin attempts to bridge provisioning without blocking. Tuned to balance latency and CPU burn.&#10;    private static final int SPIN_WAIT_ITERATIONS = 32;&#10;&#10;    // Choose a chunk byte budget (tunable)&#10;    private static final int CHUNK_SIZE = 16 * 1024;&#10;    private static final int DEFAULT_ENTITIES_PER_CHUNK = 64; // when descriptors report 0 size&#10;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; componentIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    public Archetype(ComponentMask mask, int[] componentIds, ComponentDescriptor[] descriptors, Arena arena) {&#10;        if (componentIds.length != descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;componentIds/descriptors length mismatch&quot;);&#10;        }&#10;        this.componentIds = componentIds;&#10;        this.descriptors = descriptors;&#10;        this.componentElementSizes = new long[descriptors.length];&#10;        this.mask = mask; // store provided mask&#10;        this.arena = arena;&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long s = descriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;&#10;        if (totalPerEntity &lt;= 0) {&#10;            this.entitiesPerChunk = DEFAULT_ENTITIES_PER_CHUNK;&#10;        } else {&#10;            this.entitiesPerChunk = Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        }&#10;&#10;        // init chunk array&#10;        this.chunks = new ArchetypeChunk[Math.max(4, 1)];&#10;        // Remove precomputed typeIndex; use computeIfAbsent in indexOfComponentType instead&#10;        // Create initial chunk at index 0&#10;        ArchetypeChunk first = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena);&#10;        this.chunks[0] = first;&#10;        chunkCount.set(1);&#10;        // initial chunk has all slots free; enqueue its index (0) with ticket&#10;        if (first.tryMarkQueued()) {&#10;            this.availableChunks.add(0);&#10;            this.availableCount.incrementAndGet();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get component mask (cached)&#10;     */&#10;    public ComponentMask getMask() { return mask; }&#10;&#10;    public int[] getComponentIds() { return componentIds; }&#10;&#10;    @Override&#10;    public int[] getComponentTypeIds() {&#10;        return getComponentIds();&#10;    }&#10;&#10;    public ComponentDescriptor[] getDescriptors() { return descriptors; }&#10;&#10;    public int getEntitiesPerChunk() { return entitiesPerChunk; }&#10;&#10;    /**&#10;     * Return a snapshot list of chunks. Order is physical array order.&#10;     */&#10;    @Override&#10;    public List&lt;IArchetypeChunk&gt; getChunks() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        List&lt;IArchetypeChunk&gt; list = new ArrayList&lt;&gt;(count);&#10;        for (int i = 0; i &lt; count; i++) {&#10;            list.add(snap[i]);&#10;        }&#10;        return list;&#10;    }&#10;&#10;    /**&#10;     * Get a direct reference to the current chunks array.&#10;     * &lt;p&gt;&#10;     * This method provides thread-safe access to the chunks array for parallel iteration.&#10;     * Since the 'chunks' field is declared as volatile, reading it guarantees visibility&#10;     * of the most recent array reference. The array itself may be replaced during resize&#10;     * operations, but the reference returned here is stable for the duration of its use.&#10;     * &lt;p&gt;&#10;     * This is primarily intended for parallel processing where multiple threads need to&#10;     * iterate over chunks concurrently without creating defensive copies.&#10;     *&#10;     * @return A reference to the current chunks array. The caller should also read&#10;     *         {@link #chunkCount()} to determine how many valid entries exist.&#10;     */&#10;    public ArchetypeChunk[] getChunksSnapshot() {&#10;        return this.chunks;&#10;    }&#10;&#10;    public ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        // Structured, non-recursive allocation loop&#10;        while (true) {&#10;            // 1) Try fast-path: consume available chunk(s)&#10;            ArchetypeChunk.ChunkLocation loc = tryFastPathAllocate(entityId);&#10;            if (loc != null) return loc;&#10;&#10;            // 2) If queue empty, attempt to become the provisioner (lock-free CAS)&#10;            if (provisioning.compareAndSet(false, true)) {&#10;                try {&#10;                    // Double-check fast-path in case capacity was added while acquiring provisioning&#10;                    loc = tryFastPathAllocate(entityId);&#10;                    if (loc != null) return loc;&#10;                    // Create exactly one new chunk and allocate from it&#10;                    return createChunkAndAllocate(entityId);&#10;                } finally {&#10;                    provisioning.set(false);&#10;                }&#10;            }&#10;&#10;            // 3) Someone else is provisioning. Spin briefly and retry.&#10;            for (int i = 0; i &lt; SPIN_WAIT_ITERATIONS; i++) {&#10;                loc = tryFastPathAllocate(entityId);&#10;                if (loc != null) return loc;&#10;                Thread.onSpinWait();&#10;            }&#10;            // Loop and try again&#10;        }&#10;    }&#10;&#10;    // Fast-path allocation from availableChunks; returns null if none succeed&#10;    private ArchetypeChunk.ChunkLocation tryFastPathAllocate(int entityId) {&#10;        Integer idxChunk;&#10;        while ((idxChunk = availableChunks.poll()) != null) {&#10;            availableCount.decrementAndGet();&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idxChunk];&#10;            if (chunk == null) continue;&#10;            chunk.markDequeued();&#10;            int slot = chunk.allocateSlot(entityId);&#10;            if (slot &gt;= 0) {&#10;                // Opportunistic replenishment when running low&#10;                maybeProvision();&#10;                if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;                    availableChunks.offer(idxChunk);&#10;                    availableCount.incrementAndGet();&#10;                }&#10;                return new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;            }&#10;            // If full now, do not requeue; proceed to next&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // Create one chunk, append into array, allocate a slot in it, and enqueue if it still has free capacity&#10;    private ArchetypeChunk.ChunkLocation createChunkAndAllocate(int entityId) {&#10;        ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena);&#10;        int newIndex = appendChunk(newChunk);&#10;        int slot = newChunk.allocateSlot(entityId);&#10;        if (newChunk.hasFree() &amp;&amp; newChunk.tryMarkQueued()) {&#10;            availableChunks.offer(newIndex);&#10;            availableCount.incrementAndGet();&#10;        }&#10;        return new ArchetypeChunk.ChunkLocation(newIndex, slot);&#10;    }&#10;&#10;    private int appendChunk(ArchetypeChunk newChunk) {&#10;        resizeLock.lock();&#10;        try {&#10;            ArchetypeChunk[] arr = this.chunks;&#10;            int idx = chunkCount.get();&#10;            if (idx &lt; arr.length) {&#10;                arr[idx] = newChunk;&#10;                // publish via chunkCount volatile increment&#10;                chunkCount.incrementAndGet();&#10;                return idx;&#10;            }&#10;            // resize: double capacity&#10;            int newCap = Math.max(4, arr.length &lt;&lt; 1);&#10;            ArchetypeChunk[] newArr = new ArchetypeChunk[newCap];&#10;            System.arraycopy(arr, 0, newArr, 0, idx);&#10;            newArr[idx] = newChunk;&#10;            // publish new array first&#10;            this.chunks = newArr;&#10;            // then publish count&#10;            chunkCount.incrementAndGet();&#10;            return idx;&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;    }&#10;&#10;    private void maybeProvision() {&#10;        if (availableCount.get() &lt; PROVISION_THRESHOLD &amp;&amp; provisioning.compareAndSet(false, true)) {&#10;            try {&#10;                ArchetypeChunk extra = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena);&#10;                int id = appendChunk(extra);&#10;                if (extra.tryMarkQueued()) {&#10;                    availableChunks.offer(id);&#10;                    availableCount.incrementAndGet();&#10;                }&#10;            } finally {&#10;                provisioning.set(false);&#10;            }&#10;        }&#10;    }&#10;&#10;    public void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        int idx = location.chunkIndex;&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        if (idx &lt; 0 || idx &gt;= chunkCount.get()) return;&#10;        ArchetypeChunk chunk = snap[idx];&#10;        if (chunk == null) return;&#10;        chunk.freeSlot(location.indexInChunk);&#10;        if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;            availableChunks.offer(idx);&#10;            availableCount.incrementAndGet();&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        if (chunkIndex &lt; 0 || chunkIndex &gt;= count) throw new IndexOutOfBoundsException();&#10;        return snap[chunkIndex];&#10;    }&#10;&#10;    public int chunkCount() { return this.chunkCount.get(); }&#10;&#10;    @Override&#10;    public int getChunkCount() {&#10;        return chunkCount();&#10;    }&#10;&#10;    @Override&#10;    public int getEntityCount() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        int total = 0;&#10;        for (int i = 0; i &lt; count; i++) total += snap[i].size();&#10;        return total;&#10;    }&#10;&#10;    /**&#10;     * Iterate over all entities in this archetype.&#10;     * Weakly consistent: concurrent adds/removes may or may not be observed by this traversal,&#10;     * and an entity may be skipped or visited once depending on timing. The traversal never throws&#10;     * due to concurrent modification and aims to be cache-friendly.&#10;     */&#10;    public void forEach(ArchetypeIterator iterator) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        for (int chunkId = 0; chunkId &lt; count; chunkId++) {&#10;            ArchetypeChunk chunk = snap[chunkId];&#10;            int i = chunk.nextOccupiedIndex(0);&#10;            while (i != -1) {&#10;                int eid = chunk.getEntityId(i);&#10;                if (eid != -1) iterator.accept(eid, new ArchetypeChunk.ChunkLocation(chunkId, i), chunk);&#10;                i = chunk.nextOccupiedIndex(i + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public MemorySegment getComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        return snap[location.chunkIndex].getComponentData(componentIndex, location.indexInChunk);&#10;    }&#10;&#10;    /**&#10;     * Set component data for an entity&#10;     */&#10;    public void setComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex, MemorySegment data) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        snap[location.chunkIndex].setComponentData(componentIndex, location.indexInChunk, data);&#10;    }&#10;&#10;    /**&#10;     * Get the index of a component type ID within this archetype's component arrays, or -1 if absent.&#10;     * Uses a thread-safe lazy cache to compute the mapping at most once per component type id.&#10;     */&#10;    public int indexOfComponentType(int componentTypeId) {&#10;        return componentIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                if (componentIds[i] == tid) {&#10;                    return i;&#10;                }&#10;            }&#10;            return -1; // not present in this archetype&#10;        });&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeQuery.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeQuery.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeQuery;&#10;import com.ethnicthv.ecs.core.components.ComponentHandle;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery implements IArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    private final List&lt;Class&lt;?&gt;&gt; compList = new ArrayList&lt;&gt;();&#10;    private final List&lt;Integer&gt; compIdxList = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        compList.add(componentClass);&#10;        compIdxList.add(componentTypeId);&#10;&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    @Override&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (IArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;            for (int i = 0; i &lt; compList.size(); i++) {&#10;                componentClasses[i] = compList.get(i);&#10;            }&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) {&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; compIndices.length; k++) {&#10;                        int compIdx = compIndices[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    /**&#10;     * Execute the query and process matching entities in parallel across multiple CPU cores.&#10;     * &lt;p&gt;&#10;     * This method leverages Java's parallel streams to distribute entity processing across&#10;     * available CPU cores. The processing is done at the chunk level - each chunk is processed&#10;     * by a single thread, but different chunks may be processed concurrently.&#10;     * &lt;p&gt;&#10;     * &lt;strong&gt;THREAD SAFETY REQUIREMENTS:&lt;/strong&gt;&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;The provided {@code EntityConsumer} MUST be thread-safe&lt;/li&gt;&#10;     *   &lt;li&gt;Any shared state accessed or modified by the consumer must be properly synchronized&lt;/li&gt;&#10;     *   &lt;li&gt;The consumer may be called concurrently from multiple threads&lt;/li&gt;&#10;     *   &lt;li&gt;There are no ordering guarantees - entities may be processed in any order&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     * &lt;p&gt;&#10;     * Performance considerations:&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;Best suited for CPU-intensive operations on large entity sets&lt;/li&gt;&#10;     *   &lt;li&gt;Overhead of parallelization may not be worth it for very small entity counts&lt;/li&gt;&#10;     *   &lt;li&gt;The actual parallelism depends on the ForkJoinPool common pool size&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     *&#10;     * @param consumer A thread-safe callback that processes each matching entity.&#10;     *                 Called with (entityId, handles, archetype) for each entity.&#10;     * @throws NullPointerException if consumer is null&#10;     *&#10;     * @see #forEachEntity(EntityConsumer) for sequential processing&#10;     */&#10;    public void forEachParallel(EntityConsumer consumer) {&#10;        if (consumer == null) {&#10;            throw new NullPointerException(&quot;EntityConsumer cannot be null&quot;);&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        // Prepare component classes array&#10;        Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;        for (int i = 0; i &lt; compList.size(); i++) {&#10;            componentClasses[i] = compList.get(i);&#10;        }&#10;&#10;        // Step 1: Collect all matching archetypes with their metadata&#10;        List&lt;ArchetypeWorkItem&gt; archetypeWorkItems = new ArrayList&lt;&gt;();&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) {&#10;                        matchesAny = true;&#10;                        break;&#10;                    }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            // Compute component indices for this archetype&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            boolean allFound = true;&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) {&#10;                    allFound = false;&#10;                    break;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;            if (!allFound) continue;&#10;&#10;            archetypeWorkItems.add(new ArchetypeWorkItem(archetype, compIndices));&#10;        }&#10;&#10;        // Step 2: Build a flat list of all entity work items&#10;        List&lt;EntityWorkItem&gt; workItems = new ArrayList&lt;&gt;();&#10;        for (ArchetypeWorkItem archetypeItem : archetypeWorkItems) {&#10;            Archetype archetype = archetypeItem.archetype;&#10;            int[] compIndices = archetypeItem.compIndices;&#10;            &#10;            ArchetypeChunk[] chunks = archetype.getChunksSnapshot();&#10;            int chunkCount = archetype.chunkCount();&#10;            &#10;            for (int chunkIndex = 0; chunkIndex &lt; chunkCount; chunkIndex++) {&#10;                ArchetypeChunk chunk = chunks[chunkIndex];&#10;                if (chunk == null || chunk.isEmpty()) continue;&#10;&#10;                int slotIndex = chunk.nextOccupiedIndex(0);&#10;                while (slotIndex != -1) {&#10;                    int entityId = chunk.getEntityId(slotIndex);&#10;                    if (entityId != -1) {&#10;                        workItems.add(new EntityWorkItem(&#10;                            entityId, chunk, slotIndex, compIndices, archetype&#10;                        ));&#10;                    }&#10;                    slotIndex = chunk.nextOccupiedIndex(slotIndex + 1);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Step 3: Process entities in parallel using parallel stream&#10;        workItems.parallelStream().forEach(item -&gt; {&#10;            ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;            ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;            try {&#10;                for (int k = 0; k &lt; item.compIndices.length; k++) {&#10;                    int compIdx = item.compIndices[k];&#10;                    var seg = item.chunk.getComponentData(compIdx, item.slotIndex);&#10;                    bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                    handles[k] = bound[k].handle();&#10;                }&#10;&#10;                consumer.accept(item.entityId, handles, item.archetype);&#10;            } finally {&#10;                for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                    if (boundHandle != null) {&#10;                        try { boundHandle.close(); } catch (Exception ignored) {}&#10;                    }&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Internal class to hold archetype metadata for parallel execution.&#10;     */&#10;    private static class ArchetypeWorkItem {&#10;        final Archetype archetype;&#10;        final int[] compIndices;&#10;&#10;        ArchetypeWorkItem(Archetype archetype, int[] compIndices) {&#10;            this.archetype = archetype;&#10;            this.compIndices = compIndices;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Internal class to hold entity processing metadata for parallel execution.&#10;     */&#10;    private static class EntityWorkItem {&#10;        final int entityId;&#10;        final ArchetypeChunk chunk;&#10;        final int slotIndex;&#10;        final int[] compIndices;&#10;        final Archetype archetype;&#10;&#10;        EntityWorkItem(int entityId, ArchetypeChunk chunk, int slotIndex, int[] compIndices, Archetype archetype) {&#10;            this.entityId = entityId;&#10;            this.chunk = chunk;&#10;            this.slotIndex = slotIndex;&#10;            this.compIndices = compIndices;&#10;            this.archetype = archetype;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeQuery;&#10;import com.ethnicthv.ecs.core.components.ComponentHandle;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery implements IArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    private final List&lt;Class&lt;?&gt;&gt; compList = new ArrayList&lt;&gt;();&#10;    private final List&lt;Integer&gt; compIdxList = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        compList.add(componentClass);&#10;        compIdxList.add(componentTypeId);&#10;&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    @Override&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (IArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;            for (int i = 0; i &lt; compList.size(); i++) {&#10;                componentClasses[i] = compList.get(i);&#10;            }&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) {&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; compIndices.length; k++) {&#10;                        int compIdx = compIndices[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    /**&#10;     * Execute the query and process matching entities in parallel across multiple CPU cores.&#10;     * &lt;p&gt;&#10;     * This method leverages Java's parallel streams to distribute entity processing across&#10;     * available CPU cores. The processing is done at the chunk level - each chunk is processed&#10;     * by a single thread, but different chunks may be processed concurrently.&#10;     * &lt;p&gt;&#10;     * &lt;strong&gt;THREAD SAFETY REQUIREMENTS:&lt;/strong&gt;&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;The provided {@code EntityConsumer} MUST be thread-safe&lt;/li&gt;&#10;     *   &lt;li&gt;Any shared state accessed or modified by the consumer must be properly synchronized&lt;/li&gt;&#10;     *   &lt;li&gt;The consumer may be called concurrently from multiple threads&lt;/li&gt;&#10;     *   &lt;li&gt;There are no ordering guarantees - entities may be processed in any order&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     * &lt;p&gt;&#10;     * Performance considerations:&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;Best suited for CPU-intensive operations on large entity sets&lt;/li&gt;&#10;     *   &lt;li&gt;Overhead of parallelization may not be worth it for very small entity counts&lt;/li&gt;&#10;     *   &lt;li&gt;The actual parallelism depends on the ForkJoinPool common pool size&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     *&#10;     * @param consumer A thread-safe callback that processes each matching entity.&#10;     *                 Called with (entityId, handles, archetype) for each entity.&#10;     * @throws NullPointerException if consumer is null&#10;     *&#10;     * @see #forEachEntity(EntityConsumer) for sequential processing&#10;     */&#10;    public void forEachParallel(EntityConsumer consumer) {&#10;        if (consumer == null) {&#10;            throw new NullPointerException(&quot;EntityConsumer cannot be null&quot;);&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        // Prepare component classes array&#10;        Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;        for (int i = 0; i &lt; compList.size(); i++) {&#10;            componentClasses[i] = compList.get(i);&#10;        }&#10;&#10;        // Step 1: Collect all matching archetypes with their metadata&#10;        List&lt;ArchetypeWorkItem&gt; archetypeWorkItems = new ArrayList&lt;&gt;();&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) {&#10;                        matchesAny = true;&#10;                        break;&#10;                    }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            // Compute component indices for this archetype&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            boolean allFound = true;&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) {&#10;                    allFound = false;&#10;                    break;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;            if (!allFound) continue;&#10;&#10;            archetypeWorkItems.add(new ArchetypeWorkItem(archetype, compIndices));&#10;        }&#10;&#10;        // Step 2: Build a flat list of all entity work items&#10;        List&lt;EntityWorkItem&gt; workItems = new ArrayList&lt;&gt;();&#10;        for (ArchetypeWorkItem archetypeItem : archetypeWorkItems) {&#10;            Archetype archetype = archetypeItem.archetype;&#10;            int[] compIndices = archetypeItem.compIndices;&#10;            &#10;            ArchetypeChunk[] chunks = archetype.getChunksSnapshot();&#10;            int chunkCount = archetype.chunkCount();&#10;            &#10;            for (int chunkIndex = 0; chunkIndex &lt; chunkCount; chunkIndex++) {&#10;                ArchetypeChunk chunk = chunks[chunkIndex];&#10;                if (chunk == null || chunk.isEmpty()) continue;&#10;&#10;                int slotIndex = chunk.nextOccupiedIndex(0);&#10;                while (slotIndex != -1) {&#10;                    int entityId = chunk.getEntityId(slotIndex);&#10;                    if (entityId != -1) {&#10;                        workItems.add(new EntityWorkItem(&#10;                            entityId, chunk, slotIndex, compIndices, archetype&#10;                        ));&#10;                    }&#10;                    slotIndex = chunk.nextOccupiedIndex(slotIndex + 1);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Step 3: Process entities in parallel using parallel stream&#10;        workItems.parallelStream().forEach(item -&gt; {&#10;            ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;            ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;            try {&#10;                for (int k = 0; k &lt; item.compIndices.length; k++) {&#10;                    int compIdx = item.compIndices[k];&#10;                    var seg = item.chunk.getComponentData(compIdx, item.slotIndex);&#10;                    bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                    handles[k] = bound[k].handle();&#10;                }&#10;&#10;                consumer.accept(item.entityId, handles, item.archetype);&#10;            } finally {&#10;                for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                    if (boundHandle != null) {&#10;                        try { boundHandle.close(); } catch (Exception ignored) {}&#10;                    }&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Internal class to hold archetype metadata for parallel execution.&#10;     */&#10;    private static class ArchetypeWorkItem {&#10;        final Archetype archetype;&#10;        final int[] compIndices;&#10;&#10;        ArchetypeWorkItem(Archetype archetype, int[] compIndices) {&#10;            this.archetype = archetype;&#10;            this.compIndices = compIndices;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Internal class to hold entity processing metadata for parallel execution.&#10;     */&#10;    private static class EntityWorkItem {&#10;        final int entityId;&#10;        final ArchetypeChunk chunk;&#10;        final int slotIndex;&#10;        final int[] compIndices;&#10;        final Archetype archetype;&#10;&#10;        EntityWorkItem(int entityId, ArchetypeChunk chunk, int slotIndex, int[] compIndices, Archetype archetype) {&#10;            this.entityId = entityId;&#10;            this.chunk = chunk;&#10;            this.slotIndex = slotIndex;&#10;            this.compIndices = compIndices;&#10;            this.archetype = archetype;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentDescriptor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentDescriptor.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.util.*;&#10;&#10;/**&#10; * Descriptor containing metadata about a component's memory layout&#10; * Generated by ComponentManager through reflection&#10; */&#10;public class ComponentDescriptor {&#10;    private final Class&lt;?&gt; componentClass;&#10;    private final long totalSize;&#10;    private final Map&lt;String, FieldDescriptor&gt; fields; // legacy name-&gt;descriptor&#10;    private final List&lt;FieldDescriptor&gt; fieldList;     // legacy ordered list (immutable)&#10;    private final FieldDescriptor[] fieldArray;        // fast array for index-based access&#10;    private final Map&lt;String, Integer&gt; fieldIndexMap;  // name -&gt; index (immutable)&#10;    private final Component.LayoutType layoutType;&#10;&#10;    public ComponentDescriptor(Class&lt;?&gt; componentClass, long totalSize,&#10;                              List&lt;FieldDescriptor&gt; fields, Component.LayoutType layoutType) {&#10;        this.componentClass = componentClass;&#10;        this.totalSize = totalSize;&#10;        this.fieldList = Collections.unmodifiableList(new ArrayList&lt;&gt;(fields));&#10;        this.fields = new HashMap&lt;&gt;();&#10;        for (FieldDescriptor field : fields) {&#10;            this.fields.put(field.name(), field);&#10;        }&#10;        // Build fast structures&#10;        this.fieldArray = this.fieldList.toArray(new FieldDescriptor[0]);&#10;        Map&lt;String, Integer&gt; indexMap = new HashMap&lt;&gt;(fieldArray.length);&#10;        for (int i = 0; i &lt; fieldArray.length; i++) {&#10;            indexMap.put(fieldArray[i].name(), i);&#10;        }&#10;        this.fieldIndexMap = Collections.unmodifiableMap(indexMap);&#10;&#10;        this.layoutType = layoutType;&#10;    }&#10;&#10;    public Class&lt;?&gt; getComponentClass() {&#10;        return componentClass;&#10;    }&#10;&#10;    public long getTotalSize() {&#10;        return totalSize;&#10;    }&#10;&#10;    // Legacy name-based lookup (setup-time, not hot-path)&#10;    public FieldDescriptor getField(String name) {&#10;        return fields.get(name);&#10;    }&#10;&#10;    // New: O(1) index-based access&#10;    public int getFieldIndex(String fieldName) {&#10;        Integer idx = fieldIndexMap.get(fieldName);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public FieldDescriptor getField(int index) {&#10;        return fieldArray[index];&#10;    }&#10;&#10;    public int fieldCount() {&#10;        return fieldArray.length;&#10;    }&#10;&#10;    public List&lt;FieldDescriptor&gt; getFields() {&#10;        return fieldList;&#10;    }&#10;&#10;    public Component.LayoutType getLayoutType() {&#10;        return layoutType;&#10;    }&#10;&#10;    /**&#10;     * Field descriptor with type and layout information&#10;     */&#10;    public record FieldDescriptor(&#10;        String name,&#10;        FieldType type,&#10;        long offset,&#10;        long size,&#10;        int alignment&#10;    ) {}&#10;&#10;    /**&#10;     * Supported field types&#10;     */&#10;    public enum FieldType {&#10;        BYTE(1, 1),&#10;        SHORT(2, 2),&#10;        INT(4, 4),&#10;        LONG(8, 8),&#10;        FLOAT(4, 4),&#10;        DOUBLE(8, 8),&#10;        BOOLEAN(1, 1),&#10;        CHAR(2, 2);&#10;&#10;        private final long size;&#10;        private final int naturalAlignment;&#10;&#10;        FieldType(long size, int naturalAlignment) {&#10;            this.size = size;&#10;            this.naturalAlignment = naturalAlignment;&#10;        }&#10;&#10;        public long getSize() {&#10;            return size;&#10;        }&#10;&#10;        public int getNaturalAlignment() {&#10;            return naturalAlignment;&#10;        }&#10;&#10;        public static FieldType fromJavaType(Class&lt;?&gt; type) {&#10;            if (type == byte.class || type == Byte.class) return BYTE;&#10;            if (type == short.class || type == Short.class) return SHORT;&#10;            if (type == int.class || type == Integer.class) return INT;&#10;            if (type == long.class || type == Long.class) return LONG;&#10;            if (type == float.class || type == Float.class) return FLOAT;&#10;            if (type == double.class || type == Double.class) return DOUBLE;&#10;            if (type == boolean.class || type == Boolean.class) return BOOLEAN;&#10;            if (type == char.class || type == Character.class) return CHAR;&#10;            throw new IllegalArgumentException(&quot;Unsupported field type: &quot; + type);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;ComponentDescriptor[&quot;)&#10;          .append(componentClass.getSimpleName())&#10;          .append(&quot;, size=&quot;).append(totalSize)&#10;          .append(&quot;, layout=&quot;).append(layoutType)&#10;          .append(&quot;, fields=[\n&quot;);&#10;        for (FieldDescriptor field : fieldList) {&#10;            sb.append(&quot;  &quot;).append(field.name())&#10;              .append(&quot;: &quot;).append(field.type())&#10;              .append(&quot; @&quot;).append(field.offset())&#10;              .append(&quot; (size=&quot;).append(field.size())&#10;              .append(&quot;, align=&quot;).append(field.alignment())&#10;              .append(&quot;)\n&quot;);&#10;        }&#10;        sb.append(&quot;]] &quot;);&#10;        return sb.toString();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.util.*;&#10;&#10;/**&#10; * Descriptor containing metadata about a component's memory layout&#10; * Generated by ComponentManager through reflection&#10; */&#10;public class ComponentDescriptor {&#10;    private final Class&lt;?&gt; componentClass;&#10;    private final long totalSize;&#10;    private final Map&lt;String, FieldDescriptor&gt; fields; // legacy name-&gt;descriptor&#10;    private final List&lt;FieldDescriptor&gt; fieldList;     // legacy ordered list (immutable)&#10;    private final FieldDescriptor[] fieldArray;        // fast array for index-based access&#10;    private final Map&lt;String, Integer&gt; fieldIndexMap;  // name -&gt; index (immutable)&#10;    private final Component.LayoutType layoutType;&#10;&#10;    public ComponentDescriptor(Class&lt;?&gt; componentClass, long totalSize,&#10;                              List&lt;FieldDescriptor&gt; fields, Component.LayoutType layoutType) {&#10;        this.componentClass = componentClass;&#10;        this.totalSize = totalSize;&#10;        this.fieldList = Collections.unmodifiableList(new ArrayList&lt;&gt;(fields));&#10;        this.fields = new HashMap&lt;&gt;();&#10;        for (FieldDescriptor field : fields) {&#10;            this.fields.put(field.name(), field);&#10;        }&#10;        // Build fast structures&#10;        this.fieldArray = this.fieldList.toArray(new FieldDescriptor[0]);&#10;        Map&lt;String, Integer&gt; indexMap = new HashMap&lt;&gt;(fieldArray.length);&#10;        for (int i = 0; i &lt; fieldArray.length; i++) {&#10;            indexMap.put(fieldArray[i].name(), i);&#10;        }&#10;        this.fieldIndexMap = Collections.unmodifiableMap(indexMap);&#10;&#10;        this.layoutType = layoutType;&#10;    }&#10;&#10;    public Class&lt;?&gt; getComponentClass() {&#10;        return componentClass;&#10;    }&#10;&#10;    public long getTotalSize() {&#10;        return totalSize;&#10;    }&#10;&#10;    // Legacy name-based lookup (setup-time, not hot-path)&#10;    public FieldDescriptor getField(String name) {&#10;        return fields.get(name);&#10;    }&#10;&#10;    // New: O(1) index-based access&#10;    public int getFieldIndex(String fieldName) {&#10;        Integer idx = fieldIndexMap.get(fieldName);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public FieldDescriptor getField(int index) {&#10;        return fieldArray[index];&#10;    }&#10;&#10;    public int fieldCount() {&#10;        return fieldArray.length;&#10;    }&#10;&#10;    public List&lt;FieldDescriptor&gt; getFields() {&#10;        return fieldList;&#10;    }&#10;&#10;    public Component.LayoutType getLayoutType() {&#10;        return layoutType;&#10;    }&#10;&#10;    /**&#10;     * Field descriptor with type and layout information&#10;     */&#10;    public record FieldDescriptor(&#10;        String name,&#10;        FieldType type,&#10;        long offset,&#10;        long size,&#10;        int alignment&#10;    ) {}&#10;&#10;    /**&#10;     * Supported field types&#10;     */&#10;    public enum FieldType {&#10;        BYTE(1, 1),&#10;        SHORT(2, 2),&#10;        INT(4, 4),&#10;        LONG(8, 8),&#10;        FLOAT(4, 4),&#10;        DOUBLE(8, 8),&#10;        BOOLEAN(1, 1),&#10;        CHAR(2, 2);&#10;&#10;        private final long size;&#10;        private final int naturalAlignment;&#10;&#10;        FieldType(long size, int naturalAlignment) {&#10;            this.size = size;&#10;            this.naturalAlignment = naturalAlignment;&#10;        }&#10;&#10;        public long getSize() {&#10;            return size;&#10;        }&#10;&#10;        public int getNaturalAlignment() {&#10;            return naturalAlignment;&#10;        }&#10;&#10;        public static FieldType fromJavaType(Class&lt;?&gt; type) {&#10;            if (type == byte.class || type == Byte.class) return BYTE;&#10;            if (type == short.class || type == Short.class) return SHORT;&#10;            if (type == int.class || type == Integer.class) return INT;&#10;            if (type == long.class || type == Long.class) return LONG;&#10;            if (type == float.class || type == Float.class) return FLOAT;&#10;            if (type == double.class || type == Double.class) return DOUBLE;&#10;            if (type == boolean.class || type == Boolean.class) return BOOLEAN;&#10;            if (type == char.class || type == Character.class) return CHAR;&#10;            throw new IllegalArgumentException(&quot;Unsupported field type: &quot; + type);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;ComponentDescriptor[&quot;)&#10;          .append(componentClass.getSimpleName())&#10;          .append(&quot;, size=&quot;).append(totalSize)&#10;          .append(&quot;, layout=&quot;).append(layoutType)&#10;          .append(&quot;, fields=[\n&quot;);&#10;        for (FieldDescriptor field : fieldList) {&#10;            sb.append(&quot;  &quot;).append(field.name())&#10;              .append(&quot;: &quot;).append(field.type())&#10;              .append(&quot; @&quot;).append(field.offset())&#10;              .append(&quot; (size=&quot;).append(field.size())&#10;              .append(&quot;, align=&quot;).append(field.alignment())&#10;              .append(&quot;)\n&quot;);&#10;        }&#10;        sb.append(&quot;]] &quot;);&#10;        return sb.toString();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentHandle.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentHandle.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    private void ensureIndexInRange(int index) {&#10;        int count = descriptor.fieldCount();&#10;        if (index &lt; 0 || index &gt;= count) {&#10;            throw new IndexOutOfBoundsException(&quot;Field index out of range: &quot; + index + &quot; (count=&quot; + count + &quot;)&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resolve a field name to its index. Prefer calling once at setup and reusing the index.&#10;     */&#10;    public int resolveFieldIndex(String fieldName) {&#10;        ensureBound();&#10;        int idx = descriptor.getFieldIndex(fieldName);&#10;        if (idx &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;        return idx;&#10;    }&#10;&#10;    // ------------- Index-based hot-path getters -------------&#10;    public byte getByte(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_BYTE, f.offset());&#10;    }&#10;    public short getShort(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_SHORT, f.offset());&#10;    }&#10;    public int getInt(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_INT, f.offset());&#10;    }&#10;    public long getLong(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_LONG, f.offset());&#10;    }&#10;    public float getFloat(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_FLOAT, f.offset());&#10;    }&#10;    public double getDouble(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_DOUBLE, f.offset());&#10;    }&#10;    public boolean getBoolean(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_BOOLEAN, f.offset());&#10;    }&#10;    public char getChar(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_CHAR, f.offset());&#10;    }&#10;&#10;    // ------------- Index-based hot-path setters -------------&#10;    public void setByte(int fieldIndex, byte value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_BYTE, f.offset(), value);&#10;    }&#10;    public void setShort(int fieldIndex, short value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_SHORT, f.offset(), value);&#10;    }&#10;    public void setInt(int fieldIndex, int value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_INT, f.offset(), value);&#10;    }&#10;    public void setLong(int fieldIndex, long value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_LONG, f.offset(), value);&#10;    }&#10;    public void setFloat(int fieldIndex, float value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_FLOAT, f.offset(), value);&#10;    }&#10;    public void setDouble(int fieldIndex, double value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_DOUBLE, f.offset(), value);&#10;    }&#10;    public void setBoolean(int fieldIndex, boolean value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_BOOLEAN, f.offset(), value);&#10;    }&#10;    public void setChar(int fieldIndex, char value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_CHAR, f.offset(), value);&#10;    }&#10;&#10;    // ------------- Legacy name-based API (routes through index resolution) -------------&#10;    /**&#10;     * Get a field value by name. Use only for setup; prefer index-based methods in hot-path.&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        int idx = descriptor.getFieldIndex(fieldName);&#10;        if (idx &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;        return getByIndex(idx);&#10;    }&#10;&#10;    private Object getByIndex(int idx) {&#10;        var field = descriptor.getField(idx);&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name. Use only for setup; prefer index-based methods in hot-path.&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        int idx = descriptor.getFieldIndex(fieldName);&#10;        if (idx &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;        setByIndex(idx, value);&#10;    }&#10;&#10;    private void setByIndex(int idx, Object value) {&#10;        var field = descriptor.getField(idx);&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set by name (setup-friendly)&#10;     * Prefer index-based overloads for hot-path.&#10;     */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    private void ensureIndexInRange(int index) {&#10;        int count = descriptor.fieldCount();&#10;        if (index &lt; 0 || index &gt;= count) {&#10;            throw new IndexOutOfBoundsException(&quot;Field index out of range: &quot; + index + &quot; (count=&quot; + count + &quot;)&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resolve a field name to its index. Prefer calling once at setup and reusing the index.&#10;     */&#10;    public int resolveFieldIndex(String fieldName) {&#10;        ensureBound();&#10;        int idx = descriptor.getFieldIndex(fieldName);&#10;        if (idx &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;        return idx;&#10;    }&#10;&#10;    // ------------- Index-based hot-path getters -------------&#10;    public byte getByte(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_BYTE, f.offset());&#10;    }&#10;    public short getShort(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_SHORT, f.offset());&#10;    }&#10;    public int getInt(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_INT, f.offset());&#10;    }&#10;    public long getLong(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_LONG, f.offset());&#10;    }&#10;    public float getFloat(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_FLOAT, f.offset());&#10;    }&#10;    public double getDouble(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_DOUBLE, f.offset());&#10;    }&#10;    public boolean getBoolean(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_BOOLEAN, f.offset());&#10;    }&#10;    public char getChar(int fieldIndex) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        return segment.get(ValueLayout.JAVA_CHAR, f.offset());&#10;    }&#10;&#10;    // ------------- Index-based hot-path setters -------------&#10;    public void setByte(int fieldIndex, byte value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_BYTE, f.offset(), value);&#10;    }&#10;    public void setShort(int fieldIndex, short value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_SHORT, f.offset(), value);&#10;    }&#10;    public void setInt(int fieldIndex, int value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_INT, f.offset(), value);&#10;    }&#10;    public void setLong(int fieldIndex, long value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_LONG, f.offset(), value);&#10;    }&#10;    public void setFloat(int fieldIndex, float value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_FLOAT, f.offset(), value);&#10;    }&#10;    public void setDouble(int fieldIndex, double value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_DOUBLE, f.offset(), value);&#10;    }&#10;    public void setBoolean(int fieldIndex, boolean value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_BOOLEAN, f.offset(), value);&#10;    }&#10;    public void setChar(int fieldIndex, char value) {&#10;        ensureBound(); ensureIndexInRange(fieldIndex);&#10;        var f = descriptor.getField(fieldIndex);&#10;        segment.set(ValueLayout.JAVA_CHAR, f.offset(), value);&#10;    }&#10;&#10;    // ------------- Legacy name-based API (routes through index resolution) -------------&#10;    /**&#10;     * Get a field value by name. Use only for setup; prefer index-based methods in hot-path.&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        int idx = descriptor.getFieldIndex(fieldName);&#10;        if (idx &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;        return getByIndex(idx);&#10;    }&#10;&#10;    private Object getByIndex(int idx) {&#10;        var field = descriptor.getField(idx);&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name. Use only for setup; prefer index-based methods in hot-path.&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        int idx = descriptor.getFieldIndex(fieldName);&#10;        if (idx &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;        setByIndex(idx, value);&#10;    }&#10;&#10;    private void setByIndex(int idx, Object value) {&#10;        var field = descriptor.getField(idx);&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set by name (setup-friendly)&#10;     * Prefer index-based overloads for hot-path.&#10;     */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    // Thread-safe registries&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;    private final AtomicInteger nextTypeId = new AtomicInteger(0);&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Assign a stable type id exactly once, even under races&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;&#10;        // Prefer generated descriptor if present; else build via reflection&#10;        descriptors.computeIfAbsent(componentClass, cls -&gt; {&#10;            ComponentDescriptor gen = tryLoadGeneratedDescriptor(cls);&#10;            return gen != null ? gen : buildDescriptor(cls);&#10;        });&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Register a component class with a prebuilt descriptor (e.g., from generated meta).&#10;     * Thread-safe and idempotent: type id is assigned once; descriptor installed if absent.&#10;     */&#10;    public &lt;T&gt; int registerComponentWithDescriptor(Class&lt;T&gt; componentClass, ComponentDescriptor descriptor) {&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;descriptor must not be null for &quot; + componentClass.getName());&#10;        }&#10;        descriptors.putIfAbsent(componentClass, descriptor);&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;&#10;    // Try to load a generated meta class &lt;FQN&gt; + &quot;Meta&quot; exposing DESCRIPTOR field or descriptor() method.&#10;    private ComponentDescriptor tryLoadGeneratedDescriptor(Class&lt;?&gt; componentClass) {&#10;        String metaName = componentClass.getName() + &quot;Meta&quot;;&#10;        try {&#10;            Class&lt;?&gt; meta = Class.forName(metaName, false, componentClass.getClassLoader());&#10;            try {&#10;                java.lang.reflect.Field f = meta.getField(&quot;DESCRIPTOR&quot;);&#10;                Object v = f.get(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchFieldException ignored) { }&#10;            try {&#10;                java.lang.reflect.Method m = meta.getMethod(&quot;descriptor&quot;);&#10;                Object v = m.invoke(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchMethodException ignored) { }&#10;        } catch (Throwable ignored) {&#10;            // not generated/present&#10;        }&#10;        return null;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    // Thread-safe registries&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;    private final AtomicInteger nextTypeId = new AtomicInteger(0);&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Assign a stable type id exactly once, even under races&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;&#10;        // Prefer generated descriptor if present; else build via reflection&#10;        descriptors.computeIfAbsent(componentClass, cls -&gt; {&#10;            ComponentDescriptor gen = tryLoadGeneratedDescriptor(cls);&#10;            return gen != null ? gen : buildDescriptor(cls);&#10;        });&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Register a component class with a prebuilt descriptor (e.g., from generated meta).&#10;     * Thread-safe and idempotent: type id is assigned once; descriptor installed if absent.&#10;     */&#10;    public &lt;T&gt; int registerComponentWithDescriptor(Class&lt;T&gt; componentClass, ComponentDescriptor descriptor) {&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;descriptor must not be null for &quot; + componentClass.getName());&#10;        }&#10;        descriptors.putIfAbsent(componentClass, descriptor);&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;&#10;    // Try to load a generated meta class &lt;FQN&gt; + &quot;Meta&quot; exposing DESCRIPTOR field or descriptor() method.&#10;    private ComponentDescriptor tryLoadGeneratedDescriptor(Class&lt;?&gt; componentClass) {&#10;        String metaName = componentClass.getName() + &quot;Meta&quot;;&#10;        try {&#10;            Class&lt;?&gt; meta = Class.forName(metaName, false, componentClass.getClassLoader());&#10;            try {&#10;                java.lang.reflect.Field f = meta.getField(&quot;DESCRIPTOR&quot;);&#10;                Object v = f.get(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchFieldException ignored) { }&#10;            try {&#10;                java.lang.reflect.Method m = meta.getMethod(&quot;descriptor&quot;);&#10;                Object v = m.invoke(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchMethodException ignored) { }&#10;        } catch (Throwable ignored) {&#10;            // not generated/present&#10;        }&#10;        return null;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeChunkTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeChunkTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Comprehensive tests for ArchetypeChunk&#10; */&#10;public class ArchetypeChunkTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private long[] elementSizes;&#10;    private static final int DEFAULT_CAPACITY = 64;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        elementSizes = new long[]{16, 8};&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        // Don't close shared arena - it may be used across tests&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testChunkInitialization() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(DEFAULT_CAPACITY, chunk.capacity());&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertTrue(chunk.hasFree());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateSingleSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertTrue(slot &gt;= 0 &amp;&amp; slot &lt; DEFAULT_CAPACITY);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.isEmpty());&#10;        assertEquals(100, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateMultipleSlots() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int slot = chunk.allocateSlot(1000 + i);&#10;            assertTrue(slot &gt;= 0);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slots should be unique&quot;);&#10;            assertEquals(1000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(10, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateUpToCapacity() {&#10;        int capacity = 16;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            int slot = chunk.allocateSlot(i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot &quot; + i);&#10;        }&#10;&#10;        assertEquals(capacity, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        // Try to allocate one more - should fail&#10;        int extraSlot = chunk.allocateSlot(999);&#10;        assertEquals(-1, extraSlot, &quot;Should not allocate beyond capacity&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testFreeSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertEquals(-1, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateFreeAllocate() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate&#10;        int slot1 = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        // Free&#10;        chunk.freeSlot(slot1);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Allocate again - might reuse same slot&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertTrue(slot2 &gt;= 0);&#10;        assertEquals(1, chunk.size());&#10;        assertEquals(200, chunk.getEntityId(slot2));&#10;    }&#10;&#10;    @Test&#10;    void testDoubleFree() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Double free should be safe&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testGetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Get component data for component 0&#10;        MemorySegment data = chunk.getComponentData(0, slot);&#10;        assertNotNull(data);&#10;        assertEquals(16, data.byteSize());&#10;&#10;        // Get component data for component 1&#10;        MemorySegment data2 = chunk.getComponentData(1, slot);&#10;        assertNotNull(data2);&#10;        assertEquals(8, data2.byteSize());&#10;    }&#10;&#10;    @Test&#10;    void testSetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Create test data&#10;        MemorySegment testData = arena.allocate(16);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 12345L);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 8, 67890L);&#10;&#10;        // Set component data&#10;        chunk.setComponentData(0, slot, testData);&#10;&#10;        // Retrieve and verify&#10;        MemorySegment retrieved = chunk.getComponentData(0, slot);&#10;        assertEquals(12345L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;        assertEquals(67890L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 8));&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate some slots&#10;        chunk.allocateSlot(100);&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;&#10;        // Find first occupied&#10;        int first = chunk.nextOccupiedIndex(0);&#10;        assertTrue(first &gt;= 0);&#10;        assertNotEquals(-1, chunk.getEntityId(first));&#10;&#10;        // Find next after first&#10;        int second = chunk.nextOccupiedIndex(first + 1);&#10;        assertTrue(second &gt; first);&#10;        assertNotEquals(-1, chunk.getEntityId(second));&#10;&#10;        // Count all occupied&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndexWithGaps() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate several slots&#10;        int[] slots = new int[5];&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            slots[i] = chunk.allocateSlot(100 + i);&#10;        }&#10;&#10;        // Free some to create gaps&#10;        chunk.freeSlot(slots[1]);&#10;        chunk.freeSlot(slots[3]);&#10;&#10;        // Count occupied (should be 3)&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            assertNotEquals(-1, chunk.getEntityId(idx), &quot;Occupied slot should have valid entity ID&quot;);&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testQueueingMechanism() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Initially not queued&#10;        assertTrue(chunk.tryMarkQueued());&#10;&#10;        // Should fail second time&#10;        assertFalse(chunk.tryMarkQueued());&#10;&#10;        // Mark dequeued&#10;        chunk.markDequeued();&#10;&#10;        // Should succeed again&#10;        assertTrue(chunk.tryMarkQueued());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations() throws InterruptedException {&#10;        int capacity = 128;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 4;&#10;        int allocationsPerThread = capacity / threads;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * allocationsPerThread;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; allocationsPerThread; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(10, TimeUnit.SECONDS), &quot;Timed out waiting for allocations to complete&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        assertEquals(capacity, successCount.get());&#10;        assertEquals(capacity, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocateAndFree() throws InterruptedException {&#10;        int capacity = 256;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int operations = 1000;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operations;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; operations; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                // Free every other allocation&#10;                                if (i % 2 == 0) {&#10;                                    chunk.freeSlot(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for concurrent operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        // Size should be reasonable (between 0 and capacity)&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity,&#10;                &quot;Final size &quot; + finalSize + &quot; should be in [0, &quot; + capacity + &quot;]&quot;);&#10;&#10;        // All occupied slots should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSlotDataIsZeroedOnAllocation() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate a slot and set some data&#10;        int slot1 = chunk.allocateSlot(100);&#10;        MemorySegment data1 = chunk.getComponentData(0, slot1);&#10;        data1.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 0xDEADBEEFL);&#10;&#10;        // Free the slot&#10;        chunk.freeSlot(slot1);&#10;&#10;        // Allocate again (might get the same slot)&#10;        int slot2 = chunk.allocateSlot(200);&#10;        MemorySegment data2 = chunk.getComponentData(0, slot2);&#10;&#10;        // Data should be zeroed&#10;        assertEquals(0L, data2.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidComponentIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(-1, slot));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(descriptors.length, slot));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidElementIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, -1));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, DEFAULT_CAPACITY));&#10;    }&#10;&#10;    @Test&#10;    void testZeroCapacityChunk() {&#10;        // Zero capacity should throw IllegalArgumentException because bytes = elementSize * 0 = 0&#10;        assertThrows(IllegalArgumentException.class, () -&gt;&#10;                new ArchetypeChunk(descriptors, elementSizes, 0, arena)&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testSingleSlotCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, 1, arena);&#10;&#10;        assertEquals(1, chunk.capacity());&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(0, slot);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertEquals(-1, slot2);&#10;&#10;        chunk.freeSlot(slot);&#10;        assertTrue(chunk.hasFree());&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testArenaAccess() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertNotNull(chunk.getArena());&#10;        assertEquals(arena, chunk.getArena());&#10;    }&#10;&#10;    @Test&#10;    void testGetEntityCount() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(0, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;        assertEquals(3, chunk.getEntityCount());&#10;    }&#10;&#10;    @Test&#10;    void testGetCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertEquals(DEFAULT_CAPACITY, chunk.getCapacity());&#10;    }&#10;&#10;    // Test component classes&#10;    static final class TestComponent1 {&#10;    }&#10;&#10;    static final class TestComponent2 {&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Comprehensive tests for ArchetypeChunk&#10; */&#10;public class ArchetypeChunkTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private long[] elementSizes;&#10;    private static final int DEFAULT_CAPACITY = 64;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        elementSizes = new long[]{16, 8};&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        // Don't close shared arena - it may be used across tests&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testChunkInitialization() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(DEFAULT_CAPACITY, chunk.capacity());&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertTrue(chunk.hasFree());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateSingleSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertTrue(slot &gt;= 0 &amp;&amp; slot &lt; DEFAULT_CAPACITY);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.isEmpty());&#10;        assertEquals(100, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateMultipleSlots() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int slot = chunk.allocateSlot(1000 + i);&#10;            assertTrue(slot &gt;= 0);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slots should be unique&quot;);&#10;            assertEquals(1000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(10, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateUpToCapacity() {&#10;        int capacity = 16;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            int slot = chunk.allocateSlot(i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot &quot; + i);&#10;        }&#10;&#10;        assertEquals(capacity, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        // Try to allocate one more - should fail&#10;        int extraSlot = chunk.allocateSlot(999);&#10;        assertEquals(-1, extraSlot, &quot;Should not allocate beyond capacity&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testFreeSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertEquals(-1, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateFreeAllocate() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate&#10;        int slot1 = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        // Free&#10;        chunk.freeSlot(slot1);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Allocate again - might reuse same slot&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertTrue(slot2 &gt;= 0);&#10;        assertEquals(1, chunk.size());&#10;        assertEquals(200, chunk.getEntityId(slot2));&#10;    }&#10;&#10;    @Test&#10;    void testDoubleFree() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Double free should be safe&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testGetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Get component data for component 0&#10;        MemorySegment data = chunk.getComponentData(0, slot);&#10;        assertNotNull(data);&#10;        assertEquals(16, data.byteSize());&#10;&#10;        // Get component data for component 1&#10;        MemorySegment data2 = chunk.getComponentData(1, slot);&#10;        assertNotNull(data2);&#10;        assertEquals(8, data2.byteSize());&#10;    }&#10;&#10;    @Test&#10;    void testSetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Create test data&#10;        MemorySegment testData = arena.allocate(16);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 12345L);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 8, 67890L);&#10;&#10;        // Set component data&#10;        chunk.setComponentData(0, slot, testData);&#10;&#10;        // Retrieve and verify&#10;        MemorySegment retrieved = chunk.getComponentData(0, slot);&#10;        assertEquals(12345L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;        assertEquals(67890L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 8));&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate some slots&#10;        chunk.allocateSlot(100);&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;&#10;        // Find first occupied&#10;        int first = chunk.nextOccupiedIndex(0);&#10;        assertTrue(first &gt;= 0);&#10;        assertNotEquals(-1, chunk.getEntityId(first));&#10;&#10;        // Find next after first&#10;        int second = chunk.nextOccupiedIndex(first + 1);&#10;        assertTrue(second &gt; first);&#10;        assertNotEquals(-1, chunk.getEntityId(second));&#10;&#10;        // Count all occupied&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndexWithGaps() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate several slots&#10;        int[] slots = new int[5];&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            slots[i] = chunk.allocateSlot(100 + i);&#10;        }&#10;&#10;        // Free some to create gaps&#10;        chunk.freeSlot(slots[1]);&#10;        chunk.freeSlot(slots[3]);&#10;&#10;        // Count occupied (should be 3)&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            assertNotEquals(-1, chunk.getEntityId(idx), &quot;Occupied slot should have valid entity ID&quot;);&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testQueueingMechanism() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Initially not queued&#10;        assertTrue(chunk.tryMarkQueued());&#10;&#10;        // Should fail second time&#10;        assertFalse(chunk.tryMarkQueued());&#10;&#10;        // Mark dequeued&#10;        chunk.markDequeued();&#10;&#10;        // Should succeed again&#10;        assertTrue(chunk.tryMarkQueued());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations() throws InterruptedException {&#10;        int capacity = 128;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 4;&#10;        int allocationsPerThread = capacity / threads;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * allocationsPerThread;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; allocationsPerThread; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(10, TimeUnit.SECONDS), &quot;Timed out waiting for allocations to complete&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        assertEquals(capacity, successCount.get());&#10;        assertEquals(capacity, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocateAndFree() throws InterruptedException {&#10;        int capacity = 256;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int operations = 1000;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operations;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; operations; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                // Free every other allocation&#10;                                if (i % 2 == 0) {&#10;                                    chunk.freeSlot(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for concurrent operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        // Size should be reasonable (between 0 and capacity)&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity,&#10;                &quot;Final size &quot; + finalSize + &quot; should be in [0, &quot; + capacity + &quot;]&quot;);&#10;&#10;        // All occupied slots should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSlotDataIsZeroedOnAllocation() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate a slot and set some data&#10;        int slot1 = chunk.allocateSlot(100);&#10;        MemorySegment data1 = chunk.getComponentData(0, slot1);&#10;        data1.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 0xDEADBEEFL);&#10;&#10;        // Free the slot&#10;        chunk.freeSlot(slot1);&#10;&#10;        // Allocate again (might get the same slot)&#10;        int slot2 = chunk.allocateSlot(200);&#10;        MemorySegment data2 = chunk.getComponentData(0, slot2);&#10;&#10;        // Data should be zeroed&#10;        assertEquals(0L, data2.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidComponentIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(-1, slot));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(descriptors.length, slot));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidElementIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, -1));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, DEFAULT_CAPACITY));&#10;    }&#10;&#10;    @Test&#10;    void testZeroCapacityChunk() {&#10;        // Zero capacity should throw IllegalArgumentException because bytes = elementSize * 0 = 0&#10;        assertThrows(IllegalArgumentException.class, () -&gt;&#10;                new ArchetypeChunk(descriptors, elementSizes, 0, arena)&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testSingleSlotCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, 1, arena);&#10;&#10;        assertEquals(1, chunk.capacity());&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(0, slot);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertEquals(-1, slot2);&#10;&#10;        chunk.freeSlot(slot);&#10;        assertTrue(chunk.hasFree());&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testArenaAccess() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertNotNull(chunk.getArena());&#10;        assertEquals(arena, chunk.getArena());&#10;    }&#10;&#10;    @Test&#10;    void testGetEntityCount() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(0, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;        assertEquals(3, chunk.getEntityCount());&#10;    }&#10;&#10;    @Test&#10;    void testGetCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertEquals(DEFAULT_CAPACITY, chunk.getCapacity());&#10;    }&#10;&#10;    // Test component classes&#10;    static final class TestComponent1 {&#10;    }&#10;&#10;    static final class TestComponent2 {&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.api.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Comprehensive tests for Archetype class&#10; */&#10;public class ArchetypeTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private int[] componentIds;&#10;    private ComponentMask mask;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        componentIds = new int[]{1, 2};&#10;        mask = new ComponentMask();&#10;        mask.set(1);&#10;        mask.set(2);&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        // Don't close shared arena&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testArchetypeCreation() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        assertNotNull(archetype);&#10;        assertEquals(mask, archetype.getMask());&#10;        assertArrayEquals(componentIds, archetype.getComponentIds());&#10;        assertArrayEquals(componentIds, archetype.getComponentTypeIds());&#10;        assertArrayEquals(descriptors, archetype.getDescriptors());&#10;    }&#10;&#10;    @Test&#10;    void testGetChunks() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        List&lt;IArchetypeChunk&gt; chunks = archetype.getChunks();&#10;        assertNotNull(chunks);&#10;        assertFalse(chunks.isEmpty(), &quot;Should have at least one initial chunk&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testAddSingleEntity() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(100);&#10;        assertNotNull(loc);&#10;        assertTrue(loc.chunkIndex &gt;= 0);&#10;        assertTrue(loc.indexInChunk &gt;= 0);&#10;    }&#10;&#10;    @Test&#10;    void testAddMultipleEntities() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(100 + i);&#10;            assertNotNull(loc);&#10;            assertTrue(loc.chunkIndex &gt;= 0);&#10;            assertTrue(loc.indexInChunk &gt;= 0);&#10;        }&#10;&#10;        // Verify entities can be iterated&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        archetype.forEach((eid, loc, chunk) -&gt; count.incrementAndGet());&#10;        assertEquals(10, count.get());&#10;    }&#10;&#10;    @Test&#10;    void testRemoveEntity() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entity&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(100);&#10;        assertNotNull(loc);&#10;&#10;        // Remove entity&#10;        archetype.removeEntity(loc);&#10;&#10;        // Verify entity is gone&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        archetype.forEach((eid, location, chunk) -&gt; count.incrementAndGet());&#10;        assertEquals(0, count.get());&#10;    }&#10;&#10;    @Test&#10;    void testRemoveNonExistentEntity() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ArchetypeChunk.ChunkLocation loc = new ArchetypeChunk.ChunkLocation(0, 0);&#10;        // Should handle gracefully without throwing&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(loc));&#10;    }&#10;&#10;    @Test&#10;    void testForEachIteration() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add multiple entities&#10;        int entityCount = 20;&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            archetype.addEntity(100 + i);&#10;        }&#10;&#10;        // Count via forEach&#10;        AtomicInteger iteratedCount = new AtomicInteger(0);&#10;        archetype.forEach((eid, loc, chunk) -&gt; {&#10;            assertTrue(eid &gt;= 100 &amp;&amp; eid &lt; 100 + entityCount);&#10;            assertNotNull(loc);&#10;            assertNotNull(chunk);&#10;            iteratedCount.incrementAndGet();&#10;        });&#10;&#10;        assertEquals(entityCount, iteratedCount.get());&#10;    }&#10;&#10;    @Test&#10;    void testEntitiesPerChunk() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        int entitiesPerChunk = archetype.getEntitiesPerChunk();&#10;        assertTrue(entitiesPerChunk &gt; 0, &quot;Entities per chunk should be positive&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testMultipleChunks() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        int entitiesPerChunk = archetype.getEntitiesPerChunk();&#10;        int totalEntities = entitiesPerChunk * 2 + 10; // Ensure we span multiple chunks&#10;&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            archetype.addEntity(1000 + i);&#10;        }&#10;&#10;        List&lt;IArchetypeChunk&gt; chunks = archetype.getChunks();&#10;        assertTrue(chunks.size() &gt;= 2, &quot;Should have at least 2 chunks&quot;);&#10;&#10;        // Verify iteration covers all entities&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        archetype.forEach((eid, loc, chunk) -&gt; count.incrementAndGet());&#10;        assertEquals(totalEntities, count.get());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAddEntity() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        int threads = 8;&#10;        int entitiesPerThread = 100;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * entitiesPerThread + 1;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; entitiesPerThread; i++) {&#10;                            archetype.addEntity(baseId + i);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for concurrent adds&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        // Count entities via iteration&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        archetype.forEach((eid, loc, chunk) -&gt; count.incrementAndGet());&#10;        assertEquals(threads * entitiesPerThread, count.get());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAddAndRemove() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        int threads = 4;&#10;        int operations = 50;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operations + 1;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; operations; i++) {&#10;                            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(baseId + i);&#10;                            // Remove half of them&#10;                            if (i % 2 == 0) {&#10;                                archetype.removeEntity(loc);&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for concurrent add/remove&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        // Count remaining entities&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        archetype.forEach((eid, loc, chunk) -&gt; count.incrementAndGet());&#10;&#10;        // Should have roughly half of total operations&#10;        int expected = threads * operations / 2;&#10;        assertTrue(count.get() &gt; 0 &amp;&amp; count.get() &lt;= expected,&#10;                &quot;Count &quot; + count.get() + &quot; should be between 0 and &quot; + expected);&#10;    }&#10;&#10;    @Test&#10;    void testEmptyArchetypeIteration() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        archetype.forEach((eid, loc, chunk) -&gt; count.incrementAndGet());&#10;        assertEquals(0, count.get(), &quot;Empty archetype should not iterate&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testGetComponentData() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(100);&#10;        assertNotNull(loc);&#10;&#10;        // Get component data&#10;        var data = archetype.getComponentData(loc, 0);&#10;        assertNotNull(data);&#10;    }&#10;&#10;    @Test&#10;    void testSetComponentData() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(100);&#10;        assertNotNull(loc);&#10;&#10;        // Create test data&#10;        var testData = arena.allocate(16);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 42L);&#10;&#10;        // Set component data&#10;        archetype.setComponentData(loc, 0, testData);&#10;&#10;        // Verify&#10;        var retrieved = archetype.getComponentData(loc, 0);&#10;        assertEquals(42L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;    }&#10;&#10;    @Test&#10;    void testIndexOfComponentType() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Component ID 1 should be at index 0&#10;        int index1 = archetype.indexOfComponentType(1);&#10;        assertEquals(0, index1);&#10;&#10;        // Component ID 2 should be at index 1&#10;        int index2 = archetype.indexOfComponentType(2);&#10;        assertEquals(1, index2);&#10;&#10;        // Non-existent component should return -1&#10;        int indexInvalid = archetype.indexOfComponentType(999);&#10;        assertEquals(-1, indexInvalid);&#10;    }&#10;&#10;    @Test&#10;    void testMismatchedComponentIdsAndDescriptors() {&#10;        ComponentDescriptor[] mismatchedDescs = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16)&#10;        };&#10;        int[] mismatchedIds = new int[]{1, 2}; // More IDs than descriptors&#10;&#10;        assertThrows(IllegalArgumentException.class, () -&gt;&#10;                new Archetype(mask, mismatchedIds, mismatchedDescs, arena)&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testZeroSizeComponents() {&#10;        ComponentDescriptor[] zeroSizeDescs = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 0),&#10;                makeDesc(TestComponent2.class, 0)&#10;        };&#10;&#10;        // Zero-size components should throw IllegalArgumentException when allocating chunks&#10;        assertThrows(IllegalArgumentException.class, () -&gt; {&#10;            Archetype archetype = new Archetype(mask, componentIds, zeroSizeDescs, arena);&#10;            // Attempting to add an entity will trigger chunk creation with zero-size components&#10;            archetype.addEntity(1);&#10;        });&#10;    }&#10;&#10;    // Test component classes&#10;    static final class TestComponent1 {&#10;    }&#10;&#10;    static final class TestComponent2 {&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.api.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Comprehensive tests for Archetype class&#10; */&#10;public class ArchetypeTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private int[] componentIds;&#10;    private ComponentMask mask;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        componentIds = new int[]{1, 2};&#10;        mask = new ComponentMask();&#10;        mask.set(1);&#10;        mask.set(2);&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        // Don't close shared arena&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testArchetypeCreation() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        assertNotNull(archetype);&#10;        assertEquals(mask, archetype.getMask());&#10;        assertArrayEquals(componentIds, archetype.getComponentIds());&#10;        assertArrayEquals(componentIds, archetype.getComponentTypeIds());&#10;        assertArrayEquals(descriptors, archetype.getDescriptors());&#10;    }&#10;&#10;    @Test&#10;    void testGetChunks() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        List&lt;IArchetypeChunk&gt; chunks = archetype.getChunks();&#10;        assertNotNull(chunks);&#10;        assertFalse(chunks.isEmpty(), &quot;Should have at least one initial chunk&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testAddSingleEntity() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(100);&#10;        assertNotNull(loc);&#10;        assertTrue(loc.chunkIndex &gt;= 0);&#10;        assertTrue(loc.indexInChunk &gt;= 0);&#10;    }&#10;&#10;    @Test&#10;    void testAddMultipleEntities() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(100 + i);&#10;            assertNotNull(loc);&#10;            assertTrue(loc.chunkIndex &gt;= 0);&#10;            assertTrue(loc.indexInChunk &gt;= 0);&#10;        }&#10;&#10;        // Verify entities can be iterated&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        archetype.forEach((eid, loc, chunk) -&gt; count.incrementAndGet());&#10;        assertEquals(10, count.get());&#10;    }&#10;&#10;    @Test&#10;    void testRemoveEntity() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entity&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(100);&#10;        assertNotNull(loc);&#10;&#10;        // Remove entity&#10;        archetype.removeEntity(loc);&#10;&#10;        // Verify entity is gone&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        archetype.forEach((eid, location, chunk) -&gt; count.incrementAndGet());&#10;        assertEquals(0, count.get());&#10;    }&#10;&#10;    @Test&#10;    void testRemoveNonExistentEntity() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ArchetypeChunk.ChunkLocation loc = new ArchetypeChunk.ChunkLocation(0, 0);&#10;        // Should handle gracefully without throwing&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(loc));&#10;    }&#10;&#10;    @Test&#10;    void testForEachIteration() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add multiple entities&#10;        int entityCount = 20;&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            archetype.addEntity(100 + i);&#10;        }&#10;&#10;        // Count via forEach&#10;        AtomicInteger iteratedCount = new AtomicInteger(0);&#10;        archetype.forEach((eid, loc, chunk) -&gt; {&#10;            assertTrue(eid &gt;= 100 &amp;&amp; eid &lt; 100 + entityCount);&#10;            assertNotNull(loc);&#10;            assertNotNull(chunk);&#10;            iteratedCount.incrementAndGet();&#10;        });&#10;&#10;        assertEquals(entityCount, iteratedCount.get());&#10;    }&#10;&#10;    @Test&#10;    void testEntitiesPerChunk() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        int entitiesPerChunk = archetype.getEntitiesPerChunk();&#10;        assertTrue(entitiesPerChunk &gt; 0, &quot;Entities per chunk should be positive&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testMultipleChunks() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        int entitiesPerChunk = archetype.getEntitiesPerChunk();&#10;        int totalEntities = entitiesPerChunk * 2 + 10; // Ensure we span multiple chunks&#10;&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            archetype.addEntity(1000 + i);&#10;        }&#10;&#10;        List&lt;IArchetypeChunk&gt; chunks = archetype.getChunks();&#10;        assertTrue(chunks.size() &gt;= 2, &quot;Should have at least 2 chunks&quot;);&#10;&#10;        // Verify iteration covers all entities&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        archetype.forEach((eid, loc, chunk) -&gt; count.incrementAndGet());&#10;        assertEquals(totalEntities, count.get());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAddEntity() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        int threads = 8;&#10;        int entitiesPerThread = 100;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * entitiesPerThread + 1;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; entitiesPerThread; i++) {&#10;                            archetype.addEntity(baseId + i);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for concurrent adds&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        // Count entities via iteration&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        archetype.forEach((eid, loc, chunk) -&gt; count.incrementAndGet());&#10;        assertEquals(threads * entitiesPerThread, count.get());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAddAndRemove() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        int threads = 4;&#10;        int operations = 50;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operations + 1;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; operations; i++) {&#10;                            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(baseId + i);&#10;                            // Remove half of them&#10;                            if (i % 2 == 0) {&#10;                                archetype.removeEntity(loc);&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for concurrent add/remove&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        // Count remaining entities&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        archetype.forEach((eid, loc, chunk) -&gt; count.incrementAndGet());&#10;&#10;        // Should have roughly half of total operations&#10;        int expected = threads * operations / 2;&#10;        assertTrue(count.get() &gt; 0 &amp;&amp; count.get() &lt;= expected,&#10;                &quot;Count &quot; + count.get() + &quot; should be between 0 and &quot; + expected);&#10;    }&#10;&#10;    @Test&#10;    void testEmptyArchetypeIteration() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        archetype.forEach((eid, loc, chunk) -&gt; count.incrementAndGet());&#10;        assertEquals(0, count.get(), &quot;Empty archetype should not iterate&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testGetComponentData() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(100);&#10;        assertNotNull(loc);&#10;&#10;        // Get component data&#10;        var data = archetype.getComponentData(loc, 0);&#10;        assertNotNull(data);&#10;    }&#10;&#10;    @Test&#10;    void testSetComponentData() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(100);&#10;        assertNotNull(loc);&#10;&#10;        // Create test data&#10;        var testData = arena.allocate(16);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 42L);&#10;&#10;        // Set component data&#10;        archetype.setComponentData(loc, 0, testData);&#10;&#10;        // Verify&#10;        var retrieved = archetype.getComponentData(loc, 0);&#10;        assertEquals(42L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;    }&#10;&#10;    @Test&#10;    void testIndexOfComponentType() {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Component ID 1 should be at index 0&#10;        int index1 = archetype.indexOfComponentType(1);&#10;        assertEquals(0, index1);&#10;&#10;        // Component ID 2 should be at index 1&#10;        int index2 = archetype.indexOfComponentType(2);&#10;        assertEquals(1, index2);&#10;&#10;        // Non-existent component should return -1&#10;        int indexInvalid = archetype.indexOfComponentType(999);&#10;        assertEquals(-1, indexInvalid);&#10;    }&#10;&#10;    @Test&#10;    void testMismatchedComponentIdsAndDescriptors() {&#10;        ComponentDescriptor[] mismatchedDescs = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16)&#10;        };&#10;        int[] mismatchedIds = new int[]{1, 2}; // More IDs than descriptors&#10;&#10;        assertThrows(IllegalArgumentException.class, () -&gt;&#10;                new Archetype(mask, mismatchedIds, mismatchedDescs, arena)&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testZeroSizeComponents() {&#10;        ComponentDescriptor[] zeroSizeDescs = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 0),&#10;                makeDesc(TestComponent2.class, 0)&#10;        };&#10;&#10;        // Zero-size components should throw IllegalArgumentException when allocating chunks&#10;        assertThrows(IllegalArgumentException.class, () -&gt; {&#10;            Archetype archetype = new Archetype(mask, componentIds, zeroSizeDescs, arena);&#10;            // Attempting to add an entity will trigger chunk creation with zero-size components&#10;            archetype.addEntity(1);&#10;        });&#10;    }&#10;&#10;    // Test component classes&#10;    static final class TestComponent1 {&#10;    }&#10;&#10;    static final class TestComponent2 {&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ParallelQueryTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ParallelQueryTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeQuery;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Tests for parallel query execution in ArchetypeQuery&#10; */&#10;public class ParallelQueryTest {&#10;&#10;    private ArchetypeWorld world;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        ComponentManager componentManager = new ComponentManager();&#10;        world = new ArchetypeWorld(componentManager);&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        world.close();&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelBasic() {&#10;        // Register components and create entities&#10;        world.registerComponent(TestComponent1.class);&#10;        world.registerComponent(TestComponent2.class);&#10;&#10;        // Create 100 entities with both components&#10;        int entityCount = 100;&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            world.createEntity(TestComponent1.class, TestComponent2.class);&#10;        }&#10;&#10;        // Query and count entities using parallel processing&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        Set&lt;Integer&gt; processedEntities = ConcurrentHashMap.newKeySet();&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class)&#10;             .with(TestComponent2.class);&#10;&#10;        query.forEachParallel((entityId, handles, archetype) -&gt; {&#10;            count.incrementAndGet();&#10;            processedEntities.add(entityId);&#10;        });&#10;&#10;        // Verify all entities were processed&#10;        assertEquals(entityCount, count.get());&#10;        assertEquals(entityCount, processedEntities.size());&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelThreadSafety() {&#10;        // Register component&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        // Add many entities to increase chance of parallel processing&#10;        int entityCount = 1000;&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            world.createEntity(TestComponent1.class);&#10;        }&#10;&#10;        // Use thread-safe counter&#10;        AtomicInteger counter = new AtomicInteger(0);&#10;        Set&lt;Integer&gt; uniqueEntityIds = ConcurrentHashMap.newKeySet();&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        query.forEachParallel((entityId, handles, archetype) -&gt; {&#10;            counter.incrementAndGet();&#10;            uniqueEntityIds.add(entityId);&#10;            &#10;            // Simulate some work&#10;            try {&#10;                Thread.sleep(0, 100); // Sleep for 100 nanoseconds&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        });&#10;&#10;        // Verify no entities were lost or duplicated&#10;        assertEquals(entityCount, counter.get());&#10;        assertEquals(entityCount, uniqueEntityIds.size());&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelMultipleArchetypes() {&#10;        // Register components&#10;        world.registerComponent(TestComponent1.class);&#10;        world.registerComponent(TestComponent2.class);&#10;        world.registerComponent(TestComponent3.class);&#10;&#10;        // Create entities with different component combinations&#10;        // First archetype: Component1 + Component2&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            world.createEntity(TestComponent1.class, TestComponent2.class);&#10;        }&#10;&#10;        // Second archetype: Component1 + Component3&#10;        for (int i = 0; i &lt; 75; i++) {&#10;            world.createEntity(TestComponent1.class, TestComponent3.class);&#10;        }&#10;&#10;        // Query for entities with Component1 (should match both archetypes)&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        Set&lt;Integer&gt; processedEntities = ConcurrentHashMap.newKeySet();&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        query.forEachParallel((entityId, handles, archetype) -&gt; {&#10;            count.incrementAndGet();&#10;            processedEntities.add(entityId);&#10;        });&#10;&#10;        // Should have processed entities from both archetypes&#10;        assertEquals(125, count.get());&#10;        assertEquals(125, processedEntities.size());&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelEmptyQuery() {&#10;        // Register component but don't create any entities&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        AtomicInteger count = new AtomicInteger(0);&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        // Should not call consumer for empty query&#10;        query.forEachParallel((entityId, handles, archetype) -&gt; count.incrementAndGet());&#10;&#10;        assertEquals(0, count.get());&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelNullConsumer() {&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        // Should throw NullPointerException&#10;        assertThrows(NullPointerException.class, () -&gt; query.forEachParallel(null));&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelLargeDataset() {&#10;        // Register component&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        // Add large number of entities&#10;        int entityCount = 10000;&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            world.createEntity(TestComponent1.class);&#10;        }&#10;&#10;        // Process in parallel and verify count&#10;        AtomicInteger count = new AtomicInteger(0);&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        long startTime = System.nanoTime();&#10;        query.forEachParallel((entityId, handles, archetype) -&gt; count.incrementAndGet());&#10;        long duration = System.nanoTime() - startTime;&#10;&#10;        assertEquals(entityCount, count.get());&#10;&#10;        // Just verify it completed&#10;        System.out.println(&quot;Processed &quot; + entityCount + &quot; entities in &quot; +&#10;                           (duration / 1_000_000.0) + &quot; ms&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testCompareSequentialVsParallel() {&#10;        // Register component&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        // Add entities&#10;        int entityCount = 1000;&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            world.createEntity(TestComponent1.class);&#10;        }&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        // Sequential processing&#10;        Set&lt;Integer&gt; sequentialEntities = new HashSet&lt;&gt;();&#10;        query.forEachEntity((entityId, handles, archetype) -&gt;&#10;            sequentialEntities.add(entityId)&#10;        );&#10;&#10;        // Parallel processing&#10;        Set&lt;Integer&gt; parallelEntities = ConcurrentHashMap.newKeySet();&#10;        query.forEachParallel((entityId, handles, archetype) -&gt;&#10;            parallelEntities.add(entityId)&#10;        );&#10;&#10;        // Both should process the same entities&#10;        assertEquals(sequentialEntities.size(), parallelEntities.size());&#10;        assertEquals(sequentialEntities, parallelEntities);&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelWithNoMatchingEntities() {&#10;        // Register two components&#10;        world.registerComponent(TestComponent1.class);&#10;        world.registerComponent(TestComponent2.class);&#10;&#10;        // Create entities with only Component1&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            world.createEntity(TestComponent1.class);&#10;        }&#10;&#10;        // Query for entities that must have Component2 (none will match)&#10;        AtomicInteger count = new AtomicInteger(0);&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent2.class);&#10;&#10;        query.forEachParallel((entityId, arch) -&gt; count.incrementAndGet());&#10;&#10;        assertEquals(0, count.get());&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelPreservesEntityIntegrity() {&#10;        // Register components&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        // Create entities&#10;        int entityCount = 500;&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            world.createEntity(TestComponent1.class);&#10;        }&#10;&#10;        // Process entities and verify each is valid&#10;        AtomicInteger validEntityCount = new AtomicInteger(0);&#10;        AtomicInteger invalidEntityCount = new AtomicInteger(0);&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        query.forEachParallel((entityId, arch) -&gt; {&#10;            if (entityId &gt; 0 &amp;&amp; arch != null) {&#10;                validEntityCount.incrementAndGet();&#10;            } else {&#10;                invalidEntityCount.incrementAndGet();&#10;            }&#10;        });&#10;&#10;        assertEquals(entityCount, validEntityCount.get());&#10;        assertEquals(0, invalidEntityCount.get());&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeQuery;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Tests for parallel query execution in ArchetypeQuery&#10; */&#10;public class ParallelQueryTest {&#10;&#10;    private ArchetypeWorld world;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        ComponentManager componentManager = new ComponentManager();&#10;        world = new ArchetypeWorld(componentManager);&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        world.close();&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelBasic() {&#10;        // Register components and create entities&#10;        world.registerComponent(TestComponent1.class);&#10;        world.registerComponent(TestComponent2.class);&#10;&#10;        // Create 100 entities with both components&#10;        int entityCount = 100;&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            world.createEntity(TestComponent1.class, TestComponent2.class);&#10;        }&#10;&#10;        // Query and count entities using parallel processing&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        Set&lt;Integer&gt; processedEntities = ConcurrentHashMap.newKeySet();&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class)&#10;             .with(TestComponent2.class);&#10;&#10;        query.forEachParallel((entityId, handles, archetype) -&gt; {&#10;            count.incrementAndGet();&#10;            processedEntities.add(entityId);&#10;        });&#10;&#10;        // Verify all entities were processed&#10;        assertEquals(entityCount, count.get());&#10;        assertEquals(entityCount, processedEntities.size());&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelThreadSafety() {&#10;        // Register component&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        // Add many entities to increase chance of parallel processing&#10;        int entityCount = 1000;&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            world.createEntity(TestComponent1.class);&#10;        }&#10;&#10;        // Use thread-safe counter&#10;        AtomicInteger counter = new AtomicInteger(0);&#10;        Set&lt;Integer&gt; uniqueEntityIds = ConcurrentHashMap.newKeySet();&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        query.forEachParallel((entityId, handles, archetype) -&gt; {&#10;            counter.incrementAndGet();&#10;            uniqueEntityIds.add(entityId);&#10;            &#10;            // Simulate some work&#10;            try {&#10;                Thread.sleep(0, 100); // Sleep for 100 nanoseconds&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        });&#10;&#10;        // Verify no entities were lost or duplicated&#10;        assertEquals(entityCount, counter.get());&#10;        assertEquals(entityCount, uniqueEntityIds.size());&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelMultipleArchetypes() {&#10;        // Register components&#10;        world.registerComponent(TestComponent1.class);&#10;        world.registerComponent(TestComponent2.class);&#10;        world.registerComponent(TestComponent3.class);&#10;&#10;        // Create entities with different component combinations&#10;        // First archetype: Component1 + Component2&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            world.createEntity(TestComponent1.class, TestComponent2.class);&#10;        }&#10;&#10;        // Second archetype: Component1 + Component3&#10;        for (int i = 0; i &lt; 75; i++) {&#10;            world.createEntity(TestComponent1.class, TestComponent3.class);&#10;        }&#10;&#10;        // Query for entities with Component1 (should match both archetypes)&#10;        AtomicInteger count = new AtomicInteger(0);&#10;        Set&lt;Integer&gt; processedEntities = ConcurrentHashMap.newKeySet();&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        query.forEachParallel((entityId, handles, archetype) -&gt; {&#10;            count.incrementAndGet();&#10;            processedEntities.add(entityId);&#10;        });&#10;&#10;        // Should have processed entities from both archetypes&#10;        assertEquals(125, count.get());&#10;        assertEquals(125, processedEntities.size());&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelEmptyQuery() {&#10;        // Register component but don't create any entities&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        AtomicInteger count = new AtomicInteger(0);&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        // Should not call consumer for empty query&#10;        query.forEachParallel((entityId, handles, archetype) -&gt; count.incrementAndGet());&#10;&#10;        assertEquals(0, count.get());&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelNullConsumer() {&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        // Should throw NullPointerException&#10;        assertThrows(NullPointerException.class, () -&gt; query.forEachParallel(null));&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelLargeDataset() {&#10;        // Register component&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        // Add large number of entities&#10;        int entityCount = 10000;&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            world.createEntity(TestComponent1.class);&#10;        }&#10;&#10;        // Process in parallel and verify count&#10;        AtomicInteger count = new AtomicInteger(0);&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        long startTime = System.nanoTime();&#10;        query.forEachParallel((entityId, handles, archetype) -&gt; count.incrementAndGet());&#10;        long duration = System.nanoTime() - startTime;&#10;&#10;        assertEquals(entityCount, count.get());&#10;&#10;        // Just verify it completed&#10;        System.out.println(&quot;Processed &quot; + entityCount + &quot; entities in &quot; +&#10;                           (duration / 1_000_000.0) + &quot; ms&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testCompareSequentialVsParallel() {&#10;        // Register component&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        // Add entities&#10;        int entityCount = 1000;&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            world.createEntity(TestComponent1.class);&#10;        }&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        // Sequential processing&#10;        Set&lt;Integer&gt; sequentialEntities = new HashSet&lt;&gt;();&#10;        query.forEachEntity((entityId, handles, archetype) -&gt;&#10;            sequentialEntities.add(entityId)&#10;        );&#10;&#10;        // Parallel processing&#10;        Set&lt;Integer&gt; parallelEntities = ConcurrentHashMap.newKeySet();&#10;        query.forEachParallel((entityId, handles, archetype) -&gt;&#10;            parallelEntities.add(entityId)&#10;        );&#10;&#10;        // Both should process the same entities&#10;        assertEquals(sequentialEntities.size(), parallelEntities.size());&#10;        assertEquals(sequentialEntities, parallelEntities);&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelWithNoMatchingEntities() {&#10;        // Register two components&#10;        world.registerComponent(TestComponent1.class);&#10;        world.registerComponent(TestComponent2.class);&#10;&#10;        // Create entities with only Component1&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            world.createEntity(TestComponent1.class);&#10;        }&#10;&#10;        // Query for entities that must have Component2 (none will match)&#10;        AtomicInteger count = new AtomicInteger(0);&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent2.class);&#10;&#10;        query.forEachParallel((entityId, arch) -&gt; count.incrementAndGet());&#10;&#10;        assertEquals(0, count.get());&#10;    }&#10;&#10;    @Test&#10;    void testForEachParallelPreservesEntityIntegrity() {&#10;        // Register components&#10;        world.registerComponent(TestComponent1.class);&#10;&#10;        // Create entities&#10;        int entityCount = 500;&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            world.createEntity(TestComponent1.class);&#10;        }&#10;&#10;        // Process entities and verify each is valid&#10;        AtomicInteger validEntityCount = new AtomicInteger(0);&#10;        AtomicInteger invalidEntityCount = new AtomicInteger(0);&#10;&#10;        ArchetypeQuery query = world.query();&#10;        query.with(TestComponent1.class);&#10;&#10;        query.forEachParallel((entityId, arch) -&gt; {&#10;            if (entityId &gt; 0 &amp;&amp; arch != null) {&#10;                validEntityCount.incrementAndGet();&#10;            } else {&#10;                invalidEntityCount.incrementAndGet();&#10;            }&#10;        });&#10;&#10;        assertEquals(entityCount, validEntityCount.get());&#10;        assertEquals(0, invalidEntityCount.get());&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>