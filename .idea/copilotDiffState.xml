<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    id(&quot;java&quot;)&#10;    id(&quot;application&quot;)&#10;}&#10;&#10;group = &quot;com.ethnicthv&quot;&#10;version = &quot;1.0-SNAPSHOT&quot;&#10;&#10;java {&#10;    toolchain {&#10;        languageVersion.set(JavaLanguageVersion.of(25))&#10;    }&#10;}&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    testImplementation(platform(&quot;org.junit:junit-bom:5.10.0&quot;))&#10;    testImplementation(&quot;org.junit.jupiter:junit-jupiter&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-launcher&quot;)&#10;}&#10;&#10;application {&#10;    // updated to use the demo package where the entry points were moved&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ECSDemo&quot;)&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;tasks.withType&lt;JavaCompile&gt; {&#10;    options.compilerArgs.addAll(listOf(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;    ))&#10;}&#10;&#10;tasks.withType&lt;Test&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.withType&lt;JavaExec&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the performance benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.PerformanceBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ComponentManager demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runImproved&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the improved demo with Query API and true SoA&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ImprovedDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the Archetype-based ECS demo&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Benchmark Archetype vs SparseSet ECS&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeVsSparseSetBenchmark&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeQueryDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ArchetypeQuery demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeQueryDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run Component Manager + Archetype ECS benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;,&#10;        &quot;-Xms2G&quot;,&#10;        &quot;-Xmx4G&quot;&#10;    )&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    id(&quot;java&quot;)&#10;    id(&quot;application&quot;)&#10;}&#10;&#10;group = &quot;com.ethnicthv&quot;&#10;version = &quot;1.0-SNAPSHOT&quot;&#10;&#10;java {&#10;    toolchain {&#10;        languageVersion.set(JavaLanguageVersion.of(25))&#10;    }&#10;}&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    testImplementation(platform(&quot;org.junit:junit-bom:5.10.0&quot;))&#10;    testImplementation(&quot;org.junit.jupiter:junit-jupiter&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-launcher&quot;)&#10;}&#10;&#10;application {&#10;    // updated to use the demo package where the entry points were moved&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ECSDemo&quot;)&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;tasks.withType&lt;JavaCompile&gt; {&#10;    options.compilerArgs.addAll(listOf(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;    ))&#10;}&#10;&#10;tasks.withType&lt;Test&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.withType&lt;JavaExec&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the performance benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.PerformanceBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ComponentManager demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runImproved&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the improved demo with Query API and true SoA&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ImprovedDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the Archetype-based ECS demo&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Benchmark Archetype vs SparseSet ECS&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeVsSparseSetBenchmark&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeQueryDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ArchetypeQuery demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeQueryDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run Component Manager + Archetype ECS benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;,&#10;        &quot;-Xms2G&quot;,&#10;        &quot;-Xmx4G&quot;&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/Archetype.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/Archetype.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Archetype groups entities that share the same set of components.&#10; * It stores component descriptors and manages a list of chunks.&#10; */&#10;public final class Archetype {&#10;&#10;    private final int[] componentIds;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] componentElementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final List&lt;ArchetypeChunk&gt; chunks = new ArrayList&lt;&gt;();&#10;&#10;    // Choose a chunk byte budget (tunable)&#10;    private static final int CHUNK_SIZE = 16 * 1024;&#10;    private static final int DEFAULT_ENTITIES_PER_CHUNK = 64; // when descriptors report 0 size&#10;&#10;    public Archetype(ComponentMask mask, int[] componentIds, ComponentDescriptor[] descriptors, Arena arena) {&#10;        // Note: mask parameter kept for backward compatibility, but not stored&#10;        if (componentIds.length != descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;componentIds/descriptors length mismatch&quot;);&#10;        }&#10;        this.componentIds = componentIds;&#10;        this.descriptors = descriptors;&#10;        this.componentElementSizes = new long[descriptors.length];&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long s = descriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;&#10;        if (totalPerEntity &lt;= 0) {&#10;            // if no components or sizes are zero, use a sensible default count&#10;            this.entitiesPerChunk = DEFAULT_ENTITIES_PER_CHUNK;&#10;        } else {&#10;            this.entitiesPerChunk = Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        }&#10;&#10;        // Create initial chunk&#10;        this.chunks.add(new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena));&#10;    }&#10;&#10;    /**&#10;     * Get component mask - computed on demand from componentIds&#10;     */&#10;    public ComponentMask getMask() {&#10;        ComponentMask mask = new ComponentMask();&#10;        for (int componentId : componentIds) {&#10;            mask = mask.set(componentId);&#10;        }&#10;        return mask;&#10;    }&#10;&#10;    public int[] getComponentIds() {&#10;        return componentIds;&#10;    }&#10;&#10;    public ComponentDescriptor[] getDescriptors() {&#10;        return descriptors;&#10;    }&#10;&#10;    public int getEntitiesPerChunk() {&#10;        return entitiesPerChunk;&#10;    }&#10;&#10;    public List&lt;ArchetypeChunk&gt; getChunks() {&#10;        return chunks;&#10;    }&#10;&#10;    public synchronized ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        for (int i = 0; i &lt; chunks.size(); i++) {&#10;            ArchetypeChunk chunk = chunks.get(i);&#10;            int idx = chunk.allocateSlot(entityId);&#10;            if (idx &gt;= 0) {&#10;                return new ArchetypeChunk.ChunkLocation(i, idx);&#10;            }&#10;        }&#10;        // No free slot -&gt; allocate new chunk using same arena as first&#10;        Arena arena = chunks.get(0).getArena();&#10;        ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena);&#10;        chunks.add(newChunk);&#10;        int idx = newChunk.allocateSlot(entityId);&#10;        return new ArchetypeChunk.ChunkLocation(chunks.size() - 1, idx);&#10;    }&#10;&#10;    public synchronized void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        if (location.chunkIndex &gt;= chunks.size()) return;&#10;        ArchetypeChunk chunk = chunks.get(location.chunkIndex);&#10;        chunk.freeSlot(location.indexInChunk);&#10;        // Optionally free empty chunks (except keep one)&#10;        if (chunk.isEmpty() &amp;&amp; chunks.size() &gt; 1) {&#10;            chunks.remove(location.chunkIndex);&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        return chunks.get(chunkIndex);&#10;    }&#10;&#10;    public int chunkCount() {&#10;        return chunks.size();&#10;    }&#10;&#10;    public int getEntityCount() {&#10;        int total = 0;&#10;        for (ArchetypeChunk c : chunks) total += c.size();&#10;        return total;&#10;    }&#10;&#10;    /**&#10;     * Iterate over all entities in this archetype&#10;     */&#10;    public void forEach(ArchetypeIterator iterator) {&#10;        for (int chunkIdx = 0; chunkIdx &lt; chunks.size(); chunkIdx++) {&#10;            ArchetypeChunk chunk = chunks.get(chunkIdx);&#10;            for (int i = 0; i &lt; chunk.size(); i++) {&#10;                iterator.accept(chunk.getEntityId(i), new ArchetypeChunk.ChunkLocation(chunkIdx, i), chunk);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public MemorySegment getComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex) {&#10;        ArchetypeChunk chunk = chunks.get(location.chunkIndex);&#10;        return chunk.getComponentData(componentIndex, location.indexInChunk);&#10;    }&#10;&#10;    /**&#10;     * Set component data for an entity&#10;     */&#10;    public void setComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex, MemorySegment data) {&#10;        ArchetypeChunk chunk = chunks.get(location.chunkIndex);&#10;        chunk.setComponentData(componentIndex, location.indexInChunk, data);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeIterator {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Archetype groups entities that share the same set of components.&#10; * It stores component descriptors and manages a list of chunks.&#10; */&#10;public final class Archetype {&#10;&#10;    private final int[] componentIds;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] componentElementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final List&lt;ArchetypeChunk&gt; chunks = new ArrayList&lt;&gt;();&#10;&#10;    // Choose a chunk byte budget (tunable)&#10;    private static final int CHUNK_SIZE = 16 * 1024;&#10;    private static final int DEFAULT_ENTITIES_PER_CHUNK = 64; // when descriptors report 0 size&#10;&#10;    public Archetype(ComponentMask mask, int[] componentIds, ComponentDescriptor[] descriptors, Arena arena) {&#10;        // Note: mask parameter kept for backward compatibility, but not stored&#10;        if (componentIds.length != descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;componentIds/descriptors length mismatch&quot;);&#10;        }&#10;        this.componentIds = componentIds;&#10;        this.descriptors = descriptors;&#10;        this.componentElementSizes = new long[descriptors.length];&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long s = descriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;&#10;        if (totalPerEntity &lt;= 0) {&#10;            // if no components or sizes are zero, use a sensible default count&#10;            this.entitiesPerChunk = DEFAULT_ENTITIES_PER_CHUNK;&#10;        } else {&#10;            this.entitiesPerChunk = Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        }&#10;&#10;        // Create initial chunk&#10;        this.chunks.add(new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena));&#10;    }&#10;&#10;    /**&#10;     * Get component mask - computed on demand from componentIds&#10;     */&#10;    public ComponentMask getMask() {&#10;        ComponentMask mask = new ComponentMask();&#10;        for (int componentId : componentIds) {&#10;            mask = mask.set(componentId);&#10;        }&#10;        return mask;&#10;    }&#10;&#10;    public int[] getComponentIds() {&#10;        return componentIds;&#10;    }&#10;&#10;    public ComponentDescriptor[] getDescriptors() {&#10;        return descriptors;&#10;    }&#10;&#10;    public int getEntitiesPerChunk() {&#10;        return entitiesPerChunk;&#10;    }&#10;&#10;    public List&lt;ArchetypeChunk&gt; getChunks() {&#10;        return chunks;&#10;    }&#10;&#10;    public synchronized ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        for (int i = 0; i &lt; chunks.size(); i++) {&#10;            ArchetypeChunk chunk = chunks.get(i);&#10;            int idx = chunk.allocateSlot(entityId);&#10;            if (idx &gt;= 0) {&#10;                return new ArchetypeChunk.ChunkLocation(i, idx);&#10;            }&#10;        }&#10;        // No free slot -&gt; allocate new chunk using same arena as first&#10;        Arena arena = chunks.get(0).getArena();&#10;        ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, componentElementSizes, entitiesPerChunk, arena);&#10;        chunks.add(newChunk);&#10;        int idx = newChunk.allocateSlot(entityId);&#10;        return new ArchetypeChunk.ChunkLocation(chunks.size() - 1, idx);&#10;    }&#10;&#10;    public synchronized void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        if (location.chunkIndex &gt;= chunks.size()) return;&#10;        ArchetypeChunk chunk = chunks.get(location.chunkIndex);&#10;        chunk.freeSlot(location.indexInChunk);&#10;        // Optionally free empty chunks (except keep one)&#10;        if (chunk.isEmpty() &amp;&amp; chunks.size() &gt; 1) {&#10;            chunks.remove(location.chunkIndex);&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        return chunks.get(chunkIndex);&#10;    }&#10;&#10;    public int chunkCount() {&#10;        return chunks.size();&#10;    }&#10;&#10;    public int getEntityCount() {&#10;        int total = 0;&#10;        for (ArchetypeChunk c : chunks) total += c.size();&#10;        return total;&#10;    }&#10;&#10;    /**&#10;     * Iterate over all entities in this archetype&#10;     */&#10;    public void forEach(ArchetypeIterator iterator) {&#10;        for (int chunkIdx = 0; chunkIdx &lt; chunks.size(); chunkIdx++) {&#10;            ArchetypeChunk chunk = chunks.get(chunkIdx);&#10;            for (int i = 0; i &lt; chunk.size(); i++) {&#10;                iterator.accept(chunk.getEntityId(i), new ArchetypeChunk.ChunkLocation(chunkIdx, i), chunk);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public MemorySegment getComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex) {&#10;        ArchetypeChunk chunk = chunks.get(location.chunkIndex);&#10;        return chunk.getComponentData(componentIndex, location.indexInChunk);&#10;    }&#10;&#10;    /**&#10;     * Set component data for an entity&#10;     */&#10;    public void setComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex, MemorySegment data) {&#10;        ArchetypeChunk chunk = chunks.get(location.chunkIndex);&#10;        chunk.setComponentData(componentIndex, location.indexInChunk, data);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeIterator {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeChunk.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeChunk.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.Arrays;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk {&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    private final int capacity;&#10;    private final boolean[] occupied;&#10;    private final int[] entityIds;&#10;    private final Arena arena;&#10;    private int size; // number of occupied slots&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.occupied = new boolean[capacity];&#10;        this.entityIds = new int[capacity];&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = 0;&#10;&#10;        // Allocate per-component arrays&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            this.componentArrays[i] = arena.allocate(bytes);&#10;        }&#10;&#10;        Arrays.fill(entityIds, -1);&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public synchronized int allocateSlot(int entityId) {&#10;        if (size &gt;= capacity) return -1;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (!occupied[i]) {&#10;                occupied[i] = true;&#10;                entityIds[i] = entityId;&#10;                size++;&#10;                // Optionally zero memory for each component element&#10;                return i;&#10;            }&#10;        }&#10;        return -1;&#10;    }&#10;&#10;    public synchronized void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        if (occupied[index]) {&#10;            occupied[index] = false;&#10;            entityIds[index] = -1;&#10;            size--;&#10;        }&#10;        // content left as-is; caller may overwrite&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size == 0;&#10;    }&#10;&#10;    public int getEntityId(int index) {&#10;        return entityIds[index];&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    public int size() {&#10;        return size;&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.Arrays;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk {&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    private final int capacity;&#10;    private final boolean[] occupied;&#10;    private final int[] entityIds;&#10;    private final Arena arena;&#10;    private int size; // number of occupied slots&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.occupied = new boolean[capacity];&#10;        this.entityIds = new int[capacity];&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = 0;&#10;&#10;        // Allocate per-component arrays&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            this.componentArrays[i] = arena.allocate(bytes);&#10;        }&#10;&#10;        Arrays.fill(entityIds, -1);&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public synchronized int allocateSlot(int entityId) {&#10;        if (size &gt;= capacity) return -1;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (!occupied[i]) {&#10;                occupied[i] = true;&#10;                entityIds[i] = entityId;&#10;                size++;&#10;                // Optionally zero memory for each component element&#10;                return i;&#10;            }&#10;        }&#10;        return -1;&#10;    }&#10;&#10;    public synchronized void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        if (occupied[index]) {&#10;            occupied[index] = false;&#10;            entityIds[index] = -1;&#10;            size--;&#10;        }&#10;        // content left as-is; caller may overwrite&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size == 0;&#10;    }&#10;&#10;    public int getEntityId(int index) {&#10;        return entityIds[index];&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    public int size() {&#10;        return size;&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final Map&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;&#10;    public ArchetypeManager(Arena arena) {&#10;        this.archetypes = new HashMap&lt;&gt;();&#10;        this.arena = arena;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask&#10;     * Now accepts ComponentDescriptor[] (aligned with ComponentManager).&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask, int[] componentIds, ComponentDescriptor[] descriptors) {&#10;        return archetypes.computeIfAbsent(mask,&#10;            m -&gt; new Archetype(m, componentIds, descriptors, arena));&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final Map&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;&#10;    public ArchetypeManager(Arena arena) {&#10;        this.archetypes = new HashMap&lt;&gt;();&#10;        this.arena = arena;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask&#10;     * Now accepts ComponentDescriptor[] (aligned with ComponentManager).&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask, int[] componentIds, ComponentDescriptor[] descriptors) {&#10;        return archetypes.computeIfAbsent(mask,&#10;            m -&gt; new Archetype(m, componentIds, descriptors, arena));&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeQuery.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeQuery.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentHandle;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; *&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    @SafeVarargs&#10;    public final ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // Check WITH requirements&#10;            if (!archetypeMask.contains(with)) {&#10;                continue;&#10;            }&#10;&#10;            // Check WITHOUT requirements&#10;            boolean hasExcluded = false;&#10;            for (int i = 0; i &lt; 64; i++) {&#10;                if (without.has(i) &amp;&amp; archetypeMask.has(i)) {&#10;                    hasExcluded = true;&#10;                    break;&#10;                }&#10;            }&#10;            if (hasExcluded) {&#10;                continue;&#10;            }&#10;&#10;            // Check ANY requirements&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    for (int i = 0; i &lt; 64; i++) {&#10;                        if (anyMask.has(i) &amp;&amp; archetypeMask.has(i)) {&#10;                            matchesAny = true;&#10;                            break;&#10;                        }&#10;                    }&#10;                    if (matchesAny) break;&#10;                }&#10;                if (!matchesAny) {&#10;                    continue;&#10;                }&#10;            }&#10;&#10;            // Archetype matches query - iterate over its entities&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (ArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                consumer.accept(entityId, location, chunk, archetype);&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities, providing pooled ComponentHandles for the requested component classes.&#10;     * The consumer receives an array of bound ComponentHandle (same order as componentClasses). The handles are released&#10;     * back to the manager after the consumer returns. This is intended for synchronous, short-lived access inside the consumer.&#10;     */&#10;    @SafeVarargs&#10;    public final void forEachEntityWith(EntityWithHandlesConsumer consumer, Class&lt;?&gt;... componentClasses) {&#10;        // Resolve component type IDs for requested classes&#10;        Integer[] reqTypeIds = new Integer[componentClasses.length];&#10;        for (int i = 0; i &lt; componentClasses.length; i++) {&#10;            reqTypeIds[i] = world.getComponentTypeId(componentClasses[i]);&#10;            if (reqTypeIds[i] == null) {&#10;                // If a requested component class is not registered, no entity will match; return early&#10;                return;&#10;            }&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            int[] archCompIds = archetype.getComponentIds();&#10;            // For each requested type, find index inside archetype or -1&#10;            int[] compIndices = new int[reqTypeIds.length];&#10;            boolean allPresent = true;&#10;            for (int i = 0; i &lt; reqTypeIds.length; i++) {&#10;                int tid = reqTypeIds[i];&#10;                int idx = -1;&#10;                for (int j = 0; j &lt; archCompIds.length; j++) {&#10;                    if (archCompIds[j] == tid) { idx = j; break; }&#10;                }&#10;                compIndices[i] = idx;&#10;                if (idx &lt; 0) { allPresent = false; break; }&#10;            }&#10;            if (!allPresent) return; // this archetype doesn't contain all requested components&#10;&#10;            // Iterate entities in archetype&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; compIndices.length; k++) {&#10;                        int compIdx = compIndices[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, location, archetype);&#10;                } finally {&#10;                    for (int k = 0; k &lt; bound.length; k++) {&#10;                        if (bound[k] != null) {&#10;                            try { bound[k].close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeConsumer {&#10;        void accept(Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ChunkConsumer {&#10;        void accept(ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityConsumer {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityWithHandlesConsumer {&#10;        void accept(int entityId, ComponentHandle[] handles, ArchetypeChunk.ChunkLocation location, Archetype archetype);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentHandle;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; *&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    @SafeVarargs&#10;    public final ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // Check WITH requirements&#10;            if (!archetypeMask.contains(with)) {&#10;                continue;&#10;            }&#10;&#10;            // Check WITHOUT requirements&#10;            boolean hasExcluded = false;&#10;            for (int i = 0; i &lt; 64; i++) {&#10;                if (without.has(i) &amp;&amp; archetypeMask.has(i)) {&#10;                    hasExcluded = true;&#10;                    break;&#10;                }&#10;            }&#10;            if (hasExcluded) {&#10;                continue;&#10;            }&#10;&#10;            // Check ANY requirements&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    for (int i = 0; i &lt; 64; i++) {&#10;                        if (anyMask.has(i) &amp;&amp; archetypeMask.has(i)) {&#10;                            matchesAny = true;&#10;                            break;&#10;                        }&#10;                    }&#10;                    if (matchesAny) break;&#10;                }&#10;                if (!matchesAny) {&#10;                    continue;&#10;                }&#10;            }&#10;&#10;            // Archetype matches query - iterate over its entities&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (ArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                consumer.accept(entityId, location, chunk, archetype);&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities, providing pooled ComponentHandles for the requested component classes.&#10;     * The consumer receives an array of bound ComponentHandle (same order as componentClasses). The handles are released&#10;     * back to the manager after the consumer returns. This is intended for synchronous, short-lived access inside the consumer.&#10;     */&#10;    @SafeVarargs&#10;    public final void forEachEntityWith(EntityWithHandlesConsumer consumer, Class&lt;?&gt;... componentClasses) {&#10;        // Resolve component type IDs for requested classes&#10;        Integer[] reqTypeIds = new Integer[componentClasses.length];&#10;        for (int i = 0; i &lt; componentClasses.length; i++) {&#10;            reqTypeIds[i] = world.getComponentTypeId(componentClasses[i]);&#10;            if (reqTypeIds[i] == null) {&#10;                // If a requested component class is not registered, no entity will match; return early&#10;                return;&#10;            }&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            int[] archCompIds = archetype.getComponentIds();&#10;            // For each requested type, find index inside archetype or -1&#10;            int[] compIndices = new int[reqTypeIds.length];&#10;            boolean allPresent = true;&#10;            for (int i = 0; i &lt; reqTypeIds.length; i++) {&#10;                int tid = reqTypeIds[i];&#10;                int idx = -1;&#10;                for (int j = 0; j &lt; archCompIds.length; j++) {&#10;                    if (archCompIds[j] == tid) { idx = j; break; }&#10;                }&#10;                compIndices[i] = idx;&#10;                if (idx &lt; 0) { allPresent = false; break; }&#10;            }&#10;            if (!allPresent) return; // this archetype doesn't contain all requested components&#10;&#10;            // Iterate entities in archetype&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; compIndices.length; k++) {&#10;                        int compIdx = compIndices[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, location, archetype);&#10;                } finally {&#10;                    for (int k = 0; k &lt; bound.length; k++) {&#10;                        if (bound[k] != null) {&#10;                            try { bound[k].close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeConsumer {&#10;        void accept(Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ChunkConsumer {&#10;        void accept(ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityConsumer {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityWithHandlesConsumer {&#10;        void accept(int entityId, ComponentHandle[] handles, ArchetypeChunk.ChunkLocation location, Archetype archetype);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeWorld.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeWorld.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.*;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; *&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ComponentManager componentManager;&#10;    private final Map&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final Map&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private int nextEntityId = 1;&#10;    private int nextComponentTypeId = 0;&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.archetypeManager = new ArchetypeManager(arena);&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new HashMap&lt;&gt;();&#10;        this.componentTypeIds = new HashMap&lt;&gt;();&#10;        this.componentMetadata = new HashMap&lt;&gt;();&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        int id = componentTypeIds.computeIfAbsent(componentClass, c -&gt; {&#10;            int tid = componentManager.registerComponent(componentClass);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, componentClass, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id&#10;            nextComponentTypeId = Math.max(nextComponentTypeId, tid + 1);&#10;            return tid;&#10;        });&#10;        return id;&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId++;&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask, new int[0], new ComponentDescriptor[0]);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = findComponentIndex(newRecord.archetype.getComponentIds(), componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = findComponentIndex(record.archetype.getComponentIds(), componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query for entities matching component requirements&#10;     */&#10;    public ArchetypeQuery query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Build component arrays info for new archetype&#10;        List&lt;Integer&gt; componentIdsList = new ArrayList&lt;&gt;();&#10;&#10;        for (int i = 0; i &lt; nextComponentTypeId; i++) {&#10;            if (newMask.has(i)) {&#10;                componentIdsList.add(i);&#10;            }&#10;        }&#10;&#10;        int[] componentIds = componentIdsList.stream().mapToInt(Integer::intValue).toArray();&#10;&#10;        // Build ComponentDescriptor[] for these ids&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[componentIds.length];&#10;        for (int i = 0; i &lt; componentIds.length; i++) {&#10;            ComponentMetadata meta = componentMetadata.get(componentIds[i]);&#10;            if (meta == null) {&#10;                throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + componentIds[i]);&#10;            }&#10;            descriptors[i] = componentManager.getDescriptor(meta.type);&#10;        }&#10;&#10;        // Get or create new archetype&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask, componentIds, descriptors);&#10;&#10;        // Copy existing component data&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;&#10;        // Only copy components that exist in BOTH old and new archetypes&#10;        int[] oldComponentIds = oldRecord.archetype.getComponentIds();&#10;        for (int newIdx = 0; newIdx &lt; componentIds.length; newIdx++) {&#10;            int componentTypeId = componentIds[newIdx];&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                // Find this component's index in the OLD archetype&#10;                int oldIdx = -1;&#10;                for (int j = 0; j &lt; oldComponentIds.length; j++) {&#10;                    if (oldComponentIds[j] == componentTypeId) {&#10;                        oldIdx = j;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (oldIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    /**&#10;     * Find the index of a component type ID in the archetype's component array&#10;     */&#10;    private int findComponentIndex(int[] componentIds, int componentTypeId) {&#10;        for (int i = 0; i &lt; componentIds.length; i++) {&#10;            if (componentIds[i] == componentTypeId) {&#10;                return i;&#10;            }&#10;        }&#10;        return -1;&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.*;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; *&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ComponentManager componentManager;&#10;    private final Map&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final Map&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private int nextEntityId = 1;&#10;    private int nextComponentTypeId = 0;&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.archetypeManager = new ArchetypeManager(arena);&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new HashMap&lt;&gt;();&#10;        this.componentTypeIds = new HashMap&lt;&gt;();&#10;        this.componentMetadata = new HashMap&lt;&gt;();&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        int id = componentTypeIds.computeIfAbsent(componentClass, c -&gt; {&#10;            int tid = componentManager.registerComponent(componentClass);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(componentClass);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, componentClass, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id&#10;            nextComponentTypeId = Math.max(nextComponentTypeId, tid + 1);&#10;            return tid;&#10;        });&#10;        return id;&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId++;&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask, new int[0], new ComponentDescriptor[0]);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = findComponentIndex(newRecord.archetype.getComponentIds(), componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = findComponentIndex(record.archetype.getComponentIds(), componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query for entities matching component requirements&#10;     */&#10;    public ArchetypeQuery query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Build component arrays info for new archetype&#10;        List&lt;Integer&gt; componentIdsList = new ArrayList&lt;&gt;();&#10;&#10;        for (int i = 0; i &lt; nextComponentTypeId; i++) {&#10;            if (newMask.has(i)) {&#10;                componentIdsList.add(i);&#10;            }&#10;        }&#10;&#10;        int[] componentIds = componentIdsList.stream().mapToInt(Integer::intValue).toArray();&#10;&#10;        // Build ComponentDescriptor[] for these ids&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[componentIds.length];&#10;        for (int i = 0; i &lt; componentIds.length; i++) {&#10;            ComponentMetadata meta = componentMetadata.get(componentIds[i]);&#10;            if (meta == null) {&#10;                throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + componentIds[i]);&#10;            }&#10;            descriptors[i] = componentManager.getDescriptor(meta.type);&#10;        }&#10;&#10;        // Get or create new archetype&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask, componentIds, descriptors);&#10;&#10;        // Copy existing component data&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;&#10;        // Only copy components that exist in BOTH old and new archetypes&#10;        int[] oldComponentIds = oldRecord.archetype.getComponentIds();&#10;        for (int newIdx = 0; newIdx &lt; componentIds.length; newIdx++) {&#10;            int componentTypeId = componentIds[newIdx];&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                // Find this component's index in the OLD archetype&#10;                int oldIdx = -1;&#10;                for (int j = 0; j &lt; oldComponentIds.length; j++) {&#10;                    if (oldComponentIds[j] == componentTypeId) {&#10;                        oldIdx = j;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (oldIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    /**&#10;     * Find the index of a component type ID in the archetype's component array&#10;     */&#10;    private int findComponentIndex(int[] componentIds, int componentTypeId) {&#10;        for (int i = 0; i &lt; componentIds.length; i++) {&#10;            if (componentIds[i] == componentTypeId) {&#10;                return i;&#10;            }&#10;        }&#10;        return -1;&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/system/ArchetypeMovementSystem.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/system/ArchetypeMovementSystem.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype.system;&#10;&#10;import com.ethnicthv.ecs.archetype.Archetype;&#10;import com.ethnicthv.ecs.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.components.PositionComponent;&#10;import com.ethnicthv.ecs.components.VelocityComponent;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Movement system optimized for Archetype-based ECS.&#10; * Processes entities in cache-friendly chunks.&#10; */&#10;public final class ArchetypeMovementSystem {&#10;    private final ArchetypeWorld world;&#10;    private final int positionTypeId;&#10;    private final int velocityTypeId;&#10;&#10;    public ArchetypeMovementSystem(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.positionTypeId = world.getComponentTypeId(PositionComponent.class);&#10;        this.velocityTypeId = world.getComponentTypeId(VelocityComponent.class);&#10;    }&#10;&#10;    /**&#10;     * Update all entities that have both Position and Velocity&#10;     */&#10;    public void update(float deltaTime) {&#10;        world.query()&#10;            .with(PositionComponent.class)&#10;            .with(VelocityComponent.class)&#10;            .forEachChunk((chunk, archetype) -&gt; {&#10;                updateChunk(chunk, archetype, deltaTime);&#10;            });&#10;    }&#10;&#10;    private void updateChunk(ArchetypeChunk chunk, Archetype archetype, float deltaTime) {&#10;        int size = chunk.size();&#10;&#10;        // Get component indices in this archetype&#10;        int posIndex = getComponentIndex(archetype, positionTypeId);&#10;        int velIndex = getComponentIndex(archetype, velocityTypeId);&#10;&#10;        // Process each entity in the chunk&#10;        for (int i = 0; i &lt; size; i++) {&#10;            MemorySegment posData = chunk.getComponentData(posIndex, i);&#10;            MemorySegment velData = chunk.getComponentData(velIndex, i);&#10;&#10;            if (posData != null &amp;&amp; velData != null) {&#10;                // Read velocity&#10;                float vx = velData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float vy = velData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Read position&#10;                float x = posData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float y = posData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Update position&#10;                x += vx * deltaTime;&#10;                y += vy * deltaTime;&#10;&#10;                // Write back&#10;                posData.set(ValueLayout.JAVA_FLOAT, 0, x);&#10;                posData.set(ValueLayout.JAVA_FLOAT, 4, y);&#10;            }&#10;        }&#10;    }&#10;&#10;    private int getComponentIndex(Archetype archetype, int componentTypeId) {&#10;        int index = 0;&#10;        ComponentMask mask = archetype.getMask();&#10;        for (int i = 0; i &lt; componentTypeId; i++) {&#10;            if (mask.has(i)) {&#10;                index++;&#10;            }&#10;        }&#10;        return index;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype.system;&#10;&#10;import com.ethnicthv.ecs.archetype.Archetype;&#10;import com.ethnicthv.ecs.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.components.PositionComponent;&#10;import com.ethnicthv.ecs.components.VelocityComponent;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Movement system optimized for Archetype-based ECS.&#10; * Processes entities in cache-friendly chunks.&#10; */&#10;public final class ArchetypeMovementSystem {&#10;    private final ArchetypeWorld world;&#10;    private final int positionTypeId;&#10;    private final int velocityTypeId;&#10;&#10;    public ArchetypeMovementSystem(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.positionTypeId = world.getComponentTypeId(PositionComponent.class);&#10;        this.velocityTypeId = world.getComponentTypeId(VelocityComponent.class);&#10;    }&#10;&#10;    /**&#10;     * Update all entities that have both Position and Velocity&#10;     */&#10;    public void update(float deltaTime) {&#10;        world.query()&#10;            .with(PositionComponent.class)&#10;            .with(VelocityComponent.class)&#10;            .forEachChunk((chunk, archetype) -&gt; {&#10;                updateChunk(chunk, archetype, deltaTime);&#10;            });&#10;    }&#10;&#10;    private void updateChunk(ArchetypeChunk chunk, Archetype archetype, float deltaTime) {&#10;        int size = chunk.size();&#10;&#10;        // Get component indices in this archetype&#10;        int posIndex = getComponentIndex(archetype, positionTypeId);&#10;        int velIndex = getComponentIndex(archetype, velocityTypeId);&#10;&#10;        // Process each entity in the chunk&#10;        for (int i = 0; i &lt; size; i++) {&#10;            MemorySegment posData = chunk.getComponentData(posIndex, i);&#10;            MemorySegment velData = chunk.getComponentData(velIndex, i);&#10;&#10;            if (posData != null &amp;&amp; velData != null) {&#10;                // Read velocity&#10;                float vx = velData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float vy = velData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Read position&#10;                float x = posData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float y = posData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Update position&#10;                x += vx * deltaTime;&#10;                y += vy * deltaTime;&#10;&#10;                // Write back&#10;                posData.set(ValueLayout.JAVA_FLOAT, 0, x);&#10;                posData.set(ValueLayout.JAVA_FLOAT, 4, y);&#10;            }&#10;        }&#10;    }&#10;&#10;    private int getComponentIndex(Archetype archetype, int componentTypeId) {&#10;        int index = 0;&#10;        ComponentMask mask = archetype.getMask();&#10;        for (int i = 0; i &lt; componentTypeId; i++) {&#10;            if (mask.has(i)) {&#10;                index++;&#10;            }&#10;        }&#10;        return index;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentHandle.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentHandle.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a field value by name&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a field value by name&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    private final Map&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new HashMap&lt;&gt;();&#10;    private int nextTypeId = 0;&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        if (componentTypeIds.containsKey(componentClass)) {&#10;            return componentTypeIds.get(componentClass);&#10;        }&#10;&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Build descriptor through reflection&#10;        ComponentDescriptor descriptor = buildDescriptor(componentClass);&#10;        descriptors.put(componentClass, descriptor);&#10;&#10;        int typeId = nextTypeId++;&#10;        componentTypeIds.put(componentClass, typeId);&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    private final Map&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new HashMap&lt;&gt;();&#10;    private int nextTypeId = 0;&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        if (componentTypeIds.containsKey(componentClass)) {&#10;            return componentTypeIds.get(componentClass);&#10;        }&#10;&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Build descriptor through reflection&#10;        ComponentDescriptor descriptor = buildDescriptor(componentClass);&#10;        descriptors.put(componentClass, descriptor);&#10;&#10;        int typeId = nextTypeId++;&#10;        componentTypeIds.put(componentClass, typeId);&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/MaskVsArrayBenchmark.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/MaskVsArrayBenchmark.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs;&#10;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;&#10;/**&#10; * Benchmark comparing ComponentMask (BitSet) vs int[] for component lookups&#10; */&#10;public class MaskVsArrayBenchmark {&#10;&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;=== Benchmark: ComponentMask vs int[] ===\n&quot;);&#10;&#10;        // Test with different component counts&#10;        int[] componentCounts = {3, 5, 10, 20};&#10;&#10;        for (int count : componentCounts) {&#10;            System.out.println(&quot;--- Testing with &quot; + count + &quot; components ---&quot;);&#10;            benchmarkComponentLookup(count);&#10;            System.out.println();&#10;        }&#10;    }&#10;&#10;    private static void benchmarkComponentLookup(int componentCount) {&#10;        // Setup: Create mask and array with same component IDs&#10;        ComponentMask mask = new ComponentMask();&#10;        int[] componentIds = new int[componentCount];&#10;&#10;        for (int i = 0; i &lt; componentCount; i++) {&#10;            int id = i * 2; // Sparse IDs: 0, 2, 4, 6, ...&#10;            componentIds[i] = id;&#10;            mask = mask.set(id);&#10;        }&#10;&#10;        int iterations = 10_000_000;&#10;        int lookupId = componentCount - 1; // Look for last component&#10;&#10;        // Warm up&#10;        for (int i = 0; i &lt; 1000; i++) {&#10;            mask.has(lookupId);&#10;            findInArray(componentIds, lookupId);&#10;        }&#10;&#10;        // Benchmark 1: BitSet lookup (mask.has())&#10;        long start1 = System.nanoTime();&#10;        boolean resultMask = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultMask = mask.has(lookupId);&#10;        }&#10;        long time1 = System.nanoTime() - start1;&#10;&#10;        // Benchmark 2: Array linear search&#10;        long start2 = System.nanoTime();&#10;        boolean resultArray = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultArray = findInArray(componentIds, lookupId) &gt;= 0;&#10;        }&#10;        long time2 = System.nanoTime() - start2;&#10;&#10;        // Benchmark 3: Check if mask contains all from another mask&#10;        ComponentMask queryMask = new ComponentMask().set(0).set(lookupId);&#10;        long start3 = System.nanoTime();&#10;        boolean resultContains = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultContains = mask.contains(queryMask);&#10;        }&#10;        long time3 = System.nanoTime() - start3;&#10;&#10;        // Benchmark 4: Check if array contains multiple IDs&#10;        int[] queryIds = {0, lookupId};&#10;        long start4 = System.nanoTime();&#10;        boolean resultArrayMulti = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultArrayMulti = arrayContainsAll(componentIds, queryIds);&#10;        }&#10;        long time4 = System.nanoTime() - start4;&#10;&#10;        System.out.printf(&quot;  Single lookup:\n&quot;);&#10;        System.out.printf(&quot;    BitSet.has():        %6.2f ns/op  (result=%b)\n&quot;,&#10;            time1 / (double) iterations, resultMask);&#10;        System.out.printf(&quot;    Array search:        %6.2f ns/op  (result=%b)\n&quot;,&#10;            time2 / (double) iterations, resultArray);&#10;        System.out.printf(&quot;    Speedup: %.2fx %s\n&quot;,&#10;            Math.max(time1, time2) / (double) Math.min(time1, time2),&#10;            time1 &lt; time2 ? &quot;(BitSet wins)&quot; : &quot;(Array wins)&quot;);&#10;&#10;        System.out.printf(&quot;\n  Multi-component check:\n&quot;);&#10;        System.out.printf(&quot;    Mask.containsAll():  %6.2f ns/op  (result=%b)\n&quot;,&#10;            time3 / (double) iterations, resultContains);&#10;        System.out.printf(&quot;    Array containsAll(): %6.2f ns/op  (result=%b)\n&quot;,&#10;            time4 / (double) iterations, resultArrayMulti);&#10;        System.out.printf(&quot;    Speedup: %.2fx %s\n&quot;,&#10;            Math.max(time3, time4) / (double) Math.min(time3, time4),&#10;            time3 &lt; time4 ? &quot;(Mask wins)&quot; : &quot;(Array wins)&quot;);&#10;&#10;        // Memory comparison&#10;        long maskMemory = estimateMaskMemory(mask);&#10;        long arrayMemory = 16 + componentIds.length * 4; // Array object header + int elements&#10;        System.out.printf(&quot;\n  Memory usage:\n&quot;);&#10;        System.out.printf(&quot;    BitSet (mask):       ~%d bytes\n&quot;, maskMemory);&#10;        System.out.printf(&quot;    int[] array:         ~%d bytes\n&quot;, arrayMemory);&#10;        System.out.printf(&quot;    Difference:          %+d bytes (%.1fx)\n&quot;,&#10;            maskMemory - arrayMemory,&#10;            maskMemory / (double) arrayMemory);&#10;    }&#10;&#10;    private static int findInArray(int[] array, int value) {&#10;        for (int i = 0; i &lt; array.length; i++) {&#10;            if (array[i] == value) {&#10;                return i;&#10;            }&#10;        }&#10;        return -1;&#10;    }&#10;&#10;    private static boolean arrayContainsAll(int[] haystack, int[] needles) {&#10;        for (int needle : needles) {&#10;            boolean found = false;&#10;            for (int hay : haystack) {&#10;                if (hay == needle) {&#10;                    found = true;&#10;                    break;&#10;                }&#10;            }&#10;            if (!found) return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    private static long estimateMaskMemory(ComponentMask mask) {&#10;        // BitSet internal: long[] words + object overhead&#10;        // Rough estimate: 24 bytes (object) + 16 bytes (array) + words * 8&#10;        // For small IDs, typically 1-2 long words&#10;        return 24 + 16 + 2 * 8; // ~56 bytes minimum&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs;&#10;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;&#10;/**&#10; * Benchmark comparing ComponentMask (BitSet) vs int[] for component lookups&#10; */&#10;public class MaskVsArrayBenchmark {&#10;&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;=== Benchmark: ComponentMask vs int[] ===\n&quot;);&#10;&#10;        // Test with different component counts&#10;        int[] componentCounts = {3, 5, 10, 20};&#10;&#10;        for (int count : componentCounts) {&#10;            System.out.println(&quot;--- Testing with &quot; + count + &quot; components ---&quot;);&#10;            benchmarkComponentLookup(count);&#10;            System.out.println();&#10;        }&#10;    }&#10;&#10;    private static void benchmarkComponentLookup(int componentCount) {&#10;        // Setup: Create mask and array with same component IDs&#10;        ComponentMask mask = new ComponentMask();&#10;        int[] componentIds = new int[componentCount];&#10;&#10;        for (int i = 0; i &lt; componentCount; i++) {&#10;            int id = i * 2; // Sparse IDs: 0, 2, 4, 6, ...&#10;            componentIds[i] = id;&#10;            mask = mask.set(id);&#10;        }&#10;&#10;        int iterations = 10_000_000;&#10;        int lookupId = componentCount - 1; // Look for last component&#10;&#10;        // Warm up&#10;        for (int i = 0; i &lt; 1000; i++) {&#10;            mask.has(lookupId);&#10;            findInArray(componentIds, lookupId);&#10;        }&#10;&#10;        // Benchmark 1: BitSet lookup (mask.has())&#10;        long start1 = System.nanoTime();&#10;        boolean resultMask = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultMask = mask.has(lookupId);&#10;        }&#10;        long time1 = System.nanoTime() - start1;&#10;&#10;        // Benchmark 2: Array linear search&#10;        long start2 = System.nanoTime();&#10;        boolean resultArray = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultArray = findInArray(componentIds, lookupId) &gt;= 0;&#10;        }&#10;        long time2 = System.nanoTime() - start2;&#10;&#10;        // Benchmark 3: Check if mask contains all from another mask&#10;        ComponentMask queryMask = new ComponentMask().set(0).set(lookupId);&#10;        long start3 = System.nanoTime();&#10;        boolean resultContains = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultContains = mask.contains(queryMask);&#10;        }&#10;        long time3 = System.nanoTime() - start3;&#10;&#10;        // Benchmark 4: Check if array contains multiple IDs&#10;        int[] queryIds = {0, lookupId};&#10;        long start4 = System.nanoTime();&#10;        boolean resultArrayMulti = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultArrayMulti = arrayContainsAll(componentIds, queryIds);&#10;        }&#10;        long time4 = System.nanoTime() - start4;&#10;&#10;        System.out.printf(&quot;  Single lookup:\n&quot;);&#10;        System.out.printf(&quot;    BitSet.has():        %6.2f ns/op  (result=%b)\n&quot;,&#10;            time1 / (double) iterations, resultMask);&#10;        System.out.printf(&quot;    Array search:        %6.2f ns/op  (result=%b)\n&quot;,&#10;            time2 / (double) iterations, resultArray);&#10;        System.out.printf(&quot;    Speedup: %.2fx %s\n&quot;,&#10;            Math.max(time1, time2) / (double) Math.min(time1, time2),&#10;            time1 &lt; time2 ? &quot;(BitSet wins)&quot; : &quot;(Array wins)&quot;);&#10;&#10;        System.out.printf(&quot;\n  Multi-component check:\n&quot;);&#10;        System.out.printf(&quot;    Mask.containsAll():  %6.2f ns/op  (result=%b)\n&quot;,&#10;            time3 / (double) iterations, resultContains);&#10;        System.out.printf(&quot;    Array containsAll(): %6.2f ns/op  (result=%b)\n&quot;,&#10;            time4 / (double) iterations, resultArrayMulti);&#10;        System.out.printf(&quot;    Speedup: %.2fx %s\n&quot;,&#10;            Math.max(time3, time4) / (double) Math.min(time3, time4),&#10;            time3 &lt; time4 ? &quot;(Mask wins)&quot; : &quot;(Array wins)&quot;);&#10;&#10;        // Memory comparison&#10;        long maskMemory = estimateMaskMemory(mask);&#10;        long arrayMemory = 16 + componentIds.length * 4; // Array object header + int elements&#10;        System.out.printf(&quot;\n  Memory usage:\n&quot;);&#10;        System.out.printf(&quot;    BitSet (mask):       ~%d bytes\n&quot;, maskMemory);&#10;        System.out.printf(&quot;    int[] array:         ~%d bytes\n&quot;, arrayMemory);&#10;        System.out.printf(&quot;    Difference:          %+d bytes (%.1fx)\n&quot;,&#10;            maskMemory - arrayMemory,&#10;            maskMemory / (double) arrayMemory);&#10;    }&#10;&#10;    private static int findInArray(int[] array, int value) {&#10;        for (int i = 0; i &lt; array.length; i++) {&#10;            if (array[i] == value) {&#10;                return i;&#10;            }&#10;        }&#10;        return -1;&#10;    }&#10;&#10;    private static boolean arrayContainsAll(int[] haystack, int[] needles) {&#10;        for (int needle : needles) {&#10;            boolean found = false;&#10;            for (int hay : haystack) {&#10;                if (hay == needle) {&#10;                    found = true;&#10;                    break;&#10;                }&#10;            }&#10;            if (!found) return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    private static long estimateMaskMemory(ComponentMask mask) {&#10;        // BitSet internal: long[] words + object overhead&#10;        // Rough estimate: 24 bytes (object) + 16 bytes (array) + words * 8&#10;        // For small IDs, typically 1-2 long words&#10;        return 24 + 16 + 2 * 8; // ~56 bytes minimum&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>