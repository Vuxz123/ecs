<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    id(&quot;java&quot;)&#10;    id(&quot;application&quot;)&#10;}&#10;&#10;group = &quot;com.ethnicthv&quot;&#10;version = &quot;1.0-SNAPSHOT&quot;&#10;&#10;java {&#10;    toolchain {&#10;        languageVersion.set(JavaLanguageVersion.of(25))&#10;    }&#10;}&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    testImplementation(platform(&quot;org.junit:junit-bom:5.10.0&quot;))&#10;    testImplementation(&quot;org.junit.jupiter:junit-jupiter&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-launcher&quot;)&#10;}&#10;&#10;application {&#10;    // updated to use the demo package where the entry points were moved&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ECSDemo&quot;)&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;tasks.withType&lt;JavaCompile&gt; {&#10;    options.compilerArgs.addAll(listOf(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;    ))&#10;}&#10;&#10;tasks.withType&lt;Test&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.withType&lt;JavaExec&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the performance benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.PerformanceBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ComponentManager demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runImproved&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the improved demo with Query API and true SoA&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ImprovedDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the Archetype-based ECS demo&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Benchmark Archetype vs SparseSet ECS&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeVsSparseSetBenchmark&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeQueryDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ArchetypeQuery demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeQueryDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run Component Manager + Archetype ECS benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;,&#10;        &quot;-Xms2G&quot;,&#10;        &quot;-Xmx4G&quot;&#10;    )&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    id(&quot;java&quot;)&#10;    id(&quot;application&quot;)&#10;}&#10;&#10;group = &quot;com.ethnicthv&quot;&#10;version = &quot;1.0-SNAPSHOT&quot;&#10;&#10;java {&#10;    toolchain {&#10;        languageVersion.set(JavaLanguageVersion.of(25))&#10;    }&#10;}&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    testImplementation(platform(&quot;org.junit:junit-bom:5.10.0&quot;))&#10;    testImplementation(&quot;org.junit.jupiter:junit-jupiter&quot;)&#10;    testRuntimeOnly(&quot;org.junit.platform:junit-platform-launcher&quot;)&#10;}&#10;&#10;application {&#10;    // updated to use the demo package where the entry points were moved&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ECSDemo&quot;)&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;tasks.withType&lt;JavaCompile&gt; {&#10;    options.compilerArgs.addAll(listOf(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;    ))&#10;}&#10;&#10;tasks.withType&lt;Test&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.withType&lt;JavaExec&gt; {&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the performance benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.PerformanceBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ComponentManager demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runImproved&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the improved demo with Query API and true SoA&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ImprovedDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the Archetype-based ECS demo&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeDemo&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Benchmark Archetype vs SparseSet ECS&quot;&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeVsSparseSetBenchmark&quot;)&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runArchetypeQueryDemo&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run the ArchetypeQuery demo&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ArchetypeQueryDemo&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&quot;--enable-preview&quot;, &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;)&#10;}&#10;&#10;tasks.register&lt;JavaExec&gt;(&quot;runComponentBenchmark&quot;) {&#10;    group = &quot;application&quot;&#10;    description = &quot;Run Component Manager + Archetype ECS benchmark&quot;&#10;    mainClass.set(&quot;com.ethnicthv.ecs.demo.ComponentManagerBenchmark&quot;)&#10;    classpath = sourceSets[&quot;main&quot;].runtimeClasspath&#10;    jvmArgs(&#10;        &quot;--enable-preview&quot;,&#10;        &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;,&#10;        &quot;-Xms2G&quot;,&#10;        &quot;-Xmx4G&quot;&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeChunk.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeChunk.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk {&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                size.incrementAndGet();&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                size.decrementAndGet();&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk {&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                size.incrementAndGet();&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                size.decrementAndGet();&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] componentIds = m.toComponentIdArray();&#10;            ComponentDescriptor[] descriptors = new ComponentDescriptor[componentIds.length];&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                var meta = metadataProvider.apply(componentIds[i]);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + componentIds[i]);&#10;                }&#10;                descriptors[i] = componentManager.getDescriptor(meta.type());&#10;            }&#10;            return new Archetype(m, componentIds, descriptors, arena);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] componentIds = m.toComponentIdArray();&#10;            ComponentDescriptor[] descriptors = new ComponentDescriptor[componentIds.length];&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                var meta = metadataProvider.apply(componentIds[i]);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + componentIds[i]);&#10;                }&#10;                descriptors[i] = componentManager.getDescriptor(meta.type());&#10;            }&#10;            return new Archetype(m, componentIds, descriptors, arena);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeQuery.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeQuery.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentHandle;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (ArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                consumer.accept(entityId, location, chunk, archetype);&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities, providing pooled ComponentHandles for the requested component classes.&#10;     * The consumer receives an array of bound ComponentHandle (same order as componentClasses). The handles are released&#10;     * back to the manager after the consumer returns. This is intended for synchronous, short-lived access inside the consumer.&#10;     */&#10;    public void forEachEntityWith(EntityWithHandlesConsumer consumer, Class&lt;?&gt;... componentClasses) {&#10;        // Resolve component type IDs for requested classes&#10;        int[] reqTypeIds = new int[componentClasses.length];&#10;        for (int i = 0; i &lt; componentClasses.length; i++) {&#10;            Integer tid = world.getComponentTypeId(componentClasses[i]);&#10;            if (tid == null) {&#10;                // If a requested component class is not registered, no entity will match; return early&#10;                return;&#10;            }&#10;            reqTypeIds[i] = tid;&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            int[] compIndices = new int[reqTypeIds.length];&#10;            for (int i = 0; i &lt; reqTypeIds.length; i++) {&#10;                int idx = archetype.indexOfComponentType(reqTypeIds[i]);&#10;                if (idx &lt; 0) {&#10;                    // archetype missing at least one required component; skip it&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;&#10;            // Iterate entities in archetype&#10;            final int[] useIdx = compIndices; // capture&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; useIdx.length; k++) {&#10;                        int compIdx = useIdx[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, location, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeConsumer {&#10;        void accept(Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ChunkConsumer {&#10;        void accept(ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityConsumer {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityWithHandlesConsumer {&#10;        void accept(int entityId, ComponentHandle[] handles, ArchetypeChunk.ChunkLocation location, Archetype archetype);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentHandle;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (ArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                consumer.accept(entityId, location, chunk, archetype);&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities, providing pooled ComponentHandles for the requested component classes.&#10;     * The consumer receives an array of bound ComponentHandle (same order as componentClasses). The handles are released&#10;     * back to the manager after the consumer returns. This is intended for synchronous, short-lived access inside the consumer.&#10;     */&#10;    public void forEachEntityWith(EntityWithHandlesConsumer consumer, Class&lt;?&gt;... componentClasses) {&#10;        // Resolve component type IDs for requested classes&#10;        int[] reqTypeIds = new int[componentClasses.length];&#10;        for (int i = 0; i &lt; componentClasses.length; i++) {&#10;            Integer tid = world.getComponentTypeId(componentClasses[i]);&#10;            if (tid == null) {&#10;                // If a requested component class is not registered, no entity will match; return early&#10;                return;&#10;            }&#10;            reqTypeIds[i] = tid;&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            int[] compIndices = new int[reqTypeIds.length];&#10;            for (int i = 0; i &lt; reqTypeIds.length; i++) {&#10;                int idx = archetype.indexOfComponentType(reqTypeIds[i]);&#10;                if (idx &lt; 0) {&#10;                    // archetype missing at least one required component; skip it&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;&#10;            // Iterate entities in archetype&#10;            final int[] useIdx = compIndices; // capture&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; useIdx.length; k++) {&#10;                        int compIdx = useIdx[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, location, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeConsumer {&#10;        void accept(Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ChunkConsumer {&#10;        void accept(ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityConsumer {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityWithHandlesConsumer {&#10;        void accept(int entityId, ComponentHandle[] handles, ArchetypeChunk.ChunkLocation location, Archetype archetype);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeWorld.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeWorld.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ComponentManager componentManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    private final AtomicInteger nextComponentTypeId = new AtomicInteger(0);&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentMetadata = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentTypeIds.computeIfAbsent(componentClass, cls -&gt; {&#10;            int tid = componentManager.registerComponent(cls);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(cls);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, cls, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id atomically&#10;            nextComponentTypeId.updateAndGet(prev -&gt; Math.max(prev, tid + 1));&#10;            return tid;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query for entities matching component requirements&#10;     */&#10;    public ArchetypeQuery query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Delegate archetype construction to ArchetypeManager&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;&#10;        // Copy existing component data (only components present in both)&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;        int[] componentIds = newMask.toComponentIdArray();&#10;        for (int componentTypeId : componentIds) {&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ComponentManager componentManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    private final AtomicInteger nextComponentTypeId = new AtomicInteger(0);&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentMetadata = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentTypeIds.computeIfAbsent(componentClass, cls -&gt; {&#10;            int tid = componentManager.registerComponent(cls);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(cls);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, cls, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id atomically&#10;            nextComponentTypeId.updateAndGet(prev -&gt; Math.max(prev, tid + 1));&#10;            return tid;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query for entities matching component requirements&#10;     */&#10;    public ArchetypeQuery query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Delegate archetype construction to ArchetypeManager&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;&#10;        // Copy existing component data (only components present in both)&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;        int[] componentIds = newMask.toComponentIdArray();&#10;        for (int componentTypeId : componentIds) {&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ComponentMask.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ComponentMask.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import java.util.BitSet;&#10;&#10;/**&#10; * Represents a unique signature of components that an entity possesses.&#10; * Used to identify and group entities with the same component composition.&#10; */&#10;public final class ComponentMask {&#10;    private final BitSet mask;&#10;    private final int hashCode;&#10;&#10;    public ComponentMask() {&#10;        this.mask = new BitSet();&#10;        this.hashCode = 0;&#10;    }&#10;&#10;    private ComponentMask(BitSet mask) {&#10;        this.mask = (BitSet) mask.clone();&#10;        this.hashCode = mask.hashCode();&#10;    }&#10;&#10;    /**&#10;     * Set a component bit in the mask&#10;     */&#10;    public ComponentMask set(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.set(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Clear a component bit from the mask&#10;     */&#10;    public ComponentMask clear(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.clear(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Check if a component is present in the mask&#10;     */&#10;    public boolean has(int componentId) {&#10;        return mask.get(componentId);&#10;    }&#10;&#10;    /**&#10;     * Check if this mask contains all components from another mask&#10;     */&#10;    public boolean contains(ComponentMask other) {&#10;        BitSet intersection = (BitSet) mask.clone();&#10;        intersection.and(other.mask);&#10;        return intersection.equals(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask is a superset of other (WITH semantics).&#10;     */&#10;    public boolean containsAll(ComponentMask other) {&#10;        // other - this == empty ?&#10;        BitSet diff = (BitSet) other.mask.clone();&#10;        diff.andNot(this.mask);&#10;        return diff.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask shares at least one bit with other (ANY semantics).&#10;     */&#10;    public boolean intersects(ComponentMask other) {&#10;        return this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask has no bits in common with other (WITHOUT semantics).&#10;     */&#10;    public boolean containsNone(ComponentMask other) {&#10;        return !this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Get the number of components in this mask&#10;     */&#10;    public int cardinality() {&#10;        return mask.cardinality();&#10;    }&#10;&#10;    /**&#10;     * Return all set component IDs in ascending order.&#10;     */&#10;    public int[] toComponentIdArray() {&#10;        int count = mask.cardinality();&#10;        int[] ids = new int[count];&#10;        int idx = 0;&#10;        for (int bit = mask.nextSetBit(0); bit &gt;= 0; bit = mask.nextSetBit(bit + 1)) {&#10;            ids[idx++] = bit;&#10;        }&#10;        return ids;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        ComponentMask that = (ComponentMask) o;&#10;        return mask.equals(that.mask);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return hashCode;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;ComponentMask{&quot; + mask + '}';&#10;    }&#10;&#10;    /**&#10;     * Create a builder for fluent API&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    public static class Builder {&#10;        private final BitSet mask = new BitSet();&#10;&#10;        public Builder with(int componentId) {&#10;            mask.set(componentId);&#10;            return this;&#10;        }&#10;&#10;        public ComponentMask build() {&#10;            return new ComponentMask(mask);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import java.util.BitSet;&#10;&#10;/**&#10; * Represents a unique signature of components that an entity possesses.&#10; * Used to identify and group entities with the same component composition.&#10; */&#10;public final class ComponentMask {&#10;    private final BitSet mask;&#10;    private final int hashCode;&#10;&#10;    public ComponentMask() {&#10;        this.mask = new BitSet();&#10;        this.hashCode = 0;&#10;    }&#10;&#10;    private ComponentMask(BitSet mask) {&#10;        this.mask = (BitSet) mask.clone();&#10;        this.hashCode = mask.hashCode();&#10;    }&#10;&#10;    /**&#10;     * Set a component bit in the mask&#10;     */&#10;    public ComponentMask set(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.set(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Clear a component bit from the mask&#10;     */&#10;    public ComponentMask clear(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.clear(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Check if a component is present in the mask&#10;     */&#10;    public boolean has(int componentId) {&#10;        return mask.get(componentId);&#10;    }&#10;&#10;    /**&#10;     * Check if this mask contains all components from another mask&#10;     */&#10;    public boolean contains(ComponentMask other) {&#10;        BitSet intersection = (BitSet) mask.clone();&#10;        intersection.and(other.mask);&#10;        return intersection.equals(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask is a superset of other (WITH semantics).&#10;     */&#10;    public boolean containsAll(ComponentMask other) {&#10;        // other - this == empty ?&#10;        BitSet diff = (BitSet) other.mask.clone();&#10;        diff.andNot(this.mask);&#10;        return diff.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask shares at least one bit with other (ANY semantics).&#10;     */&#10;    public boolean intersects(ComponentMask other) {&#10;        return this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask has no bits in common with other (WITHOUT semantics).&#10;     */&#10;    public boolean containsNone(ComponentMask other) {&#10;        return !this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Get the number of components in this mask&#10;     */&#10;    public int cardinality() {&#10;        return mask.cardinality();&#10;    }&#10;&#10;    /**&#10;     * Return all set component IDs in ascending order.&#10;     */&#10;    public int[] toComponentIdArray() {&#10;        int count = mask.cardinality();&#10;        int[] ids = new int[count];&#10;        int idx = 0;&#10;        for (int bit = mask.nextSetBit(0); bit &gt;= 0; bit = mask.nextSetBit(bit + 1)) {&#10;            ids[idx++] = bit;&#10;        }&#10;        return ids;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        ComponentMask that = (ComponentMask) o;&#10;        return mask.equals(that.mask);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return hashCode;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;ComponentMask{&quot; + mask + '}';&#10;    }&#10;&#10;    /**&#10;     * Create a builder for fluent API&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    public static class Builder {&#10;        private final BitSet mask = new BitSet();&#10;&#10;        public Builder with(int componentId) {&#10;            mask.set(componentId);&#10;            return this;&#10;        }&#10;&#10;        public ComponentMask build() {&#10;            return new ComponentMask(mask);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/system/ArchetypeMovementSystem.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/system/ArchetypeMovementSystem.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype.system;&#10;&#10;import com.ethnicthv.ecs.archetype.Archetype;&#10;import com.ethnicthv.ecs.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.components.PositionComponent;&#10;import com.ethnicthv.ecs.components.VelocityComponent;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Movement system optimized for Archetype-based ECS.&#10; * Processes entities in cache-friendly chunks.&#10; */&#10;public final class ArchetypeMovementSystem {&#10;    private final ArchetypeWorld world;&#10;    private final int positionTypeId;&#10;    private final int velocityTypeId;&#10;&#10;    public ArchetypeMovementSystem(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.positionTypeId = world.getComponentTypeId(PositionComponent.class);&#10;        this.velocityTypeId = world.getComponentTypeId(VelocityComponent.class);&#10;    }&#10;&#10;    /**&#10;     * Update all entities that have both Position and Velocity&#10;     */&#10;    public void update(float deltaTime) {&#10;        world.query()&#10;            .with(PositionComponent.class)&#10;            .with(VelocityComponent.class)&#10;            .forEachChunk((chunk, archetype) -&gt; {&#10;                updateChunk(chunk, archetype, deltaTime);&#10;            });&#10;    }&#10;&#10;    private void updateChunk(ArchetypeChunk chunk, Archetype archetype, float deltaTime) {&#10;        int size = chunk.size();&#10;&#10;        // Get component indices in this archetype&#10;        int posIndex = getComponentIndex(archetype, positionTypeId);&#10;        int velIndex = getComponentIndex(archetype, velocityTypeId);&#10;&#10;        // Process each entity in the chunk&#10;        for (int i = 0; i &lt; size; i++) {&#10;            MemorySegment posData = chunk.getComponentData(posIndex, i);&#10;            MemorySegment velData = chunk.getComponentData(velIndex, i);&#10;&#10;            if (posData != null &amp;&amp; velData != null) {&#10;                // Read velocity&#10;                float vx = velData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float vy = velData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Read position&#10;                float x = posData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float y = posData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Update position&#10;                x += vx * deltaTime;&#10;                y += vy * deltaTime;&#10;&#10;                // Write back&#10;                posData.set(ValueLayout.JAVA_FLOAT, 0, x);&#10;                posData.set(ValueLayout.JAVA_FLOAT, 4, y);&#10;            }&#10;        }&#10;    }&#10;&#10;    private int getComponentIndex(Archetype archetype, int componentTypeId) {&#10;        int index = 0;&#10;        ComponentMask mask = archetype.getMask();&#10;        for (int i = 0; i &lt; componentTypeId; i++) {&#10;            if (mask.has(i)) {&#10;                index++;&#10;            }&#10;        }&#10;        return index;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype.system;&#10;&#10;import com.ethnicthv.ecs.archetype.Archetype;&#10;import com.ethnicthv.ecs.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.components.PositionComponent;&#10;import com.ethnicthv.ecs.components.VelocityComponent;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Movement system optimized for Archetype-based ECS.&#10; * Processes entities in cache-friendly chunks.&#10; */&#10;public final class ArchetypeMovementSystem {&#10;    private final ArchetypeWorld world;&#10;    private final int positionTypeId;&#10;    private final int velocityTypeId;&#10;&#10;    public ArchetypeMovementSystem(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.positionTypeId = world.getComponentTypeId(PositionComponent.class);&#10;        this.velocityTypeId = world.getComponentTypeId(VelocityComponent.class);&#10;    }&#10;&#10;    /**&#10;     * Update all entities that have both Position and Velocity&#10;     */&#10;    public void update(float deltaTime) {&#10;        world.query()&#10;            .with(PositionComponent.class)&#10;            .with(VelocityComponent.class)&#10;            .forEachChunk((chunk, archetype) -&gt; {&#10;                updateChunk(chunk, archetype, deltaTime);&#10;            });&#10;    }&#10;&#10;    private void updateChunk(ArchetypeChunk chunk, Archetype archetype, float deltaTime) {&#10;        int size = chunk.size();&#10;&#10;        // Get component indices in this archetype&#10;        int posIndex = getComponentIndex(archetype, positionTypeId);&#10;        int velIndex = getComponentIndex(archetype, velocityTypeId);&#10;&#10;        // Process each entity in the chunk&#10;        for (int i = 0; i &lt; size; i++) {&#10;            MemorySegment posData = chunk.getComponentData(posIndex, i);&#10;            MemorySegment velData = chunk.getComponentData(velIndex, i);&#10;&#10;            if (posData != null &amp;&amp; velData != null) {&#10;                // Read velocity&#10;                float vx = velData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float vy = velData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Read position&#10;                float x = posData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float y = posData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Update position&#10;                x += vx * deltaTime;&#10;                y += vy * deltaTime;&#10;&#10;                // Write back&#10;                posData.set(ValueLayout.JAVA_FLOAT, 0, x);&#10;                posData.set(ValueLayout.JAVA_FLOAT, 4, y);&#10;            }&#10;        }&#10;    }&#10;&#10;    private int getComponentIndex(Archetype archetype, int componentTypeId) {&#10;        int index = 0;&#10;        ComponentMask mask = archetype.getMask();&#10;        for (int i = 0; i &lt; componentTypeId; i++) {&#10;            if (mask.has(i)) {&#10;                index++;&#10;            }&#10;        }&#10;        return index;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentHandle.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentHandle.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a field value by name&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a field value by name&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    private final Map&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new HashMap&lt;&gt;();&#10;    private int nextTypeId = 0;&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        if (componentTypeIds.containsKey(componentClass)) {&#10;            return componentTypeIds.get(componentClass);&#10;        }&#10;&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Build descriptor through reflection&#10;        ComponentDescriptor descriptor = buildDescriptor(componentClass);&#10;        descriptors.put(componentClass, descriptor);&#10;&#10;        int typeId = nextTypeId++;&#10;        componentTypeIds.put(componentClass, typeId);&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    private final Map&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new HashMap&lt;&gt;();&#10;    private int nextTypeId = 0;&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        if (componentTypeIds.containsKey(componentClass)) {&#10;            return componentTypeIds.get(componentClass);&#10;        }&#10;&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Build descriptor through reflection&#10;        ComponentDescriptor descriptor = buildDescriptor(componentClass);&#10;        descriptors.put(componentClass, descriptor);&#10;&#10;        int typeId = nextTypeId++;&#10;        componentTypeIds.put(componentClass, typeId);&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/MaskVsArrayBenchmark.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/MaskVsArrayBenchmark.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs;&#10;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;&#10;/**&#10; * Benchmark comparing ComponentMask (BitSet) vs int[] for component lookups&#10; */&#10;public class MaskVsArrayBenchmark {&#10;&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;=== Benchmark: ComponentMask vs int[] ===\n&quot;);&#10;&#10;        // Test with different component counts&#10;        int[] componentCounts = {3, 5, 10, 20};&#10;&#10;        for (int count : componentCounts) {&#10;            System.out.println(&quot;--- Testing with &quot; + count + &quot; components ---&quot;);&#10;            benchmarkComponentLookup(count);&#10;            System.out.println();&#10;        }&#10;    }&#10;&#10;    private static void benchmarkComponentLookup(int componentCount) {&#10;        // Setup: Create mask and array with same component IDs&#10;        ComponentMask mask = new ComponentMask();&#10;        int[] componentIds = new int[componentCount];&#10;&#10;        for (int i = 0; i &lt; componentCount; i++) {&#10;            int id = i * 2; // Sparse IDs: 0, 2, 4, 6, ...&#10;            componentIds[i] = id;&#10;            mask = mask.set(id);&#10;        }&#10;&#10;        int iterations = 10_000_000;&#10;        int lookupId = componentCount - 1; // Look for last component&#10;&#10;        // Warm up&#10;        for (int i = 0; i &lt; 1000; i++) {&#10;            mask.has(lookupId);&#10;            findInArray(componentIds, lookupId);&#10;        }&#10;&#10;        // Benchmark 1: BitSet lookup (mask.has())&#10;        long start1 = System.nanoTime();&#10;        boolean resultMask = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultMask = mask.has(lookupId);&#10;        }&#10;        long time1 = System.nanoTime() - start1;&#10;&#10;        // Benchmark 2: Array linear search&#10;        long start2 = System.nanoTime();&#10;        boolean resultArray = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultArray = findInArray(componentIds, lookupId) &gt;= 0;&#10;        }&#10;        long time2 = System.nanoTime() - start2;&#10;&#10;        // Benchmark 3: Check if mask contains all from another mask&#10;        ComponentMask queryMask = new ComponentMask().set(0).set(lookupId);&#10;        long start3 = System.nanoTime();&#10;        boolean resultContains = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultContains = mask.contains(queryMask);&#10;        }&#10;        long time3 = System.nanoTime() - start3;&#10;&#10;        // Benchmark 4: Check if array contains multiple IDs&#10;        int[] queryIds = {0, lookupId};&#10;        long start4 = System.nanoTime();&#10;        boolean resultArrayMulti = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultArrayMulti = arrayContainsAll(componentIds, queryIds);&#10;        }&#10;        long time4 = System.nanoTime() - start4;&#10;&#10;        System.out.printf(&quot;  Single lookup:\n&quot;);&#10;        System.out.printf(&quot;    BitSet.has():        %6.2f ns/op  (result=%b)\n&quot;,&#10;            time1 / (double) iterations, resultMask);&#10;        System.out.printf(&quot;    Array search:        %6.2f ns/op  (result=%b)\n&quot;,&#10;            time2 / (double) iterations, resultArray);&#10;        System.out.printf(&quot;    Speedup: %.2fx %s\n&quot;,&#10;            Math.max(time1, time2) / (double) Math.min(time1, time2),&#10;            time1 &lt; time2 ? &quot;(BitSet wins)&quot; : &quot;(Array wins)&quot;);&#10;&#10;        System.out.printf(&quot;\n  Multi-component check:\n&quot;);&#10;        System.out.printf(&quot;    Mask.containsAll():  %6.2f ns/op  (result=%b)\n&quot;,&#10;            time3 / (double) iterations, resultContains);&#10;        System.out.printf(&quot;    Array containsAll(): %6.2f ns/op  (result=%b)\n&quot;,&#10;            time4 / (double) iterations, resultArrayMulti);&#10;        System.out.printf(&quot;    Speedup: %.2fx %s\n&quot;,&#10;            Math.max(time3, time4) / (double) Math.min(time3, time4),&#10;            time3 &lt; time4 ? &quot;(Mask wins)&quot; : &quot;(Array wins)&quot;);&#10;&#10;        // Memory comparison&#10;        long maskMemory = estimateMaskMemory(mask);&#10;        long arrayMemory = 16 + componentIds.length * 4; // Array object header + int elements&#10;        System.out.printf(&quot;\n  Memory usage:\n&quot;);&#10;        System.out.printf(&quot;    BitSet (mask):       ~%d bytes\n&quot;, maskMemory);&#10;        System.out.printf(&quot;    int[] array:         ~%d bytes\n&quot;, arrayMemory);&#10;        System.out.printf(&quot;    Difference:          %+d bytes (%.1fx)\n&quot;,&#10;            maskMemory - arrayMemory,&#10;            maskMemory / (double) arrayMemory);&#10;    }&#10;&#10;    private static int findInArray(int[] array, int value) {&#10;        for (int i = 0; i &lt; array.length; i++) {&#10;            if (array[i] == value) {&#10;                return i;&#10;            }&#10;        }&#10;        return -1;&#10;    }&#10;&#10;    private static boolean arrayContainsAll(int[] haystack, int[] needles) {&#10;        for (int needle : needles) {&#10;            boolean found = false;&#10;            for (int hay : haystack) {&#10;                if (hay == needle) {&#10;                    found = true;&#10;                    break;&#10;                }&#10;            }&#10;            if (!found) return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    private static long estimateMaskMemory(ComponentMask mask) {&#10;        // BitSet internal: long[] words + object overhead&#10;        // Rough estimate: 24 bytes (object) + 16 bytes (array) + words * 8&#10;        // For small IDs, typically 1-2 long words&#10;        return 24 + 16 + 2 * 8; // ~56 bytes minimum&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs;&#10;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;&#10;/**&#10; * Benchmark comparing ComponentMask (BitSet) vs int[] for component lookups&#10; */&#10;public class MaskVsArrayBenchmark {&#10;&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;=== Benchmark: ComponentMask vs int[] ===\n&quot;);&#10;&#10;        // Test with different component counts&#10;        int[] componentCounts = {3, 5, 10, 20};&#10;&#10;        for (int count : componentCounts) {&#10;            System.out.println(&quot;--- Testing with &quot; + count + &quot; components ---&quot;);&#10;            benchmarkComponentLookup(count);&#10;            System.out.println();&#10;        }&#10;    }&#10;&#10;    private static void benchmarkComponentLookup(int componentCount) {&#10;        // Setup: Create mask and array with same component IDs&#10;        ComponentMask mask = new ComponentMask();&#10;        int[] componentIds = new int[componentCount];&#10;&#10;        for (int i = 0; i &lt; componentCount; i++) {&#10;            int id = i * 2; // Sparse IDs: 0, 2, 4, 6, ...&#10;            componentIds[i] = id;&#10;            mask = mask.set(id);&#10;        }&#10;&#10;        int iterations = 10_000_000;&#10;        int lookupId = componentCount - 1; // Look for last component&#10;&#10;        // Warm up&#10;        for (int i = 0; i &lt; 1000; i++) {&#10;            mask.has(lookupId);&#10;            findInArray(componentIds, lookupId);&#10;        }&#10;&#10;        // Benchmark 1: BitSet lookup (mask.has())&#10;        long start1 = System.nanoTime();&#10;        boolean resultMask = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultMask = mask.has(lookupId);&#10;        }&#10;        long time1 = System.nanoTime() - start1;&#10;&#10;        // Benchmark 2: Array linear search&#10;        long start2 = System.nanoTime();&#10;        boolean resultArray = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultArray = findInArray(componentIds, lookupId) &gt;= 0;&#10;        }&#10;        long time2 = System.nanoTime() - start2;&#10;&#10;        // Benchmark 3: Check if mask contains all from another mask&#10;        ComponentMask queryMask = new ComponentMask().set(0).set(lookupId);&#10;        long start3 = System.nanoTime();&#10;        boolean resultContains = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultContains = mask.contains(queryMask);&#10;        }&#10;        long time3 = System.nanoTime() - start3;&#10;&#10;        // Benchmark 4: Check if array contains multiple IDs&#10;        int[] queryIds = {0, lookupId};&#10;        long start4 = System.nanoTime();&#10;        boolean resultArrayMulti = false;&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            resultArrayMulti = arrayContainsAll(componentIds, queryIds);&#10;        }&#10;        long time4 = System.nanoTime() - start4;&#10;&#10;        System.out.printf(&quot;  Single lookup:\n&quot;);&#10;        System.out.printf(&quot;    BitSet.has():        %6.2f ns/op  (result=%b)\n&quot;,&#10;            time1 / (double) iterations, resultMask);&#10;        System.out.printf(&quot;    Array search:        %6.2f ns/op  (result=%b)\n&quot;,&#10;            time2 / (double) iterations, resultArray);&#10;        System.out.printf(&quot;    Speedup: %.2fx %s\n&quot;,&#10;            Math.max(time1, time2) / (double) Math.min(time1, time2),&#10;            time1 &lt; time2 ? &quot;(BitSet wins)&quot; : &quot;(Array wins)&quot;);&#10;&#10;        System.out.printf(&quot;\n  Multi-component check:\n&quot;);&#10;        System.out.printf(&quot;    Mask.containsAll():  %6.2f ns/op  (result=%b)\n&quot;,&#10;            time3 / (double) iterations, resultContains);&#10;        System.out.printf(&quot;    Array containsAll(): %6.2f ns/op  (result=%b)\n&quot;,&#10;            time4 / (double) iterations, resultArrayMulti);&#10;        System.out.printf(&quot;    Speedup: %.2fx %s\n&quot;,&#10;            Math.max(time3, time4) / (double) Math.min(time3, time4),&#10;            time3 &lt; time4 ? &quot;(Mask wins)&quot; : &quot;(Array wins)&quot;);&#10;&#10;        // Memory comparison&#10;        long maskMemory = estimateMaskMemory(mask);&#10;        long arrayMemory = 16 + componentIds.length * 4; // Array object header + int elements&#10;        System.out.printf(&quot;\n  Memory usage:\n&quot;);&#10;        System.out.printf(&quot;    BitSet (mask):       ~%d bytes\n&quot;, maskMemory);&#10;        System.out.printf(&quot;    int[] array:         ~%d bytes\n&quot;, arrayMemory);&#10;        System.out.printf(&quot;    Difference:          %+d bytes (%.1fx)\n&quot;,&#10;            maskMemory - arrayMemory,&#10;            maskMemory / (double) arrayMemory);&#10;    }&#10;&#10;    private static int findInArray(int[] array, int value) {&#10;        for (int i = 0; i &lt; array.length; i++) {&#10;            if (array[i] == value) {&#10;                return i;&#10;            }&#10;        }&#10;        return -1;&#10;    }&#10;&#10;    private static boolean arrayContainsAll(int[] haystack, int[] needles) {&#10;        for (int needle : needles) {&#10;            boolean found = false;&#10;            for (int hay : haystack) {&#10;                if (hay == needle) {&#10;                    found = true;&#10;                    break;&#10;                }&#10;            }&#10;            if (!found) return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    private static long estimateMaskMemory(ComponentMask mask) {&#10;        // BitSet internal: long[] words + object overhead&#10;        // Rough estimate: 24 bytes (object) + 16 bytes (array) + words * 8&#10;        // For small IDs, typically 1-2 long words&#10;        return 24 + 16 + 2 * 8; // ~56 bytes minimum&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>