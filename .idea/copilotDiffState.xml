<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="import com.vanniktech.maven.publish.MavenPublishBaseExtension&#10;&#10;plugins {&#10;    base&#10;    id(&quot;com.vanniktech.maven.publish&quot;) version &quot;0.34.0&quot; apply false&#10;}&#10;&#10;// Cấu hình chung cho TẤT CẢ các module con (core, processor, test, benchmark)&#10;subprojects {&#10;    // 1. Định danh chung&#10;    group = &quot;io.github.vuxz123&quot;&#10;    version = &quot;0.1.0&quot;&#10;&#10;    // 2. Kho thư viện chung (đỡ phải khai báo 4 lần)&#10;    repositories {&#10;        mavenCentral()&#10;    }&#10;&#10;    // 3. Cấu hình Java chung (Chỉ áp dụng nếu module đó là Java project)&#10;    plugins.withType&lt;JavaPlugin&gt; {&#10;        extensions.configure&lt;JavaPluginExtension&gt; {&#10;            toolchain {&#10;                languageVersion.set(JavaLanguageVersion.of(25))&#10;            }&#10;        }&#10;&#10;        // 4. Tự động bật Preview &amp; Panama cho tất cả module&#10;        // Cậu sẽ KHÔNG cần khai báo lại cái này ở module con nữa!&#10;        tasks.withType&lt;JavaCompile&gt; {&#10;            options.encoding = &quot;UTF-8&quot;&#10;            options.compilerArgs.addAll(listOf(&#10;                &quot;--enable-preview&quot;,&#10;                &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;            ))&#10;        }&#10;&#10;        // Cấu hình Test chung&#10;        tasks.withType&lt;Test&gt; {&#10;            useJUnitPlatform()&#10;            jvmArgs(&#10;                &quot;--enable-preview&quot;,&#10;                &quot;--enable-native-access=ALL-UNNAMED&quot;,&#10;                &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;// Lọc ra các module cần publish và duyệt qua từng cái&#10;subprojects {&#10;    // Chỉ áp dụng cho 2 module này&#10;    if (name == &quot;ecs-core&quot; || name == &quot;ecs-processor&quot;) {&#10;&#10;        // Ép Gradle luôn tìm file secring.gpg ở thư mục gốc project (Root Project)&#10;        // thay vì tìm trong thư mục con.&#10;        extra[&quot;signing.secretKeyRingFile&quot;] = rootProject.file(&quot;secring.gpg&quot;).absolutePath.replace(&quot;\\&quot;, &quot;/&quot;)&#10;&#10;        // Apply plugin&#10;        apply(plugin = &quot;com.vanniktech.maven.publish&quot;)&#10;&#10;        // Cấu hình Extension (Dùng extensions.configure thay vì configure&lt;T&gt;)&#10;        extensions.configure&lt;MavenPublishBaseExtension&gt; {&#10;            publishToMavenCentral()&#10;            signAllPublications()&#10;&#10;            coordinates(&#10;                groupId = &quot;io.github.vuxz123&quot;,&#10;                artifactId = project.name,&#10;                version = &quot;0.1.0&quot;&#10;            )&#10;&#10;            pom {&#10;                name.set(&quot;My ECS Engine&quot;)&#10;                description.set(&quot;A high-performance Entity Component System for Java using Project Panama.&quot;)&#10;                inceptionYear.set(&quot;2025&quot;)&#10;                url.set(&quot;https://github.com/vuxz123/ecs&quot;)&#10;&#10;                licenses {&#10;                    license {&#10;                        name.set(&quot;The Apache License, Version 2.0&quot;)&#10;                        url.set(&quot;http://www.apache.org/licenses/LICENSE-2.0.txt&quot;)&#10;                        distribution.set(&quot;repo&quot;)&#10;                    }&#10;                }&#10;&#10;                developers {&#10;                    developer {&#10;                        id.set(&quot;vuxz123&quot;)&#10;                        name.set(&quot;EthnicTHV&quot;)&#10;                        url.set(&quot;https://github.com/vuxz123&quot;)&#10;                    }&#10;                }&#10;&#10;                scm {&#10;                    url.set(&quot;https://github.com/vuxz123/ecs&quot;)&#10;                    connection.set(&quot;scm:git:git://github.com/vuxz123/ecs.git&quot;)&#10;                    developerConnection.set(&quot;scm:git:ssh://git@github.com/vuxz123/ecs.git&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="import com.vanniktech.maven.publish.MavenPublishBaseExtension&#10;&#10;plugins {&#10;    base&#10;    id(&quot;com.vanniktech.maven.publish&quot;) version &quot;0.34.0&quot; apply false&#10;}&#10;&#10;// Cấu hình chung cho TẤT CẢ các module con (core, processor, test, benchmark)&#10;subprojects {&#10;    // 1. Định danh chung&#10;    group = &quot;io.github.vuxz123&quot;&#10;    version = &quot;0.1.0&quot;&#10;&#10;    // 2. Kho thư viện chung (đỡ phải khai báo 4 lần)&#10;    repositories {&#10;        mavenCentral()&#10;    }&#10;&#10;    // 3. Cấu hình Java chung (Chỉ áp dụng nếu module đó là Java project)&#10;    plugins.withType&lt;JavaPlugin&gt; {&#10;        extensions.configure&lt;JavaPluginExtension&gt; {&#10;            toolchain {&#10;                languageVersion.set(JavaLanguageVersion.of(25))&#10;            }&#10;        }&#10;&#10;        // 4. Tự động bật Preview &amp; Panama cho tất cả module&#10;        // Cậu sẽ KHÔNG cần khai báo lại cái này ở module con nữa!&#10;        tasks.withType&lt;JavaCompile&gt; {&#10;            options.encoding = &quot;UTF-8&quot;&#10;            options.compilerArgs.addAll(listOf(&#10;                &quot;--enable-preview&quot;,&#10;                &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;            ))&#10;        }&#10;&#10;        // Cấu hình Test chung&#10;        tasks.withType&lt;Test&gt; {&#10;            useJUnitPlatform()&#10;            jvmArgs(&#10;                &quot;--enable-preview&quot;,&#10;                &quot;--enable-native-access=ALL-UNNAMED&quot;,&#10;                &quot;--add-modules&quot;, &quot;jdk.incubator.vector&quot;&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;// Lọc ra các module cần publish và duyệt qua từng cái&#10;subprojects {&#10;    // Chỉ áp dụng cho 2 module này&#10;    if (name == &quot;ecs-core&quot; || name == &quot;ecs-processor&quot;) {&#10;&#10;        // Ép Gradle luôn tìm file secring.gpg ở thư mục gốc project (Root Project)&#10;        // thay vì tìm trong thư mục con.&#10;        extra[&quot;signing.secretKeyRingFile&quot;] = rootProject.file(&quot;secring.gpg&quot;).absolutePath.replace(&quot;\\&quot;, &quot;/&quot;)&#10;&#10;        // Apply plugin&#10;        apply(plugin = &quot;com.vanniktech.maven.publish&quot;)&#10;&#10;        // Cấu hình Extension (Dùng extensions.configure thay vì configure&lt;T&gt;)&#10;        extensions.configure&lt;MavenPublishBaseExtension&gt; {&#10;            publishToMavenCentral()&#10;            signAllPublications()&#10;&#10;            coordinates(&#10;                groupId = &quot;io.github.vuxz123&quot;,&#10;                artifactId = project.name,&#10;                version = &quot;0.1.0&quot;&#10;            )&#10;&#10;            pom {&#10;                name.set(&quot;My ECS Engine&quot;)&#10;                description.set(&quot;A high-performance Entity Component System for Java using Project Panama.&quot;)&#10;                inceptionYear.set(&quot;2025&quot;)&#10;                url.set(&quot;https://github.com/vuxz123/ecs&quot;)&#10;&#10;                licenses {&#10;                    license {&#10;                        name.set(&quot;The Apache License, Version 2.0&quot;)&#10;                        url.set(&quot;http://www.apache.org/licenses/LICENSE-2.0.txt&quot;)&#10;                        distribution.set(&quot;repo&quot;)&#10;                    }&#10;                }&#10;&#10;                developers {&#10;                    developer {&#10;                        id.set(&quot;vuxz123&quot;)&#10;                        name.set(&quot;EthnicTHV&quot;)&#10;                        url.set(&quot;https://github.com/vuxz123&quot;)&#10;                    }&#10;                }&#10;&#10;                scm {&#10;                    url.set(&quot;https://github.com/vuxz123/ecs&quot;)&#10;                    connection.set(&quot;scm:git:git://github.com/vuxz123/ecs.git&quot;)&#10;                    developerConnection.set(&quot;scm:git:ssh://git@github.com/vuxz123/ecs.git&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/ADVANCED_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/ADVANCED_GUIDE.md" />
              <option name="originalContent" value="# ECS Advanced Guide&#10;&#10;Deep dives into parallel queries, performance tuning, QA/QC workflows, plus appendices that preserve the full historical docs for future reference. For a dedicated explanation of the component metadata and layout system, see `docs/COMPONENT_SYSTEM.md`. For detailed benchmark scenarios, commands, and how to read the stored results, see `docs/BENCHMARKS.md`.&#10;&#10;## 1. Parallel Systems &amp; Queries&#10;This section summarizes the current query and parallel execution model and how systems should use it. Historical designs (such as older `@Query` forms and proxy-based overrides) are kept in the appendices.&#10;&#10;The normal way to express &quot;which entities this system cares about&quot; is via `@Query`-annotated private methods with a `fieldInject` target. The annotation processor generates a query injector that, at system registration time, constructs and caches an `IGeneratedQuery` (often backed by an `ArchetypeQuery` under the hood) and assigns it to that field. Systems then call `generatedQuery.runQuery()` from `onUpdate`. Some generated queries also implement `IQueryBuilder` to allow lightweight per-frame filter configuration (for example, selecting a team via a shared component) while still reusing the same underlying cached builder instance.&#10;&#10;Directly using `ArchetypeQuery` and `world.query()` is supported but considered a low-level, advanced API for specialized use cases. The demo systems in `ecs-test` (`MovementSystem`, `HealthRegenerationSystem`, `MixedUnmanagedAndManagedSystem`, `TeamFilterSystem`) all use the generated-query path.&#10;&#10;### 1.1 Execution Model&#10;- Systems are grouped into `SystemGroup`s (INPUT, SIMULATION, PHYSICS, RENDER, CLEANUP, and any custom groups).&#10;- `SystemManager` runs groups in priority order (lower `priority` first), and within each group calls `onUpdate(deltaTime)` on enabled systems.&#10;- Within `onUpdate`, systems typically invoke one or more `IGeneratedQuery.runQuery()` calls; the generated code drives the underlying archetype iteration.&#10;- Parallelism is applied **inside** those queries via the configured `ExecutionMode` on the `@Query` annotation (for generated queries) or via low-level `ArchetypeQuery.forEachParallel(...)` if you are using the manual API.&#10;- Systems typically hold one or more pre-built queries (via `@Query` injection or manually cached `ArchetypeQuery` instances) and reuse them on every `onUpdate` call. Query construction is relatively heavy and should not be performed repeatedly inside the hot per-frame loop.&#10;- The `GameLoop` coordinates fixed-step updates for FIXED groups and variable updates for VARIABLE groups, but does not change query semantics.&#10;&#10;### 1.2 Query API Tips&#10;- Prefer `@Query`-based systems with AP-generated `IGeneratedQuery` fields as your primary way to express queries. Use `fieldInject` and `ExecutionMode` to describe which entities and how they should be processed.&#10;- When a generated query also behaves as an `IQueryBuilder`, use it to apply lightweight per-frame filters (e.g. `withShared(TeamShared)` in `TeamFilterSystem`) while still reusing the same builder instance that was created at registration time.&#10;- Use `ArchetypeQuery` and the `world.query()` builder directly only when you need fine-grained control (for example, experimental filters, tooling, or code that lives outside normal systems). Treat this as an advanced, low-level API.&#10;- Use chunked processing (built into the underlying `ArchetypeQuery`) to maintain cache locality; the engine already iterates per chunk and reuses `ComponentHandle` instances.&#10;- Use parallel execution only when:&#10;  - You have large entity counts (≈ 1,000+), and&#10;  - Per-entity work is CPU-bound, and&#10;  - Your query callbacks / system logic are fully thread-safe.&#10;&#10;### 1.3 Parallel Query Example&#10;&#10;The low-level primitive remains `ArchetypeQuery.forEachParallel(IQuery.EntityConsumer)`, but in most user code you will simply mark a generated query with `ExecutionMode.PARALLEL` and let the generated runner dispatch work in parallel.&#10;&#10;```java&#10;// Build a query (the actual helper may be generated)&#10;var query = world.query()&#10;        .with(Position.class)&#10;        .with(Velocity.class)&#10;        .build();&#10;&#10;// Thread-safe accumulator&#10;AtomicInteger processed = new AtomicInteger(0);&#10;&#10;// Parallel processing across chunks&#10;query.forEachParallel((entityId, handles, archetype) -&gt; {&#10;    // This callback may run on worker threads – it MUST be thread-safe.&#10;    processed.incrementAndGet();&#10;&#10;    // Example: use handles[0], handles[1], ... to access component data&#10;    // according to your descriptors or generated handle mapping.&#10;});&#10;```&#10;&#10;Internally, `forEachParallel`:&#10;- Filters archetypes using the configured `with` / `without` / `any` masks.&#10;- For each matching archetype, obtains a `getChunksSnapshot()` and uses `Arrays.stream(...).parallel()` so each chunk is processed by one worker.&#10;- Within a chunk, iterates entity slots sequentially, reusing `ComponentHandle` instances to avoid allocations.&#10;&#10;### 1.4 Thread-Safety Rules&#10;When using `forEachParallel`:&#10;- Treat the `EntityConsumer` body as multi-threaded code:&#10;  - Use `AtomicInteger`, `AtomicLong`, or `LongAdder` for counters.&#10;  - Use `ConcurrentHashMap` / `ConcurrentLinkedQueue` for shared collections.&#10;  - Prefer per-thread batching (e.g. thread-local lists) over coarse-grained `synchronized` blocks.&#10;- Do **not** rely on processing order; entities may be visited in any order.&#10;- Avoid blocking I/O or long critical sections in the consumer, as they can negate parallel speedups.&#10;&#10;Historical examples of the parallel API (including chunk-level diagrams and troubleshooting) are preserved in `PARALLEL_QUERY_GUIDE.md` and `README_PARALLEL_SYSTEM.md`.&#10;&#10;### 1.5 Query Best Practices&#10;&#10;This section summarizes practical rules for using the query APIs efficiently and safely.&#10;&#10;**Choose the right API**&#10;- Use `@Query`-based systems with `IGeneratedQuery` fields as the default. They are easier to read, safer to evolve, and let the annotation processor optimize query construction and caching.&#10;- Reach for `ArchetypeQuery` and `world.query()` only when you need advanced control (for example, custom filters, experimental iteration patterns, or integration code that lives outside a normal `ISystem`).&#10;&#10;**Cache and reuse queries**&#10;- Building a query (either via generated code from `@Query` or via the `ArchetypeQuery` builder) computes matching archetype sets and supporting data structures; this is relatively heavy.&#10;- Generated injectors construct and cache `IGeneratedQuery` / `IQueryBuilder` instances once per system at registration time; do not rebuild them inside `onUpdate`.&#10;- When using a builder-style query (like in `TeamFilterSystem`), treat per-frame operations (e.g. `withShared(...).build().runQuery()`) as light filter configuration on a cached builder, not as reconstructing the entire query.&#10;&#10;**Keep queries stable; move conditions into components**&#10;- Prefer stable query shapes (required/optional/excluded component sets) that rarely change at runtime.&#10;- Represent dynamic conditions with component values, tags, or flags instead of reconfiguring queries repeatedly.&#10;- If you must change the component mask, do it infrequently (for example, when entering or leaving a major game state) and reuse the updated query afterward.&#10;&#10;**Design for hot loops**&#10;- Assume the per-entity callback is in a hot loop: keep it small, avoid allocations, and avoid heavy logging.&#10;- When using parallel execution (either via `ExecutionMode.PARALLEL` or direct `forEachParallel`), treat the callback as multi-threaded code and follow the thread-safety rules from Section 1.4.&#10;- When in doubt, start with sequential queries using cached generated queries, then upgrade to parallel execution if profiling shows a consistent bottleneck and enough work per entity.&#10;&#10;## 2. Performance &amp; Memory Tuning&#10;Insights summarized from `IMPROVEMENTS.md` and `COMPONENT_SYSTEM.md`.&#10;&#10;- True SoA layout per component dimension → cache-friendly access &amp; SIMD-friendly loops.&#10;- `ComponentManager` centralizes registration; deactivate auto-registration when orchestrating load order.&#10;- Utilize bulk operations (`count()`, `forEachChunk(...)`) for query preflight checks.&#10;- Keep per-system scratch buffers off-heap to avoid GC interference, especially in hot loops.&#10;&#10;**Structural changes and batching.** Creating/destroying entities or adding/removing components reconfigures archetypes and can be significantly more expensive than plain component reads/writes. In particular, doing these changes directly inside hot query callbacks (especially with `ExecutionMode.PARALLEL`) can:&#10;- Disturb chunk iteration while it is in progress.&#10;- Introduce contention on internal structures.&#10;- Make reasoning about correctness and performance harder.&#10;&#10;Recommendation:&#10;- Use an `EntityCommandBuffer` (or equivalent command queue) to record structural changes while queries are running.&#10;- Apply the buffered commands at a well-defined sync point (e.g., immediately after `runQuery()` or at the end of the frame) on a single thread.&#10;- Combine this with query caching: build queries once, read via cached queries every frame, and route structural writes through command buffers rather than direct `world.add/remove/destroy` calls from inside query callbacks.&#10;&#10;**Benchmarks.** The `ecs-benchmark` module and the result files under `results/` (for example `results-11-52-14-11-2025.txt`) provide empirical measurements of this library’s behavior under load: entity creation and destruction, component registration and migration, sequential and parallel query iteration, structural changes (per-entity vs batched), and `EntityCommandBuffer` usage. These numbers are intended to characterize how this implementation behaves in different scenarios and to guide tuning of systems and data layouts. They are not presented as a comparison against any other engine or framework. For a more detailed walkthrough and run instructions, see `docs/BENCHMARKS.md`.&#10;&#10;## 3. QA / QC Process&#10;Key practices distilled from `QA_QC_CHECKLIST.md`, `QA_QC_TEST_CASES.md`, and `QA_QC_TEST_SUITE.md`.&#10;&#10;- **Checklist:** verify annotation processing, component registration, system scheduling order, and foreign-memory flags before any release.&#10;- **Test cases:** cover entity creation/destruction, component add/remove churn, parallel queries under load, and `GameLoop` pause/resume sequences.&#10;- **Test suite:** `ecs-test` is structured to mirror real-world scenarios; extend it rather than crafting ad hoc demos.&#10;&#10;Refer to Appendix C/D/E for the full checklists and suite definitions.&#10;&#10;## 4. Publishing &amp; Release Workflow&#10;- Root `build.gradle.kts` applies Vanniktech Maven Publish with `SonatypeHost.CENTRAL_PORTAL`.&#10;- `secring.gpg` path is normalized (e.g. `rootProject.file(&quot;secring.gpg&quot;).absolutePath.replace(&quot;\\&quot;, &quot;/&quot;)`) to avoid Windows URI issues.&#10;- Tag releases per milestone completion (see `docs/ROADMAP.md`), then run:&#10;  - `gradlew publishAllPublicationsToMavenCentralRepository` to send artifacts to Maven Central.&#10;  - `gradlew publishToMavenLocal` when you need local testing.&#10;&#10;## 5. Appendices (Full Legacy Docs)&#10;- **Appendix A:** `README_PARALLEL_SYSTEM.md`&#10;- **Appendix B:** `PARALLEL_QUERY_GUIDE.md`&#10;- **Appendix C:** `QA_QC_CHECKLIST.md`&#10;- **Appendix D:** `QA_QC_TEST_CASES.md`&#10;- **Appendix E:** `QA_QC_TEST_SUITE.md`&#10;- **Appendix F:** `COMPONENT_SYSTEM.md`&#10;- **Appendix G:** `IMPROVEMENTS.md`&#10;&#10;&gt; Keep these files in repo for historical fidelity; future updates should edit the source docs then summarize changes here.&#10;" />
              <option name="updatedContent" value="# ECS Advanced Guide&#10;&#10;Deep dives into parallel queries, performance tuning, QA/QC workflows, plus appendices that preserve the full historical docs for future reference. For a dedicated explanation of the component metadata and layout system, see `docs/COMPONENT_SYSTEM.md`. For detailed benchmark scenarios, commands, and how to read the stored results, see `docs/BENCHMARKS.md`.&#10;&#10;## 1. Parallel Systems &amp; Queries&#10;This section summarizes the current query and parallel execution model and how systems should use it. Historical designs (such as older `@Query` forms and proxy-based overrides) are kept in the appendices.&#10;&#10;The normal way to express &quot;which entities this system cares about&quot; is via `@Query`-annotated private methods with a `fieldInject` target. The annotation processor generates a query injector that, at system registration time, constructs and caches an `IGeneratedQuery` (often backed by an `ArchetypeQuery` under the hood) and assigns it to that field. Systems then call `generatedQuery.runQuery()` from `onUpdate`. Some generated queries also implement `IQueryBuilder` to allow lightweight per-frame filter configuration (for example, selecting a team via a shared component) while still reusing the same underlying cached builder instance.&#10;&#10;Directly using `ArchetypeQuery` and `world.query()` is supported but considered a low-level, advanced API for specialized use cases. The demo systems in `ecs-test` (`MovementSystem`, `HealthRegenerationSystem`, `MixedUnmanagedAndManagedSystem`, `TeamFilterSystem`) all use the generated-query path.&#10;&#10;### 1.1 Execution Model&#10;- Systems are grouped into `SystemGroup`s (INPUT, SIMULATION, PHYSICS, RENDER, CLEANUP, and any custom groups).&#10;- `SystemManager` runs groups in priority order (lower `priority` first), and within each group calls `onUpdate(deltaTime)` on enabled systems.&#10;- Within `onUpdate`, systems typically invoke one or more `IGeneratedQuery.runQuery()` calls; the generated code drives the underlying archetype iteration.&#10;- Parallelism is applied **inside** those queries via the configured `ExecutionMode` on the `@Query` annotation (for generated queries) or via low-level `ArchetypeQuery.forEachParallel(...)` if you are using the manual API.&#10;- Systems typically hold one or more pre-built queries (via `@Query` injection or manually cached `ArchetypeQuery` instances) and reuse them on every `onUpdate` call. Query construction is relatively heavy and should not be performed repeatedly inside the hot per-frame loop.&#10;- The `GameLoop` coordinates fixed-step updates for FIXED groups and variable updates for VARIABLE groups, but does not change query semantics.&#10;&#10;### 1.2 Query API Tips&#10;- Prefer `@Query`-based systems with AP-generated `IGeneratedQuery` fields as your primary way to express queries. Use `fieldInject` and `ExecutionMode` to describe which entities and how they should be processed.&#10;- When a generated query also behaves as an `IQueryBuilder`, use it to apply lightweight per-frame filters (e.g. `withShared(TeamShared)` in `TeamFilterSystem`) while still reusing the same builder instance that was created at registration time.&#10;- Use `ArchetypeQuery` and the `world.query()` builder directly only when you need fine-grained control (for example, experimental filters, tooling, or code that lives outside normal systems). Treat this as an advanced, low-level API.&#10;- Use chunked processing (built into the underlying `ArchetypeQuery`) to maintain cache locality; the engine already iterates per chunk and reuses `ComponentHandle` instances.&#10;- Use parallel execution only when:&#10;  - You have large entity counts (≈ 1,000+), and&#10;  - Per-entity work is CPU-bound, and&#10;  - Your query callbacks / system logic are fully thread-safe.&#10;&#10;### 1.3 Parallel Query Example&#10;&#10;The low-level primitive remains `ArchetypeQuery.forEachParallel(IQuery.EntityConsumer)`, but in most user code you will simply mark a generated query with `ExecutionMode.PARALLEL` and let the generated runner dispatch work in parallel.&#10;&#10;```java&#10;// Build a query (the actual helper may be generated)&#10;var query = world.query()&#10;        .with(Position.class)&#10;        .with(Velocity.class)&#10;        .build();&#10;&#10;// Thread-safe accumulator&#10;AtomicInteger processed = new AtomicInteger(0);&#10;&#10;// Parallel processing across chunks&#10;query.forEachParallel((entityId, handles, archetype) -&gt; {&#10;    // This callback may run on worker threads – it MUST be thread-safe.&#10;    processed.incrementAndGet();&#10;&#10;    // Example: use handles[0], handles[1], ... to access component data&#10;    // according to your descriptors or generated handle mapping.&#10;});&#10;```&#10;&#10;Internally, `forEachParallel`:&#10;- Filters archetypes using the configured `with` / `without` / `any` masks.&#10;- For each matching archetype, obtains a `getChunksSnapshot()` and uses `Arrays.stream(...).parallel()` so each chunk is processed by one worker.&#10;- Within a chunk, iterates entity slots sequentially, reusing `ComponentHandle` instances to avoid allocations.&#10;&#10;### 1.4 Thread-Safety Rules&#10;When using `forEachParallel`:&#10;- Treat the `EntityConsumer` body as multi-threaded code:&#10;  - Use `AtomicInteger`, `AtomicLong`, or `LongAdder` for counters.&#10;  - Use `ConcurrentHashMap` / `ConcurrentLinkedQueue` for shared collections.&#10;  - Prefer per-thread batching (e.g. thread-local lists) over coarse-grained `synchronized` blocks.&#10;- Do **not** rely on processing order; entities may be visited in any order.&#10;- Avoid blocking I/O or long critical sections in the consumer, as they can negate parallel speedups.&#10;&#10;Historical examples of the parallel API (including chunk-level diagrams and troubleshooting) are preserved in `PARALLEL_QUERY_GUIDE.md` and `README_PARALLEL_SYSTEM.md`.&#10;&#10;### 1.5 Query Best Practices&#10;&#10;This section summarizes practical rules for using the query APIs efficiently and safely.&#10;&#10;**Choose the right API**&#10;- Use `@Query`-based systems with `IGeneratedQuery` fields as the default. They are easier to read, safer to evolve, and let the annotation processor optimize query construction and caching.&#10;- Reach for `ArchetypeQuery` and `world.query()` only when you need advanced control (for example, custom filters, experimental iteration patterns, or integration code that lives outside a normal `ISystem`).&#10;&#10;**Cache and reuse queries**&#10;- Building a query (either via generated code from `@Query` or via the `ArchetypeQuery` builder) computes matching archetype sets and supporting data structures; this is relatively heavy.&#10;- Generated injectors construct and cache `IGeneratedQuery` / `IQueryBuilder` instances once per system at registration time; do not rebuild them inside `onUpdate`.&#10;- When using a builder-style query (like in `TeamFilterSystem`), treat per-frame operations (e.g. `withShared(...).build().runQuery()`) as light filter configuration on a cached builder, not as reconstructing the entire query.&#10;&#10;**Keep queries stable; move conditions into components**&#10;- Prefer stable query shapes (required/optional/excluded component sets) that rarely change at runtime.&#10;- Represent dynamic conditions with component values, tags, or flags instead of reconfiguring queries repeatedly.&#10;- If you must change the component mask, do it infrequently (for example, when entering or leaving a major game state) and reuse the updated query afterward.&#10;&#10;**Design for hot loops**&#10;- Assume the per-entity callback is in a hot loop: keep it small, avoid allocations, and avoid heavy logging.&#10;- When using parallel execution (either via `ExecutionMode.PARALLEL` or direct `forEachParallel`), treat the callback as multi-threaded code and follow the thread-safety rules from Section 1.4.&#10;- When in doubt, start with sequential queries using cached generated queries, then upgrade to parallel execution if profiling shows a consistent bottleneck and enough work per entity.&#10;&#10;## 2. Performance &amp; Memory Tuning&#10;Insights summarized from `IMPROVEMENTS.md` and `COMPONENT_SYSTEM.md`.&#10;&#10;- True SoA layout per component dimension → cache-friendly access &amp; SIMD-friendly loops.&#10;- `ComponentManager` centralizes registration; deactivate auto-registration when orchestrating load order.&#10;- Utilize bulk operations (`count()`, `forEachChunk(...)`) for query preflight checks.&#10;- Keep per-system scratch buffers off-heap to avoid GC interference, especially in hot loops.&#10;&#10;**Structural changes and batching.** Creating/destroying entities or adding/removing components reconfigures archetypes and can be significantly more expensive than plain component reads/writes. In particular, doing these changes directly inside hot query callbacks (especially with `ExecutionMode.PARALLEL`) can:&#10;- Disturb chunk iteration while it is in progress.&#10;- Introduce contention on internal structures.&#10;- Make reasoning about correctness and performance harder.&#10;&#10;Recommendation:&#10;- Use an `EntityCommandBuffer` (or equivalent command queue) to record structural changes while queries are running.&#10;- Apply the buffered commands at a well-defined sync point (e.g., immediately after `runQuery()` or at the end of the frame) on a single thread.&#10;- Combine this with query caching: build queries once, read via cached queries every frame, and route structural writes through command buffers rather than direct `world.add/remove/destroy` calls from inside query callbacks.&#10;&#10;**Benchmarks.** The `ecs-benchmark` module and the result files under `results/` (for example `results-11-52-14-11-2025.txt`) provide empirical measurements of this library’s behavior under load: entity creation and destruction, component registration and migration, sequential and parallel query iteration, structural changes (per-entity vs batched), and `EntityCommandBuffer` usage. These numbers are intended to characterize how this implementation behaves in different scenarios and to guide tuning of systems and data layouts. They are not presented as a comparison against any other engine or framework. For a more detailed walkthrough and run instructions, see `docs/BENCHMARKS.md`.&#10;&#10;## 3. QA / QC Process&#10;Key practices distilled from `QA_QC_CHECKLIST.md`, `QA_QC_TEST_CASES.md`, and `QA_QC_TEST_SUITE.md`.&#10;&#10;- **Checklist:** verify annotation processing, component registration, system scheduling order, and foreign-memory flags before any release.&#10;- **Test cases:** cover entity creation/destruction, component add/remove churn, parallel queries under load, and `GameLoop` pause/resume sequences.&#10;- **Test suite:** `ecs-test` is structured to mirror real-world scenarios; extend it rather than crafting ad hoc demos.&#10;&#10;Refer to Appendix C/D/E for the full checklists and suite definitions.&#10;&#10;## 4. Publishing &amp; Release Workflow&#10;- Root `build.gradle.kts` applies Vanniktech Maven Publish with `SonatypeHost.CENTRAL_PORTAL`.&#10;- `secring.gpg` path is normalized (e.g. `rootProject.file(&quot;secring.gpg&quot;).absolutePath.replace(&quot;\\&quot;, &quot;/&quot;)`) to avoid Windows URI issues.&#10;- Tag releases per milestone completion (see `docs/ROADMAP.md`), then run:&#10;  - `gradlew publishAllPublicationsToMavenCentralRepository` to send artifacts to Maven Central.&#10;  - `gradlew publishToMavenLocal` when you need local testing.&#10;&#10;## 5. Appendices (Full Legacy Docs)&#10;- **Appendix A:** `README_PARALLEL_SYSTEM.md`&#10;- **Appendix B:** `PARALLEL_QUERY_GUIDE.md`&#10;- **Appendix C:** `QA_QC_CHECKLIST.md`&#10;- **Appendix D:** `QA_QC_TEST_CASES.md`&#10;- **Appendix E:** `QA_QC_TEST_SUITE.md`&#10;- **Appendix F:** `COMPONENT_SYSTEM.md`&#10;- **Appendix G:** `IMPROVEMENTS.md`&#10;&#10;&gt; Keep these files in repo for historical fidelity; future updates should edit the source docs then summarize changes here." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/ARCHITECTURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/ARCHITECTURE.md" />
              <option name="originalContent" value="# ECS Architecture&#10;&#10;Textual overview of how the modules, data layout, and execution pipeline fit together, with supporting details sourced from `IMPROVEMENTS.md`, `COMPONENT_SYSTEM.md`, `README_PARALLEL_SYSTEM.md`, `PARALLEL_QUERY_GUIDE.md`, and the QA docs. Release-by-release evolution lives in `docs/ROADMAP.md`; deep appendices stay in `docs/ADVANCED_GUIDE.md`. For a focused description of the annotation- and Panama-based component model, see `docs/COMPONENT_SYSTEM.md`. For the system lifecycle and scheduling model, see `docs/SYSTEMS.md`.&#10;&#10;## 1. System Overview&#10;- **ecs-core** – Hosts `ECS` facade, `ComponentManager`, `ArchetypeWorld`, `SystemManager`, and `GameLoop`.&#10;- **ecs-processor** – Annotation processor that scans component classes and emits descriptors, handles, and `GeneratedComponents.registerAll(...)` glue.&#10;- **ecs-test** – Regression and QA suites mirroring real gameplay scenarios.&#10;- **ecs-benchmark** – JMH suite targeting SoA layout, SIMD loops, and parallel query throughput (see `PHASE2_COMPLETION.md`).&#10;- **Root Gradle build** – Applies shared toolchain flags (preview/VECTOR/Panama), configures Maven publish via Vanniktech + `SonatypeHost.CENTRAL_PORTAL`, and normalizes signing files for Windows per the QA checklist.&#10;&#10;## 2. Module Interaction&#10;```&#10;Application code → ECS facade → ArchetypeWorld ↔ ComponentManager&#10;                                 ↓&#10;                          SystemManager&#10;                                 ↓&#10;                            GameLoop&#10;```&#10;Build phase:&#10;- `ecs-processor` inspects component classes → generates handles/descriptors → writes `GeneratedComponents` registrar.&#10;Runtime phase:&#10;- `ECS` builder auto-invokes the registrar, initializing `ComponentManager` before the world and system pipeline spin up.&#10;&#10;## 3. Data Flow &amp; Memory Layout&#10;The world combines an archetype/chunk layout with three component storage paths: unmanaged (off-heap), managed (on-heap objects via tickets), and shared (per-chunk-group state).&#10;&#10;### 3.1 Component metadata &amp; registration&#10;- All component types are registered with `ComponentManager`, which assigns a stable **component type id** and builds a `ComponentDescriptor`.&#10;- Descriptors carry layout and management flags (e.g. `isManaged()`), coming from annotations described in `COMPONENT_SYSTEM.md`.&#10;- At startup, `ECS.Builder` normally invokes `GeneratedComponents.registerAll(componentManager)` to register all known components; you can override this manually.&#10;&#10;### 3.2 Archetypes, chunk groups, and chunks&#10;- An **Archetype** represents a unique `ComponentMask` – a bitset of component type ids.&#10;- For each archetype, the world maintains one or more **ChunkGroup**s keyed by a `SharedValueKey` (shared-component configuration).&#10;- Each **ArchetypeChunk** in a group holds a fixed-capacity slice of entities that share the same component mask + shared key.&#10;&#10;Conceptually:&#10;```text&#10;Archetype(mask = {Position, Velocity, Health})&#10;  └─ ChunkGroup(sharedKey)&#10;       ├─ Chunk 0&#10;       │    ├─ unmanaged arrays per component type&#10;       │    ├─ managed ticket arrays per managed type&#10;       │    └─ entityIds[]&#10;       └─ Chunk 1&#10;            ...&#10;```&#10;&#10;### 3.3 Unmanaged (off-heap) components&#10;Unmanaged components are value-like and live entirely in foreign memory:&#10;- `ComponentDescriptor.isManaged() == false`.&#10;- For each entity + unmanaged component type, the world allocates a `MemorySegment` using `ComponentManager.allocate(componentClass, arena)`.&#10;- `ArchetypeChunk` stores these segments in per-type/per-entity slots via `setComponentData(location, componentIndex, segment)`.&#10;&#10;Logically, per chunk:&#10;```text&#10;unmanaged[componentTypeIndex][entityIndex] -&gt; MemorySegment&#10;```&#10;The actual field layout inside each segment (SoA/struct-like) is defined by the descriptor and annotation config.&#10;&#10;### 3.4 Managed (on-heap) components&#10;Managed components are full Java objects stored indirectly:&#10;- Marked `@Component.Managed` and reported as `isManaged() == true` in `ComponentDescriptor`.&#10;- Instances live in a global `ManagedComponentStore`.&#10;- When you call `addComponent(entityId, myManagedComponent)`, the store returns an integer **ticket**:&#10;  1. The entity is moved to a new archetype/ChunkGroup whose mask includes that component type id.&#10;  2. The destination chunk writes the ticket into a per-type ticket array using `setManagedTicket(managedTypeIndex, indexInChunk, ticket)`.&#10;&#10;Per chunk, this is conceptually:&#10;```text&#10;managedTickets[managedTypeIndex][entityIndex] -&gt; int ticket&#10;ManagedComponentStore[ticket] -&gt; actual object instance&#10;```&#10;Systems resolve tickets back to objects when they need to operate on managed state.&#10;&#10;### 3.5 Shared components and `SharedComponentStore`&#10;Some state is shared across many entities in the same chunk group:&#10;- A `SharedValueKey` identifies a particular combination of shared component values.&#10;- `SharedComponentStore` holds the actual shared data bundles.&#10;- `ArchetypeWorld` uses the key when creating/finding a `ChunkGroup`, so all entities in that group implicitly share those values.&#10;&#10;At a high level:&#10;```text&#10;SharedComponentStore[sharedKey] -&gt; shared data&#10;Archetype(mask)&#10;  └─ ChunkGroup(sharedKey)  // all chunks here see the same shared data&#10;```&#10;&#10;### 3.6 Entity lifecycle&#10;The entity lifecycle ties these pieces together:&#10;1. **Creation** (`createEntityWithComponents`)&#10;   - Allocate a new entity id.&#10;   - Build a `ComponentMask` from the requested component classes.&#10;   - Ask `ArchetypeManager` for an archetype matching that mask.&#10;   - Get or create a `ChunkGroup` for the default `SharedValueKey` (no explicit shared data yet).&#10;   - Add the entity to a chunk via `ChunkGroup.addEntity`, which returns a `ChunkLocation`.&#10;   - For each **unmanaged** component: allocate a zeroed `MemorySegment` and wire it into the chunk.&#10;   - For **managed** components: tickets default to `-1` until an instance is attached.&#10;&#10;2. **Structural changes** (add/remove component)&#10;   - Compute a new `ComponentMask` that includes/excludes the component's type id.&#10;   - Call `moveEntityToArchetype(...)` to move the entity between archetypes while preserving its `SharedValueKey`.&#10;   - For unmanaged components, copy or assign the relevant `MemorySegment` into the new chunk slot.&#10;   - For managed components, update tickets and, if removing, release the old ticket from `ManagedComponentStore`.&#10;&#10;3. **Shared component changes**&#10;   - Changing shared state effectively means moving the entity to another `ChunkGroup` with a different `SharedValueKey`.&#10;&#10;This design allows:&#10;- Dense per-archetype storage for predictable iteration order.&#10;- Off-heap value storage for tight loops.&#10;- On-heap managed objects when you need rich Java semantics.&#10;- De-duplicated shared state without duplicating memory across thousands of entities.&#10;&#10;## 4. Execution Pipeline &amp; GameLoop&#10;- Systems live inside `SystemGroup`s (INPUT, SIMULATION, RENDER, custom). Groups carry rank/priority to preserve deterministic ordering (`README_PARALLEL_SYSTEM.md`).&#10;- `SystemManager.registerPipelineSystem(system, group)` wires systems into each group; dependency injection populates generated query handles.&#10;- `GameLoop` (default 60 Hz) ticks groups sequentially each frame; `ECS.createGameLoop(targetHz)` lets clients embed loops at custom rates or threads (virtual or platform).&#10;&#10;```&#10;[GameLoop tick]&#10;  → INPUT systems&#10;  → SIMULATION systems (optionally parallel per query)&#10;  → RENDER systems&#10;```&#10;- Parallel execution: queries call `.parallel(...)` (see Section 5) to fan out chunk work items across a ForkJoinPool. Systems must keep per-thread state isolated or rely on concurrent primitives.&#10;&#10;## 5. Parallel Query Model&#10;Derived from `PARALLEL_QUERY_GUIDE.md`.&#10;1. Filter archetypes by required/optional components.&#10;2. Snapshot volatile chunk arrays (`getChunksSnapshot()`).&#10;3. Flatten into `ChunkWorkItem[]` and submit to a ForkJoin worker.&#10;4. Within each chunk, process entities sequentially to maximize cache hits, invoking the thread-safe consumer for each entity.&#10;&#10;Performance defaults:&#10;- Break-even entity count ~1k (below that, stay sequential).&#10;- Fusing Vector API operations (`FloatVector.fma`) yields ~3× speedups on 10k entities (data from `IMPROVEMENTS.md`).&#10;- Consumers must use atomics or thread-local batching to avoid contention (see QA checklist “Parallel Safety”).&#10;&#10;## 6. Component Lifecycle &amp; Codegen&#10;1. **Registration** – Builder auto-runs `GeneratedComponents.registerAll(componentManager)` unless `noAutoRegistration()` is set. Manual overrides call `registerComponent(Class&lt;?&gt;)`.&#10;2. **Entity creation** – `ArchetypeWorld` picks/creates a chunk based on component signature, assigning contiguous slots per component column.&#10;3. **System execution** – Generated handles (e.g., `PositionHandle`) provide zero-copy getters/setters inside query lambdas, avoiding reflection and boxing.&#10;&#10;## 7. QA, Publishing, and Tooling&#10;- QA gates (`QA_QC_CHECKLIST.md`): verify AP output, SoA layout integrity, parallel query determinism, and JVM args (`--enable-preview --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.vector`).&#10;- Test suites (`QA_QC_TEST_CASES.md`, `QA_QC_TEST_SUITE.md`) map to `ecs-test`; run via Gradle so all flags apply consistently.&#10;- Publishing: root `build.gradle.kts` configures Vanniktech with `SonatypeHost.CENTRAL_PORTAL`, normalized `secring.gpg` path, and coordinates `io.github.vuxz123:{ecs-core|ecs-processor}:0.1.+`.&#10;- Benchmarks: `ecs-benchmark` JMH scenarios guard SoA/SIMD regressions; results feed into Phase completion reports.&#10;&#10;## 8. Reference Map&#10;- `docs/ADVANCED_GUIDE.md` – Expanded discussions + appendices (parallel systems, QA artifacts, improvement logs).&#10;- `docs/ROADMAP.md` – Milestone history (Phase 1/2) and rolling backlog for future architectural shifts.&#10;- `PHASE1_COMPLETION.md`, `PHASE2_COMPLETION.md` – Deep historical records referenced by the roadmap.&#10;- Legacy design docs (`IMPROVEMENTS.md`, `COMPONENT_SYSTEM.md`, `README_PARALLEL_SYSTEM.md`, `PARALLEL_QUERY_GUIDE.md`, `QA_QC_*`) remain the canonical sources for the summaries above; edit them first, then refresh this file.&#10;&#10;&gt; Update this document whenever foundational architecture changes. For chronological context or upcoming work, rely on the roadmap; for exhaustive technical detail, use the advanced guide appendices.&#10;" />
              <option name="updatedContent" value="# ECS Architecture&#10;&#10;Textual overview of how the modules, data layout, and execution pipeline fit together, with supporting details sourced from `IMPROVEMENTS.md`, `COMPONENT_SYSTEM.md`, `README_PARALLEL_SYSTEM.md`, `PARALLEL_QUERY_GUIDE.md`, and the QA docs. Release-by-release evolution lives in `docs/ROADMAP.md`; deep appendices stay in `docs/ADVANCED_GUIDE.md`. For a focused description of the annotation- and Panama-based component model, see `docs/COMPONENT_SYSTEM.md`. For the system lifecycle and scheduling model, see `docs/SYSTEMS.md`.&#10;&#10;## 1. System Overview&#10;- **ecs-core** – Hosts `ECS` facade, `ComponentManager`, `ArchetypeWorld`, `SystemManager`, and `GameLoop`.&#10;- **ecs-processor** – Annotation processor that scans component classes and emits descriptors, handles, and `GeneratedComponents.registerAll(...)` glue.&#10;- **ecs-test** – Regression and QA suites mirroring real gameplay scenarios.&#10;- **ecs-benchmark** – JMH suite targeting SoA layout, SIMD loops, and parallel query throughput (see `PHASE2_COMPLETION.md`).&#10;- **Root Gradle build** – Applies shared toolchain flags (preview/VECTOR/Panama), configures Maven publish via Vanniktech + `SonatypeHost.CENTRAL_PORTAL`, and normalizes signing files for Windows per the QA checklist.&#10;&#10;## 2. Module Interaction&#10;```&#10;Application code → ECS facade → ArchetypeWorld ↔ ComponentManager&#10;                                 ↓&#10;                          SystemManager&#10;                                 ↓&#10;                            GameLoop&#10;```&#10;Build phase:&#10;- `ecs-processor` inspects component classes → generates handles/descriptors → writes `GeneratedComponents` registrar.&#10;Runtime phase:&#10;- `ECS` builder auto-invokes the registrar, initializing `ComponentManager` before the world and system pipeline spin up.&#10;&#10;## 3. Data Flow &amp; Memory Layout&#10;The world combines an archetype/chunk layout with three component storage paths: unmanaged (off-heap), managed (on-heap objects via tickets), and shared (per-chunk-group state).&#10;&#10;### 3.1 Component metadata &amp; registration&#10;- All component types are registered with `ComponentManager`, which assigns a stable **component type id** and builds a `ComponentDescriptor`.&#10;- Descriptors carry layout and management flags (e.g. `isManaged()`), coming from annotations described in `COMPONENT_SYSTEM.md`.&#10;- At startup, `ECS.Builder` normally invokes `GeneratedComponents.registerAll(componentManager)` to register all known components; you can override this manually.&#10;&#10;### 3.2 Archetypes, chunk groups, and chunks&#10;- An **Archetype** represents a unique `ComponentMask` – a bitset of component type ids.&#10;- For each archetype, the world maintains one or more **ChunkGroup**s keyed by a `SharedValueKey` (shared-component configuration).&#10;- Each **ArchetypeChunk** in a group holds a fixed-capacity slice of entities that share the same component mask + shared key.&#10;&#10;Conceptually:&#10;```text&#10;Archetype(mask = {Position, Velocity, Health})&#10;  └─ ChunkGroup(sharedKey)&#10;       ├─ Chunk 0&#10;       │    ├─ unmanaged arrays per component type&#10;       │    ├─ managed ticket arrays per managed type&#10;       │    └─ entityIds[]&#10;       └─ Chunk 1&#10;            ...&#10;```&#10;&#10;### 3.3 Unmanaged (off-heap) components&#10;Unmanaged components are value-like and live entirely in foreign memory:&#10;- `ComponentDescriptor.isManaged() == false`.&#10;- For each entity + unmanaged component type, the world allocates a `MemorySegment` using `ComponentManager.allocate(componentClass, arena)`.&#10;- `ArchetypeChunk` stores these segments in per-type/per-entity slots via `setComponentData(location, componentIndex, segment)`.&#10;&#10;Logically, per chunk:&#10;```text&#10;unmanaged[componentTypeIndex][entityIndex] -&gt; MemorySegment&#10;```&#10;The actual field layout inside each segment (SoA/struct-like) is defined by the descriptor and annotation config.&#10;&#10;### 3.4 Managed (on-heap) components&#10;Managed components are full Java objects stored indirectly:&#10;- Marked `@Component.Managed` and reported as `isManaged() == true` in `ComponentDescriptor`.&#10;- Instances live in a global `ManagedComponentStore`.&#10;- When you call `addComponent(entityId, myManagedComponent)`, the store returns an integer **ticket**:&#10;  1. The entity is moved to a new archetype/ChunkGroup whose mask includes that component type id.&#10;  2. The destination chunk writes the ticket into a per-type ticket array using `setManagedTicket(managedTypeIndex, indexInChunk, ticket)`.&#10;&#10;Per chunk, this is conceptually:&#10;```text&#10;managedTickets[managedTypeIndex][entityIndex] -&gt; int ticket&#10;ManagedComponentStore[ticket] -&gt; actual object instance&#10;```&#10;Systems resolve tickets back to objects when they need to operate on managed state.&#10;&#10;### 3.5 Shared components and `SharedComponentStore`&#10;Some state is shared across many entities in the same chunk group:&#10;- A `SharedValueKey` identifies a particular combination of shared component values.&#10;- `SharedComponentStore` holds the actual shared data bundles.&#10;- `ArchetypeWorld` uses the key when creating/finding a `ChunkGroup`, so all entities in that group implicitly share those values.&#10;&#10;At a high level:&#10;```text&#10;SharedComponentStore[sharedKey] -&gt; shared data&#10;Archetype(mask)&#10;  └─ ChunkGroup(sharedKey)  // all chunks here see the same shared data&#10;```&#10;&#10;### 3.6 Entity lifecycle&#10;The entity lifecycle ties these pieces together:&#10;1. **Creation** (`createEntityWithComponents`)&#10;   - Allocate a new entity id.&#10;   - Build a `ComponentMask` from the requested component classes.&#10;   - Ask `ArchetypeManager` for an archetype matching that mask.&#10;   - Get or create a `ChunkGroup` for the default `SharedValueKey` (no explicit shared data yet).&#10;   - Add the entity to a chunk via `ChunkGroup.addEntity`, which returns a `ChunkLocation`.&#10;   - For each **unmanaged** component: allocate a zeroed `MemorySegment` and wire it into the chunk.&#10;   - For **managed** components: tickets default to `-1` until an instance is attached.&#10;&#10;2. **Structural changes** (add/remove component)&#10;   - Compute a new `ComponentMask` that includes/excludes the component's type id.&#10;   - Call `moveEntityToArchetype(...)` to move the entity between archetypes while preserving its `SharedValueKey`.&#10;   - For unmanaged components, copy or assign the relevant `MemorySegment` into the new chunk slot.&#10;   - For managed components, update tickets and, if removing, release the old ticket from `ManagedComponentStore`.&#10;&#10;3. **Shared component changes**&#10;   - Changing shared state effectively means moving the entity to another `ChunkGroup` with a different `SharedValueKey`.&#10;&#10;This design allows:&#10;- Dense per-archetype storage for predictable iteration order.&#10;- Off-heap value storage for tight loops.&#10;- On-heap managed objects when you need rich Java semantics.&#10;- De-duplicated shared state without duplicating memory across thousands of entities.&#10;&#10;## 4. Execution Pipeline &amp; GameLoop&#10;- Systems live inside `SystemGroup`s (INPUT, SIMULATION, RENDER, custom). Groups carry rank/priority to preserve deterministic ordering (`README_PARALLEL_SYSTEM.md`).&#10;- `SystemManager.registerPipelineSystem(system, group)` wires systems into each group; dependency injection populates generated query handles.&#10;- `GameLoop` (default 60 Hz) ticks groups sequentially each frame; `ECS.createGameLoop(targetHz)` lets clients embed loops at custom rates or threads (virtual or platform).&#10;&#10;```&#10;[GameLoop tick]&#10;  → INPUT systems&#10;  → SIMULATION systems (optionally parallel per query)&#10;  → RENDER systems&#10;```&#10;- Parallel execution: queries call `.parallel(...)` (see Section 5) to fan out chunk work items across a ForkJoinPool. Systems must keep per-thread state isolated or rely on concurrent primitives.&#10;&#10;## 5. Parallel Query Model&#10;Derived from `PARALLEL_QUERY_GUIDE.md`.&#10;1. Filter archetypes by required/optional components.&#10;2. Snapshot volatile chunk arrays (`getChunksSnapshot()`).&#10;3. Flatten into `ChunkWorkItem[]` and submit to a ForkJoin worker.&#10;4. Within each chunk, process entities sequentially to maximize cache hits, invoking the thread-safe consumer for each entity.&#10;&#10;Performance defaults:&#10;- Break-even entity count ~1k (below that, stay sequential).&#10;- Fusing Vector API operations (`FloatVector.fma`) yields ~3× speedups on 10k entities (data from `IMPROVEMENTS.md`).&#10;- Consumers must use atomics or thread-local batching to avoid contention (see QA checklist “Parallel Safety”).&#10;&#10;## 6. Component Lifecycle &amp; Codegen&#10;1. **Registration** – Builder auto-runs `GeneratedComponents.registerAll(componentManager)` unless `noAutoRegistration()` is set. Manual overrides call `registerComponent(Class&lt;?&gt;)`.&#10;2. **Entity creation** – `ArchetypeWorld` picks/creates a chunk based on component signature, assigning contiguous slots per component column.&#10;3. **System execution** – Generated handles (e.g., `PositionHandle`) provide zero-copy getters/setters inside query lambdas, avoiding reflection and boxing.&#10;&#10;## 7. QA, Publishing, and Tooling&#10;- QA gates (`QA_QC_CHECKLIST.md`): verify AP output, SoA layout integrity, parallel query determinism, and JVM args (`--enable-preview --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.vector`).&#10;- Test suites (`QA_QC_TEST_CASES.md`, `QA_QC_TEST_SUITE.md`) map to `ecs-test`; run via Gradle so all flags apply consistently.&#10;- Publishing: root `build.gradle.kts` configures Vanniktech with `SonatypeHost.CENTRAL_PORTAL`, normalized `secring.gpg` path, and coordinates `io.github.vuxz123:{ecs-core|ecs-processor}:0.1.+`.&#10;- Benchmarks: `ecs-benchmark` JMH scenarios guard SoA/SIMD regressions; results feed into Phase completion reports.&#10;&#10;## 8. Reference Map&#10;- `docs/ADVANCED_GUIDE.md` – Expanded discussions + appendices (parallel systems, QA artifacts, improvement logs).&#10;- `docs/ROADMAP.md` – Milestone history (Phase 1/2) and rolling backlog for future architectural shifts.&#10;- `PHASE1_COMPLETION.md`, `PHASE2_COMPLETION.md` – Deep historical records referenced by the roadmap.&#10;- Legacy design docs (`IMPROVEMENTS.md`, `COMPONENT_SYSTEM.md`, `README_PARALLEL_SYSTEM.md`, `PARALLEL_QUERY_GUIDE.md`, `QA_QC_*`) remain the canonical sources for the summaries above; edit them first, then refresh this file.&#10;&#10;&gt; Update this document whenever foundational architecture changes. For chronological context or upcoming work, rely on the roadmap; for exhaustive technical detail, use the advanced guide appendices." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/SYSTEMS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/SYSTEMS.md" />
              <option name="originalContent" value="# Systems&#10;&#10;This guide explains how systems work in the ECS: what they are, how they are scheduled through groups, how they access data, and how they integrate with the `GameLoop`.&#10;&#10;## 1. What Is a System?&#10;&#10;A **System** is a unit of behavior that runs on every tick and operates over entities that match some component pattern.&#10;&#10;In code, systems implement the `ISystem` interface:&#10;&#10;```java&#10;public interface ISystem {&#10;    void onAwake(ArchetypeWorld world);   // called once when registered&#10;    void onUpdate(float deltaTime);       // called every tick while enabled&#10;    void onDispose();                     // called when the world is closing or system is removed&#10;&#10;    boolean isEnabled();                  // current enabled state&#10;    void setEnabled(boolean enabled);     // toggle participation in updates&#10;}&#10;```&#10;&#10;Lifecycle:&#10;- **onAwake** – invoked once when the system is registered; you can cache references, set up queries, etc.&#10;- **onUpdate** – invoked once per tick by the `SystemManager`/`GameLoop` if the system is enabled.&#10;- **onDispose** – invoked when the ECS world is closing or the system is being removed.&#10;&#10;## 2. System Groups&#10;&#10;Systems are organized into **SystemGroup**s that represent phases of the frame:&#10;&#10;```java&#10;public record SystemGroup(String name, int priority, UpdateMode mode) implements Comparable&lt;SystemGroup&gt; {&#10;    public static final SystemGroup INPUT      = new SystemGroup(&quot;Input&quot;,      0,    UpdateMode.VARIABLE);&#10;    public static final SystemGroup SIMULATION = new SystemGroup(&quot;Simulation&quot;, 1000, UpdateMode.FIXED);&#10;    public static final SystemGroup PHYSICS    = new SystemGroup(&quot;Physics&quot;,    2000, UpdateMode.FIXED);&#10;    public static final SystemGroup RENDER     = new SystemGroup(&quot;Render&quot;,     3000, UpdateMode.VARIABLE);&#10;    public static final SystemGroup CLEANUP    = new SystemGroup(&quot;Cleanup&quot;,    4000, UpdateMode.VARIABLE);&#10;}&#10;```&#10;&#10;- `name` – label for debugging/logging.&#10;- `priority` – lower values run earlier.&#10;- `mode` – `FIXED` or `VARIABLE` (used by `SystemManager` and `GameLoop` to decide which groups participate in fixed-step updates).&#10;&#10;You can define your own groups; they will be sorted alongside the built-ins by `priority`, then by `name`.&#10;&#10;## 3. Registering Systems&#10;&#10;The easiest way to register systems is via the `ECS` builder:&#10;&#10;```java&#10;try (var ecs = ECS.builder()&#10;        .addSystem(new InputSystem(), SystemGroup.INPUT)&#10;        .addSystem(new MovementSystem(), SystemGroup.SIMULATION)&#10;        .addSystem(new RenderSystem(), SystemGroup.RENDER)&#10;        .build()) {&#10;    ecs.run();&#10;}&#10;```&#10;&#10;Builder methods:&#10;- `addSystem(ISystem system)` – registers into `SystemGroup.SIMULATION` by default.&#10;- `addSystem(ISystem system, SystemGroup group)` – registers into a specific group.&#10;&#10;Internally this calls:&#10;&#10;```java&#10;SystemManager sysMgr = new SystemManager(world);&#10;sysMgr.registerPipelineSystem(system, group);&#10;```&#10;&#10;### 3.1 What SystemManager Does&#10;&#10;`SystemManager` is responsible for:&#10;- Keeping a map of `SystemGroup -&gt; List&lt;ISystem&gt;`.&#10;- Calling a generated injector for each system (if present) to wire up queries.&#10;- Managing group ordering (fixed vs variable) and running systems each frame.&#10;&#10;Key methods:&#10;&#10;```java&#10;public &lt;T extends ISystem&gt; T registerSystem(T system);              // default SIMULATION&#10;public &lt;T extends ISystem&gt; T registerPipelineSystem(T system, SystemGroup group);&#10;public void updateGroup(SystemGroup group, float deltaTime);       // run one group&#10;public void update(float deltaTime);                               // run all groups&#10;```&#10;&#10;During registration:&#10;1. The manager tries to invoke a generated injector named `YourSystem__QueryInjector`.&#10;2. `onAwake(world)` is called on the system.&#10;3. The system is placed into the appropriate group list and group ordering is recomputed.&#10;&#10;## 4. Execution Order &amp; GameLoop&#10;&#10;The `GameLoop` drives systems via `SystemManager`:&#10;&#10;- **Per tick** it will:&#10;  1. Run all `FIXED`-mode groups in priority order.&#10;  2. Run all `VARIABLE`-mode groups in priority order.&#10;&#10;Conceptually:&#10;&#10;```text&#10;[GameLoop tick]&#10;  → INPUT   (VARIABLE)  systems&#10;  → SIMULATION (FIXED)  systems&#10;  → PHYSICS  (FIXED)    systems&#10;  → RENDER   (VARIABLE) systems&#10;  → CLEANUP  (VARIABLE) systems&#10;```&#10;&#10;From the `ECS` facade you can:&#10;- Call `ecs.run()` – start the default fixed-timestep loop (blocks until `ecs.stop()` is called).&#10;- Create a custom loop: `GameLoop loop = ecs.createGameLoop(targetHz); loop.run();`.&#10;- Manually step a group: `ecs.updateGroup(SystemGroup.SIMULATION, dt);`.&#10;&#10;## 5. Data Access Inside Systems&#10;&#10;Systems typically operate over entities via **generated queries** driven by the `@Query` annotation on private methods. The primary model looks like the demo systems in `ecs-test` (`MovementSystem`, `HealthRegenerationSystem`, `MixedUnmanagedAndManagedSystem`, `TeamFilterSystem`):&#10;&#10;- You declare a private method annotated with `@Query` that describes the component pattern and execution mode.&#10;- You provide a `fieldInject` name; the annotation processor generates an injector that initializes that field with an `IGeneratedQuery` instance when the system is registered.&#10;- In `onUpdate`, the system calls `generatedQuery.runQuery()` to process all matching entities.&#10;&#10;This keeps the hot path very simple and lets the generated code own the heavy query construction and wiring.&#10;&#10;### 5.1 `@Query` + `IGeneratedQuery` (Recommended)&#10;&#10;A typical pattern, as in `MovementSystem` and `HealthRegenerationSystem`:&#10;&#10;- The system has a field of type `IGeneratedQuery` (for example, `movingEntities`, `healthyEntities`).&#10;- A private `@Query`-annotated method declares:&#10;  - `fieldInject = &quot;movingEntities&quot;`.&#10;  - `mode = ExecutionMode.SEQUENTIAL` or `ExecutionMode.PARALLEL`.&#10;  - A `with = { ... }` list describing required components.&#10;- At registration time, the generated injector:&#10;  - Builds and caches the underlying query/builder once.&#10;  - Stores it in the target field.&#10;- On each `onUpdate`, the system just checks `if (movingEntities != null)` and calls `movingEntities.runQuery()`.&#10;&#10;Some generated query fields also implement `IQueryBuilder` (see `TeamFilterSystem`):&#10;- The field is still created once and cached by the injector.&#10;- At runtime you can adjust light filters on that builder, such as `withShared(new TeamShared(&quot;A&quot;))`, then call `build().runQuery()`.&#10;- The heavy part (wiring up the underlying query over archetypes and components) is still done once; per-frame you only tweak the filter state and run.&#10;&#10;As a rule of thumb:&#10;- Prefer `@Query` + `IGeneratedQuery` for normal game and simulation logic.&#10;- Let the generated code manage query creation and caching; your systems should mostly just call `runQuery()` in `onUpdate`.&#10;&#10;### 5.2 Manual `ArchetypeQuery` Usage (Advanced / Low-Level)&#10;&#10;For specialized needs you can manually build and run queries against `ArchetypeWorld` using `ArchetypeQuery` and `world.query()`. This is a **low-level** API that is not used in the standard demo systems and is intended for advanced integrations, experiments, or tooling.&#10;&#10;If you do use it, follow these rules:&#10;- Build and cache an `ArchetypeQuery` once (e.g., in the constructor or `onAwake`).&#10;- Reuse that cached query inside `onUpdate` to iterate matching entities.&#10;- Avoid rebuilding the same query on every frame or inside inner loops.&#10;&#10;**Query construction cost.** Building a query (whether via `@Query`-generated code or via the `ArchetypeQuery` builder) computes archetype filters and internal data structures. This is relatively heavy compared to a plain loop. You should almost always:&#10;- Build queries once per system (for example, during registration or `onAwake`).&#10;- Reuse those query instances on every tick.&#10;- Only adjust lightweight filters (like shared/team selection) in hot paths, not the fundamental component mask.&#10;&#10;For deeper details on queries and data layout, see:&#10;- `docs/COMPONENT_SYSTEM.md`&#10;- `docs/ARCHITECTURE.md`&#10;- `docs/ADVANCED_GUIDE.md` (parallel queries and best practices)&#10;&#10;## 6. Parallel Work in Systems&#10;&#10;Systems can use the **parallel query model** described in `PARALLEL_QUERY_GUIDE.md` and `README_PARALLEL_SYSTEM.md` by calling `forEachParallel` on queries.&#10;&#10;```java&#10;var query = world.query()&#10;        .with(Position.class)&#10;        .with(Velocity.class)&#10;        .build();&#10;&#10;AtomicInteger processed = new AtomicInteger(0);&#10;&#10;query.forEachParallel((entityId, handles, archetype) -&gt; {&#10;    // This code may run on worker threads – must be thread-safe&#10;    processed.incrementAndGet();&#10;&#10;    ComponentHandle pos = handles[0];&#10;    ComponentHandle vel = handles[1];&#10;    // Apply movement or other CPU-heavy logic here&#10;});&#10;```&#10;&#10;Rules of thumb:&#10;- Treat the `forEachParallel` consumer body as multi-threaded code:&#10;  - Use `Atomic*` or concurrent collections for shared counters or maps.&#10;  - Prefer per-thread batching (e.g., thread-local lists) over heavy synchronization.&#10;- Only use parallel queries when you have enough work (roughly 1k+ entities) or CPU-heavy logic.&#10;&#10;For full design details and performance tips, see `docs/ADVANCED_GUIDE.md` and the parallel query guides listed there.&#10;&#10;## 7. Patterns &amp; Best Practices&#10;&#10;**Do:**&#10;- Keep each System focused on a single responsibility (movement, rendering, health regen, etc.).&#10;- Use groups to sequence phases (input → simulation → physics → render).&#10;- Use the query API instead of hand-rolled loops over entity ids.&#10;&#10;**Avoid:**&#10;- Blocking I/O (disk, network) in `onUpdate` for high-frequency Systems.&#10;- Storing large mutable global state shared between Systems without synchronization.&#10;- Mutating component structure (adding/removing components) inside tight per-entity loops unnecessarily; batch structural changes when possible.&#10;&#10;With these guidelines, Systems remain easy to reason about and scale well as you add more behavior to your game or simulation.&#10;&#10;## 8. Batching Structural Changes with EntityCommandBuffer&#10;&#10;When a system wants to create/destroy entities or add/remove components while it is iterating over entities, doing those structural changes directly inside the query callback can be problematic, especially for parallel systems. To keep iteration stable and avoid complex synchronization, you should batch these operations via an `EntityCommandBuffer`.&#10;&#10;### 8.1 General Idea&#10;&#10;Instead of:&#10;- Calling `world.createEntity(...)`, `world.addComponent(...)`, `world.removeComponent(...)`, or `world.destroyEntity(...)` directly inside the callback of `@Query` / `runQuery()`.&#10;&#10;Do:&#10;- Record (enqueue) those operations into an `EntityCommandBuffer` while the query is running.&#10;- After `generatedQuery.runQuery()` (or the entire frame) finishes, call a `commandBuffer.flush(world)`-like function to apply all changes at once.&#10;&#10;Benefits:&#10;- **Structural Stability**: doesn't break layout / iterator of `ArchetypeWorld` while the query is iterating entities.&#10;- **Thread-safe with Parallel**: `ExecutionMode.PARALLEL` systems can let each worker thread write commands to its own buffer and then merge, instead of directly touching the world from multiple threads.&#10;- **Easier reasoning**: clearly separates the &quot;read + decide&quot; and &quot;commit structural changes&quot; phases.&#10;&#10;### 8.2 When to Use EntityCommandBuffer&#10;&#10;Prefer using `EntityCommandBuffer` when:&#10;- Your system is using `ExecutionMode.PARALLEL` and wants to:&#10;  - Spawn additional entities from inside the query.&#10;  - Add / remove components of the entities being processed.&#10;  - Destroy entities based on conditions.&#10;- The system logic is complex, with many rules potentially touching the same entity / component in one frame.&#10;- You want to batch statistics / logs about structural changes (how many entities were created, how many components were removed, etc.) before committing.&#10;&#10;### 8.3 Typical Processing Flow in System&#10;&#10;A typical flow with `EntityCommandBuffer` looks like this:&#10;&#10;1. System holds a buffer (or receives one from ECS context) to use for each frame.&#10;2. In `onUpdate(float dt)`:&#10;   - Reset / clear the buffer for the new frame.&#10;   - Call `generatedQuery.runQuery()`. Inside the `@Query` callback:&#10;     - **Only read** components and make decisions.&#10;     - Instead of calling `world.add/remove/destroy` directly, just enqueue the corresponding commands to the buffer.&#10;3. After `runQuery()` finishes:&#10;   - Call `buffer.flush(world)` (or equivalent API) to apply all commands to the `ArchetypeWorld`.&#10;&#10;With parallel systems:&#10;- Each thread can use its own buffer (thread-local) or `EntityCommandBuffer` that supports internal batching.&#10;- After the query finishes, ECS can merge the batches and apply them on a single thread (or at a safe sync point) to ensure consistency.&#10;&#10;### 8.4 Best Practices for Batching&#10;&#10;- **Don't modify the world directly in hot loop queries**:&#10;  - In the `@Query` callback, only read data and enqueue commands to the buffer.&#10;- **Clearly separate the two phases**:&#10;  - Phase 1: `runQuery()` – read state, decide what needs to change, push commands to the buffer.&#10;  - Phase 2: `flush()` – commit structural changes (create/destroy/add/remove) to the `ArchetypeWorld`.&#10;- **Reduce order dependencies**:&#10;  - Design commands so that the results don't depend too much on the exact order in the buffer (unless the engine guarantees apply order).&#10;- **Combine with query caching**:&#10;  - Continue to follow the rule: queries are built and cached once; each frame only lightweight conditions are changed (e.g., shared/team), use queries for reading, and use buffers for writing.&#10;&#10;For more details on structural change costs and how to optimize memory layout, see `docs/COMPONENT_SYSTEM.md` and the Performance section in `docs/ADVANCED_GUIDE.md`." />
              <option name="updatedContent" value="# Systems&#10;&#10;This guide explains how systems work in the ECS: what they are, how they are scheduled through groups, how they access data, and how they integrate with the `GameLoop`.&#10;&#10;## 1. What Is a System?&#10;&#10;A **System** is a unit of behavior that runs on every tick and operates over entities that match some component pattern.&#10;&#10;In code, systems implement the `ISystem` interface:&#10;&#10;```java&#10;public interface ISystem {&#10;    void onAwake(ArchetypeWorld world);   // called once when registered&#10;    void onUpdate(float deltaTime);       // called every tick while enabled&#10;    void onDispose();                     // called when the world is closing or system is removed&#10;&#10;    boolean isEnabled();                  // current enabled state&#10;    void setEnabled(boolean enabled);     // toggle participation in updates&#10;}&#10;```&#10;&#10;Lifecycle:&#10;- **onAwake** – invoked once when the system is registered; you can cache references, set up queries, etc.&#10;- **onUpdate** – invoked once per tick by the `SystemManager`/`GameLoop` if the system is enabled.&#10;- **onDispose** – invoked when the ECS world is closing or the system is being removed.&#10;&#10;## 2. System Groups&#10;&#10;Systems are organized into **SystemGroup**s that represent phases of the frame:&#10;&#10;```java&#10;public record SystemGroup(String name, int priority, UpdateMode mode) implements Comparable&lt;SystemGroup&gt; {&#10;    public static final SystemGroup INPUT      = new SystemGroup(&quot;Input&quot;,      0,    UpdateMode.VARIABLE);&#10;    public static final SystemGroup SIMULATION = new SystemGroup(&quot;Simulation&quot;, 1000, UpdateMode.FIXED);&#10;    public static final SystemGroup PHYSICS    = new SystemGroup(&quot;Physics&quot;,    2000, UpdateMode.FIXED);&#10;    public static final SystemGroup RENDER     = new SystemGroup(&quot;Render&quot;,     3000, UpdateMode.VARIABLE);&#10;    public static final SystemGroup CLEANUP    = new SystemGroup(&quot;Cleanup&quot;,    4000, UpdateMode.VARIABLE);&#10;}&#10;```&#10;&#10;- `name` – label for debugging/logging.&#10;- `priority` – lower values run earlier.&#10;- `mode` – `FIXED` or `VARIABLE` (used by `SystemManager` and `GameLoop` to decide which groups participate in fixed-step updates).&#10;&#10;You can define your own groups; they will be sorted alongside the built-ins by `priority`, then by `name`.&#10;&#10;## 3. Registering Systems&#10;&#10;The easiest way to register systems is via the `ECS` builder:&#10;&#10;```java&#10;try (var ecs = ECS.builder()&#10;        .addSystem(new InputSystem(), SystemGroup.INPUT)&#10;        .addSystem(new MovementSystem(), SystemGroup.SIMULATION)&#10;        .addSystem(new RenderSystem(), SystemGroup.RENDER)&#10;        .build()) {&#10;    ecs.run();&#10;}&#10;```&#10;&#10;Builder methods:&#10;- `addSystem(ISystem system)` – registers into `SystemGroup.SIMULATION` by default.&#10;- `addSystem(ISystem system, SystemGroup group)` – registers into a specific group.&#10;&#10;Internally this calls:&#10;&#10;```java&#10;SystemManager sysMgr = new SystemManager(world);&#10;sysMgr.registerPipelineSystem(system, group);&#10;```&#10;&#10;### 3.1 What SystemManager Does&#10;&#10;`SystemManager` is responsible for:&#10;- Keeping a map of `SystemGroup -&gt; List&lt;ISystem&gt;`.&#10;- Calling a generated injector for each system (if present) to wire up queries.&#10;- Managing group ordering (fixed vs variable) and running systems each frame.&#10;&#10;Key methods:&#10;&#10;```java&#10;public &lt;T extends ISystem&gt; T registerSystem(T system);              // default SIMULATION&#10;public &lt;T extends ISystem&gt; T registerPipelineSystem(T system, SystemGroup group);&#10;public void updateGroup(SystemGroup group, float deltaTime);       // run one group&#10;public void update(float deltaTime);                               // run all groups&#10;```&#10;&#10;During registration:&#10;1. The manager tries to invoke a generated injector named `YourSystem__QueryInjector`.&#10;2. `onAwake(world)` is called on the system.&#10;3. The system is placed into the appropriate group list and group ordering is recomputed.&#10;&#10;## 4. Execution Order &amp; GameLoop&#10;&#10;The `GameLoop` drives systems via `SystemManager`:&#10;&#10;- **Per tick** it will:&#10;  1. Run all `FIXED`-mode groups in priority order.&#10;  2. Run all `VARIABLE`-mode groups in priority order.&#10;&#10;Conceptually:&#10;&#10;```text&#10;[GameLoop tick]&#10;  → INPUT   (VARIABLE)  systems&#10;  → SIMULATION (FIXED)  systems&#10;  → PHYSICS  (FIXED)    systems&#10;  → RENDER   (VARIABLE) systems&#10;  → CLEANUP  (VARIABLE) systems&#10;```&#10;&#10;From the `ECS` facade you can:&#10;- Call `ecs.run()` – start the default fixed-timestep loop (blocks until `ecs.stop()` is called).&#10;- Create a custom loop: `GameLoop loop = ecs.createGameLoop(targetHz); loop.run();`.&#10;- Manually step a group: `ecs.updateGroup(SystemGroup.SIMULATION, dt);`.&#10;&#10;## 5. Data Access Inside Systems&#10;&#10;Systems typically operate over entities via **generated queries** driven by the `@Query` annotation on private methods. The primary model looks like the demo systems in `ecs-test` (`MovementSystem`, `HealthRegenerationSystem`, `MixedUnmanagedAndManagedSystem`, `TeamFilterSystem`):&#10;&#10;- You declare a private method annotated with `@Query` that describes the component pattern and execution mode.&#10;- You provide a `fieldInject` name; the annotation processor generates an injector that initializes that field with an `IGeneratedQuery` instance when the system is registered.&#10;- In `onUpdate`, the system calls `generatedQuery.runQuery()` to process all matching entities.&#10;&#10;This keeps the hot path very simple and lets the generated code own the heavy query construction and wiring.&#10;&#10;### 5.1 `@Query` + `IGeneratedQuery` (Recommended)&#10;&#10;A typical pattern, as in `MovementSystem` and `HealthRegenerationSystem`:&#10;&#10;- The system has a field of type `IGeneratedQuery` (for example, `movingEntities`, `healthyEntities`).&#10;- A private `@Query`-annotated method declares:&#10;  - `fieldInject = &quot;movingEntities&quot;`.&#10;  - `mode = ExecutionMode.SEQUENTIAL` or `ExecutionMode.PARALLEL`.&#10;  - A `with = { ... }` list describing required components.&#10;- At registration time, the generated injector:&#10;  - Builds and caches the underlying query/builder once.&#10;  - Stores it in the target field.&#10;- On each `onUpdate`, the system just checks `if (movingEntities != null)` and calls `movingEntities.runQuery()`.&#10;&#10;Some generated query fields also implement `IQueryBuilder` (see `TeamFilterSystem`):&#10;- The field is still created once and cached by the injector.&#10;- At runtime you can adjust light filters on that builder, such as `withShared(new TeamShared(&quot;A&quot;))`, then call `build().runQuery()`.&#10;- The heavy part (wiring up the underlying query over archetypes and components) is still done once; per-frame you only tweak the filter state and run.&#10;&#10;As a rule of thumb:&#10;- Prefer `@Query` + `IGeneratedQuery` for normal game and simulation logic.&#10;- Let the generated code manage query creation and caching; your systems should mostly just call `runQuery()` in `onUpdate`.&#10;&#10;### 5.2 Manual `ArchetypeQuery` Usage (Advanced / Low-Level)&#10;&#10;For specialized needs you can manually build and run queries against `ArchetypeWorld` using `ArchetypeQuery` and `world.query()`. This is a **low-level** API that is not used in the standard demo systems and is intended for advanced integrations, experiments, or tooling.&#10;&#10;If you do use it, follow these rules:&#10;- Build and cache an `ArchetypeQuery` once (e.g., in the constructor or `onAwake`).&#10;- Reuse that cached query inside `onUpdate` to iterate matching entities.&#10;- Avoid rebuilding the same query on every frame or inside inner loops.&#10;&#10;**Query construction cost.** Building a query (whether via `@Query`-generated code or via the `ArchetypeQuery` builder) computes archetype filters and internal data structures. This is relatively heavy compared to a plain loop. You should almost always:&#10;- Build queries once per system (for example, during registration or `onAwake`).&#10;- Reuse those query instances on every tick.&#10;- Only adjust lightweight filters (like shared/team selection) in hot paths, not the fundamental component mask.&#10;&#10;For deeper details on queries and data layout, see:&#10;- `docs/COMPONENT_SYSTEM.md`&#10;- `docs/ARCHITECTURE.md`&#10;- `docs/ADVANCED_GUIDE.md` (parallel queries and best practices)&#10;&#10;## 6. Parallel Work in Systems&#10;&#10;Systems can use the **parallel query model** described in `PARALLEL_QUERY_GUIDE.md` and `README_PARALLEL_SYSTEM.md` by calling `forEachParallel` on queries.&#10;&#10;```java&#10;var query = world.query()&#10;        .with(Position.class)&#10;        .with(Velocity.class)&#10;        .build();&#10;&#10;AtomicInteger processed = new AtomicInteger(0);&#10;&#10;query.forEachParallel((entityId, handles, archetype) -&gt; {&#10;    // This code may run on worker threads – must be thread-safe&#10;    processed.incrementAndGet();&#10;&#10;    ComponentHandle pos = handles[0];&#10;    ComponentHandle vel = handles[1];&#10;    // Apply movement or other CPU-heavy logic here&#10;});&#10;```&#10;&#10;Rules of thumb:&#10;- Treat the `forEachParallel` consumer body as multi-threaded code:&#10;  - Use `Atomic*` or concurrent collections for shared counters or maps.&#10;  - Prefer per-thread batching (e.g., thread-local lists) over heavy synchronization.&#10;- Only use parallel queries when you have enough work (roughly 1k+ entities) or CPU-heavy logic.&#10;&#10;For full design details and performance tips, see `docs/ADVANCED_GUIDE.md` and the parallel query guides listed there.&#10;&#10;## 7. Patterns &amp; Best Practices&#10;&#10;**Do:**&#10;- Keep each System focused on a single responsibility (movement, rendering, health regen, etc.).&#10;- Use groups to sequence phases (input → simulation → physics → render).&#10;- Use the query API instead of hand-rolled loops over entity ids.&#10;&#10;**Avoid:**&#10;- Blocking I/O (disk, network) in `onUpdate` for high-frequency Systems.&#10;- Storing large mutable global state shared between Systems without synchronization.&#10;- Mutating component structure (adding/removing components) inside tight per-entity loops unnecessarily; batch structural changes when possible.&#10;&#10;With these guidelines, Systems remain easy to reason about and scale well as you add more behavior to your game or simulation.&#10;&#10;## 8. Batching Structural Changes with EntityCommandBuffer&#10;&#10;When a system wants to create/destroy entities or add/remove components while it is iterating over entities, doing those structural changes directly inside the query callback can be problematic, especially for parallel systems. To keep iteration stable and avoid complex synchronization, you should batch these operations via an `EntityCommandBuffer`.&#10;&#10;### 8.1 General Idea&#10;&#10;Instead of:&#10;- Calling `world.createEntity(...)`, `world.addComponent(...)`, `world.removeComponent(...)`, or `world.destroyEntity(...)` directly inside the callback of `@Query` / `runQuery()`.&#10;&#10;Do:&#10;- Record (enqueue) those operations into an `EntityCommandBuffer` while the query is running.&#10;- After `generatedQuery.runQuery()` (or the entire frame) finishes, call a `commandBuffer.flush(world)`-like function to apply all changes at once.&#10;&#10;Benefits:&#10;- **Structural Stability**: doesn't break layout / iterator of `ArchetypeWorld` while the query is iterating entities.&#10;- **Thread-safe with Parallel**: `ExecutionMode.PARALLEL` systems can let each worker thread write commands to its own buffer and then merge, instead of directly touching the world from multiple threads.&#10;- **Easier reasoning**: clearly separates the &quot;read + decide&quot; and &quot;commit structural changes&quot; phases.&#10;&#10;### 8.2 When to Use EntityCommandBuffer&#10;&#10;Prefer using `EntityCommandBuffer` when:&#10;- Your system is using `ExecutionMode.PARALLEL` and wants to:&#10;  - Spawn additional entities from inside the query.&#10;  - Add / remove components of the entities being processed.&#10;  - Destroy entities based on conditions.&#10;- The system logic is complex, with many rules potentially touching the same entity / component in one frame.&#10;- You want to batch statistics / logs about structural changes (how many entities were created, how many components were removed, etc.) before committing.&#10;&#10;### 8.3 Typical Processing Flow in System&#10;&#10;A typical flow with `EntityCommandBuffer` looks like this:&#10;&#10;1. System holds a buffer (or receives one from ECS context) to use for each frame.&#10;2. In `onUpdate(float dt)`:&#10;   - Reset / clear the buffer for the new frame.&#10;   - Call `generatedQuery.runQuery()`. Inside the `@Query` callback:&#10;     - **Only read** components and make decisions.&#10;     - Instead of calling `world.add/remove/destroy` directly, just enqueue the corresponding commands to the buffer.&#10;3. After `runQuery()` finishes:&#10;   - Call `buffer.flush(world)` (or equivalent API) to apply all commands to the `ArchetypeWorld`.&#10;&#10;With parallel systems:&#10;- Each thread can use its own buffer (thread-local) or `EntityCommandBuffer` that supports internal batching.&#10;- After the query finishes, ECS can merge the batches and apply them on a single thread (or at a safe sync point) to ensure consistency.&#10;&#10;### 8.4 Best Practices for Batching&#10;&#10;- **Don't modify the world directly in hot loop queries**:&#10;  - In the `@Query` callback, only read data and enqueue commands to the buffer.&#10;- **Clearly separate the two phases**:&#10;  - Phase 1: `runQuery()` – read state, decide what needs to change, push commands to the buffer.&#10;  - Phase 2: `flush()` – commit structural changes (create/destroy/add/remove) to the `ArchetypeWorld`.&#10;- **Reduce order dependencies**:&#10;  - Design commands so that the results don't depend too much on the exact order in the buffer (unless the engine guarantees apply order).&#10;- **Combine with query caching**:&#10;  - Continue to follow the rule: queries are built and cached once; each frame only lightweight conditions are changed (e.g., shared/team), use queries for reading, and use buffers for writing.&#10;&#10;For more details on structural change costs and how to optimize memory layout, see `docs/COMPONENT_SYSTEM.md` and the Performance section in `docs/ADVANCED_GUIDE.md`." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/USAGE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/USAGE.md" />
              <option name="originalContent" value="# ECS Usage Guide&#10;&#10;Detailed walkthrough for configuring the facade, wiring systems, and running the built-in `GameLoop`. For architecture dives, see `docs/ADVANCED_GUIDE.md`.&#10;&#10;## 1. Project Setup&#10;1. Add dependencies from `README.md` (floating `0.1.+` stays current).&#10;2. Enable annotation processing so `ecs-processor` emits handles + `GeneratedComponents`.&#10;3. Run `gradlew build` once to seed generated sources before launching samples.&#10;&#10;```kotlin&#10;plugins { id(&quot;application&quot;) }&#10;dependencies {&#10;    implementation(&quot;io.github.vuxz123:ecs-core:0.1.+&quot;)&#10;    annotationProcessor(&quot;io.github.vuxz123:ecs-processor:0.1.+&quot;)&#10;}&#10;```&#10;&#10;&gt; IntelliJ IDEA: Settings → Build → Compiler → Annotation Processors → *Enable*. Other IDEs need Gradle sync so generated sources appear in classpath.&#10;&#10;## 2. Builder Recipes&#10;`ECS.builder()` composes the ComponentManager, ArchetypeWorld, and SystemManager.&#10;&#10;| Builder hook | Use case |&#10;| --- | --- |&#10;| `addSystem(system)` | Register into `SystemGroup.SIMULATION` (default fixed-step).&#10;| `addSystem(system, group)` | Route to other groups (`INPUT`, `RENDER`, custom).&#10;| `registerComponent(clazz)` | Manual component wiring (pairs well with `noAutoRegistration()`).&#10;| `noAutoRegistration()` | Skip `GeneratedComponents.registerAll` when you need explicit ordering or AP is offline.&#10;&#10;Example:&#10;```java&#10;var ecs = ECS.builder()&#10;        .registerComponent(PositionComponent.class)&#10;        .registerComponent(VelocityComponent.class)&#10;        .addSystem(new PhysicsSystem())&#10;        .addSystem(new RenderSystem(), SystemGroup.RENDER)&#10;        .build();&#10;```&#10;&#10;Most systems in this project follow the same pattern as the demo classes in `ecs-test` (`MovementSystem`, `HealthRegenerationSystem`, `MixedUnmanagedAndManagedSystem`, `TeamFilterSystem`):&#10;- A field of type `IGeneratedQuery` (optionally also `IQueryBuilder`) is declared on the system.&#10;- A private method annotated with `@Query` uses `fieldInject` to point at that field and describes required components and `ExecutionMode`.&#10;- When you call `ECS.builder().addSystem(...)`, the `SystemManager` will run the generated injector for each system at registration time, constructing and caching the appropriate query object.&#10;- In `onUpdate`, the system simply checks for null and calls `generatedQuery.runQuery()` (and, when needed, applies lightweight per-frame filters like `withShared(TeamShared)` on a cached builder before running).&#10;&#10;You rarely need to construct `ArchetypeQuery` manually unless you are doing advanced or integration work; the normal flow is entirely driven by `@Query` + generated `IGeneratedQuery` fields.&#10;&#10;### 2.1 System API Demo (How it Fits Together)&#10;&#10;The `SystemAPIDemo` in `ecs-test` shows this end-to-end:&#10;- It creates an `ECS` instance via `ECS.builder()`.&#10;- It registers systems like `MovementSystem`, `HealthRegenerationSystem`, `MixedUnmanagedAndManagedSystem`, and `TeamFilterSystem`.&#10;- It registers additional components (`NameComponent`, `TeamShared`) that those systems depend on.&#10;- When `build()` is called, `SystemManager`:&#10;  - Runs the generated injectors for each system.&#10;  - Initializes their `IGeneratedQuery` / `IQueryBuilder` fields based on the `@Query` annotations.&#10;- The demo then creates 10,000 entities using the `ecs.createEntity(...)` API and initializes unmanaged components via the typed-handle `addComponent` helpers.&#10;- Finally, it calls `systemManager.update(deltaTime)`, which runs all enabled systems in group order; each system’s `onUpdate` simply invokes its generated queries (`runQuery()`) to apply game logic.&#10;&#10;You can use `SystemAPIDemo` as a reference template for wiring your own systems and seeing how `@Query`, generated queries, and the `ECS` facade work together.&#10;&#10;Custom phases are simple records:&#10;```java&#10;public static final SystemGroup UI = new SystemGroup(&quot;UI&quot;, 1500, UpdateMode.VARIABLE);&#10;```&#10;Register systems against `UI` to blend them into the pipeline.&#10;&#10;## 3. Lifecycle &amp; GameLoop&#10;The facade owns a default 60 Hz `GameLoop`.&#10;&#10;Blocking loop:&#10;```java&#10;try (var ecs = ECS.builder()&#10;        .addSystem(new SimulationSystem())&#10;        .addSystem(new RenderSystem(), SystemGroup.RENDER)&#10;        .build()) {&#10;    ecs.run();&#10;}&#10;```&#10;&#10;Custom rate / embedding:&#10;```java&#10;var ecs = ECS.builder().addSystem(new SimulationSystem()).build();&#10;GameLoop loop = ecs.createGameLoop(120f);&#10;Thread loopThread = Thread.ofVirtual().start(loop::run);&#10;// ... later&#10;loop.stop();&#10;loopThread.join();&#10;```&#10;&#10;Manual stepping (tests, scripts):&#10;```java&#10;float dt = 1f / 30f;&#10;ecs.updateGroup(SystemGroup.SIMULATION, dt);&#10;ecs.updateGroup(SystemGroup.RENDER, dt);&#10;```&#10;&#10;## 4. Entities &amp; Components&#10;&#10;Creating entities chooses optimal overloads before falling back to `createEntityWithComponents`:&#10;```java&#10;int enemy = ecs.createEntity(Position.class, Velocity.class, Health.class);&#10;```&#10;&#10;Zero-copy initialization uses generated handles:&#10;```java&#10;ecs.addComponent(enemy, Health.class, (HealthHandle h) -&gt; h.setValue(100));&#10;```&#10;If `GeneratedComponents` is missing, rebuild with AP enabled.&#10;&#10;## 5. Testing, Benchmarks, Publishing&#10;- Tests: `gradlew test` (preview flags wired via root Gradle script).&#10;- Benchmarks: `gradlew :ecs-benchmark:jmh`.&#10;- Local publish: `gradlew publishToMavenLocal`.&#10;- Maven Central: `gradlew publishAllPublicationsToMavenCentralRepository` (Vanniktech plugin config + `SonatypeHost.CENTRAL_PORTAL` already in root build).&#10;&#10;Publishing tips:&#10;- `secring.gpg` path normalized in root script (`replace(&quot;\\&quot;, &quot;/&quot;)`).&#10;- Use `sonatypeSnapshots()` in consuming apps if you need pre-release bits.&#10;- Keep version floating (`0.1.+`) so updates land automatically.&#10;&#10;## 6. Troubleshooting&#10;- `GeneratedComponents` missing → AP disabled or build never run.&#10;- Foreign-memory flags missing → run via Gradle tasks (they inject `--enable-preview --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.vector`).&#10;- Systems idle → verify `ISystem` implementation, builder registration, and `GameLoop` is running or groups are stepped manually.&#10;- Publish `file://` errors → allow root Gradle script to resolve URIs; avoid manual `file://` entries.&#10;&#10;## 7. Beyond the Basics&#10;- See `docs/ADVANCED_GUIDE.md` for the query model (including `@Query`-based systems, generated `IGeneratedQuery`/`IQueryBuilder` usage, and advanced manual `ArchetypeQuery` APIs), parallel queries, QA/QC process, performance tuning, and historical appendices.&#10;- Track milestones in `docs/ROADMAP.md` (updated each milestone with backlog items).&#10;- Explore `ecs-test` and `ecs-benchmark` for canonical patterns and performance baselines.&#10;" />
              <option name="updatedContent" value="# ECS Usage Guide&#10;&#10;Detailed walkthrough for configuring the facade, wiring systems, and running the built-in `GameLoop`. For architecture dives, see `docs/ADVANCED_GUIDE.md`.&#10;&#10;## 1. Project Setup&#10;1. Add dependencies from `README.md` (floating `0.1.+` stays current).&#10;2. Enable annotation processing so `ecs-processor` emits handles + `GeneratedComponents`.&#10;3. Run `gradlew build` once to seed generated sources before launching samples.&#10;&#10;```kotlin&#10;plugins { id(&quot;application&quot;) }&#10;dependencies {&#10;    implementation(&quot;io.github.vuxz123:ecs-core:0.1.+&quot;)&#10;    annotationProcessor(&quot;io.github.vuxz123:ecs-processor:0.1.+&quot;)&#10;}&#10;```&#10;&#10;&gt; IntelliJ IDEA: Settings → Build → Compiler → Annotation Processors → *Enable*. Other IDEs need Gradle sync so generated sources appear in classpath.&#10;&#10;## 2. Builder Recipes&#10;`ECS.builder()` composes the ComponentManager, ArchetypeWorld, and SystemManager.&#10;&#10;| Builder hook | Use case |&#10;| --- | --- |&#10;| `addSystem(system)` | Register into `SystemGroup.SIMULATION` (default fixed-step).&#10;| `addSystem(system, group)` | Route to other groups (`INPUT`, `RENDER`, custom).&#10;| `registerComponent(clazz)` | Manual component wiring (pairs well with `noAutoRegistration()`).&#10;| `noAutoRegistration()` | Skip `GeneratedComponents.registerAll` when you need explicit ordering or AP is offline.&#10;&#10;Example:&#10;```java&#10;var ecs = ECS.builder()&#10;        .registerComponent(PositionComponent.class)&#10;        .registerComponent(VelocityComponent.class)&#10;        .addSystem(new PhysicsSystem())&#10;        .addSystem(new RenderSystem(), SystemGroup.RENDER)&#10;        .build();&#10;```&#10;&#10;Most systems in this project follow the same pattern as the demo classes in `ecs-test` (`MovementSystem`, `HealthRegenerationSystem`, `MixedUnmanagedAndManagedSystem`, `TeamFilterSystem`):&#10;- A field of type `IGeneratedQuery` (optionally also `IQueryBuilder`) is declared on the system.&#10;- A private method annotated with `@Query` uses `fieldInject` to point at that field and describes required components and `ExecutionMode`.&#10;- When you call `ECS.builder().addSystem(...)`, the `SystemManager` will run the generated injector for each system at registration time, constructing and caching the appropriate query object.&#10;- In `onUpdate`, the system simply checks for null and calls `generatedQuery.runQuery()` (and, when needed, applies lightweight per-frame filters like `withShared(TeamShared)` on a cached builder before running).&#10;&#10;You rarely need to construct `ArchetypeQuery` manually unless you are doing advanced or integration work; the normal flow is entirely driven by `@Query` + generated `IGeneratedQuery` fields.&#10;&#10;### 2.1 System API Demo (How it Fits Together)&#10;&#10;The `SystemAPIDemo` in `ecs-test` shows this end-to-end:&#10;- It creates an `ECS` instance via `ECS.builder()`.&#10;- It registers systems like `MovementSystem`, `HealthRegenerationSystem`, `MixedUnmanagedAndManagedSystem`, and `TeamFilterSystem`.&#10;- It registers additional components (`NameComponent`, `TeamShared`) that those systems depend on.&#10;- When `build()` is called, `SystemManager`:&#10;  - Runs the generated injectors for each system.&#10;  - Initializes their `IGeneratedQuery` / `IQueryBuilder` fields based on the `@Query` annotations.&#10;- The demo then creates 10,000 entities using the `ecs.createEntity(...)` API and initializes unmanaged components via the typed-handle `addComponent` helpers.&#10;- Finally, it calls `systemManager.update(deltaTime)`, which runs all enabled systems in group order; each system’s `onUpdate` simply invokes its generated queries (`runQuery()`) to apply game logic.&#10;&#10;You can use `SystemAPIDemo` as a reference template for wiring your own systems and seeing how `@Query`, generated queries, and the `ECS` facade work together.&#10;&#10;Custom phases are simple records:&#10;```java&#10;public static final SystemGroup UI = new SystemGroup(&quot;UI&quot;, 1500, UpdateMode.VARIABLE);&#10;```&#10;Register systems against `UI` to blend them into the pipeline.&#10;&#10;## 3. Lifecycle &amp; GameLoop&#10;The facade owns a default 60 Hz `GameLoop`.&#10;&#10;Blocking loop:&#10;```java&#10;try (var ecs = ECS.builder()&#10;        .addSystem(new SimulationSystem())&#10;        .addSystem(new RenderSystem(), SystemGroup.RENDER)&#10;        .build()) {&#10;    ecs.run();&#10;}&#10;```&#10;&#10;Custom rate / embedding:&#10;```java&#10;var ecs = ECS.builder().addSystem(new SimulationSystem()).build();&#10;GameLoop loop = ecs.createGameLoop(120f);&#10;Thread loopThread = Thread.ofVirtual().start(loop::run);&#10;// ... later&#10;loop.stop();&#10;loopThread.join();&#10;```&#10;&#10;Manual stepping (tests, scripts):&#10;```java&#10;float dt = 1f / 30f;&#10;ecs.updateGroup(SystemGroup.SIMULATION, dt);&#10;ecs.updateGroup(SystemGroup.RENDER, dt);&#10;```&#10;&#10;## 4. Entities &amp; Components&#10;&#10;Creating entities chooses optimal overloads before falling back to `createEntityWithComponents`:&#10;```java&#10;int enemy = ecs.createEntity(Position.class, Velocity.class, Health.class);&#10;```&#10;&#10;Zero-copy initialization uses generated handles:&#10;```java&#10;ecs.addComponent(enemy, Health.class, (HealthHandle h) -&gt; h.setValue(100));&#10;```&#10;If `GeneratedComponents` is missing, rebuild with AP enabled.&#10;&#10;## 5. Testing, Benchmarks, Publishing&#10;- Tests: `gradlew test` (preview flags wired via root Gradle script).&#10;- Benchmarks: `gradlew :ecs-benchmark:jmh`.&#10;- Local publish: `gradlew publishToMavenLocal`.&#10;- Maven Central: `gradlew publishAllPublicationsToMavenCentralRepository` (Vanniktech plugin config + `SonatypeHost.CENTRAL_PORTAL` already in root build).&#10;&#10;Publishing tips:&#10;- `secring.gpg` path normalized in root script (`replace(&quot;\\&quot;, &quot;/&quot;)`).&#10;- Use `sonatypeSnapshots()` in consuming apps if you need pre-release bits.&#10;- Keep version floating (`0.1.+`) so updates land automatically.&#10;&#10;## 6. Troubleshooting&#10;- `GeneratedComponents` missing → AP disabled or build never run.&#10;- Foreign-memory flags missing → run via Gradle tasks (they inject `--enable-preview --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.vector`).&#10;- Systems idle → verify `ISystem` implementation, builder registration, and `GameLoop` is running or groups are stepped manually.&#10;- Publish `file://` errors → allow root Gradle script to resolve URIs; avoid manual `file://` entries.&#10;&#10;## 7. Beyond the Basics&#10;- See `docs/ADVANCED_GUIDE.md` for the query model (including `@Query`-based systems, generated `IGeneratedQuery`/`IQueryBuilder` usage, and advanced manual `ArchetypeQuery` APIs), parallel queries, QA/QC process, performance tuning, and historical appendices.&#10;- Track milestones in `docs/ROADMAP.md` (updated each milestone with backlog items).&#10;- Explore `ecs-test` and `ecs-benchmark` for canonical patterns and performance baselines." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ecs-core/src/main/java/com/ethnicthv/ecs/ECS.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ecs-core/src/main/java/com/ethnicthv/ecs/ECS.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import com.ethnicthv.ecs.core.components.IBindableHandle;&#10;import com.ethnicthv.ecs.core.system.*;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.function.Consumer;&#10;&#10;/**&#10; * ECS - The single entry point (Facade) for the Entity Component System.&#10; * &lt;p&gt;&#10; * Wraps ComponentManager, ArchetypeWorld, and SystemManager into a unified API.&#10; * Provides a Builder for fluent initialization and resource management via AutoCloseable.&#10; */&#10;public final class ECS implements AutoCloseable {&#10;&#10;    private final ArchetypeWorld world;&#10;    private final SystemManager systemManager;&#10;    private final GameLoop gameLoop;&#10;&#10;    // Private constructor, use ECS.builder() instead.&#10;    private ECS(ArchetypeWorld world, SystemManager systemManager) {&#10;        this.world = world;&#10;        this.systemManager = systemManager;&#10;        this.gameLoop = new GameLoop(systemManager);&#10;    }&#10;&#10;    /**&#10;     * Create a new Builder instance to configure the ECS world.&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    // =================================================================&#10;    // Public API Delegates&#10;    // =================================================================&#10;&#10;    /**&#10;     * Create a new entity with the specified component types.&#10;     * Components will be initialized with default (zero) values.&#10;     *&#10;     * @param components The component classes to add.&#10;     * @return The entity ID.&#10;     */&#10;    public int createEntity(Class&lt;?&gt;... components) {&#10;        // Delegate to the concrete overloads on ArchetypeWorld to avoid signature mismatch&#10;        return switch (components.length) {&#10;            case 0 -&gt; world.createEntity();&#10;            case 1 -&gt; world.createEntity(components[0]);&#10;            case 2 -&gt; world.createEntity(components[0], components[1]);&#10;            case 3 -&gt; world.createEntity(components[0], components[1], components[2]);&#10;            case 4 -&gt; world.createEntity(components[0], components[1], components[2], components[3]);&#10;            case 5 -&gt; world.createEntity(components[0], components[1], components[2], components[3], components[4]);&#10;            case 6 -&gt; world.createEntity(components[0], components[1], components[2], components[3], components[4], components[5]);&#10;            default -&gt; world.createEntityWithComponents(components);&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity and initialize it immediately using a zero-copy lambda.&#10;     * &lt;p&gt;&#10;     * Example:&#10;     * &lt;pre&gt;{@code&#10;     * ecs.addComponent(entityId, PositionComponent.class, (PositionHandle p) -&gt; {&#10;     *     p.setX(100);&#10;     *     p.setY(200);&#10;     * });&#10;     * }&lt;/pre&gt;&#10;     *&#10;     * @param entityId       The target entity ID.&#10;     * @param componentClass The component class to add.&#10;     * @param initializer    A lambda to configure the component data directly in the chunk.&#10;     * @param &lt;THandle&gt;      The type of the generated handle.&#10;     */&#10;    public &lt;THandle extends IBindableHandle&gt; void addComponent(&#10;            int entityId,&#10;            Class&lt;?&gt; componentClass,&#10;            Consumer&lt;THandle&gt; initializer&#10;    ) {&#10;        world.addComponent(entityId, componentClass, initializer);&#10;    }&#10;&#10;    /**&#10;     * Access the underlying ArchetypeWorld for advanced operations.&#10;     */&#10;    public ArchetypeWorld getWorld() {&#10;        return world;&#10;    }&#10;&#10;    /**&#10;     * Access the SystemManager to retrieve registered systems.&#10;     */&#10;    public SystemManager getSystemManager() {&#10;        return systemManager;&#10;    }&#10;&#10;    /**&#10;     * Start the main game loop (blocking).&#10;     */&#10;    public void run() {&#10;        gameLoop.run();&#10;    }&#10;&#10;    /**&#10;     * Stop the game loop gracefully.&#10;     */&#10;    public void stop() {&#10;        gameLoop.stop();&#10;    }&#10;&#10;    /**&#10;     * Closes the ECS world, releasing all off-heap memory resources (Arenas).&#10;     */&#10;    @Override&#10;    public void close() {&#10;        gameLoop.stop();&#10;        world.close();&#10;    }&#10;&#10;    /**&#10;     * Run a single system group once with the given deltaTime.&#10;     * This is useful for custom loops or tests that want fine-grained control&#10;     * without creating a full {@link GameLoop}.&#10;     */&#10;    public void updateGroup(SystemGroup group, float deltaTime) {&#10;        systemManager.updateGroup(group, deltaTime);&#10;    }&#10;&#10;    /**&#10;     * Create a {@link GameLoop} instance bound to this ECS's SystemManager.&#10;     * Caller is responsible for running and stopping the loop.&#10;     */&#10;    public GameLoop createGameLoop(float targetTickRate) {&#10;        return new GameLoop(systemManager, targetTickRate);&#10;    }&#10;&#10;    // =================================================================&#10;    // Builder Implementation&#10;    // =================================================================&#10;&#10;    public static class Builder {&#10;        private final ComponentManager componentManager = new ComponentManager();&#10;        private final List&lt;SystemRegistration&gt; systems = new ArrayList&lt;&gt;();&#10;        private boolean autoRegisterComponents = true;&#10;&#10;        record SystemRegistration(ISystem system, SystemGroup group) {}&#10;&#10;        /**&#10;         * Disable automatic registration of components found by the Annotation Processor.&#10;         * Use this if you want to manually control component registration order.&#10;         */&#10;        public Builder noAutoRegistration() {&#10;            this.autoRegisterComponents = false;&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Manually register a component.&#10;         * Useful if auto-registration is disabled or for runtime-defined components.&#10;         */&#10;        public Builder registerComponent(Class&lt;?&gt; componentClass) {&#10;            componentManager.registerComponent(componentClass);&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Add a System instance to be registered in the world in the default SIMULATION group.&#10;         * The SystemManager will automatically inject queries into this system.&#10;         */&#10;        public Builder addSystem(ISystem system) {&#10;            systems.add(new SystemRegistration(system, SystemGroup.SIMULATION));&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Add a System instance to be registered in a specific execution group.&#10;         */&#10;        public Builder addSystem(ISystem system, SystemGroup group) {&#10;            systems.add(new SystemRegistration(system, group));&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Build and initialize the ECS world.&#10;         * This will:&#10;         * 1. Auto-register components (if enabled).&#10;         * 2. Create the ArchetypeWorld.&#10;         * 3. Create the SystemManager and register all added systems.&#10;         */&#10;        public ECS build() {&#10;            // 1. Auto-register components via generated code&#10;            if (autoRegisterComponents) {&#10;                try {&#10;                    // Use reflection to avoid hard dependency on the generated class at compile time.&#10;                    Class&lt;?&gt; gen = Class.forName(&quot;com.ethnicthv.ecs.generated.GeneratedComponents&quot;, false, getClass().getClassLoader());&#10;                    java.lang.reflect.Method m = gen.getMethod(&quot;registerAll&quot;, ComponentManager.class);&#10;                    m.invoke(null, componentManager);&#10;                } catch (ClassNotFoundException e) {&#10;                    // This happens if the user hasn't run the build/AP yet.&#10;                    // We warn them but proceed (manual registration might still work).&#10;                    System.err.println(&quot;[ECS] Warning: 'GeneratedComponents' class not found. &quot; +&#10;                            &quot;Automatic component registration failed. &quot; +&#10;                            &quot;Ensure Annotation Processing is enabled and the project is built.&quot;);&#10;                } catch (ReflectiveOperationException e) {&#10;                    throw new IllegalStateException(&quot;Failed to invoke GeneratedComponents.registerAll&quot;, e);&#10;                }&#10;            }&#10;&#10;            ArchetypeWorld world = new ArchetypeWorld(componentManager);&#10;            SystemManager sysMgr = new SystemManager(world);&#10;&#10;            for (SystemRegistration reg : systems) {&#10;                sysMgr.registerPipelineSystem(reg.system(), reg.group());&#10;            }&#10;&#10;            return new ECS(world, sysMgr);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import com.ethnicthv.ecs.core.components.IBindableHandle;&#10;import com.ethnicthv.ecs.core.system.*;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.function.Consumer;&#10;&#10;/**&#10; * ECS - The single entry point (Facade) for the Entity Component System.&#10; * &lt;p&gt;&#10; * Wraps ComponentManager, ArchetypeWorld, and SystemManager into a unified API.&#10; * Provides a Builder for fluent initialization and resource management via AutoCloseable.&#10; */&#10;public final class ECS implements AutoCloseable {&#10;&#10;    private final ArchetypeWorld world;&#10;    private final SystemManager systemManager;&#10;    private final GameLoop gameLoop;&#10;&#10;    // Private constructor, use ECS.builder() instead.&#10;    private ECS(ArchetypeWorld world, SystemManager systemManager) {&#10;        this.world = world;&#10;        this.systemManager = systemManager;&#10;        this.gameLoop = new GameLoop(systemManager);&#10;    }&#10;&#10;    /**&#10;     * Create a new Builder instance to configure the ECS world.&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    // =================================================================&#10;    // Public API Delegates&#10;    // =================================================================&#10;&#10;    /**&#10;     * Create a new entity with the specified component types.&#10;     * Components will be initialized with default (zero) values.&#10;     *&#10;     * @param components The component classes to add.&#10;     * @return The entity ID.&#10;     */&#10;    public int createEntity(Class&lt;?&gt;... components) {&#10;        // Delegate to the concrete overloads on ArchetypeWorld to avoid signature mismatch&#10;        return switch (components.length) {&#10;            case 0 -&gt; world.createEntity();&#10;            case 1 -&gt; world.createEntity(components[0]);&#10;            case 2 -&gt; world.createEntity(components[0], components[1]);&#10;            case 3 -&gt; world.createEntity(components[0], components[1], components[2]);&#10;            case 4 -&gt; world.createEntity(components[0], components[1], components[2], components[3]);&#10;            case 5 -&gt; world.createEntity(components[0], components[1], components[2], components[3], components[4]);&#10;            case 6 -&gt; world.createEntity(components[0], components[1], components[2], components[3], components[4], components[5]);&#10;            default -&gt; world.createEntityWithComponents(components);&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity and initialize it immediately using a zero-copy lambda.&#10;     * &lt;p&gt;&#10;     * Example:&#10;     * &lt;pre&gt;{@code&#10;     * ecs.addComponent(entityId, PositionComponent.class, (PositionHandle p) -&gt; {&#10;     *     p.setX(100);&#10;     *     p.setY(200);&#10;     * });&#10;     * }&lt;/pre&gt;&#10;     *&#10;     * @param entityId       The target entity ID.&#10;     * @param componentClass The component class to add.&#10;     * @param initializer    A lambda to configure the component data directly in the chunk.&#10;     * @param &lt;THandle&gt;      The type of the generated handle.&#10;     */&#10;    public &lt;THandle extends IBindableHandle&gt; void addComponent(&#10;            int entityId,&#10;            Class&lt;?&gt; componentClass,&#10;            Consumer&lt;THandle&gt; initializer&#10;    ) {&#10;        world.addComponent(entityId, componentClass, initializer);&#10;    }&#10;&#10;    /**&#10;     * Access the underlying ArchetypeWorld for advanced operations.&#10;     */&#10;    public ArchetypeWorld getWorld() {&#10;        return world;&#10;    }&#10;&#10;    /**&#10;     * Access the SystemManager to retrieve registered systems.&#10;     */&#10;    public SystemManager getSystemManager() {&#10;        return systemManager;&#10;    }&#10;&#10;    /**&#10;     * Start the main game loop (blocking).&#10;     */&#10;    public void run() {&#10;        gameLoop.run();&#10;    }&#10;&#10;    /**&#10;     * Stop the game loop gracefully.&#10;     */&#10;    public void stop() {&#10;        gameLoop.stop();&#10;    }&#10;&#10;    /**&#10;     * Closes the ECS world, releasing all off-heap memory resources (Arenas).&#10;     */&#10;    @Override&#10;    public void close() {&#10;        gameLoop.stop();&#10;        world.close();&#10;    }&#10;&#10;    /**&#10;     * Run a single system group once with the given deltaTime.&#10;     * This is useful for custom loops or tests that want fine-grained control&#10;     * without creating a full {@link GameLoop}.&#10;     */&#10;    public void updateGroup(SystemGroup group, float deltaTime) {&#10;        systemManager.updateGroup(group, deltaTime);&#10;    }&#10;&#10;    /**&#10;     * Create a {@link GameLoop} instance bound to this ECS's SystemManager.&#10;     * Caller is responsible for running and stopping the loop.&#10;     */&#10;    public GameLoop createGameLoop(float targetTickRate) {&#10;        return new GameLoop(systemManager, targetTickRate);&#10;    }&#10;&#10;    // =================================================================&#10;    // Builder Implementation&#10;    // =================================================================&#10;&#10;    public static class Builder {&#10;        private final ComponentManager componentManager = new ComponentManager();&#10;        private final List&lt;SystemRegistration&gt; systems = new ArrayList&lt;&gt;();&#10;        private boolean autoRegisterComponents = true;&#10;&#10;        record SystemRegistration(ISystem system, SystemGroup group) {}&#10;&#10;        /**&#10;         * Disable automatic registration of components found by the Annotation Processor.&#10;         * Use this if you want to manually control component registration order.&#10;         */&#10;        public Builder noAutoRegistration() {&#10;            this.autoRegisterComponents = false;&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Manually register a component.&#10;         * Useful if auto-registration is disabled or for runtime-defined components.&#10;         */&#10;        public Builder registerComponent(Class&lt;?&gt; componentClass) {&#10;            componentManager.registerComponent(componentClass);&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Add a System instance to be registered in the world in the default SIMULATION group.&#10;         * The SystemManager will automatically inject queries into this system.&#10;         */&#10;        public Builder addSystem(ISystem system) {&#10;            systems.add(new SystemRegistration(system, SystemGroup.SIMULATION));&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Add a System instance to be registered in a specific execution group.&#10;         */&#10;        public Builder addSystem(ISystem system, SystemGroup group) {&#10;            systems.add(new SystemRegistration(system, group));&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Build and initialize the ECS world.&#10;         * This will:&#10;         * 1. Auto-register components (if enabled).&#10;         * 2. Create the ArchetypeWorld.&#10;         * 3. Create the SystemManager and register all added systems.&#10;         */&#10;        public ECS build() {&#10;            // 1. Auto-register components via generated code&#10;            if (autoRegisterComponents) {&#10;                try {&#10;                    // Use reflection to avoid hard dependency on the generated class at compile time.&#10;                    Class&lt;?&gt; gen = Class.forName(&quot;com.ethnicthv.ecs.generated.GeneratedComponents&quot;, false, getClass().getClassLoader());&#10;                    java.lang.reflect.Method m = gen.getMethod(&quot;registerAll&quot;, ComponentManager.class);&#10;                    m.invoke(null, componentManager);&#10;                } catch (ClassNotFoundException e) {&#10;                    // This happens if the user hasn't run the build/AP yet.&#10;                    // We warn them but proceed (manual registration might still work).&#10;                    System.err.println(&quot;[ECS] Warning: 'GeneratedComponents' class not found. &quot; +&#10;                            &quot;Automatic component registration failed. &quot; +&#10;                            &quot;Ensure Annotation Processing is enabled and the project is built.&quot;);&#10;                } catch (ReflectiveOperationException e) {&#10;                    throw new IllegalStateException(&quot;Failed to invoke GeneratedComponents.registerAll&quot;, e);&#10;                }&#10;            }&#10;&#10;            ArchetypeWorld world = new ArchetypeWorld(componentManager);&#10;            SystemManager sysMgr = new SystemManager(world);&#10;&#10;            for (SystemRegistration reg : systems) {&#10;                sysMgr.registerPipelineSystem(reg.system(), reg.group());&#10;            }&#10;&#10;            return new ECS(world, sysMgr);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/settings.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/settings.gradle.kts" />
              <option name="originalContent" value="rootProject.name = &quot;ecs&quot;&#10;include(&quot;:ecs-processor&quot;, &quot;:ecs-core&quot;, &quot;:ecs-benchmark&quot;, &quot;:ecs-test&quot;)" />
              <option name="updatedContent" value="rootProject.name = &quot;ecs&quot;&#10;include(&quot;:ecs-processor&quot;, &quot;:ecs-core&quot;, &quot;:ecs-benchmark&quot;, &quot;:ecs-test&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/ECS.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/ECS.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import com.ethnicthv.ecs.core.components.IBindableHandle;&#10;import com.ethnicthv.ecs.core.system.GameLoop;&#10;import com.ethnicthv.ecs.core.system.ISystem;&#10;import com.ethnicthv.ecs.core.system.SystemGroup;&#10;import com.ethnicthv.ecs.core.system.SystemManager;&#10;import com.ethnicthv.ecs.generated.GeneratedComponents;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.function.Consumer;&#10;&#10;/**&#10; * ECS - The single entry point (Facade) for the Entity Component System.&#10; * &lt;p&gt;&#10; * Wraps ComponentManager, ArchetypeWorld, and SystemManager into a unified API.&#10; * Provides a Builder for fluent initialization and resource management via AutoCloseable.&#10; */&#10;public final class ECS implements AutoCloseable {&#10;&#10;    private final ArchetypeWorld world;&#10;    private final SystemManager systemManager;&#10;    private final GameLoop gameLoop;&#10;&#10;    // Private constructor, use ECS.builder() instead.&#10;    private ECS(ArchetypeWorld world, SystemManager systemManager) {&#10;        this.world = world;&#10;        this.systemManager = systemManager;&#10;        this.gameLoop = new GameLoop(systemManager);&#10;    }&#10;&#10;    /**&#10;     * Create a new Builder instance to configure the ECS world.&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    // =================================================================&#10;    // Public API Delegates&#10;    // =================================================================&#10;&#10;    /**&#10;     * Create a new entity with the specified component types.&#10;     * Components will be initialized with default (zero) values.&#10;     *&#10;     * @param components The component classes to add.&#10;     * @return The entity ID.&#10;     */&#10;    public int createEntity(Class&lt;?&gt;... components) {&#10;        // Delegate to the concrete overloads on ArchetypeWorld to avoid signature mismatch&#10;        return switch (components.length) {&#10;            case 0 -&gt; world.createEntity();&#10;            case 1 -&gt; world.createEntity(components[0]);&#10;            case 2 -&gt; world.createEntity(components[0], components[1]);&#10;            case 3 -&gt; world.createEntity(components[0], components[1], components[2]);&#10;            case 4 -&gt; world.createEntity(components[0], components[1], components[2], components[3]);&#10;            case 5 -&gt; world.createEntity(components[0], components[1], components[2], components[3], components[4]);&#10;            case 6 -&gt; world.createEntity(components[0], components[1], components[2], components[3], components[4], components[5]);&#10;            default -&gt; world.createEntityWithComponents(components);&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity and initialize it immediately using a zero-copy lambda.&#10;     * &lt;p&gt;&#10;     * Example:&#10;     * &lt;pre&gt;{@code&#10;     * ecs.addComponent(entityId, PositionComponent.class, (PositionHandle p) -&gt; {&#10;     *     p.setX(100);&#10;     *     p.setY(200);&#10;     * });&#10;     * }&lt;/pre&gt;&#10;     *&#10;     * @param entityId       The target entity ID.&#10;     * @param componentClass The component class to add.&#10;     * @param initializer    A lambda to configure the component data directly in the chunk.&#10;     * @param &lt;THandle&gt;      The type of the generated handle.&#10;     */&#10;    public &lt;THandle extends IBindableHandle&gt; void addComponent(&#10;            int entityId,&#10;            Class&lt;?&gt; componentClass,&#10;            Consumer&lt;THandle&gt; initializer&#10;    ) {&#10;        world.addComponent(entityId, componentClass, initializer);&#10;    }&#10;&#10;    /**&#10;     * Access the underlying ArchetypeWorld for advanced operations.&#10;     */&#10;    public ArchetypeWorld getWorld() {&#10;        return world;&#10;    }&#10;&#10;    /**&#10;     * Access the SystemManager to retrieve registered systems.&#10;     */&#10;    public SystemManager getSystemManager() {&#10;        return systemManager;&#10;    }&#10;&#10;    /**&#10;     * Start the main game loop (blocking).&#10;     */&#10;    public void run() {&#10;        gameLoop.run();&#10;    }&#10;&#10;    /**&#10;     * Stop the game loop gracefully.&#10;     */&#10;    public void stop() {&#10;        gameLoop.stop();&#10;    }&#10;&#10;    /**&#10;     * Closes the ECS world, releasing all off-heap memory resources (Arenas).&#10;     */&#10;    @Override&#10;    public void close() {&#10;        gameLoop.stop();&#10;        world.close();&#10;    }&#10;&#10;    /**&#10;     * Run a single system group once with the given deltaTime.&#10;     * This is useful for custom loops or tests that want fine-grained control&#10;     * without creating a full {@link GameLoop}.&#10;     */&#10;    public void updateGroup(SystemGroup group, float deltaTime) {&#10;        systemManager.updateGroup(group, deltaTime);&#10;    }&#10;&#10;    /**&#10;     * Create a {@link GameLoop} instance bound to this ECS's SystemManager.&#10;     * Caller is responsible for running and stopping the loop.&#10;     */&#10;    public GameLoop createGameLoop(float targetTickRate) {&#10;        return new GameLoop(systemManager, targetTickRate);&#10;    }&#10;&#10;    // =================================================================&#10;    // Builder Implementation&#10;    // =================================================================&#10;&#10;    public static class Builder {&#10;        // We create ComponentManager first because it is the Source of Truth for IDs.&#10;        private final ComponentManager componentManager = new ComponentManager();&#10;        private final List&lt;SystemRegistration&gt; systems = new ArrayList&lt;&gt;();&#10;        private boolean autoRegisterComponents = true;&#10;&#10;        record SystemRegistration(ISystem system, SystemGroup group) {}&#10;&#10;        /**&#10;         * Disable automatic registration of components found by the Annotation Processor.&#10;         * Use this if you want to manually control component registration order.&#10;         */&#10;        public Builder noAutoRegistration() {&#10;            this.autoRegisterComponents = false;&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Manually register a component.&#10;         * Useful if auto-registration is disabled or for runtime-defined components.&#10;         */&#10;        public Builder registerComponent(Class&lt;?&gt; componentClass) {&#10;            componentManager.registerComponent(componentClass);&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Add a System instance to be registered in the world in the default SIMULATION group.&#10;         * The SystemManager will automatically inject queries into this system.&#10;         */&#10;        public Builder addSystem(ISystem system) {&#10;            systems.add(new SystemRegistration(system, SystemGroup.SIMULATION));&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Add a System instance to be registered in a specific execution group.&#10;         */&#10;        public Builder addSystem(ISystem system, SystemGroup group) {&#10;            systems.add(new SystemRegistration(system, group));&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Build and initialize the ECS world.&#10;         * This will:&#10;         * 1. Auto-register components (if enabled).&#10;         * 2. Create the ArchetypeWorld.&#10;         * 3. Create the SystemManager and register all added systems.&#10;         */&#10;        public ECS build() {&#10;            // 1. Auto-register components via generated code&#10;            if (autoRegisterComponents) {&#10;                try {&#10;                    // Use reflection to avoid hard dependency on the generated class at compile time.&#10;                    Class&lt;?&gt; gen = Class.forName(&quot;com.ethnicthv.ecs.generated.GeneratedComponents&quot;, false, getClass().getClassLoader());&#10;                    java.lang.reflect.Method m = gen.getMethod(&quot;registerAll&quot;, ComponentManager.class);&#10;                    m.invoke(null, componentManager);&#10;                } catch (ClassNotFoundException e) {&#10;                    // This happens if the user hasn't run the build/AP yet.&#10;                    // We warn them but proceed (manual registration might still work).&#10;                    System.err.println(&quot;[ECS] Warning: 'GeneratedComponents' class not found. &quot; +&#10;                            &quot;Automatic component registration failed. &quot; +&#10;                            &quot;Ensure Annotation Processing is enabled and the project is built.&quot;);&#10;                } catch (ReflectiveOperationException e) {&#10;                    throw new IllegalStateException(&quot;Failed to invoke GeneratedComponents.registerAll&quot;, e);&#10;                }&#10;            }&#10;&#10;            // 2. Create World (ComponentManager passed in as the single source of truth)&#10;            ArchetypeWorld world = new ArchetypeWorld(componentManager);&#10;&#10;            // 3. Create SystemManager&#10;            SystemManager sysMgr = new SystemManager(world);&#10;&#10;            // 4. Register Systems (Dependency Injection happens here)&#10;            for (SystemRegistration reg : systems) {&#10;                try {&#10;                    sysMgr.registerPipelineSystem(reg.system(), reg.group());&#10;                } catch (Exception ex) {&#10;                    throw new IllegalStateException(&quot;Failed to register system &quot; + reg.system().getClass().getName(), ex);&#10;                }&#10;            }&#10;&#10;            return new ECS(world, sysMgr);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import com.ethnicthv.ecs.core.components.IBindableHandle;&#10;import com.ethnicthv.ecs.core.system.GameLoop;&#10;import com.ethnicthv.ecs.core.system.ISystem;&#10;import com.ethnicthv.ecs.core.system.SystemGroup;&#10;import com.ethnicthv.ecs.core.system.SystemManager;&#10;import com.ethnicthv.ecs.generated.GeneratedComponents;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.function.Consumer;&#10;&#10;/**&#10; * ECS - The single entry point (Facade) for the Entity Component System.&#10; * &lt;p&gt;&#10; * Wraps ComponentManager, ArchetypeWorld, and SystemManager into a unified API.&#10; * Provides a Builder for fluent initialization and resource management via AutoCloseable.&#10; */&#10;public final class ECS implements AutoCloseable {&#10;&#10;    private final ArchetypeWorld world;&#10;    private final SystemManager systemManager;&#10;    private final GameLoop gameLoop;&#10;&#10;    // Private constructor, use ECS.builder() instead.&#10;    private ECS(ArchetypeWorld world, SystemManager systemManager) {&#10;        this.world = world;&#10;        this.systemManager = systemManager;&#10;        this.gameLoop = new GameLoop(systemManager);&#10;    }&#10;&#10;    /**&#10;     * Create a new Builder instance to configure the ECS world.&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    // =================================================================&#10;    // Public API Delegates&#10;    // =================================================================&#10;&#10;    /**&#10;     * Create a new entity with the specified component types.&#10;     * Components will be initialized with default (zero) values.&#10;     *&#10;     * @param components The component classes to add.&#10;     * @return The entity ID.&#10;     */&#10;    public int createEntity(Class&lt;?&gt;... components) {&#10;        // Delegate to the concrete overloads on ArchetypeWorld to avoid signature mismatch&#10;        return switch (components.length) {&#10;            case 0 -&gt; world.createEntity();&#10;            case 1 -&gt; world.createEntity(components[0]);&#10;            case 2 -&gt; world.createEntity(components[0], components[1]);&#10;            case 3 -&gt; world.createEntity(components[0], components[1], components[2]);&#10;            case 4 -&gt; world.createEntity(components[0], components[1], components[2], components[3]);&#10;            case 5 -&gt; world.createEntity(components[0], components[1], components[2], components[3], components[4]);&#10;            case 6 -&gt; world.createEntity(components[0], components[1], components[2], components[3], components[4], components[5]);&#10;            default -&gt; world.createEntityWithComponents(components);&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity and initialize it immediately using a zero-copy lambda.&#10;     * &lt;p&gt;&#10;     * Example:&#10;     * &lt;pre&gt;{@code&#10;     * ecs.addComponent(entityId, PositionComponent.class, (PositionHandle p) -&gt; {&#10;     *     p.setX(100);&#10;     *     p.setY(200);&#10;     * });&#10;     * }&lt;/pre&gt;&#10;     *&#10;     * @param entityId       The target entity ID.&#10;     * @param componentClass The component class to add.&#10;     * @param initializer    A lambda to configure the component data directly in the chunk.&#10;     * @param &lt;THandle&gt;      The type of the generated handle.&#10;     */&#10;    public &lt;THandle extends IBindableHandle&gt; void addComponent(&#10;            int entityId,&#10;            Class&lt;?&gt; componentClass,&#10;            Consumer&lt;THandle&gt; initializer&#10;    ) {&#10;        world.addComponent(entityId, componentClass, initializer);&#10;    }&#10;&#10;    /**&#10;     * Access the underlying ArchetypeWorld for advanced operations.&#10;     */&#10;    public ArchetypeWorld getWorld() {&#10;        return world;&#10;    }&#10;&#10;    /**&#10;     * Access the SystemManager to retrieve registered systems.&#10;     */&#10;    public SystemManager getSystemManager() {&#10;        return systemManager;&#10;    }&#10;&#10;    /**&#10;     * Start the main game loop (blocking).&#10;     */&#10;    public void run() {&#10;        gameLoop.run();&#10;    }&#10;&#10;    /**&#10;     * Stop the game loop gracefully.&#10;     */&#10;    public void stop() {&#10;        gameLoop.stop();&#10;    }&#10;&#10;    /**&#10;     * Closes the ECS world, releasing all off-heap memory resources (Arenas).&#10;     */&#10;    @Override&#10;    public void close() {&#10;        gameLoop.stop();&#10;        world.close();&#10;    }&#10;&#10;    /**&#10;     * Run a single system group once with the given deltaTime.&#10;     * This is useful for custom loops or tests that want fine-grained control&#10;     * without creating a full {@link GameLoop}.&#10;     */&#10;    public void updateGroup(SystemGroup group, float deltaTime) {&#10;        systemManager.updateGroup(group, deltaTime);&#10;    }&#10;&#10;    /**&#10;     * Create a {@link GameLoop} instance bound to this ECS's SystemManager.&#10;     * Caller is responsible for running and stopping the loop.&#10;     */&#10;    public GameLoop createGameLoop(float targetTickRate) {&#10;        return new GameLoop(systemManager, targetTickRate);&#10;    }&#10;&#10;    // =================================================================&#10;    // Builder Implementation&#10;    // =================================================================&#10;&#10;    public static class Builder {&#10;        // We create ComponentManager first because it is the Source of Truth for IDs.&#10;        private final ComponentManager componentManager = new ComponentManager();&#10;        private final List&lt;SystemRegistration&gt; systems = new ArrayList&lt;&gt;();&#10;        private boolean autoRegisterComponents = true;&#10;&#10;        record SystemRegistration(ISystem system, SystemGroup group) {}&#10;&#10;        /**&#10;         * Disable automatic registration of components found by the Annotation Processor.&#10;         * Use this if you want to manually control component registration order.&#10;         */&#10;        public Builder noAutoRegistration() {&#10;            this.autoRegisterComponents = false;&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Manually register a component.&#10;         * Useful if auto-registration is disabled or for runtime-defined components.&#10;         */&#10;        public Builder registerComponent(Class&lt;?&gt; componentClass) {&#10;            componentManager.registerComponent(componentClass);&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Add a System instance to be registered in the world in the default SIMULATION group.&#10;         * The SystemManager will automatically inject queries into this system.&#10;         */&#10;        public Builder addSystem(ISystem system) {&#10;            systems.add(new SystemRegistration(system, SystemGroup.SIMULATION));&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Add a System instance to be registered in a specific execution group.&#10;         */&#10;        public Builder addSystem(ISystem system, SystemGroup group) {&#10;            systems.add(new SystemRegistration(system, group));&#10;            return this;&#10;        }&#10;&#10;        /**&#10;         * Build and initialize the ECS world.&#10;         * This will:&#10;         * 1. Auto-register components (if enabled).&#10;         * 2. Create the ArchetypeWorld.&#10;         * 3. Create the SystemManager and register all added systems.&#10;         */&#10;        public ECS build() {&#10;            // 1. Auto-register components via generated code&#10;            if (autoRegisterComponents) {&#10;                try {&#10;                    // Use reflection to avoid hard dependency on the generated class at compile time.&#10;                    Class&lt;?&gt; gen = Class.forName(&quot;com.ethnicthv.ecs.generated.GeneratedComponents&quot;, false, getClass().getClassLoader());&#10;                    java.lang.reflect.Method m = gen.getMethod(&quot;registerAll&quot;, ComponentManager.class);&#10;                    m.invoke(null, componentManager);&#10;                } catch (ClassNotFoundException e) {&#10;                    // This happens if the user hasn't run the build/AP yet.&#10;                    // We warn them but proceed (manual registration might still work).&#10;                    System.err.println(&quot;[ECS] Warning: 'GeneratedComponents' class not found. &quot; +&#10;                            &quot;Automatic component registration failed. &quot; +&#10;                            &quot;Ensure Annotation Processing is enabled and the project is built.&quot;);&#10;                } catch (ReflectiveOperationException e) {&#10;                    throw new IllegalStateException(&quot;Failed to invoke GeneratedComponents.registerAll&quot;, e);&#10;                }&#10;            }&#10;&#10;            // 2. Create World (ComponentManager passed in as the single source of truth)&#10;            ArchetypeWorld world = new ArchetypeWorld(componentManager);&#10;&#10;            // 3. Create SystemManager&#10;            SystemManager sysMgr = new SystemManager(world);&#10;&#10;            // 4. Register Systems (Dependency Injection happens here)&#10;            for (SystemRegistration reg : systems) {&#10;                try {&#10;                    sysMgr.registerPipelineSystem(reg.system(), reg.group());&#10;                } catch (Exception ex) {&#10;                    throw new IllegalStateException(&quot;Failed to register system &quot; + reg.system().getClass().getName(), ex);&#10;                }&#10;            }&#10;&#10;            return new ECS(world, sysMgr);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeChunk.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeChunk.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk {&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                size.incrementAndGet();&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                size.decrementAndGet();&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk {&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                size.incrementAndGet();&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                size.decrementAndGet();&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] componentIds = m.toComponentIdArray();&#10;            ComponentDescriptor[] descriptors = new ComponentDescriptor[componentIds.length];&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                var meta = metadataProvider.apply(componentIds[i]);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + componentIds[i]);&#10;                }&#10;                descriptors[i] = componentManager.getDescriptor(meta.type());&#10;            }&#10;            return new Archetype(m, componentIds, descriptors, arena);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] componentIds = m.toComponentIdArray();&#10;            ComponentDescriptor[] descriptors = new ComponentDescriptor[componentIds.length];&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                var meta = metadataProvider.apply(componentIds[i]);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + componentIds[i]);&#10;                }&#10;                descriptors[i] = componentManager.getDescriptor(meta.type());&#10;            }&#10;            return new Archetype(m, componentIds, descriptors, arena);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeQuery.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeQuery.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentHandle;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (ArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                consumer.accept(entityId, location, chunk, archetype);&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities, providing pooled ComponentHandles for the requested component classes.&#10;     * The consumer receives an array of bound ComponentHandle (same order as componentClasses). The handles are released&#10;     * back to the manager after the consumer returns. This is intended for synchronous, short-lived access inside the consumer.&#10;     */&#10;    public void forEachEntityWith(EntityWithHandlesConsumer consumer, Class&lt;?&gt;... componentClasses) {&#10;        // Resolve component type IDs for requested classes&#10;        int[] reqTypeIds = new int[componentClasses.length];&#10;        for (int i = 0; i &lt; componentClasses.length; i++) {&#10;            Integer tid = world.getComponentTypeId(componentClasses[i]);&#10;            if (tid == null) {&#10;                // If a requested component class is not registered, no entity will match; return early&#10;                return;&#10;            }&#10;            reqTypeIds[i] = tid;&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            int[] compIndices = new int[reqTypeIds.length];&#10;            for (int i = 0; i &lt; reqTypeIds.length; i++) {&#10;                int idx = archetype.indexOfComponentType(reqTypeIds[i]);&#10;                if (idx &lt; 0) {&#10;                    // archetype missing at least one required component; skip it&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;&#10;            // Iterate entities in archetype&#10;            final int[] useIdx = compIndices; // capture&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; useIdx.length; k++) {&#10;                        int compIdx = useIdx[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, location, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeConsumer {&#10;        void accept(Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ChunkConsumer {&#10;        void accept(ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityConsumer {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityWithHandlesConsumer {&#10;        void accept(int entityId, ComponentHandle[] handles, ArchetypeChunk.ChunkLocation location, Archetype archetype);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentHandle;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) {&#10;        this.world = world;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    public void forEach(ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) {&#10;                    if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; }&#10;                }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    public void forEachChunk(ChunkConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            for (ArchetypeChunk chunk : archetype.getChunks()) {&#10;                consumer.accept(chunk, archetype);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    public void forEachEntity(EntityConsumer consumer) {&#10;        forEach(archetype -&gt; {&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                consumer.accept(entityId, location, chunk, archetype);&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities, providing pooled ComponentHandles for the requested component classes.&#10;     * The consumer receives an array of bound ComponentHandle (same order as componentClasses). The handles are released&#10;     * back to the manager after the consumer returns. This is intended for synchronous, short-lived access inside the consumer.&#10;     */&#10;    public void forEachEntityWith(EntityWithHandlesConsumer consumer, Class&lt;?&gt;... componentClasses) {&#10;        // Resolve component type IDs for requested classes&#10;        int[] reqTypeIds = new int[componentClasses.length];&#10;        for (int i = 0; i &lt; componentClasses.length; i++) {&#10;            Integer tid = world.getComponentTypeId(componentClasses[i]);&#10;            if (tid == null) {&#10;                // If a requested component class is not registered, no entity will match; return early&#10;                return;&#10;            }&#10;            reqTypeIds[i] = tid;&#10;        }&#10;&#10;        ComponentManager mgr = world.getComponentManager();&#10;&#10;        forEach(archetype -&gt; {&#10;            // Compute component indices for this archetype using its internal cache&#10;            int[] compIndices = new int[reqTypeIds.length];&#10;            for (int i = 0; i &lt; reqTypeIds.length; i++) {&#10;                int idx = archetype.indexOfComponentType(reqTypeIds[i]);&#10;                if (idx &lt; 0) {&#10;                    // archetype missing at least one required component; skip it&#10;                    return;&#10;                }&#10;                compIndices[i] = idx;&#10;            }&#10;&#10;            // Iterate entities in archetype&#10;            final int[] useIdx = compIndices; // capture&#10;            archetype.forEach((entityId, location, chunk) -&gt; {&#10;                ComponentManager.BoundHandle[] bound = new ComponentManager.BoundHandle[componentClasses.length];&#10;                ComponentHandle[] handles = new ComponentHandle[componentClasses.length];&#10;                try {&#10;                    for (int k = 0; k &lt; useIdx.length; k++) {&#10;                        int compIdx = useIdx[k];&#10;                        var seg = chunk.getComponentData(compIdx, location.indexInChunk);&#10;                        bound[k] = mgr.acquireBoundHandle(componentClasses[k], seg);&#10;                        handles[k] = bound[k].handle();&#10;                    }&#10;&#10;                    consumer.accept(entityId, handles, location, archetype);&#10;                } finally {&#10;                    for (ComponentManager.BoundHandle boundHandle : bound) {&#10;                        if (boundHandle != null) {&#10;                            try { boundHandle.close(); } catch (Exception ignored) {}&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ArchetypeConsumer {&#10;        void accept(Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ChunkConsumer {&#10;        void accept(ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityConsumer {&#10;        void accept(int entityId, ArchetypeChunk.ChunkLocation location, ArchetypeChunk chunk, Archetype archetype);&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface EntityWithHandlesConsumer {&#10;        void accept(int entityId, ComponentHandle[] handles, ArchetypeChunk.ChunkLocation location, Archetype archetype);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeWorld.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ArchetypeWorld.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ComponentManager componentManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    private final AtomicInteger nextComponentTypeId = new AtomicInteger(0);&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentMetadata = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentTypeIds.computeIfAbsent(componentClass, cls -&gt; {&#10;            int tid = componentManager.registerComponent(cls);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(cls);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, cls, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id atomically&#10;            nextComponentTypeId.updateAndGet(prev -&gt; Math.max(prev, tid + 1));&#10;            return tid;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query for entities matching component requirements&#10;     */&#10;    public ArchetypeQuery query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Delegate archetype construction to ArchetypeManager&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;&#10;        // Copy existing component data (only components present in both)&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;        int[] componentIds = newMask.toComponentIdArray();&#10;        for (int componentTypeId : componentIds) {&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ArchetypeWorld - Main ECS World using Archetype pattern&#10; * &lt;p&gt;&#10; * Manages entities, components, and archetypes for cache-friendly data access.&#10; * Entities with the same component composition are grouped together in archetypes.&#10; */&#10;public final class ArchetypeWorld implements AutoCloseable {&#10;    private final ArchetypeManager archetypeManager;&#10;    private final ComponentManager componentManager;&#10;    private final ConcurrentHashMap&lt;Integer, EntityRecord&gt; entityRecords; // entityId -&gt; location in archetype&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, ComponentMetadata&gt; componentMetadata;&#10;    private final Arena arena;&#10;    private final AtomicInteger nextEntityId = new AtomicInteger(1);&#10;    private final AtomicInteger nextComponentTypeId = new AtomicInteger(0);&#10;&#10;    public ArchetypeWorld(ComponentManager componentManager) {&#10;        this.arena = Arena.ofShared();&#10;        this.componentManager = componentManager;&#10;        this.entityRecords = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;        this.componentMetadata = new ConcurrentHashMap&lt;&gt;();&#10;        // Initialize ArchetypeManager after metadata map is ready&#10;        this.archetypeManager = new ArchetypeManager(arena, componentManager, this::getComponentMetadata);&#10;    }&#10;&#10;    /**&#10;     * Register a component type via ComponentManager&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        return componentTypeIds.computeIfAbsent(componentClass, cls -&gt; {&#10;            int tid = componentManager.registerComponent(cls);&#10;            // store metadata from descriptor&#10;            ComponentDescriptor desc = componentManager.getDescriptor(cls);&#10;            componentMetadata.put(tid, new ComponentMetadata(tid, cls, desc.getTotalSize()));&#10;            // update nextComponentTypeId to reflect assigned id atomically&#10;            nextComponentTypeId.updateAndGet(prev -&gt; Math.max(prev, tid + 1));&#10;            return tid;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create a new entity&#10;     */&#10;    public int createEntity() {&#10;        int entityId = nextEntityId.getAndIncrement();&#10;        // Start with empty archetype (no components)&#10;        ComponentMask emptyMask = new ComponentMask();&#10;        Archetype archetype = archetypeManager.getOrCreateArchetype(emptyMask);&#10;        ArchetypeChunk.ChunkLocation location = archetype.addEntity(entityId);&#10;        entityRecords.put(entityId, new EntityRecord(archetype, location, emptyMask));&#10;        return entityId;&#10;    }&#10;&#10;    /**&#10;     * Add a component to an entity&#10;     */&#10;    public &lt;T&gt; void addComponent(int entityId, Class&lt;T&gt; componentClass, MemorySegment data) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null) {&#10;            throw new IllegalArgumentException(&quot;Component type &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;&#10;        // Create new mask with the additional component&#10;        ComponentMask newMask = record.mask.set(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;&#10;        // Set component data&#10;        EntityRecord newRecord = entityRecords.get(entityId);&#10;        int componentIndex = newRecord.archetype.indexOfComponentType(componentTypeId);&#10;        newRecord.archetype.setComponentData(newRecord.location, componentIndex, data);&#10;    }&#10;&#10;    /**&#10;     * Remove a component from an entity&#10;     */&#10;    public &lt;T&gt; void removeComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            throw new IllegalArgumentException(&quot;Entity &quot; + entityId + &quot; does not exist&quot;);&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return; // Component doesn't exist on this entity&#10;        }&#10;&#10;        // Create new mask without the component&#10;        ComponentMask newMask = record.mask.clear(componentTypeId);&#10;&#10;        // Move entity to new archetype&#10;        moveEntityToArchetype(entityId, record, newMask);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public &lt;T&gt; MemorySegment getComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return null;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        if (componentTypeId == null || !record.mask.has(componentTypeId)) {&#10;            return null;&#10;        }&#10;&#10;        int componentIndex = record.archetype.indexOfComponentType(componentTypeId);&#10;        return record.archetype.getComponentData(record.location, componentIndex);&#10;    }&#10;&#10;    /**&#10;     * Check if entity has a component&#10;     */&#10;    public &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass) {&#10;        EntityRecord record = entityRecords.get(entityId);&#10;        if (record == null) {&#10;            return false;&#10;        }&#10;&#10;        Integer componentTypeId = componentTypeIds.get(componentClass);&#10;        return componentTypeId != null &amp;&amp; record.mask.has(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Destroy an entity&#10;     */&#10;    public void destroyEntity(int entityId) {&#10;        EntityRecord record = entityRecords.remove(entityId);&#10;        if (record != null) {&#10;            record.archetype.removeEntity(record.location);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a query for entities matching component requirements&#10;     */&#10;    public ArchetypeQuery query() {&#10;        return new ArchetypeQuery(this);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypeManager.getAllArchetypes();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count&#10;     */&#10;    public int getEntityCount() {&#10;        return entityRecords.size();&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getComponentTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component metadata&#10;     */&#10;    public ComponentMetadata getComponentMetadata(int componentTypeId) {&#10;        return componentMetadata.get(componentTypeId);&#10;    }&#10;&#10;    /**&#10;     * Close the world and release resources&#10;     */&#10;    public void close() {&#10;        arena.close();&#10;    }&#10;&#10;    public ComponentManager getComponentManager() {&#10;        return componentManager;&#10;    }&#10;&#10;    // ============ Internal Methods ============&#10;&#10;    private void moveEntityToArchetype(int entityId, EntityRecord oldRecord, ComponentMask newMask) {&#10;        // Delegate archetype construction to ArchetypeManager&#10;        Archetype newArchetype = archetypeManager.getOrCreateArchetype(newMask);&#10;&#10;        // Copy existing component data (only components present in both)&#10;        ArchetypeChunk.ChunkLocation newLocation = newArchetype.addEntity(entityId);&#10;        int[] componentIds = newMask.toComponentIdArray();&#10;        for (int componentTypeId : componentIds) {&#10;            if (oldRecord.mask.has(componentTypeId)) {&#10;                int oldIdx = oldRecord.archetype.indexOfComponentType(componentTypeId);&#10;                int newIdx = newArchetype.indexOfComponentType(componentTypeId);&#10;                if (oldIdx &gt;= 0 &amp;&amp; newIdx &gt;= 0) {&#10;                    MemorySegment oldData = oldRecord.archetype.getComponentData(oldRecord.location, oldIdx);&#10;                    if (oldData != null) {&#10;                        newArchetype.setComponentData(newLocation, newIdx, oldData);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Remove from old archetype&#10;        oldRecord.archetype.removeEntity(oldRecord.location);&#10;&#10;        // Update entity record&#10;        entityRecords.put(entityId, new EntityRecord(newArchetype, newLocation, newMask));&#10;    }&#10;&#10;    // ============ Internal Records ============&#10;&#10;    record EntityRecord(Archetype archetype, ArchetypeChunk.ChunkLocation location, ComponentMask mask) {}&#10;&#10;    public record ComponentMetadata(int id, Class&lt;?&gt; type, long size) {}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ComponentMask.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/ComponentMask.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import java.util.BitSet;&#10;&#10;/**&#10; * Represents a unique signature of components that an entity possesses.&#10; * Used to identify and group entities with the same component composition.&#10; */&#10;public final class ComponentMask {&#10;    private final BitSet mask;&#10;    private final int hashCode;&#10;&#10;    public ComponentMask() {&#10;        this.mask = new BitSet();&#10;        this.hashCode = 0;&#10;    }&#10;&#10;    private ComponentMask(BitSet mask) {&#10;        this.mask = (BitSet) mask.clone();&#10;        this.hashCode = mask.hashCode();&#10;    }&#10;&#10;    /**&#10;     * Set a component bit in the mask&#10;     */&#10;    public ComponentMask set(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.set(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Clear a component bit from the mask&#10;     */&#10;    public ComponentMask clear(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.clear(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Check if a component is present in the mask&#10;     */&#10;    public boolean has(int componentId) {&#10;        return mask.get(componentId);&#10;    }&#10;&#10;    /**&#10;     * Check if this mask contains all components from another mask&#10;     */&#10;    public boolean contains(ComponentMask other) {&#10;        BitSet intersection = (BitSet) mask.clone();&#10;        intersection.and(other.mask);&#10;        return intersection.equals(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask is a superset of other (WITH semantics).&#10;     */&#10;    public boolean containsAll(ComponentMask other) {&#10;        // other - this == empty ?&#10;        BitSet diff = (BitSet) other.mask.clone();&#10;        diff.andNot(this.mask);&#10;        return diff.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask shares at least one bit with other (ANY semantics).&#10;     */&#10;    public boolean intersects(ComponentMask other) {&#10;        return this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask has no bits in common with other (WITHOUT semantics).&#10;     */&#10;    public boolean containsNone(ComponentMask other) {&#10;        return !this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Get the number of components in this mask&#10;     */&#10;    public int cardinality() {&#10;        return mask.cardinality();&#10;    }&#10;&#10;    /**&#10;     * Return all set component IDs in ascending order.&#10;     */&#10;    public int[] toComponentIdArray() {&#10;        int count = mask.cardinality();&#10;        int[] ids = new int[count];&#10;        int idx = 0;&#10;        for (int bit = mask.nextSetBit(0); bit &gt;= 0; bit = mask.nextSetBit(bit + 1)) {&#10;            ids[idx++] = bit;&#10;        }&#10;        return ids;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        ComponentMask that = (ComponentMask) o;&#10;        return mask.equals(that.mask);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return hashCode;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;ComponentMask{&quot; + mask + '}';&#10;    }&#10;&#10;    /**&#10;     * Create a builder for fluent API&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    public static class Builder {&#10;        private final BitSet mask = new BitSet();&#10;&#10;        public Builder with(int componentId) {&#10;            mask.set(componentId);&#10;            return this;&#10;        }&#10;&#10;        public ComponentMask build() {&#10;            return new ComponentMask(mask);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import java.util.BitSet;&#10;&#10;/**&#10; * Represents a unique signature of components that an entity possesses.&#10; * Used to identify and group entities with the same component composition.&#10; */&#10;public final class ComponentMask {&#10;    private final BitSet mask;&#10;    private final int hashCode;&#10;&#10;    public ComponentMask() {&#10;        this.mask = new BitSet();&#10;        this.hashCode = 0;&#10;    }&#10;&#10;    private ComponentMask(BitSet mask) {&#10;        this.mask = (BitSet) mask.clone();&#10;        this.hashCode = mask.hashCode();&#10;    }&#10;&#10;    /**&#10;     * Set a component bit in the mask&#10;     */&#10;    public ComponentMask set(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.set(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Clear a component bit from the mask&#10;     */&#10;    public ComponentMask clear(int componentId) {&#10;        BitSet newMask = (BitSet) mask.clone();&#10;        newMask.clear(componentId);&#10;        return new ComponentMask(newMask);&#10;    }&#10;&#10;    /**&#10;     * Check if a component is present in the mask&#10;     */&#10;    public boolean has(int componentId) {&#10;        return mask.get(componentId);&#10;    }&#10;&#10;    /**&#10;     * Check if this mask contains all components from another mask&#10;     */&#10;    public boolean contains(ComponentMask other) {&#10;        BitSet intersection = (BitSet) mask.clone();&#10;        intersection.and(other.mask);&#10;        return intersection.equals(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask is a superset of other (WITH semantics).&#10;     */&#10;    public boolean containsAll(ComponentMask other) {&#10;        // other - this == empty ?&#10;        BitSet diff = (BitSet) other.mask.clone();&#10;        diff.andNot(this.mask);&#10;        return diff.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask shares at least one bit with other (ANY semantics).&#10;     */&#10;    public boolean intersects(ComponentMask other) {&#10;        return this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Optimized: return true if this mask has no bits in common with other (WITHOUT semantics).&#10;     */&#10;    public boolean containsNone(ComponentMask other) {&#10;        return !this.mask.intersects(other.mask);&#10;    }&#10;&#10;    /**&#10;     * Get the number of components in this mask&#10;     */&#10;    public int cardinality() {&#10;        return mask.cardinality();&#10;    }&#10;&#10;    /**&#10;     * Return all set component IDs in ascending order.&#10;     */&#10;    public int[] toComponentIdArray() {&#10;        int count = mask.cardinality();&#10;        int[] ids = new int[count];&#10;        int idx = 0;&#10;        for (int bit = mask.nextSetBit(0); bit &gt;= 0; bit = mask.nextSetBit(bit + 1)) {&#10;            ids[idx++] = bit;&#10;        }&#10;        return ids;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        ComponentMask that = (ComponentMask) o;&#10;        return mask.equals(that.mask);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return hashCode;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;ComponentMask{&quot; + mask + '}';&#10;    }&#10;&#10;    /**&#10;     * Create a builder for fluent API&#10;     */&#10;    public static Builder builder() {&#10;        return new Builder();&#10;    }&#10;&#10;    public static class Builder {&#10;        private final BitSet mask = new BitSet();&#10;&#10;        public Builder with(int componentId) {&#10;            mask.set(componentId);&#10;            return this;&#10;        }&#10;&#10;        public ComponentMask build() {&#10;            return new ComponentMask(mask);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/system/ArchetypeMovementSystem.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/archetype/system/ArchetypeMovementSystem.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype.system;&#10;&#10;import com.ethnicthv.ecs.archetype.Archetype;&#10;import com.ethnicthv.ecs.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.components.PositionComponent;&#10;import com.ethnicthv.ecs.components.VelocityComponent;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Movement system optimized for Archetype-based ECS.&#10; * Processes entities in cache-friendly chunks.&#10; */&#10;public final class ArchetypeMovementSystem {&#10;    private final ArchetypeWorld world;&#10;    private final int positionTypeId;&#10;    private final int velocityTypeId;&#10;&#10;    public ArchetypeMovementSystem(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.positionTypeId = world.getComponentTypeId(PositionComponent.class);&#10;        this.velocityTypeId = world.getComponentTypeId(VelocityComponent.class);&#10;    }&#10;&#10;    /**&#10;     * Update all entities that have both Position and Velocity&#10;     */&#10;    public void update(float deltaTime) {&#10;        world.query()&#10;            .with(PositionComponent.class)&#10;            .with(VelocityComponent.class)&#10;            .forEachChunk((chunk, archetype) -&gt; {&#10;                updateChunk(chunk, archetype, deltaTime);&#10;            });&#10;    }&#10;&#10;    private void updateChunk(ArchetypeChunk chunk, Archetype archetype, float deltaTime) {&#10;        int size = chunk.size();&#10;&#10;        // Get component indices in this archetype&#10;        int posIndex = getComponentIndex(archetype, positionTypeId);&#10;        int velIndex = getComponentIndex(archetype, velocityTypeId);&#10;&#10;        // Process each entity in the chunk&#10;        for (int i = 0; i &lt; size; i++) {&#10;            MemorySegment posData = chunk.getComponentData(posIndex, i);&#10;            MemorySegment velData = chunk.getComponentData(velIndex, i);&#10;&#10;            if (posData != null &amp;&amp; velData != null) {&#10;                // Read velocity&#10;                float vx = velData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float vy = velData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Read position&#10;                float x = posData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float y = posData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Update position&#10;                x += vx * deltaTime;&#10;                y += vy * deltaTime;&#10;&#10;                // Write back&#10;                posData.set(ValueLayout.JAVA_FLOAT, 0, x);&#10;                posData.set(ValueLayout.JAVA_FLOAT, 4, y);&#10;            }&#10;        }&#10;    }&#10;&#10;    private int getComponentIndex(Archetype archetype, int componentTypeId) {&#10;        int index = 0;&#10;        ComponentMask mask = archetype.getMask();&#10;        for (int i = 0; i &lt; componentTypeId; i++) {&#10;            if (mask.has(i)) {&#10;                index++;&#10;            }&#10;        }&#10;        return index;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype.system;&#10;&#10;import com.ethnicthv.ecs.archetype.Archetype;&#10;import com.ethnicthv.ecs.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.components.PositionComponent;&#10;import com.ethnicthv.ecs.components.VelocityComponent;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Movement system optimized for Archetype-based ECS.&#10; * Processes entities in cache-friendly chunks.&#10; */&#10;public final class ArchetypeMovementSystem {&#10;    private final ArchetypeWorld world;&#10;    private final int positionTypeId;&#10;    private final int velocityTypeId;&#10;&#10;    public ArchetypeMovementSystem(ArchetypeWorld world) {&#10;        this.world = world;&#10;        this.positionTypeId = world.getComponentTypeId(PositionComponent.class);&#10;        this.velocityTypeId = world.getComponentTypeId(VelocityComponent.class);&#10;    }&#10;&#10;    /**&#10;     * Update all entities that have both Position and Velocity&#10;     */&#10;    public void update(float deltaTime) {&#10;        world.query()&#10;            .with(PositionComponent.class)&#10;            .with(VelocityComponent.class)&#10;            .forEachChunk((chunk, archetype) -&gt; {&#10;                updateChunk(chunk, archetype, deltaTime);&#10;            });&#10;    }&#10;&#10;    private void updateChunk(ArchetypeChunk chunk, Archetype archetype, float deltaTime) {&#10;        int size = chunk.size();&#10;&#10;        // Get component indices in this archetype&#10;        int posIndex = getComponentIndex(archetype, positionTypeId);&#10;        int velIndex = getComponentIndex(archetype, velocityTypeId);&#10;&#10;        // Process each entity in the chunk&#10;        for (int i = 0; i &lt; size; i++) {&#10;            MemorySegment posData = chunk.getComponentData(posIndex, i);&#10;            MemorySegment velData = chunk.getComponentData(velIndex, i);&#10;&#10;            if (posData != null &amp;&amp; velData != null) {&#10;                // Read velocity&#10;                float vx = velData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float vy = velData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Read position&#10;                float x = posData.get(ValueLayout.JAVA_FLOAT, 0);&#10;                float y = posData.get(ValueLayout.JAVA_FLOAT, 4);&#10;&#10;                // Update position&#10;                x += vx * deltaTime;&#10;                y += vy * deltaTime;&#10;&#10;                // Write back&#10;                posData.set(ValueLayout.JAVA_FLOAT, 0, x);&#10;                posData.set(ValueLayout.JAVA_FLOAT, 4, y);&#10;            }&#10;        }&#10;    }&#10;&#10;    private int getComponentIndex(Archetype archetype, int componentTypeId) {&#10;        int index = 0;&#10;        ComponentMask mask = archetype.getMask();&#10;        for (int i = 0; i &lt; componentTypeId; i++) {&#10;            if (mask.has(i)) {&#10;                index++;&#10;            }&#10;        }&#10;        return index;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentHandle.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentHandle.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a field value by name&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;&#10;/**&#10; * Reusable handle to access component data in memory using Panama Foreign Memory API&#10; * The handle can be reset to point at a different MemorySegment/descriptor so it can be pooled.&#10; */&#10;public class ComponentHandle {&#10;    private MemorySegment segment; // mutable so the handle can be reused&#10;    private ComponentDescriptor descriptor;&#10;&#10;    /**&#10;     * No-arg constructor to allow pooling + later reset&#10;     */&#10;    public ComponentHandle() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    /**&#10;     * Construct and bind to a segment immediately&#10;     */&#10;    public ComponentHandle(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Bind this handle to a MemorySegment and descriptor (reusable)&#10;     */&#10;    public void reset(MemorySegment segment, ComponentDescriptor descriptor) {&#10;        this.segment = segment;&#10;        this.descriptor = descriptor;&#10;    }&#10;&#10;    /**&#10;     * Unbind / clear the handle to prepare for pooling&#10;     */&#10;    public void clear() {&#10;        this.segment = null;&#10;        this.descriptor = null;&#10;    }&#10;&#10;    private void ensureBound() {&#10;        if (segment == null || descriptor == null) {&#10;            throw new IllegalStateException(&quot;ComponentHandle is not bound to a segment/descriptor&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a field value by name&#10;     */&#10;    public Object get(String fieldName) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        return switch (field.type()) {&#10;            case BYTE -&gt; segment.get(ValueLayout.JAVA_BYTE, field.offset());&#10;            case SHORT -&gt; segment.get(ValueLayout.JAVA_SHORT, field.offset());&#10;            case INT -&gt; segment.get(ValueLayout.JAVA_INT, field.offset());&#10;            case LONG -&gt; segment.get(ValueLayout.JAVA_LONG, field.offset());&#10;            case FLOAT -&gt; segment.get(ValueLayout.JAVA_FLOAT, field.offset());&#10;            case DOUBLE -&gt; segment.get(ValueLayout.JAVA_DOUBLE, field.offset());&#10;            case BOOLEAN -&gt; segment.get(ValueLayout.JAVA_BOOLEAN, field.offset());&#10;            case CHAR -&gt; segment.get(ValueLayout.JAVA_CHAR, field.offset());&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Set a field value by name&#10;     */&#10;    public void set(String fieldName, Object value) {&#10;        ensureBound();&#10;        ComponentDescriptor.FieldDescriptor field = descriptor.getField(fieldName);&#10;        if (field == null) {&#10;            throw new IllegalArgumentException(&quot;Field &quot; + fieldName + &quot; not found&quot;);&#10;        }&#10;&#10;        switch (field.type()) {&#10;            case BYTE -&gt; segment.set(ValueLayout.JAVA_BYTE, field.offset(), (byte) value);&#10;            case SHORT -&gt; segment.set(ValueLayout.JAVA_SHORT, field.offset(), (short) value);&#10;            case INT -&gt; segment.set(ValueLayout.JAVA_INT, field.offset(), (int) value);&#10;            case LONG -&gt; segment.set(ValueLayout.JAVA_LONG, field.offset(), (long) value);&#10;            case FLOAT -&gt; segment.set(ValueLayout.JAVA_FLOAT, field.offset(), (float) value);&#10;            case DOUBLE -&gt; segment.set(ValueLayout.JAVA_DOUBLE, field.offset(), (double) value);&#10;            case BOOLEAN -&gt; segment.set(ValueLayout.JAVA_BOOLEAN, field.offset(), (boolean) value);&#10;            case CHAR -&gt; segment.set(ValueLayout.JAVA_CHAR, field.offset(), (char) value);&#10;        }&#10;    }&#10;&#10;    /** Type-safe getters/setters proxying to generic get/set */&#10;    public byte getByte(String fieldName) { return (byte) get(fieldName); }&#10;    public short getShort(String fieldName) { return (short) get(fieldName); }&#10;    public int getInt(String fieldName) { return (int) get(fieldName); }&#10;    public long getLong(String fieldName) { return (long) get(fieldName); }&#10;    public float getFloat(String fieldName) { return (float) get(fieldName); }&#10;    public double getDouble(String fieldName) { return (double) get(fieldName); }&#10;    public boolean getBoolean(String fieldName) { return (boolean) get(fieldName); }&#10;    public char getChar(String fieldName) { return (char) get(fieldName); }&#10;&#10;    public void setByte(String fieldName, byte value) { set(fieldName, value); }&#10;    public void setShort(String fieldName, short value) { set(fieldName, value); }&#10;    public void setInt(String fieldName, int value) { set(fieldName, value); }&#10;    public void setLong(String fieldName, long value) { set(fieldName, value); }&#10;    public void setFloat(String fieldName, float value) { set(fieldName, value); }&#10;    public void setDouble(String fieldName, double value) { set(fieldName, value); }&#10;    public void setBoolean(String fieldName, boolean value) { set(fieldName, value); }&#10;    public void setChar(String fieldName, char value) { set(fieldName, value); }&#10;&#10;    public MemorySegment getSegment() { return segment; }&#10;    public ComponentDescriptor getDescriptor() { return descriptor; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/ComponentManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    private final Map&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new HashMap&lt;&gt;();&#10;    private int nextTypeId = 0;&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        if (componentTypeIds.containsKey(componentClass)) {&#10;            return componentTypeIds.get(componentClass);&#10;        }&#10;&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Build descriptor through reflection&#10;        ComponentDescriptor descriptor = buildDescriptor(componentClass);&#10;        descriptors.put(componentClass, descriptor);&#10;&#10;        int typeId = nextTypeId++;&#10;        componentTypeIds.put(componentClass, typeId);&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    private final Map&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new HashMap&lt;&gt;();&#10;    private int nextTypeId = 0;&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        if (componentTypeIds.containsKey(componentClass)) {&#10;            return componentTypeIds.get(componentClass);&#10;        }&#10;&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Build descriptor through reflection&#10;        ComponentDescriptor descriptor = buildDescriptor(componentClass);&#10;        descriptors.put(componentClass, descriptor);&#10;&#10;        int typeId = nextTypeId++;&#10;        componentTypeIds.put(componentClass, typeId);&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType);&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/api/IWorld.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/api/IWorld.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.api;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;&#10;/**&#10; * Public API for the ECS world, providing safe access to entity and component management.&#10; * &lt;p&gt;&#10; * This interface exposes the core functionality of the Archetype-based ECS system&#10; * without revealing internal implementation details.&#10; */&#10;public interface IWorld extends AutoCloseable {&#10;    /**&#10;     * Register a component type in the world.&#10;     *&#10;     * @param componentClass The component class to register.&#10;     * @return The unique type ID assigned to this component.&#10;     */&#10;    &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass);&#10;&#10;    /**&#10;     * Create a new entity with no components.&#10;     *&#10;     * @return The unique ID of the newly created entity.&#10;     */&#10;    int createEntity();&#10;&#10;    /**&#10;     * Create a new entity with the specified component types.&#10;     * Components are initialized with default (zeroed) values.&#10;     *&#10;     * @param componentClasses The component classes to add to the entity.&#10;     * @return The unique ID of the newly created entity.&#10;     */&#10;    int createEntity(Class&lt;?&gt;... componentClasses);&#10;&#10;    /**&#10;     * Check if an entity has a specific component.&#10;     *&#10;     * @param entityId The entity ID.&#10;     * @param componentClass The component class to check for.&#10;     * @return True if the entity has the component, false otherwise.&#10;     */&#10;    &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass);&#10;&#10;    /**&#10;     * Destroy an entity and remove it from the world.&#10;     *&#10;     * @param entityId The ID of the entity to destroy.&#10;     */&#10;    void destroyEntity(int entityId);&#10;&#10;    /**&#10;     * Create a query builder for filtering entities based on component requirements.&#10;     *&#10;     * @return A new query builder instance.&#10;     */&#10;    IQueryBuilder query();&#10;&#10;    /**&#10;     * Get the total number of entities currently in the world.&#10;     *&#10;     * @return The entity count.&#10;     */&#10;    int getEntityCount();&#10;&#10;    /**&#10;     * Get the component type ID for a registered component class.&#10;     *&#10;     * @param componentClass The component class.&#10;     * @return The type ID, or null if not registered.&#10;     */&#10;    Integer getComponentTypeId(Class&lt;?&gt; componentClass);&#10;&#10;    /**&#10;     * Close the world and release all associated resources.&#10;     */&#10;    @Override&#10;    void close();&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.api;&#13;&#10;&#13;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#13;&#10;&#13;&#10;/**&#13;&#10; * Public API for the ECS world, providing safe access to entity and component management.&#13;&#10; * &lt;p&gt;&#13;&#10; * This interface exposes the core functionality of the Archetype-based ECS system&#13;&#10; * without revealing internal implementation details.&#13;&#10; */&#13;&#10;public interface IWorld extends AutoCloseable {&#13;&#10;    /**&#13;&#10;     * Register a component type in the world.&#13;&#10;     *&#13;&#10;     * @param componentClass The component class to register.&#13;&#10;     * @return The unique type ID assigned to this component.&#13;&#10;     */&#13;&#10;    &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create a new entity with no components.&#13;&#10;     *&#13;&#10;     * @return The unique ID of the newly created entity.&#13;&#10;     */&#13;&#10;    int createEntity();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create a new entity with the specified component types.&#13;&#10;     * Components are initialized with default (zeroed) values.&#13;&#10;     *&#13;&#10;     * @param componentClasses The component classes to add to the entity.&#13;&#10;     * @return The unique ID of the newly created entity.&#13;&#10;     */&#13;&#10;    int createEntity(Class&lt;?&gt;... componentClasses);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Check if an entity has a specific component.&#13;&#10;     *&#13;&#10;     * @param entityId The entity ID.&#13;&#10;     * @param componentClass The component class to check for.&#13;&#10;     * @return True if the entity has the component, false otherwise.&#13;&#10;     */&#13;&#10;    &lt;T&gt; boolean hasComponent(int entityId, Class&lt;T&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Destroy an entity and remove it from the world.&#13;&#10;     *&#13;&#10;     * @param entityId The ID of the entity to destroy.&#13;&#10;     */&#13;&#10;    void destroyEntity(int entityId);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create a query builder for filtering entities based on component requirements.&#13;&#10;     *&#13;&#10;     * @return A new query builder instance.&#13;&#10;     */&#13;&#10;    IQueryBuilder query();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get the total number of entities currently in the world.&#13;&#10;     *&#13;&#10;     * @return The entity count.&#13;&#10;     */&#13;&#10;    int getEntityCount();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get the component type ID for a registered component class.&#13;&#10;     *&#13;&#10;     * @param componentClass The component class.&#13;&#10;     * @return The type ID, or null if not registered.&#13;&#10;     */&#13;&#10;    Integer getComponentTypeId(Class&lt;?&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Close the world and release all associated resources.&#13;&#10;     */&#13;&#10;    @Override&#13;&#10;    void close();&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/api/archetype/IQueryBuilder.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/api/archetype/IQueryBuilder.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.api.archetype;&#10;&#10;/**&#10; * Mutable builder interface for constructing archetype queries.&#10; * &lt;p&gt;&#10; * This interface follows the Builder pattern and allows fluent configuration&#10; * of query criteria. Once configuration is complete, call {@link #build()}&#10; * to create an immutable {@link IQuery} instance.&#10; * &lt;p&gt;&#10; * Example usage:&#10; * &lt;pre&gt;{@code&#10; * IQuery query = world.query()&#10; *     .with(Position.class)&#10; *     .with(Velocity.class)&#10; *     .without(Stunned.class)&#10; *     .build();&#10; * }&lt;/pre&gt;&#10; *&#10; * @see IQuery&#10; */&#10;public interface IQueryBuilder {&#10;&#10;    /**&#10;     * Add a required component to the query.&#10;     * &lt;p&gt;&#10;     * Entities must have this component to match the query.&#10;     *&#10;     * @param componentClass the component class to require&#10;     * @param &lt;T&gt; the component type&#10;     * @return this builder for chaining&#10;     */&#10;    &lt;T&gt; IQueryBuilder with(Class&lt;T&gt; componentClass);&#10;&#10;    /**&#10;     * Add an excluded component to the query.&#10;     * &lt;p&gt;&#10;     * Entities must NOT have this component to match the query.&#10;     *&#10;     * @param componentClass the component class to exclude&#10;     * @param &lt;T&gt; the component type&#10;     * @return this builder for chaining&#10;     */&#10;    &lt;T&gt; IQueryBuilder without(Class&lt;T&gt; componentClass);&#10;&#10;    /**&#10;     * Add optional components to the query.&#10;     * &lt;p&gt;&#10;     * Entities must have at least ONE of these components to match the query.&#10;     *&#10;     * @param componentClasses the component classes (at least one required)&#10;     * @return this builder for chaining&#10;     */&#10;    IQueryBuilder any(Class&lt;?&gt;... componentClasses);&#10;&#10;    /**&#10;     * Filter by a managed shared component value. Only chunks in groups with this shared value will be considered.&#10;     */&#10;    IQueryBuilder withShared(Object managedValue);&#10;&#10;    /**&#10;     * Filter by an unmanaged shared component value (type + 64-bit value).&#10;     */&#10;    IQueryBuilder withShared(Class&lt;?&gt; unmanagedSharedType, long value);&#10;&#10;    /**&#10;     * Build an immutable query from this builder's configuration.&#10;     * &lt;p&gt;&#10;     * The returned {@link IQuery} is thread-safe and immutable.&#10;     * This builder can continue to be used after calling build().&#10;     *&#10;     * @return an immutable query instance&#10;     */&#10;    IQuery build();&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.api.archetype;&#13;&#10;&#13;&#10;/**&#13;&#10; * Mutable builder interface for constructing archetype queries.&#13;&#10; * &lt;p&gt;&#13;&#10; * This interface follows the Builder pattern and allows fluent configuration&#13;&#10; * of query criteria. Once configuration is complete, call {@link #build()}&#13;&#10; * to create an immutable {@link IQuery} instance.&#13;&#10; * &lt;p&gt;&#13;&#10; * Example usage:&#13;&#10; * &lt;pre&gt;{@code&#13;&#10; * IQuery query = world.query()&#13;&#10; *     .with(Position.class)&#13;&#10; *     .with(Velocity.class)&#13;&#10; *     .without(Stunned.class)&#13;&#10; *     .build();&#13;&#10; * }&lt;/pre&gt;&#13;&#10; *&#13;&#10; * @see IQuery&#13;&#10; */&#13;&#10;public interface IQueryBuilder {&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Add a required component to the query.&#13;&#10;     * &lt;p&gt;&#13;&#10;     * Entities must have this component to match the query.&#13;&#10;     *&#13;&#10;     * @param componentClass the component class to require&#13;&#10;     * @param &lt;T&gt; the component type&#13;&#10;     * @return this builder for chaining&#13;&#10;     */&#13;&#10;    &lt;T&gt; IQueryBuilder with(Class&lt;T&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Add an excluded component to the query.&#13;&#10;     * &lt;p&gt;&#13;&#10;     * Entities must NOT have this component to match the query.&#13;&#10;     *&#13;&#10;     * @param componentClass the component class to exclude&#13;&#10;     * @param &lt;T&gt; the component type&#13;&#10;     * @return this builder for chaining&#13;&#10;     */&#13;&#10;    &lt;T&gt; IQueryBuilder without(Class&lt;T&gt; componentClass);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Add optional components to the query.&#13;&#10;     * &lt;p&gt;&#13;&#10;     * Entities must have at least ONE of these components to match the query.&#13;&#10;     *&#13;&#10;     * @param componentClasses the component classes (at least one required)&#13;&#10;     * @return this builder for chaining&#13;&#10;     */&#13;&#10;    IQueryBuilder any(Class&lt;?&gt;... componentClasses);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Filter by a managed shared component value. Only chunks in groups with this shared value will be considered.&#13;&#10;     */&#13;&#10;    IQueryBuilder withShared(Object managedValue);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Filter by an unmanaged shared component value (type + 64-bit value).&#13;&#10;     */&#13;&#10;    IQueryBuilder withShared(Class&lt;?&gt; unmanagedSharedType, long value);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Build an immutable query from this builder's configuration.&#13;&#10;     * &lt;p&gt;&#13;&#10;     * The returned {@link IQuery} is thread-safe and immutable.&#13;&#10;     * This builder can continue to be used after calling build().&#13;&#10;     *&#13;&#10;     * @return an immutable query instance&#13;&#10;     */&#13;&#10;    IQuery build();&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/Archetype.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/Archetype.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.ArrayList;&#10;import java.util.Collection;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Archetype groups entities that share the same set of components.&#10; * It stores component descriptors and manages a list of chunks.&#10; */&#10;public final class Archetype implements IArchetype {&#10;&#10;    private final int[] componentIds;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] componentElementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final ComponentMask mask; // cached mask&#10;    private final Arena arena; // arena for new chunk allocations&#10;&#10;    private final int[] allComponentTypeIds;&#10;    private final int[] managedTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; managedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; componentIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // New: per-shared-value grouping of chunks&#10;    private final ConcurrentHashMap&lt;SharedValueKey, ChunkGroup&gt; chunkGroups = new ConcurrentHashMap&lt;&gt;();&#10;    // New: shared component type ids (unmanaged and managed) and their index maps&#10;    private final int[] sharedManagedTypeIds;&#10;    private final int[] sharedUnmanagedTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; sharedManagedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; sharedUnmanagedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // constants preserved&#10;    private static final int CHUNK_SIZE = 16 * 1024;&#10;    private static final int DEFAULT_ENTITIES_PER_CHUNK = 64;&#10;&#10;    public Archetype(ComponentMask mask, int[] componentIds, ComponentDescriptor[] descriptors, Arena arena) {&#10;        if (componentIds.length != descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;componentIds/descriptors length mismatch&quot;);&#10;        }&#10;        this.componentIds = componentIds;&#10;        this.descriptors = descriptors;&#10;        this.componentElementSizes = new long[descriptors.length];&#10;        this.mask = mask;&#10;        this.arena = arena;&#10;        this.allComponentTypeIds = null;&#10;        this.managedTypeIds = new int[0];&#10;        this.sharedManagedTypeIds = new int[0];&#10;        this.sharedUnmanagedTypeIds = new int[0];&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long s = descriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        if (totalPerEntity &lt;= 0) {&#10;            this.entitiesPerChunk = DEFAULT_ENTITIES_PER_CHUNK;&#10;        } else {&#10;            this.entitiesPerChunk = Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        }&#10;        // Create default group to preserve previous behavior (one initial chunk)&#10;        getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;    }&#10;&#10;    // Managed-aware constructor: unmanaged descriptors + separate managed type ids&#10;    public Archetype(ComponentMask mask, int[] allComponentTypeIds, ComponentDescriptor[] unmanagedDescriptors, int[] managedTypeIds, Arena arena) {&#10;        this.mask = mask;&#10;        this.allComponentTypeIds = allComponentTypeIds;&#10;        this.managedTypeIds = managedTypeIds != null ? managedTypeIds.clone() : new int[0];&#10;        this.componentIds = new int[unmanagedDescriptors.length];&#10;        this.descriptors = unmanagedDescriptors;&#10;        this.componentElementSizes = new long[unmanagedDescriptors.length];&#10;        this.arena = arena;&#10;        this.sharedManagedTypeIds = new int[0];&#10;        this.sharedUnmanagedTypeIds = new int[0];&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; unmanagedDescriptors.length; i++) {&#10;            long s = unmanagedDescriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        this.entitiesPerChunk = (totalPerEntity &lt;= 0) ? DEFAULT_ENTITIES_PER_CHUNK : Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        // Create default group to preserve previous behavior&#10;        getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;    }&#10;&#10;    // New: Fully managed/shared aware constructor&#10;    public Archetype(ComponentMask mask,&#10;                     int[] allComponentTypeIds,&#10;                     ComponentDescriptor[] unmanagedInstanceDescriptors,&#10;                     int[] managedInstanceTypeIds,&#10;                     int[] unmanagedSharedTypeIds,&#10;                     int[] managedSharedTypeIds,&#10;                     Arena arena) {&#10;        this.mask = mask;&#10;        this.allComponentTypeIds = allComponentTypeIds;&#10;        this.managedTypeIds = managedInstanceTypeIds != null ? managedInstanceTypeIds.clone() : new int[0];&#10;        this.sharedUnmanagedTypeIds = unmanagedSharedTypeIds != null ? unmanagedSharedTypeIds.clone() : new int[0];&#10;        this.sharedManagedTypeIds = managedSharedTypeIds != null ? managedSharedTypeIds.clone() : new int[0];&#10;        this.componentIds = new int[unmanagedInstanceDescriptors.length];&#10;        this.descriptors = unmanagedInstanceDescriptors;&#10;        this.componentElementSizes = new long[unmanagedInstanceDescriptors.length];&#10;        this.arena = arena;&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; unmanagedInstanceDescriptors.length; i++) {&#10;            long s = unmanagedInstanceDescriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        this.entitiesPerChunk = (totalPerEntity &lt;= 0) ? DEFAULT_ENTITIES_PER_CHUNK : Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;&#10;        // Build index maps for shared type ids&#10;        for (int i = 0; i &lt; this.sharedManagedTypeIds.length; i++) {&#10;            sharedManagedIndexMap.put(this.sharedManagedTypeIds[i], i);&#10;        }&#10;        for (int i = 0; i &lt; this.sharedUnmanagedTypeIds.length; i++) {&#10;            sharedUnmanagedIndexMap.put(this.sharedUnmanagedTypeIds[i], i);&#10;        }&#10;        // Create default group to preserve previous behavior&#10;        getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;    }&#10;&#10;    // Internal helper to set unmanaged type ids after construction (used by ArchetypeManager)&#10;    void setUnmanagedTypeIds(int[] unmanagedTypeIds) {&#10;        if (unmanagedTypeIds == null || unmanagedTypeIds.length != this.descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;unmanagedTypeIds length mismatch&quot;);&#10;        }&#10;        System.arraycopy(unmanagedTypeIds, 0, this.componentIds, 0, unmanagedTypeIds.length);&#10;    }&#10;&#10;    /**&#10;     * Get component mask (cached)&#10;     */&#10;    public ComponentMask getMask() { return mask; }&#10;&#10;    public int[] getComponentIds() { return componentIds; }&#10;&#10;    @Override&#10;    public int[] getComponentTypeIds() {&#10;        return allComponentTypeIds != null ? allComponentTypeIds : getComponentIds();&#10;    }&#10;&#10;    public ComponentDescriptor[] getDescriptors() { return descriptors; }&#10;&#10;    public int getEntitiesPerChunk() { return entitiesPerChunk; }&#10;&#10;    public long[] getElementSizes() { return componentElementSizes; }&#10;&#10;    /**&#10;     * Return a snapshot list of chunks. Order is physical array order.&#10;     */&#10;    @Override&#10;    public List&lt;IArchetypeChunk&gt; getChunks() {&#10;        // Backward compatible: if no shared grouping used, return chunks from a default group if present&#10;        ChunkGroup defaultGroup = chunkGroups.getOrDefault(new SharedValueKey(null, null), null);&#10;        if (defaultGroup == null) return List.of();&#10;        List&lt;ArchetypeChunk&gt; list = defaultGroup.getChunks();&#10;        return new ArrayList&lt;&gt;(list);&#10;    }&#10;&#10;    /**&#10;     * Get a direct reference to the current chunks array.&#10;     * &lt;p&gt;&#10;     * This method provides thread-safe access to the chunks array for parallel iteration.&#10;     * Since the 'chunks' field is declared as volatile, reading it guarantees visibility&#10;     * of the most recent array reference. The array itself may be replaced during resize&#10;     * operations, but the reference returned here is stable for the duration of its use.&#10;     * &lt;p&gt;&#10;     * This is primarily intended for parallel processing where multiple threads need to&#10;     * iterate over chunks concurrently without creating defensive copies.&#10;     *&#10;     * @return A reference to the current chunks array. The caller should also read&#10;     *         {@link #chunkCount()} to determine how many valid entries exist.&#10;     */&#10;    public ArchetypeChunk[] getChunksSnapshot() {&#10;        ChunkGroup defaultGroup = chunkGroups.getOrDefault(new SharedValueKey(null, null), null);&#10;        return defaultGroup != null ? defaultGroup.getChunksSnapshot() : new ArchetypeChunk[0];&#10;    }&#10;&#10;    public ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        // Place into default group when no shared key is defined&#10;        ChunkGroup group = getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;        return group.addEntity(entityId);&#10;    }&#10;&#10;    public void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        // Assume default group for backward compatibility&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        if (defaultGroup != null) defaultGroup.removeEntity(location);&#10;    }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        if (defaultGroup == null) throw new IndexOutOfBoundsException();&#10;        return defaultGroup.getChunk(chunkIndex);&#10;    }&#10;&#10;    public int chunkCount() {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        return defaultGroup != null ? defaultGroup.chunkCount() : 0;&#10;    }&#10;&#10;    @Override&#10;    public int getChunkCount() { return chunkCount(); }&#10;&#10;    @Override&#10;    public int getEntityCount() {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        return defaultGroup != null ? defaultGroup.getEntityCount() : 0;&#10;    }&#10;&#10;    /**&#10;     * Iterate over all entities in this archetype.&#10;     * Weakly consistent: concurrent adds/removes may or may not be observed by this traversal,&#10;     * and an entity may be skipped or visited once depending on timing. The traversal never throws&#10;     * due to concurrent modification and aims to be cache-friendly.&#10;     */&#10;    public void forEach(ArchetypeIterator iterator) {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        if (defaultGroup == null) return;&#10;        defaultGroup.forEach(iterator);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public MemorySegment getComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex) {&#10;        ArchetypeChunk[] snap = this.getChunksSnapshot();&#10;        return (location.chunkIndex &gt;= 0 &amp;&amp; location.chunkIndex &lt; snap.length)&#10;            ? snap[location.chunkIndex].getComponentData(componentIndex, location.indexInChunk)&#10;            : null;&#10;    }&#10;&#10;    /**&#10;     * Set component data for an entity&#10;     */&#10;    public void setComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex, MemorySegment data) {&#10;        ArchetypeChunk[] snap = this.getChunksSnapshot();&#10;        if (location.chunkIndex &gt;= 0 &amp;&amp; location.chunkIndex &lt; snap.length) {&#10;            snap[location.chunkIndex].setComponentData(componentIndex, location.indexInChunk, data);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the index of a component type ID within this archetype's component arrays, or -1 if absent.&#10;     * Uses a thread-safe lazy cache to compute the mapping at most once per component type id.&#10;     */&#10;    public int indexOfComponentType(int componentTypeId) {&#10;        return componentIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                if (componentIds[i] == tid) {&#10;                    return i;&#10;                }&#10;            }&#10;            return -1; // not present in this archetype or is managed-only&#10;        });&#10;    }&#10;&#10;    // Managed helpers&#10;    public int getManagedTypeIndex(int componentTypeId) {&#10;        if (managedTypeIds.length == 0) return -1;&#10;        return managedIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; managedTypeIds.length; i++) if (managedTypeIds[i] == tid) return i;&#10;            return -1;&#10;        });&#10;    }&#10;&#10;    public int[] getManagedTypeIds() { return managedTypeIds; }&#10;&#10;    // New APIs for chunk group by shared values&#10;    public ChunkGroup getOrCreateChunkGroup(SharedValueKey key) {&#10;        return chunkGroups.computeIfAbsent(key, k -&gt; new ChunkGroup(descriptors, componentElementSizes, entitiesPerChunk, arena, managedTypeIds.length));&#10;    }&#10;&#10;    public ChunkGroup getChunkGroup(SharedValueKey key) {&#10;        return chunkGroups.get(key);&#10;    }&#10;&#10;    public int[] getSharedManagedTypeIds() { return sharedManagedTypeIds; }&#10;    public int[] getSharedUnmanagedTypeIds() { return sharedUnmanagedTypeIds; }&#10;&#10;    public int getSharedManagedIndex(int componentTypeId) {&#10;        Integer idx = sharedManagedIndexMap.get(componentTypeId);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public int getSharedUnmanagedIndex(int componentTypeId) {&#10;        Integer idx = sharedUnmanagedIndexMap.get(componentTypeId);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public java.util.Collection&lt;ChunkGroup&gt; getAllChunkGroups() {&#10;        return chunkGroups.values();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.ArrayList;&#10;import java.util.Collection;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Archetype groups entities that share the same set of components.&#10; * It stores component descriptors and manages a list of chunks.&#10; */&#10;public final class Archetype implements IArchetype {&#10;&#10;    private final int[] componentIds;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] componentElementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final ComponentMask mask; // cached mask&#10;    private final Arena arena; // arena for new chunk allocations&#10;&#10;    private final int[] allComponentTypeIds;&#10;    private final int[] managedTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; managedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; componentIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // New: per-shared-value grouping of chunks&#10;    private final ConcurrentHashMap&lt;SharedValueKey, ChunkGroup&gt; chunkGroups = new ConcurrentHashMap&lt;&gt;();&#10;    // New: shared component type ids (unmanaged and managed) and their index maps&#10;    private final int[] sharedManagedTypeIds;&#10;    private final int[] sharedUnmanagedTypeIds;&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; sharedManagedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;Integer, Integer&gt; sharedUnmanagedIndexMap = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // constants preserved&#10;    private static final int CHUNK_SIZE = 16 * 1024;&#10;    private static final int DEFAULT_ENTITIES_PER_CHUNK = 64;&#10;&#10;    public Archetype(ComponentMask mask, int[] componentIds, ComponentDescriptor[] descriptors, Arena arena) {&#10;        if (componentIds.length != descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;componentIds/descriptors length mismatch&quot;);&#10;        }&#10;        this.componentIds = componentIds;&#10;        this.descriptors = descriptors;&#10;        this.componentElementSizes = new long[descriptors.length];&#10;        this.mask = mask;&#10;        this.arena = arena;&#10;        this.allComponentTypeIds = null;&#10;        this.managedTypeIds = new int[0];&#10;        this.sharedManagedTypeIds = new int[0];&#10;        this.sharedUnmanagedTypeIds = new int[0];&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long s = descriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        if (totalPerEntity &lt;= 0) {&#10;            this.entitiesPerChunk = DEFAULT_ENTITIES_PER_CHUNK;&#10;        } else {&#10;            this.entitiesPerChunk = Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        }&#10;        // Create default group to preserve previous behavior (one initial chunk)&#10;        getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;    }&#10;&#10;    // Managed-aware constructor: unmanaged descriptors + separate managed type ids&#10;    public Archetype(ComponentMask mask, int[] allComponentTypeIds, ComponentDescriptor[] unmanagedDescriptors, int[] managedTypeIds, Arena arena) {&#10;        this.mask = mask;&#10;        this.allComponentTypeIds = allComponentTypeIds;&#10;        this.managedTypeIds = managedTypeIds != null ? managedTypeIds.clone() : new int[0];&#10;        this.componentIds = new int[unmanagedDescriptors.length];&#10;        this.descriptors = unmanagedDescriptors;&#10;        this.componentElementSizes = new long[unmanagedDescriptors.length];&#10;        this.arena = arena;&#10;        this.sharedManagedTypeIds = new int[0];&#10;        this.sharedUnmanagedTypeIds = new int[0];&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; unmanagedDescriptors.length; i++) {&#10;            long s = unmanagedDescriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        this.entitiesPerChunk = (totalPerEntity &lt;= 0) ? DEFAULT_ENTITIES_PER_CHUNK : Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;        // Create default group to preserve previous behavior&#10;        getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;    }&#10;&#10;    // New: Fully managed/shared aware constructor&#10;    public Archetype(ComponentMask mask,&#10;                     int[] allComponentTypeIds,&#10;                     ComponentDescriptor[] unmanagedInstanceDescriptors,&#10;                     int[] managedInstanceTypeIds,&#10;                     int[] unmanagedSharedTypeIds,&#10;                     int[] managedSharedTypeIds,&#10;                     Arena arena) {&#10;        this.mask = mask;&#10;        this.allComponentTypeIds = allComponentTypeIds;&#10;        this.managedTypeIds = managedInstanceTypeIds != null ? managedInstanceTypeIds.clone() : new int[0];&#10;        this.sharedUnmanagedTypeIds = unmanagedSharedTypeIds != null ? unmanagedSharedTypeIds.clone() : new int[0];&#10;        this.sharedManagedTypeIds = managedSharedTypeIds != null ? managedSharedTypeIds.clone() : new int[0];&#10;        this.componentIds = new int[unmanagedInstanceDescriptors.length];&#10;        this.descriptors = unmanagedInstanceDescriptors;&#10;        this.componentElementSizes = new long[unmanagedInstanceDescriptors.length];&#10;        this.arena = arena;&#10;&#10;        long totalPerEntity = 0;&#10;        for (int i = 0; i &lt; unmanagedInstanceDescriptors.length; i++) {&#10;            long s = unmanagedInstanceDescriptors[i].getTotalSize();&#10;            componentElementSizes[i] = s;&#10;            totalPerEntity += s;&#10;        }&#10;        this.entitiesPerChunk = (totalPerEntity &lt;= 0) ? DEFAULT_ENTITIES_PER_CHUNK : Math.max(1, (int) (CHUNK_SIZE / totalPerEntity));&#10;&#10;        // Build index maps for shared type ids&#10;        for (int i = 0; i &lt; this.sharedManagedTypeIds.length; i++) {&#10;            sharedManagedIndexMap.put(this.sharedManagedTypeIds[i], i);&#10;        }&#10;        for (int i = 0; i &lt; this.sharedUnmanagedTypeIds.length; i++) {&#10;            sharedUnmanagedIndexMap.put(this.sharedUnmanagedTypeIds[i], i);&#10;        }&#10;        // Create default group to preserve previous behavior&#10;        getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;    }&#10;&#10;    // Internal helper to set unmanaged type ids after construction (used by ArchetypeManager)&#10;    void setUnmanagedTypeIds(int[] unmanagedTypeIds) {&#10;        if (unmanagedTypeIds == null || unmanagedTypeIds.length != this.descriptors.length) {&#10;            throw new IllegalArgumentException(&quot;unmanagedTypeIds length mismatch&quot;);&#10;        }&#10;        System.arraycopy(unmanagedTypeIds, 0, this.componentIds, 0, unmanagedTypeIds.length);&#10;    }&#10;&#10;    /**&#10;     * Get component mask (cached)&#10;     */&#10;    public ComponentMask getMask() { return mask; }&#10;&#10;    public int[] getComponentIds() { return componentIds; }&#10;&#10;    @Override&#10;    public int[] getComponentTypeIds() {&#10;        return allComponentTypeIds != null ? allComponentTypeIds : getComponentIds();&#10;    }&#10;&#10;    public ComponentDescriptor[] getDescriptors() { return descriptors; }&#10;&#10;    public int getEntitiesPerChunk() { return entitiesPerChunk; }&#10;&#10;    public long[] getElementSizes() { return componentElementSizes; }&#10;&#10;    /**&#10;     * Return a snapshot list of chunks. Order is physical array order.&#10;     */&#10;    @Override&#10;    public List&lt;IArchetypeChunk&gt; getChunks() {&#10;        // Backward compatible: if no shared grouping used, return chunks from a default group if present&#10;        ChunkGroup defaultGroup = chunkGroups.getOrDefault(new SharedValueKey(null, null), null);&#10;        if (defaultGroup == null) return List.of();&#10;        List&lt;ArchetypeChunk&gt; list = defaultGroup.getChunks();&#10;        return new ArrayList&lt;&gt;(list);&#10;    }&#10;&#10;    /**&#10;     * Get a direct reference to the current chunks array.&#10;     * &lt;p&gt;&#10;     * This method provides thread-safe access to the chunks array for parallel iteration.&#10;     * Since the 'chunks' field is declared as volatile, reading it guarantees visibility&#10;     * of the most recent array reference. The array itself may be replaced during resize&#10;     * operations, but the reference returned here is stable for the duration of its use.&#10;     * &lt;p&gt;&#10;     * This is primarily intended for parallel processing where multiple threads need to&#10;     * iterate over chunks concurrently without creating defensive copies.&#10;     *&#10;     * @return A reference to the current chunks array. The caller should also read&#10;     *         {@link #chunkCount()} to determine how many valid entries exist.&#10;     */&#10;    public ArchetypeChunk[] getChunksSnapshot() {&#10;        ChunkGroup defaultGroup = chunkGroups.getOrDefault(new SharedValueKey(null, null), null);&#10;        return defaultGroup != null ? defaultGroup.getChunksSnapshot() : new ArchetypeChunk[0];&#10;    }&#10;&#10;    public ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        // Place into default group when no shared key is defined&#10;        ChunkGroup group = getOrCreateChunkGroup(new SharedValueKey(null, null));&#10;        return group.addEntity(entityId);&#10;    }&#10;&#10;    public void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        // Assume default group for backward compatibility&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        if (defaultGroup != null) defaultGroup.removeEntity(location);&#10;    }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        if (defaultGroup == null) throw new IndexOutOfBoundsException();&#10;        return defaultGroup.getChunk(chunkIndex);&#10;    }&#10;&#10;    public int chunkCount() {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        return defaultGroup != null ? defaultGroup.chunkCount() : 0;&#10;    }&#10;&#10;    @Override&#10;    public int getChunkCount() { return chunkCount(); }&#10;&#10;    @Override&#10;    public int getEntityCount() {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        return defaultGroup != null ? defaultGroup.getEntityCount() : 0;&#10;    }&#10;&#10;    /**&#10;     * Iterate over all entities in this archetype.&#10;     * Weakly consistent: concurrent adds/removes may or may not be observed by this traversal,&#10;     * and an entity may be skipped or visited once depending on timing. The traversal never throws&#10;     * due to concurrent modification and aims to be cache-friendly.&#10;     */&#10;    public void forEach(ArchetypeIterator iterator) {&#10;        ChunkGroup defaultGroup = chunkGroups.get(new SharedValueKey(null, null));&#10;        if (defaultGroup == null) return;&#10;        defaultGroup.forEach(iterator);&#10;    }&#10;&#10;    /**&#10;     * Get component data for an entity&#10;     */&#10;    public MemorySegment getComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex) {&#10;        ArchetypeChunk[] snap = this.getChunksSnapshot();&#10;        return (location.chunkIndex &gt;= 0 &amp;&amp; location.chunkIndex &lt; snap.length)&#10;            ? snap[location.chunkIndex].getComponentData(componentIndex, location.indexInChunk)&#10;            : null;&#10;    }&#10;&#10;    /**&#10;     * Set component data for an entity&#10;     */&#10;    public void setComponentData(ArchetypeChunk.ChunkLocation location, int componentIndex, MemorySegment data) {&#10;        ArchetypeChunk[] snap = this.getChunksSnapshot();&#10;        if (location.chunkIndex &gt;= 0 &amp;&amp; location.chunkIndex &lt; snap.length) {&#10;            snap[location.chunkIndex].setComponentData(componentIndex, location.indexInChunk, data);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the index of a component type ID within this archetype's component arrays, or -1 if absent.&#10;     * Uses a thread-safe lazy cache to compute the mapping at most once per component type id.&#10;     */&#10;    public int indexOfComponentType(int componentTypeId) {&#10;        return componentIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; componentIds.length; i++) {&#10;                if (componentIds[i] == tid) {&#10;                    return i;&#10;                }&#10;            }&#10;            return -1; // not present in this archetype or is managed-only&#10;        });&#10;    }&#10;&#10;    // Managed helpers&#10;    public int getManagedTypeIndex(int componentTypeId) {&#10;        if (managedTypeIds.length == 0) return -1;&#10;        return managedIndexMap.computeIfAbsent(componentTypeId, tid -&gt; {&#10;            for (int i = 0; i &lt; managedTypeIds.length; i++) if (managedTypeIds[i] == tid) return i;&#10;            return -1;&#10;        });&#10;    }&#10;&#10;    public int[] getManagedTypeIds() { return managedTypeIds; }&#10;&#10;    // New APIs for chunk group by shared values&#10;    public ChunkGroup getOrCreateChunkGroup(SharedValueKey key) {&#10;        return chunkGroups.computeIfAbsent(key, k -&gt; new ChunkGroup(descriptors, componentElementSizes, entitiesPerChunk, arena, managedTypeIds.length));&#10;    }&#10;&#10;    public ChunkGroup getChunkGroup(SharedValueKey key) {&#10;        return chunkGroups.get(key);&#10;    }&#10;&#10;    public int[] getSharedManagedTypeIds() { return sharedManagedTypeIds; }&#10;    public int[] getSharedUnmanagedTypeIds() { return sharedUnmanagedTypeIds; }&#10;&#10;    public int getSharedManagedIndex(int componentTypeId) {&#10;        Integer idx = sharedManagedIndexMap.get(componentTypeId);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public int getSharedUnmanagedIndex(int componentTypeId) {&#10;        Integer idx = sharedUnmanagedIndexMap.get(componentTypeId);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public java.util.Collection&lt;ChunkGroup&gt; getAllChunkGroups() {&#10;        return chunkGroups.values();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeChunk.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeChunk.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.exception.ECSMemoryAllocationException;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#10;import java.util.Arrays;&#10;&#10;/**&#10; * Single chunk storing SoA arrays for each component.&#10; */&#10;public final class ArchetypeChunk implements IArchetypeChunk {&#10;&#10;    private final long[] elementSizes;&#10;    private final MemorySegment[] componentArrays;&#10;    // New: per-managed-type ticket arrays; may be empty if no managed types&#10;    private final int[][] managedComponentIndexArrays;&#10;    private final int capacity;&#10;    // Lock-free free list: Treiber stack of free indices&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#10;    private final int[] nextFree; // next pointer for each slot&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#10;    private final Arena arena;&#10;    private final AtomicInteger size; // number of occupied slots&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#10;    private static final int BITS_PER_WORD = 64;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#10;&#10;    public static final class ChunkLocation {&#10;        public final int chunkIndex;&#10;        public final int indexInChunk;&#10;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#10;            this.chunkIndex = chunkIndex;&#10;            this.indexInChunk = indexInChunk;&#10;        }&#10;    }&#10;&#10;    // Backwards-compatible constructor (no managed types)&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#10;        this(descriptors, elementSizes, capacity, arena, 0);&#10;    }&#10;&#10;    // New constructor supporting managed types&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena, int managedTypeCount) {&#10;        this.elementSizes = elementSizes;&#10;        this.capacity = capacity;&#10;        this.arena = arena;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#10;        this.size = new AtomicInteger(0);&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#10;        this.nextFree = new int[capacity];&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#10;            nextFree[i] = i + 1;&#10;            entityIds.set(i, -1);&#10;        }&#10;        if (capacity &gt; 0) {&#10;            nextFree[capacity - 1] = -1;&#10;            entityIds.set(capacity - 1, -1);&#10;        }&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#10;&#10;        // Allocate per-component arrays and zero-initialize them&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#10;            long bytes = elementSizes[i] * (long) capacity;&#10;            if (bytes &lt;= 0) {&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#10;            }&#10;            try {&#10;                this.componentArrays[i] = arena.allocate(bytes);&#10;                // zero entire component array to ensure new slots start clean&#10;                this.componentArrays[i].fill((byte) 0);&#10;            } catch (OutOfMemoryError oom) {&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#10;            }&#10;        }&#10;&#10;        // Initialize managed ticket arrays (filled with -1 indicating empty)&#10;        if (managedTypeCount &gt; 0) {&#10;            this.managedComponentIndexArrays = new int[managedTypeCount][];&#10;            for (int i = 0; i &lt; managedTypeCount; i++) {&#10;                int[] arr = new int[capacity];&#10;                Arrays.fill(arr, -1);&#10;                this.managedComponentIndexArrays[i] = arr;&#10;            }&#10;        } else {&#10;            this.managedComponentIndexArrays = new int[0][];&#10;        }&#10;&#10;        // keep entityIds initialized to -1&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#10;    }&#10;&#10;    public Arena getArena() {&#10;        return arena;&#10;    }&#10;&#10;    /**&#10;     * Allocate a free slot and associate with entityId.&#10;     * Returns index or -1 if full.&#10;     */&#10;    public int allocateSlot(int entityId) {&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            if (head == -1) return -1; // full&#10;            int next = nextFree[head];&#10;            if (freeHead.compareAndSet(head, next)) {&#10;                // zero out the slot data before making it visible to iterators or readers&#10;                zeroSlot(head);&#10;                // publish entity id for the claimed slot&#10;                entityIds.set(head, entityId);&#10;                // mark occupancy bit so iterators can observe&#10;                setBit(head);&#10;                int newSize = size.incrementAndGet();&#10;                if (newSize &gt; capacity) {&#10;                    // Defensive: should never happen; roll back and fail fast&#10;                    size.decrementAndGet();&#10;                    clearBit(head);&#10;                    entityIds.set(head, -1);&#10;                    // push slot back to free list&#10;                    while (true) {&#10;                        int h = freeHead.get();&#10;                        nextFree[head] = h;&#10;                        if (freeHead.compareAndSet(h, head)) break;&#10;                    }&#10;                    throw new IllegalStateException(&quot;ArchetypeChunk size overflow: &quot; + newSize + &quot; &gt; capacity=&quot; + capacity);&#10;                }&#10;                return head;&#10;            }&#10;            // CAS failed: retry&#10;        }&#10;    }&#10;&#10;    public void freeSlot(int index) {&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#10;        // mark entity id as free first (helps readers)&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#10;            // already free; ignore double free&#10;            return;&#10;        }&#10;        int newSize = size.decrementAndGet();&#10;        if (newSize &lt; 0) {&#10;            // Defensive: should never happen; restore and fail fast&#10;            size.incrementAndGet();&#10;            entityIds.set(index, -1);&#10;            throw new IllegalStateException(&quot;ArchetypeChunk size underflow: &quot; + newSize);&#10;        }&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#10;        clearBit(index);&#10;        // push index onto free list&#10;        while (true) {&#10;            int head = freeHead.get();&#10;            nextFree[index] = head;&#10;            if (freeHead.compareAndSet(head, index)) {&#10;                return;&#10;            }&#10;            // retry on contention&#10;        }&#10;    }&#10;&#10;    private void zeroSlot(int idx) {&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#10;            long elemSize = elementSizes[c];&#10;            long offset = elemSize * (long) idx;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#10;        }&#10;        // Reset managed tickets to -1 for this slot&#10;        for (int i = 0; i &lt; managedComponentIndexArrays.length; i++) {&#10;            managedComponentIndexArrays[i][idx] = -1;&#10;        }&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return size.get() == 0;&#10;    }&#10;&#10;    @Override&#10;    public int getEntityId(int index) {&#10;        return entityIds.get(index);&#10;    }&#10;&#10;    public int capacity() {&#10;        return capacity;&#10;    }&#10;&#10;    @Override&#10;    public int getCapacity() {&#10;        return capacity;&#10;    }&#10;&#10;    /**&#10;     * Current number of occupied slots in this chunk&#10;     */&#10;    @Override&#10;    public int size() {&#10;        return size.get();&#10;    }&#10;&#10;    @Override&#10;    public int getEntityCount() {&#10;        return size();&#10;    }&#10;&#10;    /**&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#10;     * The returned slice is a view into the backing component array (zero-copy).&#10;     */&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#10;    }&#10;&#10;    /**&#10;     * Copy provided segment into the element slot for componentIndex.&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#10;     */&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#10;    }&#10;&#10;    public boolean hasFree() {&#10;        return freeHead.get() != -1;&#10;    }&#10;&#10;    /**&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#10;     */&#10;    public boolean tryMarkQueued() {&#10;        return queued.compareAndSet(0, 1);&#10;    }&#10;&#10;    /**&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#10;     */&#10;    public void markDequeued() {&#10;        queued.set(0);&#10;    }&#10;&#10;    private void setBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur | mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    private void clearBit(int idx) {&#10;        int word = idx &gt;&gt;&gt; 6;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#10;        while (true) {&#10;            long cur = occupancy.get(word);&#10;            long nxt = cur &amp; ~mask;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#10;     */&#10;    public int nextOccupiedIndex(int fromIndex) {&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#10;        if (fromIndex &gt;= capacity) return -1;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#10;        int bit = fromIndex &amp; 63;&#10;        int words = occupancy.length();&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#10;        // mask off bits before 'bit'&#10;        w &amp;= (-1L &lt;&lt; bit);&#10;        while (true) {&#10;            if (w != 0) {&#10;                int offset = Long.numberOfTrailingZeros(w);&#10;                int idx = (word &lt;&lt; 6) + offset;&#10;                if (idx &lt; capacity) return idx;&#10;                return -1;&#10;            }&#10;            word++;&#10;            if (word &gt;= words) return -1;&#10;            w = occupancy.get(word);&#10;        }&#10;    }&#10;&#10;    // ===== Managed component ticket accessors =====&#10;&#10;    public int[] getManagedIndexArray(int managedTypeIndex) {&#10;        return managedComponentIndexArrays[managedTypeIndex];&#10;    }&#10;&#10;    public int getManagedTicket(int managedTypeIndex, int elementIndex) {&#10;        if (managedTypeIndex &lt; 0 || managedTypeIndex &gt;= managedComponentIndexArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;managedTypeIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        return managedComponentIndexArrays[managedTypeIndex][elementIndex];&#10;    }&#10;&#10;    public void setManagedTicket(int managedTypeIndex, int elementIndex, int ticket) {&#10;        if (managedTypeIndex &lt; 0 || managedTypeIndex &gt;= managedComponentIndexArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;managedTypeIndex out of range&quot;);&#10;        }&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#10;        }&#10;        managedComponentIndexArrays[managedTypeIndex][elementIndex] = ticket;&#10;    }&#10;&#10;    public MemorySegment getComponentArray(int componentIndex) {&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#10;        }&#10;        return componentArrays[componentIndex];&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#13;&#10;&#13;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#13;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#13;&#10;import com.ethnicthv.ecs.core.exception.ECSMemoryAllocationException;&#13;&#10;&#13;&#10;import java.lang.foreign.Arena;&#13;&#10;import java.lang.foreign.MemorySegment;&#13;&#10;import java.util.concurrent.atomic.AtomicInteger;&#13;&#10;import java.util.concurrent.atomic.AtomicIntegerArray;&#13;&#10;import java.util.concurrent.atomic.AtomicLongArray;&#13;&#10;import java.util.Arrays;&#13;&#10;&#13;&#10;/**&#13;&#10; * Single chunk storing SoA arrays for each component.&#13;&#10; */&#13;&#10;public final class ArchetypeChunk implements IArchetypeChunk {&#13;&#10;&#13;&#10;    private final long[] elementSizes;&#13;&#10;    private final MemorySegment[] componentArrays;&#13;&#10;    // New: per-managed-type ticket arrays; may be empty if no managed types&#13;&#10;    private final int[][] managedComponentIndexArrays;&#13;&#10;    private final int capacity;&#13;&#10;    // Lock-free free list: Treiber stack of free indices&#13;&#10;    private final AtomicInteger freeHead; // head index of free list, -1 if none&#13;&#10;    private final int[] nextFree; // next pointer for each slot&#13;&#10;    private final AtomicIntegerArray entityIds; // -1 means free&#13;&#10;    private final Arena arena;&#13;&#10;    private final AtomicInteger size; // number of occupied slots&#13;&#10;    // Queue ticket to suppress duplicate enqueues into availableChunks&#13;&#10;    private final AtomicInteger queued = new AtomicInteger(0); // 0 = not queued, 1 = queued&#13;&#10;    private static final int BITS_PER_WORD = 64;&#13;&#10;    private final AtomicLongArray occupancy; // bit i = 1 if slot i is occupied&#13;&#10;&#13;&#10;    public static final class ChunkLocation {&#13;&#10;        public final int chunkIndex;&#13;&#10;        public final int indexInChunk;&#13;&#10;&#13;&#10;        public ChunkLocation(int chunkIndex, int indexInChunk) {&#13;&#10;            this.chunkIndex = chunkIndex;&#13;&#10;            this.indexInChunk = indexInChunk;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Backwards-compatible constructor (no managed types)&#13;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena) {&#13;&#10;        this(descriptors, elementSizes, capacity, arena, 0);&#13;&#10;    }&#13;&#10;&#13;&#10;    // New constructor supporting managed types&#13;&#10;    public ArchetypeChunk(ComponentDescriptor[] descriptors, long[] elementSizes, int capacity, Arena arena, int managedTypeCount) {&#13;&#10;        this.elementSizes = elementSizes;&#13;&#10;        this.capacity = capacity;&#13;&#10;        this.arena = arena;&#13;&#10;        this.componentArrays = new MemorySegment[descriptors.length];&#13;&#10;        this.size = new AtomicInteger(0);&#13;&#10;        this.entityIds = new AtomicIntegerArray(capacity);&#13;&#10;        this.nextFree = new int[capacity];&#13;&#10;        this.occupancy = new AtomicLongArray((capacity + BITS_PER_WORD - 1) / BITS_PER_WORD);&#13;&#10;        // Initialize free list: 0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; (capacity-1) -&gt; -1&#13;&#10;        for (int i = 0; i &lt; capacity - 1; i++) {&#13;&#10;            nextFree[i] = i + 1;&#13;&#10;            entityIds.set(i, -1);&#13;&#10;        }&#13;&#10;        if (capacity &gt; 0) {&#13;&#10;            nextFree[capacity - 1] = -1;&#13;&#10;            entityIds.set(capacity - 1, -1);&#13;&#10;        }&#13;&#10;        this.freeHead = new AtomicInteger(capacity &gt; 0 ? 0 : -1);&#13;&#10;&#13;&#10;        // Allocate per-component arrays and zero-initialize them&#13;&#10;        for (int i = 0; i &lt; descriptors.length; i++) {&#13;&#10;            long bytes = elementSizes[i] * (long) capacity;&#13;&#10;            if (bytes &lt;= 0) {&#13;&#10;                throw new IllegalArgumentException(&quot;Invalid element size for component &quot; + i + &quot;: &quot; + elementSizes[i]);&#13;&#10;            }&#13;&#10;            try {&#13;&#10;                this.componentArrays[i] = arena.allocate(bytes);&#13;&#10;                // zero entire component array to ensure new slots start clean&#13;&#10;                this.componentArrays[i].fill((byte) 0);&#13;&#10;            } catch (OutOfMemoryError oom) {&#13;&#10;                throw new ECSMemoryAllocationException(&quot;Failed to allocate component array (index=&quot; + i + &quot;, bytes=&quot; + bytes + &quot;, capacity=&quot; + capacity + &quot;)&quot;, oom);&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        // Initialize managed ticket arrays (filled with -1 indicating empty)&#13;&#10;        if (managedTypeCount &gt; 0) {&#13;&#10;            this.managedComponentIndexArrays = new int[managedTypeCount][];&#13;&#10;            for (int i = 0; i &lt; managedTypeCount; i++) {&#13;&#10;                int[] arr = new int[capacity];&#13;&#10;                Arrays.fill(arr, -1);&#13;&#10;                this.managedComponentIndexArrays[i] = arr;&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            this.managedComponentIndexArrays = new int[0][];&#13;&#10;        }&#13;&#10;&#13;&#10;        // keep entityIds initialized to -1&#13;&#10;        // Arrays.fill handled above via AtomicIntegerArray sets&#13;&#10;    }&#13;&#10;&#13;&#10;    public Arena getArena() {&#13;&#10;        return arena;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Allocate a free slot and associate with entityId.&#13;&#10;     * Returns index or -1 if full.&#13;&#10;     */&#13;&#10;    public int allocateSlot(int entityId) {&#13;&#10;        while (true) {&#13;&#10;            int head = freeHead.get();&#13;&#10;            if (head == -1) return -1; // full&#13;&#10;            int next = nextFree[head];&#13;&#10;            if (freeHead.compareAndSet(head, next)) {&#13;&#10;                // zero out the slot data before making it visible to iterators or readers&#13;&#10;                zeroSlot(head);&#13;&#10;                // publish entity id for the claimed slot&#13;&#10;                entityIds.set(head, entityId);&#13;&#10;                // mark occupancy bit so iterators can observe&#13;&#10;                setBit(head);&#13;&#10;                int newSize = size.incrementAndGet();&#13;&#10;                if (newSize &gt; capacity) {&#13;&#10;                    // Defensive: should never happen; roll back and fail fast&#13;&#10;                    size.decrementAndGet();&#13;&#10;                    clearBit(head);&#13;&#10;                    entityIds.set(head, -1);&#13;&#10;                    // push slot back to free list&#13;&#10;                    while (true) {&#13;&#10;                        int h = freeHead.get();&#13;&#10;                        nextFree[head] = h;&#13;&#10;                        if (freeHead.compareAndSet(h, head)) break;&#13;&#10;                    }&#13;&#10;                    throw new IllegalStateException(&quot;ArchetypeChunk size overflow: &quot; + newSize + &quot; &gt; capacity=&quot; + capacity);&#13;&#10;                }&#13;&#10;                return head;&#13;&#10;            }&#13;&#10;            // CAS failed: retry&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public void freeSlot(int index) {&#13;&#10;        if (index &lt; 0 || index &gt;= capacity) return;&#13;&#10;        // mark entity id as free first (helps readers)&#13;&#10;        if (entityIds.getAndSet(index, -1) == -1) {&#13;&#10;            // already free; ignore double free&#13;&#10;            return;&#13;&#10;        }&#13;&#10;        int newSize = size.decrementAndGet();&#13;&#10;        if (newSize &lt; 0) {&#13;&#10;            // Defensive: should never happen; restore and fail fast&#13;&#10;            size.incrementAndGet();&#13;&#10;            entityIds.set(index, -1);&#13;&#10;            throw new IllegalStateException(&quot;ArchetypeChunk size underflow: &quot; + newSize);&#13;&#10;        }&#13;&#10;        // clear occupancy bit (iteration won't visit this index after this point)&#13;&#10;        clearBit(index);&#13;&#10;        // push index onto free list&#13;&#10;        while (true) {&#13;&#10;            int head = freeHead.get();&#13;&#10;            nextFree[index] = head;&#13;&#10;            if (freeHead.compareAndSet(head, index)) {&#13;&#10;                return;&#13;&#10;            }&#13;&#10;            // retry on contention&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void zeroSlot(int idx) {&#13;&#10;        for (int c = 0; c &lt; componentArrays.length; c++) {&#13;&#10;            long elemSize = elementSizes[c];&#13;&#10;            long offset = elemSize * (long) idx;&#13;&#10;            componentArrays[c].asSlice(offset, elemSize).fill((byte) 0);&#13;&#10;        }&#13;&#10;        // Reset managed tickets to -1 for this slot&#13;&#10;        for (int i = 0; i &lt; managedComponentIndexArrays.length; i++) {&#13;&#10;            managedComponentIndexArrays[i][idx] = -1;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isEmpty() {&#13;&#10;        return size.get() == 0;&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public int getEntityId(int index) {&#13;&#10;        return entityIds.get(index);&#13;&#10;    }&#13;&#10;&#13;&#10;    public int capacity() {&#13;&#10;        return capacity;&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public int getCapacity() {&#13;&#10;        return capacity;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Current number of occupied slots in this chunk&#13;&#10;     */&#13;&#10;    @Override&#13;&#10;    public int size() {&#13;&#10;        return size.get();&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public int getEntityCount() {&#13;&#10;        return size();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Return a MemorySegment slice pointing to the component element for an entity slot.&#13;&#10;     * The returned slice is a view into the backing component array (zero-copy).&#13;&#10;     */&#13;&#10;    public MemorySegment getComponentData(int componentIndex, int elementIndex) {&#13;&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        long offset = elementSizes[componentIndex] * (long) elementIndex;&#13;&#10;        return componentArrays[componentIndex].asSlice(offset, elementSizes[componentIndex]);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Copy provided segment into the element slot for componentIndex.&#13;&#10;     * Expects src.byteSize() &lt;= elementSize for that component.&#13;&#10;     */&#13;&#10;    public void setComponentData(int componentIndex, int elementIndex, MemorySegment src) {&#13;&#10;        MemorySegment dst = getComponentData(componentIndex, elementIndex);&#13;&#10;        long copyLen = Math.min(dst.byteSize(), src.byteSize());&#13;&#10;        MemorySegment.copy(src, 0, dst, 0, copyLen);&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean hasFree() {&#13;&#10;        return freeHead.get() != -1;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Try to mark this chunk as queued; returns true if caller should enqueue its index.&#13;&#10;     */&#13;&#10;    public boolean tryMarkQueued() {&#13;&#10;        return queued.compareAndSet(0, 1);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Clear queued mark when a consumer polls this chunk from the queue.&#13;&#10;     */&#13;&#10;    public void markDequeued() {&#13;&#10;        queued.set(0);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void setBit(int idx) {&#13;&#10;        int word = idx &gt;&gt;&gt; 6; // /64&#13;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#13;&#10;        while (true) {&#13;&#10;            long cur = occupancy.get(word);&#13;&#10;            long nxt = cur | mask;&#13;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void clearBit(int idx) {&#13;&#10;        int word = idx &gt;&gt;&gt; 6;&#13;&#10;        long mask = 1L &lt;&lt; (idx &amp; 63);&#13;&#10;        while (true) {&#13;&#10;            long cur = occupancy.get(word);&#13;&#10;            long nxt = cur &amp; ~mask;&#13;&#10;            if (cur == nxt || occupancy.compareAndSet(word, cur, nxt)) return;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Find next occupied slot index &gt;= fromIndex using occupancy bitset. Returns -1 if none.&#13;&#10;     */&#13;&#10;    public int nextOccupiedIndex(int fromIndex) {&#13;&#10;        if (fromIndex &lt; 0) fromIndex = 0;&#13;&#10;        if (fromIndex &gt;= capacity) return -1;&#13;&#10;        int word = fromIndex &gt;&gt;&gt; 6;&#13;&#10;        int bit = fromIndex &amp; 63;&#13;&#10;        int words = occupancy.length();&#13;&#10;        long w = (word &lt; words) ? occupancy.get(word) : 0L;&#13;&#10;        // mask off bits before 'bit'&#13;&#10;        w &amp;= (-1L &lt;&lt; bit);&#13;&#10;        while (true) {&#13;&#10;            if (w != 0) {&#13;&#10;                int offset = Long.numberOfTrailingZeros(w);&#13;&#10;                int idx = (word &lt;&lt; 6) + offset;&#13;&#10;                if (idx &lt; capacity) return idx;&#13;&#10;                return -1;&#13;&#10;            }&#13;&#10;            word++;&#13;&#10;            if (word &gt;= words) return -1;&#13;&#10;            w = occupancy.get(word);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // ===== Managed component ticket accessors =====&#13;&#10;&#13;&#10;    public int[] getManagedIndexArray(int managedTypeIndex) {&#13;&#10;        return managedComponentIndexArrays[managedTypeIndex];&#13;&#10;    }&#13;&#10;&#13;&#10;    public int getManagedTicket(int managedTypeIndex, int elementIndex) {&#13;&#10;        if (managedTypeIndex &lt; 0 || managedTypeIndex &gt;= managedComponentIndexArrays.length) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;managedTypeIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        return managedComponentIndexArrays[managedTypeIndex][elementIndex];&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setManagedTicket(int managedTypeIndex, int elementIndex, int ticket) {&#13;&#10;        if (managedTypeIndex &lt; 0 || managedTypeIndex &gt;= managedComponentIndexArrays.length) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;managedTypeIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        if (elementIndex &lt; 0 || elementIndex &gt;= capacity) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;elementIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        managedComponentIndexArrays[managedTypeIndex][elementIndex] = ticket;&#13;&#10;    }&#13;&#10;&#13;&#10;    public MemorySegment getComponentArray(int componentIndex) {&#13;&#10;        if (componentIndex &lt; 0 || componentIndex &gt;= componentArrays.length) {&#13;&#10;            throw new IndexOutOfBoundsException(&quot;componentIndex out of range&quot;);&#13;&#10;        }&#13;&#10;        return componentArrays[componentIndex];&#13;&#10;    }&#13;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] allTypeIds = m.toComponentIdArray();&#10;&#10;            List&lt;ComponentDescriptor&gt; unmanagedInstanceDescs = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; unmanagedInstanceIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; managedInstanceIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; unmanagedSharedIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; managedSharedIds = new ArrayList&lt;&gt;();&#10;&#10;            for (int typeId : allTypeIds) {&#10;                var meta = metadataProvider.apply(typeId);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + typeId);&#10;                }&#10;                ComponentDescriptor desc = componentManager.getDescriptor(meta.type());&#10;                if (desc == null) {&#10;                    throw new IllegalStateException(&quot;Descriptor missing for component &quot; + meta.type().getName());&#10;                }&#10;                ComponentDescriptor.ComponentKind kind = desc.getKind();&#10;                switch (kind) {&#10;                    case INSTANCE_UNMANAGED -&gt; {&#10;                        unmanagedInstanceIds.add(typeId);&#10;                        unmanagedInstanceDescs.add(desc);&#10;                    }&#10;                    case INSTANCE_MANAGED -&gt; managedInstanceIds.add(typeId);&#10;                    case SHARED_UNMANAGED -&gt; unmanagedSharedIds.add(typeId);&#10;                    case SHARED_MANAGED -&gt; managedSharedIds.add(typeId);&#10;                }&#10;            }&#10;&#10;            ComponentDescriptor[] unmanagedInstanceArray = unmanagedInstanceDescs.toArray(new ComponentDescriptor[0]);&#10;            int[] managedInstanceIdsArray = managedInstanceIds.stream().mapToInt(Integer::intValue).toArray();&#10;            int[] unmanagedSharedIdsArray = unmanagedSharedIds.stream().mapToInt(Integer::intValue).toArray();&#10;            int[] managedSharedIdsArray = managedSharedIds.stream().mapToInt(Integer::intValue).toArray();&#10;&#10;            Archetype archetype = new Archetype(m, allTypeIds, unmanagedInstanceArray, managedInstanceIdsArray, unmanagedSharedIdsArray, managedSharedIdsArray, arena);&#10;            // Provide the mapping for unmanaged instance type ids order used in this archetype&#10;            int[] unmanagedInstanceIdsArray = unmanagedInstanceIds.stream().mapToInt(Integer::intValue).toArray();&#10;            archetype.setUnmanagedTypeIds(unmanagedInstanceIdsArray);&#10;            return archetype;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.IntFunction;&#10;&#10;/**&#10; * Manages all archetypes in the ECS world.&#10; * Creates and retrieves archetypes based on component masks.&#10; */&#10;public final class ArchetypeManager {&#10;    private final ConcurrentHashMap&lt;ComponentMask, Archetype&gt; archetypes;&#10;    private final Arena arena;&#10;    private final ComponentManager componentManager;&#10;    private final IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider;&#10;&#10;    public ArchetypeManager(Arena arena, ComponentManager componentManager,&#10;                            IntFunction&lt;ArchetypeWorld.ComponentMetadata&gt; metadataProvider) {&#10;        this.archetypes = new ConcurrentHashMap&lt;&gt;();&#10;        this.arena = arena;&#10;        this.componentManager = componentManager;&#10;        this.metadataProvider = metadataProvider;&#10;    }&#10;&#10;    /**&#10;     * Get or create an archetype for the given component mask.&#10;     * Thread-safe: computeIfAbsent is atomic per key on ConcurrentHashMap.&#10;     * This overload derives componentIds and descriptors internally from the mask.&#10;     */&#10;    public Archetype getOrCreateArchetype(ComponentMask mask) {&#10;        return archetypes.computeIfAbsent(mask, m -&gt; {&#10;            int[] allTypeIds = m.toComponentIdArray();&#10;&#10;            List&lt;ComponentDescriptor&gt; unmanagedInstanceDescs = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; unmanagedInstanceIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; managedInstanceIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; unmanagedSharedIds = new ArrayList&lt;&gt;();&#10;            List&lt;Integer&gt; managedSharedIds = new ArrayList&lt;&gt;();&#10;&#10;            for (int typeId : allTypeIds) {&#10;                var meta = metadataProvider.apply(typeId);&#10;                if (meta == null) {&#10;                    throw new IllegalStateException(&quot;Component metadata missing for id=&quot; + typeId);&#10;                }&#10;                ComponentDescriptor desc = componentManager.getDescriptor(meta.type());&#10;                if (desc == null) {&#10;                    throw new IllegalStateException(&quot;Descriptor missing for component &quot; + meta.type().getName());&#10;                }&#10;                ComponentDescriptor.ComponentKind kind = desc.getKind();&#10;                switch (kind) {&#10;                    case INSTANCE_UNMANAGED -&gt; {&#10;                        unmanagedInstanceIds.add(typeId);&#10;                        unmanagedInstanceDescs.add(desc);&#10;                    }&#10;                    case INSTANCE_MANAGED -&gt; managedInstanceIds.add(typeId);&#10;                    case SHARED_UNMANAGED -&gt; unmanagedSharedIds.add(typeId);&#10;                    case SHARED_MANAGED -&gt; managedSharedIds.add(typeId);&#10;                }&#10;            }&#10;&#10;            ComponentDescriptor[] unmanagedInstanceArray = unmanagedInstanceDescs.toArray(new ComponentDescriptor[0]);&#10;            int[] managedInstanceIdsArray = managedInstanceIds.stream().mapToInt(Integer::intValue).toArray();&#10;            int[] unmanagedSharedIdsArray = unmanagedSharedIds.stream().mapToInt(Integer::intValue).toArray();&#10;            int[] managedSharedIdsArray = managedSharedIds.stream().mapToInt(Integer::intValue).toArray();&#10;&#10;            Archetype archetype = new Archetype(m, allTypeIds, unmanagedInstanceArray, managedInstanceIdsArray, unmanagedSharedIdsArray, managedSharedIdsArray, arena);&#10;            // Provide the mapping for unmanaged instance type ids order used in this archetype&#10;            int[] unmanagedInstanceIdsArray = unmanagedInstanceIds.stream().mapToInt(Integer::intValue).toArray();&#10;            archetype.setUnmanagedTypeIds(unmanagedInstanceIdsArray);&#10;            return archetype;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get an existing archetype or null if it doesn't exist&#10;     */&#10;    public Archetype getArchetype(ComponentMask mask) {&#10;        return archetypes.get(mask);&#10;    }&#10;&#10;    /**&#10;     * Get all archetypes. The returned view is weakly consistent and safe to iterate while&#10;     * other threads add new archetypes; it will not throw ConcurrentModificationException.&#10;     */&#10;    public Iterable&lt;Archetype&gt; getAllArchetypes() {&#10;        return archetypes.values();&#10;    }&#10;&#10;    /**&#10;     * Get total entity count across all archetypes&#10;     */&#10;    public int getTotalEntityCount() {&#10;        return archetypes.values().stream()&#10;            .mapToInt(Archetype::getEntityCount)&#10;            .sum();&#10;    }&#10;&#10;    /**&#10;     * Clear all archetypes&#10;     */&#10;    public void clear() {&#10;        archetypes.clear();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeQuery.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ArchetypeQuery.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQuery;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentHandle;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Arrays;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * This class implements both {@link IQueryBuilder} (for configuration) and&#10; * {@link IQuery} (for execution). Once {@link #build()} is called, it returns&#10; * an immutable snapshot of the query configuration.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery implements IQueryBuilder, IQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    private final List&lt;Class&lt;?&gt;&gt; compList = new ArrayList&lt;&gt;();&#10;    private final List&lt;Integer&gt; compIdxList = new ArrayList&lt;&gt;();&#10;&#10;    // New: shared filters (at most one managed value and many unmanaged pairs)&#10;    private Object managedSharedFilter = null;&#10;    private final List&lt;UnmanagedFilter&gt; unmanagedSharedFilters = new ArrayList&lt;&gt;();&#10;&#10;    // Expose for generated code to reference as a type&#10;    public static final class UnmanagedFilter {&#10;        public final Class&lt;?&gt; type;&#10;        public final long value;&#10;        public UnmanagedFilter(Class&lt;?&gt; type, long value) { this.type = type; this.value = value; }&#10;    }&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) { this.world = world; }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        compList.add(componentClass);&#10;        compIdxList.add(componentTypeId);&#10;&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    @Override&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    @Override&#10;    public IQueryBuilder withShared(Object managedValue) {&#10;        this.managedSharedFilter = managedValue;&#10;        return this;&#10;    }&#10;&#10;    @Override&#10;    public IQueryBuilder withShared(Class&lt;?&gt; unmanagedSharedType, long value) {&#10;        unmanagedSharedFilters.add(new UnmanagedFilter(unmanagedSharedType, value));&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Build an immutable query from this builder's configuration.&#10;     * &lt;p&gt;&#10;     * This method creates a snapshot of the current query configuration.&#10;     * The returned {@link IQuery} is immutable and thread-safe.&#10;     * &lt;p&gt;&#10;     * Note: Since ArchetypeQuery implements both IQueryBuilder and IQuery,&#10;     * this method simply returns itself. However, callers should treat the&#10;     * returned reference as immutable and not call builder methods on it.&#10;     *&#10;     * @return an immutable query instance&#10;     */&#10;    @Override&#10;    public IQuery build() {&#10;        // For now, we return this instance&#10;        // In a more sophisticated implementation, we could create&#10;        // a truly immutable wrapper or snapshot&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    @Override&#10;    public void forEach(IQuery.ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            // Build query key if any shared filters provided&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue; // skip archetype entirely&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    @Override&#10;    public void forEachChunk(IQuery.ChunkConsumer consumer) {&#10;        // Use group-level filtering if possible&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;            if (!archetypeMask.containsAll(with)) continue;&#10;            if (!archetypeMask.containsNone(without)) continue;&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue;&#10;                ArchetypeChunk[] chunks = group.getChunksSnapshot();&#10;                int count = group.chunkCount();&#10;                for (int i = 0; i &lt; count; i++) consumer.accept(chunks[i], archetype);&#10;            } else {&#10;                for (IArchetypeChunk chunk : archetype.getChunks()) consumer.accept(chunk, archetype);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    @Override&#10;    public void forEachEntity(IQuery.EntityConsumer consumer) {&#10;        ComponentManager mgr = world.getComponentManager();&#10;        Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;        for (int i = 0; i &lt; compList.size(); i++) componentClasses[i] = compList.get(i);&#10;&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;            if (!archetypeMask.containsAll(with)) continue;&#10;            if (!archetypeMask.containsNone(without)) continue;&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            // Precompute component indices for this archetype&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            boolean ok = true;&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) { ok = false; break; }&#10;                compIndices[i] = idx;&#10;            }&#10;            if (!ok) continue;&#10;&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue;&#10;                ArchetypeChunk[] chunks = group.getChunksSnapshot();&#10;                int count = group.chunkCount();&#10;                for (int ci = 0; ci &lt; count; ci++) {&#10;                    ArchetypeChunk chunk = chunks[ci];&#10;                    iterateChunkEntities(chunk, mgr, componentClasses, compIndices, consumer, archetype);&#10;                }&#10;            } else {&#10;                for (IArchetypeChunk chunk : archetype.getChunks()) {&#10;                    iterateChunkEntities((ArchetypeChunk) chunk, mgr, componentClasses, compIndices, consumer, archetype);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void iterateChunkEntities(ArchetypeChunk chunk, ComponentManager mgr, Class&lt;?&gt;[] componentClasses, int[] compIndices, IQuery.EntityConsumer consumer, Archetype archetype) {&#10;        ComponentHandle[] pooled = new ComponentHandle[compIndices.length];&#10;        for (int k = 0; k &lt; compIndices.length; k++) pooled[k] = mgr.acquireHandle();&#10;        try {&#10;            int idx = chunk.nextOccupiedIndex(0);&#10;            while (idx &gt;= 0) {&#10;                int entityId = chunk.getEntityId(idx);&#10;                for (int k = 0; k &lt; compIndices.length; k++) {&#10;                    var seg = chunk.getComponentData(compIndices[k], idx);&#10;                    pooled[k].reset(seg, mgr.getDescriptor(componentClasses[k]));&#10;                }&#10;                consumer.accept(entityId, pooled, archetype);&#10;                idx = chunk.nextOccupiedIndex(idx + 1);&#10;            }&#10;        } finally {&#10;            for (int k = 0; k &lt; compIndices.length; k++) if (pooled[k] != null) mgr.releaseHandle(pooled[k]);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    @Override&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    /**&#10;     * Execute the query and process matching entities in parallel across multiple CPU cores.&#10;     * &lt;p&gt;&#10;     * This method leverages Java's parallel streams to distribute entity processing across&#10;     * available CPU cores. The processing is done at the chunk level - each chunk is processed&#10;     * by a single thread, but different chunks may be processed concurrently.&#10;     * &lt;p&gt;&#10;     * &lt;strong&gt;THREAD SAFETY REQUIREMENTS:&lt;/strong&gt;&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;The provided {@code EntityConsumer} MUST be thread-safe&lt;/li&gt;&#10;     *   &lt;li&gt;Any shared state accessed or modified by the consumer must be properly synchronized&lt;/li&gt;&#10;     *   &lt;li&gt;The consumer may be called concurrently from multiple threads&lt;/li&gt;&#10;     *   &lt;li&gt;There are no ordering guarantees - entities may be processed in any order&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     * &lt;p&gt;&#10;     * Performance considerations:&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;Best suited for CPU-intensive operations on large entity sets&lt;/li&gt;&#10;     *   &lt;li&gt;Overhead of parallelization may not be worth it for very small entity counts&lt;/li&gt;&#10;     *   &lt;li&gt;The actual parallelism depends on the ForkJoinPool common pool size&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     *&#10;     * @param consumer A thread-safe callback that processes each matching entity.&#10;     *                 Called with (entityId, handles, archetype) for each entity.&#10;     * @throws NullPointerException if consumer is null&#10;     *&#10;     * @see #forEachEntity(EntityConsumer) for sequential processing&#10;     */&#10;    @Override&#10;    public void forEachParallel(IQuery.EntityConsumer consumer) {&#10;        if (consumer == null) throw new NullPointerException(&quot;EntityConsumer must not be null&quot;);&#10;        ComponentManager mgr = world.getComponentManager();&#10;        Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;        for (int i = 0; i &lt; compList.size(); i++) componentClasses[i] = compList.get(i);&#10;&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;            if (!archetypeMask.containsAll(with)) continue;&#10;            if (!archetypeMask.containsNone(without)) continue;&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            boolean ok = true;&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) { ok = false; break; }&#10;                compIndices[i] = idx;&#10;            }&#10;            if (!ok) continue;&#10;&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue;&#10;                ArchetypeChunk[] chunks = group.getChunksSnapshot();&#10;                int count = group.chunkCount();&#10;                Arrays.stream(chunks, 0, count).parallel().forEach(chunk -&gt;&#10;                    iterateChunkEntities(chunk, mgr, componentClasses, compIndices, consumer, archetype)&#10;                );&#10;            } else {&#10;                ArchetypeChunk[] chunks = archetype.getChunksSnapshot();&#10;                int count = archetype.chunkCount();&#10;                Arrays.stream(chunks, 0, count).parallel().forEach(chunk -&gt;&#10;                    iterateChunkEntities(chunk, mgr, componentClasses, compIndices, consumer, archetype)&#10;                );&#10;            }&#10;        }&#10;    }&#10;&#10;    private SharedValueKey buildQueryKey(Archetype archetype) {&#10;        int[] managedIdx = null;&#10;        long[] unmanagedVals = null;&#10;        boolean any = false;&#10;&#10;        if (managedSharedFilter != null) {&#10;            int ticket = world.findSharedIndex(managedSharedFilter);&#10;            if (ticket &lt; 0) return null;&#10;            int managedCount = archetype.getSharedManagedTypeIds().length;&#10;            if (managedCount == 0) return null;&#10;            managedIdx = new int[managedCount];&#10;            Arrays.fill(managedIdx, -1);&#10;            for (int typeId : archetype.getSharedManagedTypeIds()) {&#10;                int pos = archetype.getSharedManagedIndex(typeId);&#10;                if (pos &gt;= 0) { managedIdx[pos] = ticket; any = true; }&#10;            }&#10;        }&#10;        if (!unmanagedSharedFilters.isEmpty()) {&#10;            int unmanagedCount = archetype.getSharedUnmanagedTypeIds().length;&#10;            if (unmanagedCount == 0) return null;&#10;            unmanagedVals = new long[unmanagedCount];&#10;            Arrays.fill(unmanagedVals, Long.MIN_VALUE);&#10;            for (UnmanagedFilter f : unmanagedSharedFilters) {&#10;                Integer typeId = world.getComponentTypeId(f.type);&#10;                if (typeId == null) return null;&#10;                int pos = archetype.getSharedUnmanagedIndex(typeId);&#10;                if (pos &lt; 0) return null;&#10;                unmanagedVals[pos] = f.value; any = true;&#10;            }&#10;        }&#10;        if (!any) return null;&#10;        return new SharedValueKey(managedIdx, unmanagedVals);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IQuery;&#10;import com.ethnicthv.ecs.core.api.archetype.IQueryBuilder;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.ComponentHandle;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Arrays;&#10;&#10;/**&#10; * Query system for filtering archetypes based on component requirements.&#10; * &lt;p&gt;&#10; * This class implements both {@link IQueryBuilder} (for configuration) and&#10; * {@link IQuery} (for execution). Once {@link #build()} is called, it returns&#10; * an immutable snapshot of the query configuration.&#10; * &lt;p&gt;&#10; * Supports:&#10; * - with(): entities MUST have these components&#10; * - without(): entities MUST NOT have these components&#10; * - any(): entities must have AT LEAST ONE of these components&#10; */&#10;public final class ArchetypeQuery implements IQueryBuilder, IQuery {&#10;    private final ArchetypeWorld world;&#10;    private final ComponentMask.Builder withMask = ComponentMask.builder();&#10;    private final ComponentMask.Builder withoutMask = ComponentMask.builder();&#10;    private final List&lt;ComponentMask&gt; anyMasks = new ArrayList&lt;&gt;();&#10;&#10;    private final List&lt;Class&lt;?&gt;&gt; compList = new ArrayList&lt;&gt;();&#10;    private final List&lt;Integer&gt; compIdxList = new ArrayList&lt;&gt;();&#10;&#10;    // New: shared filters (at most one managed value and many unmanaged pairs)&#10;    private Object managedSharedFilter = null;&#10;    private final List&lt;UnmanagedFilter&gt; unmanagedSharedFilters = new ArrayList&lt;&gt;();&#10;&#10;    // Expose for generated code to reference as a type&#10;    public static final class UnmanagedFilter {&#10;        public final Class&lt;?&gt; type;&#10;        public final long value;&#10;        public UnmanagedFilter(Class&lt;?&gt; type, long value) { this.type = type; this.value = value; }&#10;    }&#10;&#10;    public ArchetypeQuery(ArchetypeWorld world) { this.world = world; }&#10;&#10;    /**&#10;     * Require entities to have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery with(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        compList.add(componentClass);&#10;        compIdxList.add(componentTypeId);&#10;&#10;        if (componentTypeId != null) {&#10;            withMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to NOT have this component&#10;     */&#10;    public &lt;T&gt; ArchetypeQuery without(Class&lt;T&gt; componentClass) {&#10;        Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;        if (componentTypeId != null) {&#10;            withoutMask.with(componentTypeId);&#10;        }&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Require entities to have at least one of the specified components&#10;     */&#10;    @Override&#10;    public ArchetypeQuery any(Class&lt;?&gt;... componentClasses) {&#10;        ComponentMask.Builder anyBuilder = ComponentMask.builder();&#10;        for (Class&lt;?&gt; componentClass : componentClasses) {&#10;            Integer componentTypeId = world.getComponentTypeId(componentClass);&#10;            if (componentTypeId != null) {&#10;                anyBuilder.with(componentTypeId);&#10;            }&#10;        }&#10;        anyMasks.add(anyBuilder.build());&#10;        return this;&#10;    }&#10;&#10;    @Override&#10;    public IQueryBuilder withShared(Object managedValue) {&#10;        this.managedSharedFilter = managedValue;&#10;        return this;&#10;    }&#10;&#10;    @Override&#10;    public IQueryBuilder withShared(Class&lt;?&gt; unmanagedSharedType, long value) {&#10;        unmanagedSharedFilters.add(new UnmanagedFilter(unmanagedSharedType, value));&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Build an immutable query from this builder's configuration.&#10;     * &lt;p&gt;&#10;     * This method creates a snapshot of the current query configuration.&#10;     * The returned {@link IQuery} is immutable and thread-safe.&#10;     * &lt;p&gt;&#10;     * Note: Since ArchetypeQuery implements both IQueryBuilder and IQuery,&#10;     * this method simply returns itself. However, callers should treat the&#10;     * returned reference as immutable and not call builder methods on it.&#10;     *&#10;     * @return an immutable query instance&#10;     */&#10;    @Override&#10;    public IQuery build() {&#10;        // For now, we return this instance&#10;        // In a more sophisticated implementation, we could create&#10;        // a truly immutable wrapper or snapshot&#10;        return this;&#10;    }&#10;&#10;    /**&#10;     * Execute the query and iterate over matching archetypes&#10;     */&#10;    @Override&#10;    public void forEach(IQuery.ArchetypeConsumer consumer) {&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;&#10;            // WITH: archetype must contain all required bits&#10;            if (!archetypeMask.containsAll(with)) {&#10;                continue;&#10;            }&#10;            // WITHOUT: archetype must contain none of the excluded bits&#10;            if (!archetypeMask.containsNone(without)) {&#10;                continue;&#10;            }&#10;            // ANY: archetype must intersect at least one any-mask (if present)&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            // Build query key if any shared filters provided&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue; // skip archetype entirely&#10;            }&#10;&#10;            consumer.accept(archetype);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching chunks&#10;     */&#10;    @Override&#10;    public void forEachChunk(IQuery.ChunkConsumer consumer) {&#10;        // Use group-level filtering if possible&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;            if (!archetypeMask.containsAll(with)) continue;&#10;            if (!archetypeMask.containsNone(without)) continue;&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue;&#10;                ArchetypeChunk[] chunks = group.getChunksSnapshot();&#10;                int count = group.chunkCount();&#10;                for (int i = 0; i &lt; count; i++) consumer.accept(chunks[i], archetype);&#10;            } else {&#10;                for (IArchetypeChunk chunk : archetype.getChunks()) consumer.accept(chunk, archetype);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute query and iterate over matching entities&#10;     */&#10;    @Override&#10;    public void forEachEntity(IQuery.EntityConsumer consumer) {&#10;        ComponentManager mgr = world.getComponentManager();&#10;        Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;        for (int i = 0; i &lt; compList.size(); i++) componentClasses[i] = compList.get(i);&#10;&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;            if (!archetypeMask.containsAll(with)) continue;&#10;            if (!archetypeMask.containsNone(without)) continue;&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            // Precompute component indices for this archetype&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            boolean ok = true;&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) { ok = false; break; }&#10;                compIndices[i] = idx;&#10;            }&#10;            if (!ok) continue;&#10;&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue;&#10;                ArchetypeChunk[] chunks = group.getChunksSnapshot();&#10;                int count = group.chunkCount();&#10;                for (int ci = 0; ci &lt; count; ci++) {&#10;                    ArchetypeChunk chunk = chunks[ci];&#10;                    iterateChunkEntities(chunk, mgr, componentClasses, compIndices, consumer, archetype);&#10;                }&#10;            } else {&#10;                for (IArchetypeChunk chunk : archetype.getChunks()) {&#10;                    iterateChunkEntities((ArchetypeChunk) chunk, mgr, componentClasses, compIndices, consumer, archetype);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void iterateChunkEntities(ArchetypeChunk chunk, ComponentManager mgr, Class&lt;?&gt;[] componentClasses, int[] compIndices, IQuery.EntityConsumer consumer, Archetype archetype) {&#10;        ComponentHandle[] pooled = new ComponentHandle[compIndices.length];&#10;        for (int k = 0; k &lt; compIndices.length; k++) pooled[k] = mgr.acquireHandle();&#10;        try {&#10;            int idx = chunk.nextOccupiedIndex(0);&#10;            while (idx &gt;= 0) {&#10;                int entityId = chunk.getEntityId(idx);&#10;                for (int k = 0; k &lt; compIndices.length; k++) {&#10;                    var seg = chunk.getComponentData(compIndices[k], idx);&#10;                    pooled[k].reset(seg, mgr.getDescriptor(componentClasses[k]));&#10;                }&#10;                consumer.accept(entityId, pooled, archetype);&#10;                idx = chunk.nextOccupiedIndex(idx + 1);&#10;            }&#10;        } finally {&#10;            for (int k = 0; k &lt; compIndices.length; k++) if (pooled[k] != null) mgr.releaseHandle(pooled[k]);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Count matching entities&#10;     */&#10;    @Override&#10;    public int count() {&#10;        final int[] count = {0};&#10;        forEach(archetype -&gt; count[0] += archetype.getEntityCount());&#10;        return count[0];&#10;    }&#10;&#10;    /**&#10;     * Execute the query and process matching entities in parallel across multiple CPU cores.&#10;     * &lt;p&gt;&#10;     * This method leverages Java's parallel streams to distribute entity processing across&#10;     * available CPU cores. The processing is done at the chunk level - each chunk is processed&#10;     * by a single thread, but different chunks may be processed concurrently.&#10;     * &lt;p&gt;&#10;     * &lt;strong&gt;THREAD SAFETY REQUIREMENTS:&lt;/strong&gt;&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;The provided {@code EntityConsumer} MUST be thread-safe&lt;/li&gt;&#10;     *   &lt;li&gt;Any shared state accessed or modified by the consumer must be properly synchronized&lt;/li&gt;&#10;     *   &lt;li&gt;The consumer may be called concurrently from multiple threads&lt;/li&gt;&#10;     *   &lt;li&gt;There are no ordering guarantees - entities may be processed in any order&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     * &lt;p&gt;&#10;     * Performance considerations:&#10;     * &lt;ul&gt;&#10;     *   &lt;li&gt;Best suited for CPU-intensive operations on large entity sets&lt;/li&gt;&#10;     *   &lt;li&gt;Overhead of parallelization may not be worth it for very small entity counts&lt;/li&gt;&#10;     *   &lt;li&gt;The actual parallelism depends on the ForkJoinPool common pool size&lt;/li&gt;&#10;     * &lt;/ul&gt;&#10;     *&#10;     * @param consumer A thread-safe callback that processes each matching entity.&#10;     *                 Called with (entityId, handles, archetype) for each entity.&#10;     * @throws NullPointerException if consumer is null&#10;     *&#10;     * @see #forEachEntity(EntityConsumer) for sequential processing&#10;     */&#10;    @Override&#10;    public void forEachParallel(IQuery.EntityConsumer consumer) {&#10;        if (consumer == null) throw new NullPointerException(&quot;EntityConsumer must not be null&quot;);&#10;        ComponentManager mgr = world.getComponentManager();&#10;        Class&lt;?&gt;[] componentClasses = new Class&lt;?&gt;[compList.size()];&#10;        for (int i = 0; i &lt; compList.size(); i++) componentClasses[i] = compList.get(i);&#10;&#10;        ComponentMask with = withMask.build();&#10;        ComponentMask without = withoutMask.build();&#10;&#10;        for (Archetype archetype : world.getAllArchetypes()) {&#10;            ComponentMask archetypeMask = archetype.getMask();&#10;            if (!archetypeMask.containsAll(with)) continue;&#10;            if (!archetypeMask.containsNone(without)) continue;&#10;            if (!anyMasks.isEmpty()) {&#10;                boolean matchesAny = false;&#10;                for (ComponentMask anyMask : anyMasks) { if (archetypeMask.intersects(anyMask)) { matchesAny = true; break; } }&#10;                if (!matchesAny) continue;&#10;            }&#10;&#10;            int[] compIndices = new int[compIdxList.size()];&#10;            boolean ok = true;&#10;            for (int i = 0; i &lt; compIdxList.size(); i++) {&#10;                int idx = archetype.indexOfComponentType(compIdxList.get(i));&#10;                if (idx &lt; 0) { ok = false; break; }&#10;                compIndices[i] = idx;&#10;            }&#10;            if (!ok) continue;&#10;&#10;            SharedValueKey key = buildQueryKey(archetype);&#10;            if (key != null) {&#10;                ChunkGroup group = archetype.getChunkGroup(key);&#10;                if (group == null) continue;&#10;                ArchetypeChunk[] chunks = group.getChunksSnapshot();&#10;                int count = group.chunkCount();&#10;                Arrays.stream(chunks, 0, count).parallel().forEach(chunk -&gt;&#10;                    iterateChunkEntities(chunk, mgr, componentClasses, compIndices, consumer, archetype)&#10;                );&#10;            } else {&#10;                ArchetypeChunk[] chunks = archetype.getChunksSnapshot();&#10;                int count = archetype.chunkCount();&#10;                Arrays.stream(chunks, 0, count).parallel().forEach(chunk -&gt;&#10;                    iterateChunkEntities(chunk, mgr, componentClasses, compIndices, consumer, archetype)&#10;                );&#10;            }&#10;        }&#10;    }&#10;&#10;    private SharedValueKey buildQueryKey(Archetype archetype) {&#10;        int[] managedIdx = null;&#10;        long[] unmanagedVals = null;&#10;        boolean any = false;&#10;&#10;        if (managedSharedFilter != null) {&#10;            int ticket = world.findSharedIndex(managedSharedFilter);&#10;            if (ticket &lt; 0) return null;&#10;            int managedCount = archetype.getSharedManagedTypeIds().length;&#10;            if (managedCount == 0) return null;&#10;            managedIdx = new int[managedCount];&#10;            Arrays.fill(managedIdx, -1);&#10;            for (int typeId : archetype.getSharedManagedTypeIds()) {&#10;                int pos = archetype.getSharedManagedIndex(typeId);&#10;                if (pos &gt;= 0) { managedIdx[pos] = ticket; any = true; }&#10;            }&#10;        }&#10;        if (!unmanagedSharedFilters.isEmpty()) {&#10;            int unmanagedCount = archetype.getSharedUnmanagedTypeIds().length;&#10;            if (unmanagedCount == 0) return null;&#10;            unmanagedVals = new long[unmanagedCount];&#10;            Arrays.fill(unmanagedVals, Long.MIN_VALUE);&#10;            for (UnmanagedFilter f : unmanagedSharedFilters) {&#10;                Integer typeId = world.getComponentTypeId(f.type);&#10;                if (typeId == null) return null;&#10;                int pos = archetype.getSharedUnmanagedIndex(typeId);&#10;                if (pos &lt; 0) return null;&#10;                unmanagedVals[pos] = f.value; any = true;&#10;            }&#10;        }&#10;        if (!any) return null;&#10;        return new SharedValueKey(managedIdx, unmanagedVals);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ChunkGroup.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/ChunkGroup.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;/**&#10; * ChunkGroup encapsulates chunk management logic for an Archetype.&#10; * Simplified provisioning logic: only uses resizeLock (no spin / atomic boolean coordination).&#10; */&#10;public final class ChunkGroup {&#10;    private volatile ArchetypeChunk[] chunks;&#10;    private final AtomicInteger chunkCount = new AtomicInteger(0);&#10;    private final ReentrantLock resizeLock = new ReentrantLock();&#10;    private final ConcurrentLinkedQueue&lt;Integer&gt; availableChunks = new ConcurrentLinkedQueue&lt;&gt;();&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final Arena arena;&#10;    private final int managedTypeCount;&#10;&#10;    public ChunkGroup(ComponentDescriptor[] descriptors, long[] elementSizes, int entitiesPerChunk, Arena arena, int managedTypeCount) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.entitiesPerChunk = entitiesPerChunk;&#10;        this.arena = arena;&#10;        this.managedTypeCount = managedTypeCount;&#10;        this.chunks = new ArchetypeChunk[Math.max(4, 1)];&#10;        ArchetypeChunk first = new ArchetypeChunk(descriptors, elementSizes, entitiesPerChunk, arena, managedTypeCount);&#10;        this.chunks[0] = first;&#10;        chunkCount.set(1);&#10;        if (first.tryMarkQueued()) {&#10;            this.availableChunks.add(0);&#10;        }&#10;    }&#10;&#10;    // --- New optimistic addEntity implementation ---&#10;    public ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        // 1. Fast path attempt without locking&#10;        ArchetypeChunk.ChunkLocation loc = tryFastPathAllocate(entityId);&#10;        if (loc != null) return loc;&#10;&#10;        // 2. Slow path: acquire real lock, double-check, then create&#10;        resizeLock.lock();&#10;        try {&#10;            // 3. Double-check after acquiring lock (another thread may have inserted a chunk)&#10;            loc = tryFastPathAllocate(entityId);&#10;            if (loc != null) return loc;&#10;            // 4. Still no space: create new chunk and allocate&#10;            return createChunkAndAllocate(entityId);&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;    }&#10;&#10;    private ArchetypeChunk.ChunkLocation tryFastPathAllocate(int entityId) {&#10;        Integer idxChunk;&#10;        while ((idxChunk = availableChunks.poll()) != null) { // dequeue a chunk with (expected) free slots&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idxChunk];&#10;            if (chunk == null) continue;&#10;            chunk.markDequeued();&#10;            int slot = chunk.allocateSlot(entityId);&#10;            if (slot &gt;= 0) {&#10;                if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) { // requeue if still space&#10;                    availableChunks.offer(idxChunk);&#10;                }&#10;                return new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;            }&#10;            // If allocation failed (race filled chunk), just loop to next available&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private ArchetypeChunk.ChunkLocation createChunkAndAllocate(int entityId) {&#10;        ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, elementSizes, entitiesPerChunk, arena, managedTypeCount);&#10;        int newIndex = appendChunk(newChunk); // appendChunk already uses resizeLock (reentrant safe)&#10;        int slot = newChunk.allocateSlot(entityId);&#10;        if (newChunk.hasFree() &amp;&amp; newChunk.tryMarkQueued()) {&#10;            availableChunks.offer(newIndex);&#10;        }&#10;        return new ArchetypeChunk.ChunkLocation(newIndex, slot);&#10;    }&#10;&#10;    public int appendChunk(ArchetypeChunk newChunk) {&#10;        resizeLock.lock();&#10;        try {&#10;            ArchetypeChunk[] arr = this.chunks;&#10;            int idx = chunkCount.get();&#10;            if (idx &lt; arr.length) {&#10;                arr[idx] = newChunk;&#10;                chunkCount.incrementAndGet();&#10;                return idx;&#10;            }&#10;            int newCap = Math.max(4, arr.length &lt;&lt; 1);&#10;            ArchetypeChunk[] newArr = new ArchetypeChunk[newCap];&#10;            System.arraycopy(arr, 0, newArr, 0, idx);&#10;            newArr[idx] = newChunk;&#10;            this.chunks = newArr;&#10;            chunkCount.incrementAndGet();&#10;            return idx;&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;    }&#10;&#10;    public void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        int idx = location.chunkIndex;&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        if (idx &lt; 0 || idx &gt;= chunkCount.get()) return;&#10;        ArchetypeChunk chunk = snap[idx];&#10;        if (chunk == null) return;&#10;        chunk.freeSlot(location.indexInChunk);&#10;        if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;            availableChunks.offer(idx);&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk[] getChunksSnapshot() { return this.chunks; }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        if (chunkIndex &lt; 0 || chunkIndex &gt;= count) throw new IndexOutOfBoundsException();&#10;        return snap[chunkIndex];&#10;    }&#10;&#10;    public int chunkCount() { return this.chunkCount.get(); }&#10;&#10;    public int getEntityCount() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        int total = 0;&#10;        for (int i = 0; i &lt; count; i++) total += snap[i].size();&#10;        return total;&#10;    }&#10;&#10;    public List&lt;ArchetypeChunk&gt; getChunks() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        List&lt;ArchetypeChunk&gt; list = new ArrayList&lt;&gt;(count);&#10;        for (int i = 0; i &lt; count; i++) list.add(snap[i]);&#10;        return list;&#10;    }&#10;&#10;    public void forEach(IArchetype.ArchetypeIterator iterator) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        for (int chunkId = 0; chunkId &lt; count; chunkId++) {&#10;            ArchetypeChunk chunk = snap[chunkId];&#10;            int i = chunk.nextOccupiedIndex(0);&#10;            while (i != -1) {&#10;                int eid = chunk.getEntityId(i);&#10;                if (eid != -1) iterator.accept(eid, new ArchetypeChunk.ChunkLocation(chunkId, i), chunk);&#10;                i = chunk.nextOccupiedIndex(i + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Batch APIs ---&#10;    public ArchetypeChunk.ChunkLocation[] addEntities(int[] entityIds) {&#10;        if (entityIds == null || entityIds.length == 0) return new ArchetypeChunk.ChunkLocation[0];&#10;        ArchetypeChunk.ChunkLocation[] out = new ArchetypeChunk.ChunkLocation[entityIds.length];&#10;        int need = entityIds.length;&#10;        int produced = 0;&#10;        // Consume available queued chunks, allocate as many as possible from each before moving on&#10;        Integer idxChunk;&#10;        while (produced &lt; need &amp;&amp; (idxChunk = availableChunks.poll()) != null) {&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idxChunk];&#10;            if (chunk == null) continue;&#10;            chunk.markDequeued();&#10;            while (produced &lt; need) {&#10;                int slot = chunk.allocateSlot(entityIds[produced]);&#10;                if (slot &lt; 0) break;&#10;                out[produced] = new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;                produced++;&#10;            }&#10;            if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;                availableChunks.offer(idxChunk);&#10;            }&#10;        }&#10;        if (produced == need) return out;&#10;        // Slow path: lock and either consume any newly queued chunks or create new chunks&#10;        resizeLock.lock();&#10;        try {&#10;            // Double-check: consume any available after acquiring lock&#10;            while (produced &lt; need &amp;&amp; (idxChunk = availableChunks.poll()) != null) {&#10;                ArchetypeChunk[] snap = this.chunks;&#10;                int count = this.chunkCount.get();&#10;                if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;                ArchetypeChunk chunk = snap[idxChunk];&#10;                if (chunk == null) continue;&#10;                chunk.markDequeued();&#10;                while (produced &lt; need) {&#10;                    int slot = chunk.allocateSlot(entityIds[produced]);&#10;                    if (slot &lt; 0) break;&#10;                    out[produced] = new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;                    produced++;&#10;                }&#10;                if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) availableChunks.offer(idxChunk);&#10;            }&#10;            // Create new chunks until satisfied&#10;            while (produced &lt; need) {&#10;                ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, elementSizes, entitiesPerChunk, arena, managedTypeCount);&#10;                int newIndex = appendChunk(newChunk); // appendChunk is reentrant with resizeLock&#10;                int toAlloc = Math.min(need - produced, entitiesPerChunk);&#10;                // Fresh chunk yields contiguous indices [0..toAlloc-1]&#10;                for (int i = 0; i &lt; toAlloc; i++) {&#10;                    int slot = newChunk.allocateSlot(entityIds[produced]);&#10;                    out[produced] = new ArchetypeChunk.ChunkLocation(newIndex, slot);&#10;                    produced++;&#10;                }&#10;                if (newChunk.hasFree() &amp;&amp; newChunk.tryMarkQueued()) availableChunks.offer(newIndex);&#10;            }&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;        return out;&#10;    }&#10;&#10;    public void removeEntities(ArchetypeChunk.ChunkLocation[] locations) {&#10;        if (locations == null || locations.length == 0) return;&#10;        // Free slots; afterwards enqueue chunks that still have free space&#10;        // Group by chunk to reduce repeated offers; but offering multiple times is harmless due to tryMarkQueued&#10;        for (ArchetypeChunk.ChunkLocation loc : locations) {&#10;            if (loc == null) continue;&#10;            int idx = loc.chunkIndex;&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idx &lt; 0 || idx &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idx];&#10;            if (chunk == null) continue;&#10;            chunk.freeSlot(loc.indexInChunk);&#10;            if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) availableChunks.offer(idx);&#10;        }&#10;    }&#10;&#10;    public ReentrantLock getResizeLock() { return resizeLock; }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import com.ethnicthv.ecs.core.api.archetype.IArchetype;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;/**&#10; * ChunkGroup encapsulates chunk management logic for an Archetype.&#10; * Simplified provisioning logic: only uses resizeLock (no spin / atomic boolean coordination).&#10; */&#10;public final class ChunkGroup {&#10;    private volatile ArchetypeChunk[] chunks;&#10;    private final AtomicInteger chunkCount = new AtomicInteger(0);&#10;    private final ReentrantLock resizeLock = new ReentrantLock();&#10;    private final ConcurrentLinkedQueue&lt;Integer&gt; availableChunks = new ConcurrentLinkedQueue&lt;&gt;();&#10;&#10;    private final ComponentDescriptor[] descriptors;&#10;    private final long[] elementSizes;&#10;    private final int entitiesPerChunk;&#10;    private final Arena arena;&#10;    private final int managedTypeCount;&#10;&#10;    public ChunkGroup(ComponentDescriptor[] descriptors, long[] elementSizes, int entitiesPerChunk, Arena arena, int managedTypeCount) {&#10;        this.descriptors = descriptors;&#10;        this.elementSizes = elementSizes;&#10;        this.entitiesPerChunk = entitiesPerChunk;&#10;        this.arena = arena;&#10;        this.managedTypeCount = managedTypeCount;&#10;        this.chunks = new ArchetypeChunk[Math.max(4, 1)];&#10;        ArchetypeChunk first = new ArchetypeChunk(descriptors, elementSizes, entitiesPerChunk, arena, managedTypeCount);&#10;        this.chunks[0] = first;&#10;        chunkCount.set(1);&#10;        if (first.tryMarkQueued()) {&#10;            this.availableChunks.add(0);&#10;        }&#10;    }&#10;&#10;    // --- New optimistic addEntity implementation ---&#10;    public ArchetypeChunk.ChunkLocation addEntity(int entityId) {&#10;        // 1. Fast path attempt without locking&#10;        ArchetypeChunk.ChunkLocation loc = tryFastPathAllocate(entityId);&#10;        if (loc != null) return loc;&#10;&#10;        // 2. Slow path: acquire real lock, double-check, then create&#10;        resizeLock.lock();&#10;        try {&#10;            // 3. Double-check after acquiring lock (another thread may have inserted a chunk)&#10;            loc = tryFastPathAllocate(entityId);&#10;            if (loc != null) return loc;&#10;            // 4. Still no space: create new chunk and allocate&#10;            return createChunkAndAllocate(entityId);&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;    }&#10;&#10;    private ArchetypeChunk.ChunkLocation tryFastPathAllocate(int entityId) {&#10;        Integer idxChunk;&#10;        while ((idxChunk = availableChunks.poll()) != null) { // dequeue a chunk with (expected) free slots&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idxChunk];&#10;            if (chunk == null) continue;&#10;            chunk.markDequeued();&#10;            int slot = chunk.allocateSlot(entityId);&#10;            if (slot &gt;= 0) {&#10;                if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) { // requeue if still space&#10;                    availableChunks.offer(idxChunk);&#10;                }&#10;                return new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;            }&#10;            // If allocation failed (race filled chunk), just loop to next available&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private ArchetypeChunk.ChunkLocation createChunkAndAllocate(int entityId) {&#10;        ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, elementSizes, entitiesPerChunk, arena, managedTypeCount);&#10;        int newIndex = appendChunk(newChunk); // appendChunk already uses resizeLock (reentrant safe)&#10;        int slot = newChunk.allocateSlot(entityId);&#10;        if (newChunk.hasFree() &amp;&amp; newChunk.tryMarkQueued()) {&#10;            availableChunks.offer(newIndex);&#10;        }&#10;        return new ArchetypeChunk.ChunkLocation(newIndex, slot);&#10;    }&#10;&#10;    public int appendChunk(ArchetypeChunk newChunk) {&#10;        resizeLock.lock();&#10;        try {&#10;            ArchetypeChunk[] arr = this.chunks;&#10;            int idx = chunkCount.get();&#10;            if (idx &lt; arr.length) {&#10;                arr[idx] = newChunk;&#10;                chunkCount.incrementAndGet();&#10;                return idx;&#10;            }&#10;            int newCap = Math.max(4, arr.length &lt;&lt; 1);&#10;            ArchetypeChunk[] newArr = new ArchetypeChunk[newCap];&#10;            System.arraycopy(arr, 0, newArr, 0, idx);&#10;            newArr[idx] = newChunk;&#10;            this.chunks = newArr;&#10;            chunkCount.incrementAndGet();&#10;            return idx;&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;    }&#10;&#10;    public void removeEntity(ArchetypeChunk.ChunkLocation location) {&#10;        int idx = location.chunkIndex;&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        if (idx &lt; 0 || idx &gt;= chunkCount.get()) return;&#10;        ArchetypeChunk chunk = snap[idx];&#10;        if (chunk == null) return;&#10;        chunk.freeSlot(location.indexInChunk);&#10;        if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;            availableChunks.offer(idx);&#10;        }&#10;    }&#10;&#10;    public ArchetypeChunk[] getChunksSnapshot() { return this.chunks; }&#10;&#10;    public ArchetypeChunk getChunk(int chunkIndex) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        if (chunkIndex &lt; 0 || chunkIndex &gt;= count) throw new IndexOutOfBoundsException();&#10;        return snap[chunkIndex];&#10;    }&#10;&#10;    public int chunkCount() { return this.chunkCount.get(); }&#10;&#10;    public int getEntityCount() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        int total = 0;&#10;        for (int i = 0; i &lt; count; i++) total += snap[i].size();&#10;        return total;&#10;    }&#10;&#10;    public List&lt;ArchetypeChunk&gt; getChunks() {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        List&lt;ArchetypeChunk&gt; list = new ArrayList&lt;&gt;(count);&#10;        for (int i = 0; i &lt; count; i++) list.add(snap[i]);&#10;        return list;&#10;    }&#10;&#10;    public void forEach(IArchetype.ArchetypeIterator iterator) {&#10;        ArchetypeChunk[] snap = this.chunks;&#10;        int count = this.chunkCount.get();&#10;        for (int chunkId = 0; chunkId &lt; count; chunkId++) {&#10;            ArchetypeChunk chunk = snap[chunkId];&#10;            int i = chunk.nextOccupiedIndex(0);&#10;            while (i != -1) {&#10;                int eid = chunk.getEntityId(i);&#10;                if (eid != -1) iterator.accept(eid, new ArchetypeChunk.ChunkLocation(chunkId, i), chunk);&#10;                i = chunk.nextOccupiedIndex(i + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Batch APIs ---&#10;    public ArchetypeChunk.ChunkLocation[] addEntities(int[] entityIds) {&#10;        if (entityIds == null || entityIds.length == 0) return new ArchetypeChunk.ChunkLocation[0];&#10;        ArchetypeChunk.ChunkLocation[] out = new ArchetypeChunk.ChunkLocation[entityIds.length];&#10;        int need = entityIds.length;&#10;        int produced = 0;&#10;        // Consume available queued chunks, allocate as many as possible from each before moving on&#10;        Integer idxChunk;&#10;        while (produced &lt; need &amp;&amp; (idxChunk = availableChunks.poll()) != null) {&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idxChunk];&#10;            if (chunk == null) continue;&#10;            chunk.markDequeued();&#10;            while (produced &lt; need) {&#10;                int slot = chunk.allocateSlot(entityIds[produced]);&#10;                if (slot &lt; 0) break;&#10;                out[produced] = new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;                produced++;&#10;            }&#10;            if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) {&#10;                availableChunks.offer(idxChunk);&#10;            }&#10;        }&#10;        if (produced == need) return out;&#10;        // Slow path: lock and either consume any newly queued chunks or create new chunks&#10;        resizeLock.lock();&#10;        try {&#10;            // Double-check: consume any available after acquiring lock&#10;            while (produced &lt; need &amp;&amp; (idxChunk = availableChunks.poll()) != null) {&#10;                ArchetypeChunk[] snap = this.chunks;&#10;                int count = this.chunkCount.get();&#10;                if (idxChunk &lt; 0 || idxChunk &gt;= count) continue;&#10;                ArchetypeChunk chunk = snap[idxChunk];&#10;                if (chunk == null) continue;&#10;                chunk.markDequeued();&#10;                while (produced &lt; need) {&#10;                    int slot = chunk.allocateSlot(entityIds[produced]);&#10;                    if (slot &lt; 0) break;&#10;                    out[produced] = new ArchetypeChunk.ChunkLocation(idxChunk, slot);&#10;                    produced++;&#10;                }&#10;                if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) availableChunks.offer(idxChunk);&#10;            }&#10;            // Create new chunks until satisfied&#10;            while (produced &lt; need) {&#10;                ArchetypeChunk newChunk = new ArchetypeChunk(descriptors, elementSizes, entitiesPerChunk, arena, managedTypeCount);&#10;                int newIndex = appendChunk(newChunk); // appendChunk is reentrant with resizeLock&#10;                int toAlloc = Math.min(need - produced, entitiesPerChunk);&#10;                // Fresh chunk yields contiguous indices [0..toAlloc-1]&#10;                for (int i = 0; i &lt; toAlloc; i++) {&#10;                    int slot = newChunk.allocateSlot(entityIds[produced]);&#10;                    out[produced] = new ArchetypeChunk.ChunkLocation(newIndex, slot);&#10;                    produced++;&#10;                }&#10;                if (newChunk.hasFree() &amp;&amp; newChunk.tryMarkQueued()) availableChunks.offer(newIndex);&#10;            }&#10;        } finally {&#10;            resizeLock.unlock();&#10;        }&#10;        return out;&#10;    }&#10;&#10;    public void removeEntities(ArchetypeChunk.ChunkLocation[] locations) {&#10;        if (locations == null || locations.length == 0) return;&#10;        // Free slots; afterwards enqueue chunks that still have free space&#10;        // Group by chunk to reduce repeated offers; but offering multiple times is harmless due to tryMarkQueued&#10;        for (ArchetypeChunk.ChunkLocation loc : locations) {&#10;            if (loc == null) continue;&#10;            int idx = loc.chunkIndex;&#10;            ArchetypeChunk[] snap = this.chunks;&#10;            int count = this.chunkCount.get();&#10;            if (idx &lt; 0 || idx &gt;= count) continue;&#10;            ArchetypeChunk chunk = snap[idx];&#10;            if (chunk == null) continue;&#10;            chunk.freeSlot(loc.indexInChunk);&#10;            if (chunk.hasFree() &amp;&amp; chunk.tryMarkQueued()) availableChunks.offer(idx);&#10;        }&#10;    }&#10;&#10;    public ReentrantLock getResizeLock() { return resizeLock; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/EntityCommandBuffer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/archetype/EntityCommandBuffer.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;&#10;/**&#10; * EntityCommandBuffer – Pillar 4: Write-Fast, Sort-on-Playback.&#10; *&#10; * Phase 1: write-side O(1) zero-garbage API backed by per-thread lanes.&#10; * Phase 2: playback-side O(N log N) sorting and batch execution.&#10; */&#10;public final class EntityCommandBuffer implements AutoCloseable {&#10;    // ---- Command opcodes ----&#10;    static final int CMD_ADD_COMPONENT = 1;&#10;    static final int CMD_REMOVE_COMPONENT = 2;&#10;    static final int CMD_SET_SHARED_MANAGED = 3;&#10;    static final int CMD_DESTROY_ENTITY = 4;&#10;    static final int CMD_MUTATE_COMPONENTS = 5; // multi add/remove per entity&#10;&#10;    // Size in bytes reserved per lane segment&#10;    private static final long LANE_CAPACITY = 64 * 1024; // 64KB&#10;&#10;    private final Arena bufferArena;&#10;&#10;    // Pool of reusable lanes&#10;    private final ConcurrentLinkedQueue&lt;ECBWriterLane&gt; freeLanes = new ConcurrentLinkedQueue&lt;&gt;();&#10;    // Collected lanes for playback&#10;    private final ConcurrentLinkedQueue&lt;ECBWriterLane&gt; usedLanes = new ConcurrentLinkedQueue&lt;&gt;();&#10;&#10;    // Per-thread writer lane&#10;    private final ThreadLocal&lt;ECBWriterLane&gt; threadLocalLane;&#10;&#10;    public EntityCommandBuffer(Arena parentArena) {&#10;        // For now reuse parent arena; playback phase may introduce a dedicated arena strategy.&#10;        this.bufferArena = parentArena;&#10;        this.threadLocalLane = ThreadLocal.withInitial(() -&gt; {&#10;            ECBWriterLane lane = freeLanes.poll();&#10;            if (lane == null) {&#10;                lane = new ECBWriterLane(bufferArena.allocate(LANE_CAPACITY));&#10;            } else {&#10;                lane.reset();&#10;            }&#10;            usedLanes.add(lane);&#10;            return lane;&#10;        });&#10;    }&#10;&#10;    // Expose a lightweight writer for use in parallel jobs&#10;    public ParallelWriter asParallelWriter(ArchetypeWorld world) {&#10;        return new ParallelWriter(threadLocalLane.get(), world);&#10;    }&#10;&#10;    @Override&#10;    public void close() {&#10;        // Lanes memory is owned by bufferArena; do not close arena here.&#10;        freeLanes.clear();&#10;        usedLanes.clear();&#10;    }&#10;&#10;    /**&#10;     * Decode all lanes, sort commands, and execute them in batches against the world.&#10;     */&#10;    public void playback(ArchetypeWorld world) {&#10;        // 1) Gather &amp; decode raw lanes into interpreted commands (O(N))&#10;        List&lt;InterpretedCommand&gt; allCommands = new ArrayList&lt;&gt;();&#10;        for (ECBWriterLane lane : usedLanes) {&#10;            long offset = 0L;&#10;            long limit = lane.offset;&#10;            MemorySegment segment = lane.segment;&#10;            while (offset &lt; limit) {&#10;                int cmdId = segment.get(ValueLayout.JAVA_INT, offset);&#10;                switch (cmdId) {&#10;                    case CMD_ADD_COMPONENT: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int tid = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        allCommands.add(InterpretedCommand.addComponent(eid, tid));&#10;                        offset += 12L;&#10;                        break;&#10;                    }&#10;                    case CMD_REMOVE_COMPONENT: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int tid = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        allCommands.add(InterpretedCommand.removeComponent(eid, tid));&#10;                        offset += 12L;&#10;                        break;&#10;                    }&#10;                    case CMD_DESTROY_ENTITY: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        allCommands.add(InterpretedCommand.destroyEntity(eid));&#10;                        offset += 8L;&#10;                        break;&#10;                    }&#10;                    case CMD_SET_SHARED_MANAGED: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int tid = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        int sharedIndex = segment.get(ValueLayout.JAVA_INT, offset + 12);&#10;                        allCommands.add(InterpretedCommand.setSharedManaged(eid, tid, sharedIndex));&#10;                        offset += 16L;&#10;                        break;&#10;                    }&#10;                    case CMD_MUTATE_COMPONENTS: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int addCount = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        int remCount = segment.get(ValueLayout.JAVA_INT, offset + 12);&#10;                        int[] addIds = new int[addCount];&#10;                        int[] remIds = new int[remCount];&#10;                        long p = offset + 16L;&#10;                        for (int i = 0; i &lt; addCount; i++) {&#10;                            addIds[i] = segment.get(ValueLayout.JAVA_INT, p);&#10;                            p += 4L;&#10;                        }&#10;                        for (int i = 0; i &lt; remCount; i++) {&#10;                            remIds[i] = segment.get(ValueLayout.JAVA_INT, p);&#10;                            p += 4L;&#10;                        }&#10;                        allCommands.add(InterpretedCommand.mutateComponents(eid, addIds, remIds));&#10;                        offset = p;&#10;                        break;&#10;                    }&#10;                    default:&#10;                        // Unknown or unimplemented command id – skip one int to avoid infinite loop&#10;                        offset += 4L;&#10;                        break;&#10;                }&#10;            }&#10;        }&#10;        // recycle lanes for next frame&#10;        recycleLanes();&#10;        if (allCommands.isEmpty()) return;&#10;&#10;        // 2) Sort commands using the massive O(N log N) comparator&#10;        Collections.sort(allCommands);&#10;&#10;        // 3) Execute sorted commands in batches via ArchetypeWorld batch API&#10;        executeSortedCommands(allCommands, world);&#10;    }&#10;&#10;    /**&#10;     * Return used lanes back to free pool and reset offsets.&#10;     */&#10;    private void recycleLanes() {&#10;        ECBWriterLane lane;&#10;        while ((lane = usedLanes.poll()) != null) {&#10;            lane.reset();&#10;            freeLanes.offer(lane);&#10;        }&#10;    }&#10;&#10;    // ---- Inner types ----&#10;&#10;    /**&#10;     * One contiguous lane of raw command bytes for a single writer thread.&#10;     * Not thread-safe by design; only the owning thread writes to offset.&#10;     */&#10;    static final class ECBWriterLane {&#10;        MemorySegment segment;&#10;        long offset;&#10;&#10;        ECBWriterLane(MemorySegment segment) {&#10;            this.segment = segment;&#10;            this.offset = 0L;&#10;        }&#10;&#10;        void reset() {&#10;            this.offset = 0L;&#10;        }&#10;&#10;        // Simple ensureCapacity: if not enough space, allocate a fresh segment&#10;        // and swap; old contents are expected to be consumed in playback before&#10;        // reuse. For Phase 1 we keep it simple and single-chunk per lane.&#10;        void ensureCapacity(long needed, Arena arena) {&#10;            long remaining = segment.byteSize() - offset;&#10;            if (remaining &gt;= needed) return;&#10;            // allocate a new chunk and reset offset&#10;            this.segment = arena.allocate(Math.max(LANE_CAPACITY, needed));&#10;            this.offset = 0L;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lightweight, zero-allocation facade to record commands into a lane.&#10;     */&#10;    public static final class ParallelWriter {&#10;        private final ECBWriterLane lane;&#10;        private final ArchetypeWorld world;&#10;&#10;        public ParallelWriter(ECBWriterLane lane, ArchetypeWorld world) {&#10;            this.lane = lane;&#10;            this.world = world;&#10;        }&#10;&#10;        public void addComponent(int entityId, Class&lt;?&gt; type) {&#10;            // getComponentTypeId returns Integer; handle unknown types cheaply&#10;            Integer typeId = world.getComponentTypeId(type);&#10;            if (typeId == null) return; // or throw, but write side should be cheap&#10;            long bytes = 12L; // opcode + entityId + typeId&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_ADD_COMPONENT);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, typeId);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        public void removeComponent(int entityId, Class&lt;?&gt; type) {&#10;            Integer typeId = world.getComponentTypeId(type);&#10;            if (typeId == null) return;&#10;            long bytes = 12L;&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_REMOVE_COMPONENT);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, typeId);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        public void destroyEntity(int entityId) {&#10;            long bytes = 8L; // opcode + entityId&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_DESTROY_ENTITY);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        // New: record a shared-managed component assignment.&#10;        public void setSharedManaged(int entityId, Object sharedValue) {&#10;            if (sharedValue == null) return;&#10;            Class&lt;?&gt; type = sharedValue.getClass();&#10;            Integer typeId = world.getComponentTypeId(type);&#10;            if (typeId == null) return; // unknown type: ignore at write side&#10;            // Ensure the value has a stable shared index in the store.&#10;            // Using getOrAddSharedIndex here guarantees we never encode -1,&#10;            // and that playback can always reconstruct the value via the store.&#10;            int sharedIndex = world.sharedStore.getOrAddSharedIndex(sharedValue);&#10;            long bytes = 16L; // cmdId + entityId + typeId + sharedIndex&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_SET_SHARED_MANAGED);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, typeId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 12, sharedIndex);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        /**&#10;         * Multi-component structural mutation for a single entity: add/remove multiple component types.&#10;         * This encodes a compact command that playback can batch across entities with the same add/remove sets.&#10;         */&#10;        public void mutateComponents(int entityId, Class&lt;?&gt;[] addTypes, Class&lt;?&gt;[] removeTypes) {&#10;            int addCount = addTypes != null ? addTypes.length : 0;&#10;            int remCount = removeTypes != null ? removeTypes.length : 0;&#10;            if (addCount == 0 &amp;&amp; remCount == 0) return;&#10;            int[] addIds = new int[addCount];&#10;            int[] remIds = new int[remCount];&#10;            for (int i = 0; i &lt; addCount; i++) {&#10;                Integer tid = world.getComponentTypeId(addTypes[i]);&#10;                if (tid == null) throw new IllegalArgumentException(&quot;Unregistered component: &quot; + addTypes[i]);&#10;                addIds[i] = tid;&#10;            }&#10;            for (int i = 0; i &lt; remCount; i++) {&#10;                Integer tid = world.getComponentTypeId(removeTypes[i]);&#10;                if (tid == null) throw new IllegalArgumentException(&quot;Unregistered component: &quot; + removeTypes[i]);&#10;                remIds[i] = tid;&#10;            }&#10;            // Encode: [cmdId, entityId, addCount, remCount, addIds..., remIds...]&#10;            long bytes = 16L + 4L * (addCount + remCount);&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_MUTATE_COMPONENTS);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, addCount);&#10;            seg.set(ValueLayout.JAVA_INT, off + 12, remCount);&#10;            long p = off + 16L;&#10;            for (int id : addIds) {&#10;                seg.set(ValueLayout.JAVA_INT, p, id);&#10;                p += 4L;&#10;            }&#10;            for (int id : remIds) {&#10;                seg.set(ValueLayout.JAVA_INT, p, id);&#10;                p += 4L;&#10;            }&#10;            lane.offset = p;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Decoded command representation used for sorting &amp; batching.&#10;     */&#10;    private static final class InterpretedCommand implements Comparable&lt;InterpretedCommand&gt; {&#10;        final int commandId;&#10;        final int entityId;&#10;        final int typeId1;   // primary component type (for add/remove/shared)&#10;        final int typeId2;   // used as sharedIndex for CMD_SET_SHARED_MANAGED&#10;        final int[] addTypeIds;    // for CMD_MUTATE_COMPONENTS&#10;        final int[] removeTypeIds; // for CMD_MUTATE_COMPONENTS&#10;&#10;        private InterpretedCommand(int commandId, int entityId, int typeId1, int typeId2,&#10;                                   int[] addTypeIds, int[] removeTypeIds) {&#10;            this.commandId = commandId;&#10;            this.entityId = entityId;&#10;            this.typeId1 = typeId1;&#10;            this.typeId2 = typeId2;&#10;            this.addTypeIds = addTypeIds;&#10;            this.removeTypeIds = removeTypeIds;&#10;        }&#10;&#10;        static InterpretedCommand addComponent(int entityId, int typeId) {&#10;            return new InterpretedCommand(CMD_ADD_COMPONENT, entityId, typeId, -1, null, null);&#10;        }&#10;&#10;        static InterpretedCommand removeComponent(int entityId, int typeId) {&#10;            return new InterpretedCommand(CMD_REMOVE_COMPONENT, entityId, typeId, -1, null, null);&#10;        }&#10;&#10;        static InterpretedCommand destroyEntity(int entityId) {&#10;            return new InterpretedCommand(CMD_DESTROY_ENTITY, entityId, -1, -1, null, null);&#10;        }&#10;&#10;        static InterpretedCommand setSharedManaged(int entityId, int typeId, int sharedIndex) {&#10;            return new InterpretedCommand(CMD_SET_SHARED_MANAGED, entityId, typeId, sharedIndex, null, null);&#10;        }&#10;&#10;        static InterpretedCommand mutateComponents(int entityId, int[] addIds, int[] remIds) {&#10;            // For sorting/batching, we normalize (sort) the id arrays&#10;            int[] a = addIds != null ? addIds.clone() : new int[0];&#10;            int[] r = remIds != null ? remIds.clone() : new int[0];&#10;            java.util.Arrays.sort(a);&#10;            java.util.Arrays.sort(r);&#10;            return new InterpretedCommand(CMD_MUTATE_COMPONENTS, entityId, 0, 0, a, r);&#10;        }&#10;&#10;        @Override&#10;        public int compareTo(InterpretedCommand other) {&#10;            // 1) Destroy trước&#10;            boolean thisDestroy = this.commandId == CMD_DESTROY_ENTITY;&#10;            boolean otherDestroy = other.commandId == CMD_DESTROY_ENTITY;&#10;            if (thisDestroy &amp;&amp; !otherDestroy) return -1;&#10;            if (!thisDestroy &amp;&amp; otherDestroy) return 1;&#10;&#10;            // 2) Gom theo loại lệnh&#10;            int c = Integer.compare(this.commandId, other.commandId);&#10;            if (c != 0) return c;&#10;&#10;            // 3) Với multi-mutate, gom theo add/remove sets&#10;            if (this.commandId == CMD_MUTATE_COMPONENTS) {&#10;                int lenA = this.addTypeIds.length;&#10;                int lenB = other.addTypeIds.length;&#10;                c = Integer.compare(lenA, lenB);&#10;                if (c != 0) return c;&#10;                for (int i = 0; i &lt; lenA; i++) {&#10;                    c = Integer.compare(this.addTypeIds[i], other.addTypeIds[i]);&#10;                    if (c != 0) return c;&#10;                }&#10;                int lenRA = this.removeTypeIds.length;&#10;                int lenRB = other.removeTypeIds.length;&#10;                c = Integer.compare(lenRA, lenRB);&#10;                if (c != 0) return c;&#10;                for (int i = 0; i &lt; lenRA; i++) {&#10;                    c = Integer.compare(this.removeTypeIds[i], other.removeTypeIds[i]);&#10;                    if (c != 0) return c;&#10;                }&#10;            } else {&#10;                // 3b) Các loại lệnh khác gom theo typeId1 (component type) và sharedIndex nếu cần&#10;                c = Integer.compare(this.typeId1, other.typeId1);&#10;                if (c != 0) return c;&#10;                if (this.commandId == CMD_SET_SHARED_MANAGED) {&#10;                    c = Integer.compare(this.typeId2, other.typeId2);&#10;                    if (c != 0) return c;&#10;                }&#10;            }&#10;&#10;            // 4) Cuối cùng theo entity id&#10;            return Integer.compare(this.entityId, other.entityId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Key describing a batch of structural mutations by command kind and component type.&#10;     */&#10;    private static final class MutateKey {&#10;        final int commandId;&#10;        final int typeId;&#10;        final int sharedIndex; // only meaningful for CMD_SET_SHARED_MANAGED&#10;        final int[] addTypeIds;    // for CMD_MUTATE_COMPONENTS&#10;        final int[] removeTypeIds; // for CMD_MUTATE_COMPONENTS&#10;&#10;        MutateKey(int commandId, int typeId, int sharedIndex) {&#10;            this(commandId, typeId, sharedIndex, null, null);&#10;        }&#10;&#10;        MutateKey(int commandId, int typeId, int sharedIndex, int[] addTypeIds, int[] removeTypeIds) {&#10;            this.commandId = commandId;&#10;            this.typeId = typeId;&#10;            this.sharedIndex = sharedIndex;&#10;            this.addTypeIds = addTypeIds;&#10;            this.removeTypeIds = removeTypeIds;&#10;        }&#10;&#10;        boolean isDestroy() { return commandId == CMD_DESTROY_ENTITY; }&#10;        boolean isAdd()     { return commandId == CMD_ADD_COMPONENT; }&#10;        boolean isRemove()  { return commandId == CMD_REMOVE_COMPONENT; }&#10;        boolean isSetShared() { return commandId == CMD_SET_SHARED_MANAGED; }&#10;        boolean isMutateMulti() { return commandId == CMD_MUTATE_COMPONENTS; }&#10;&#10;        @Override&#10;        public boolean equals(Object o) {&#10;            if (this == o) return true;&#10;            if (!(o instanceof MutateKey other)) return false;&#10;            if (commandId != other.commandId) return false;&#10;            if (commandId == CMD_MUTATE_COMPONENTS) {&#10;                return java.util.Arrays.equals(this.addTypeIds, other.addTypeIds)&#10;                        &amp;&amp; java.util.Arrays.equals(this.removeTypeIds, other.removeTypeIds);&#10;            }&#10;            return typeId == other.typeId &amp;&amp; sharedIndex == other.sharedIndex;&#10;        }&#10;&#10;        @Override&#10;        public int hashCode() {&#10;            int result = commandId;&#10;            if (commandId == CMD_MUTATE_COMPONENTS) {&#10;                result = 31 * result + java.util.Arrays.hashCode(addTypeIds);&#10;                result = 31 * result + java.util.Arrays.hashCode(removeTypeIds);&#10;            } else {&#10;                result = 31 * result + typeId;&#10;                result = 31 * result + sharedIndex;&#10;            }&#10;            return result;&#10;        }&#10;    }&#10;&#10;    private void executeSortedCommands(List&lt;InterpretedCommand&gt; sortedCommands, ArchetypeWorld world) {&#10;        List&lt;Integer&gt; entityBatch = new ArrayList&lt;&gt;();&#10;        MutateKey currentKey = null;&#10;&#10;        for (InterpretedCommand cmd : sortedCommands) {&#10;            MutateKey cmdKey;&#10;            if (cmd.commandId == CMD_MUTATE_COMPONENTS) {&#10;                cmdKey = new MutateKey(cmd.commandId, 0, 0, cmd.addTypeIds, cmd.removeTypeIds);&#10;            } else {&#10;                int sharedIndex = (cmd.commandId == CMD_SET_SHARED_MANAGED) ? cmd.typeId2 : -1;&#10;                cmdKey = new MutateKey(cmd.commandId, cmd.typeId1, sharedIndex);&#10;            }&#10;            if (currentKey != null &amp;&amp; cmdKey.equals(currentKey)) {&#10;                entityBatch.add(cmd.entityId);&#10;            } else {&#10;                if (!entityBatch.isEmpty()) {&#10;                    flushBatch(currentKey, entityBatch, world);&#10;                }&#10;                entityBatch.clear();&#10;                entityBatch.add(cmd.entityId);&#10;                currentKey = cmdKey;&#10;            }&#10;        }&#10;        if (!entityBatch.isEmpty() &amp;&amp; currentKey != null) {&#10;            flushBatch(currentKey, entityBatch, world);&#10;        }&#10;    }&#10;&#10;    private void flushBatch(MutateKey key, List&lt;Integer&gt; entityBatch, ArchetypeWorld world) {&#10;        int size = entityBatch.size();&#10;        int[] ids = new int[size];&#10;        for (int i = 0; i &lt; size; i++) ids[i] = entityBatch.get(i);&#10;        ArchetypeWorld.EntityBatch batch = ArchetypeWorld.EntityBatch.of(ids);&#10;&#10;        if (key.isDestroy()) {&#10;            for (int id : ids) {&#10;                world.destroyEntity(id);&#10;            }&#10;        } else if (key.isAdd()) {&#10;            Class&lt;?&gt; componentClass = world.getComponentMetadata(key.typeId).type();&#10;            world.addComponents(batch, componentClass);&#10;        } else if (key.isRemove()) {&#10;            Class&lt;?&gt; componentClass = world.getComponentMetadata(key.typeId).type();&#10;            world.removeComponents(batch, componentClass);&#10;        } else if (key.isSetShared()) {&#10;            Object sharedValue = world.sharedStore.getValue(key.sharedIndex);&#10;            if (sharedValue != null) {&#10;                // Use batch shared API to leverage O(M + N*M_intersect) path.&#10;                world.setSharedComponent(batch, sharedValue);&#10;            }&#10;        } else if (key.isMutateMulti()) {&#10;            // Multi-component mutate: map type ids back to classes and delegate to ArchetypeWorld&#10;            Class&lt;?&gt;[] addClasses = new Class&lt;?&gt;[key.addTypeIds.length];&#10;            for (int i = 0; i &lt; key.addTypeIds.length; i++) {&#10;                addClasses[i] = world.getComponentMetadata(key.addTypeIds[i]).type();&#10;            }&#10;            Class&lt;?&gt;[] remClasses = new Class&lt;?&gt;[key.removeTypeIds.length];&#10;            for (int i = 0; i &lt; key.removeTypeIds.length; i++) {&#10;                remClasses[i] = world.getComponentMetadata(key.removeTypeIds[i]).type();&#10;            }&#10;            world.mutateComponents(batch, addClasses, remClasses);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.archetype;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;&#10;/**&#10; * EntityCommandBuffer – Pillar 4: Write-Fast, Sort-on-Playback.&#10; *&#10; * Phase 1: write-side O(1) zero-garbage API backed by per-thread lanes.&#10; * Phase 2: playback-side O(N log N) sorting and batch execution.&#10; */&#10;public final class EntityCommandBuffer implements AutoCloseable {&#10;    // ---- Command opcodes ----&#10;    static final int CMD_ADD_COMPONENT = 1;&#10;    static final int CMD_REMOVE_COMPONENT = 2;&#10;    static final int CMD_SET_SHARED_MANAGED = 3;&#10;    static final int CMD_DESTROY_ENTITY = 4;&#10;    static final int CMD_MUTATE_COMPONENTS = 5; // multi add/remove per entity&#10;&#10;    // Size in bytes reserved per lane segment&#10;    private static final long LANE_CAPACITY = 64 * 1024; // 64KB&#10;&#10;    private final Arena bufferArena;&#10;&#10;    // Pool of reusable lanes&#10;    private final ConcurrentLinkedQueue&lt;ECBWriterLane&gt; freeLanes = new ConcurrentLinkedQueue&lt;&gt;();&#10;    // Collected lanes for playback&#10;    private final ConcurrentLinkedQueue&lt;ECBWriterLane&gt; usedLanes = new ConcurrentLinkedQueue&lt;&gt;();&#10;&#10;    // Per-thread writer lane&#10;    private final ThreadLocal&lt;ECBWriterLane&gt; threadLocalLane;&#10;&#10;    public EntityCommandBuffer(Arena parentArena) {&#10;        // For now reuse parent arena; playback phase may introduce a dedicated arena strategy.&#10;        this.bufferArena = parentArena;&#10;        this.threadLocalLane = ThreadLocal.withInitial(() -&gt; {&#10;            ECBWriterLane lane = freeLanes.poll();&#10;            if (lane == null) {&#10;                lane = new ECBWriterLane(bufferArena.allocate(LANE_CAPACITY));&#10;            } else {&#10;                lane.reset();&#10;            }&#10;            usedLanes.add(lane);&#10;            return lane;&#10;        });&#10;    }&#10;&#10;    // Expose a lightweight writer for use in parallel jobs&#10;    public ParallelWriter asParallelWriter(ArchetypeWorld world) {&#10;        return new ParallelWriter(threadLocalLane.get(), world);&#10;    }&#10;&#10;    @Override&#10;    public void close() {&#10;        // Lanes memory is owned by bufferArena; do not close arena here.&#10;        freeLanes.clear();&#10;        usedLanes.clear();&#10;    }&#10;&#10;    /**&#10;     * Decode all lanes, sort commands, and execute them in batches against the world.&#10;     */&#10;    public void playback(ArchetypeWorld world) {&#10;        // 1) Gather &amp; decode raw lanes into interpreted commands (O(N))&#10;        List&lt;InterpretedCommand&gt; allCommands = new ArrayList&lt;&gt;();&#10;        for (ECBWriterLane lane : usedLanes) {&#10;            long offset = 0L;&#10;            long limit = lane.offset;&#10;            MemorySegment segment = lane.segment;&#10;            while (offset &lt; limit) {&#10;                int cmdId = segment.get(ValueLayout.JAVA_INT, offset);&#10;                switch (cmdId) {&#10;                    case CMD_ADD_COMPONENT: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int tid = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        allCommands.add(InterpretedCommand.addComponent(eid, tid));&#10;                        offset += 12L;&#10;                        break;&#10;                    }&#10;                    case CMD_REMOVE_COMPONENT: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int tid = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        allCommands.add(InterpretedCommand.removeComponent(eid, tid));&#10;                        offset += 12L;&#10;                        break;&#10;                    }&#10;                    case CMD_DESTROY_ENTITY: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        allCommands.add(InterpretedCommand.destroyEntity(eid));&#10;                        offset += 8L;&#10;                        break;&#10;                    }&#10;                    case CMD_SET_SHARED_MANAGED: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int tid = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        int sharedIndex = segment.get(ValueLayout.JAVA_INT, offset + 12);&#10;                        allCommands.add(InterpretedCommand.setSharedManaged(eid, tid, sharedIndex));&#10;                        offset += 16L;&#10;                        break;&#10;                    }&#10;                    case CMD_MUTATE_COMPONENTS: {&#10;                        int eid = segment.get(ValueLayout.JAVA_INT, offset + 4);&#10;                        int addCount = segment.get(ValueLayout.JAVA_INT, offset + 8);&#10;                        int remCount = segment.get(ValueLayout.JAVA_INT, offset + 12);&#10;                        int[] addIds = new int[addCount];&#10;                        int[] remIds = new int[remCount];&#10;                        long p = offset + 16L;&#10;                        for (int i = 0; i &lt; addCount; i++) {&#10;                            addIds[i] = segment.get(ValueLayout.JAVA_INT, p);&#10;                            p += 4L;&#10;                        }&#10;                        for (int i = 0; i &lt; remCount; i++) {&#10;                            remIds[i] = segment.get(ValueLayout.JAVA_INT, p);&#10;                            p += 4L;&#10;                        }&#10;                        allCommands.add(InterpretedCommand.mutateComponents(eid, addIds, remIds));&#10;                        offset = p;&#10;                        break;&#10;                    }&#10;                    default:&#10;                        // Unknown or unimplemented command id – skip one int to avoid infinite loop&#10;                        offset += 4L;&#10;                        break;&#10;                }&#10;            }&#10;        }&#10;        // recycle lanes for next frame&#10;        recycleLanes();&#10;        if (allCommands.isEmpty()) return;&#10;&#10;        // 2) Sort commands using the massive O(N log N) comparator&#10;        Collections.sort(allCommands);&#10;&#10;        // 3) Execute sorted commands in batches via ArchetypeWorld batch API&#10;        executeSortedCommands(allCommands, world);&#10;    }&#10;&#10;    /**&#10;     * Return used lanes back to free pool and reset offsets.&#10;     */&#10;    private void recycleLanes() {&#10;        ECBWriterLane lane;&#10;        while ((lane = usedLanes.poll()) != null) {&#10;            lane.reset();&#10;            freeLanes.offer(lane);&#10;        }&#10;    }&#10;&#10;    // ---- Inner types ----&#10;&#10;    /**&#10;     * One contiguous lane of raw command bytes for a single writer thread.&#10;     * Not thread-safe by design; only the owning thread writes to offset.&#10;     */&#10;    static final class ECBWriterLane {&#10;        MemorySegment segment;&#10;        long offset;&#10;&#10;        ECBWriterLane(MemorySegment segment) {&#10;            this.segment = segment;&#10;            this.offset = 0L;&#10;        }&#10;&#10;        void reset() {&#10;            this.offset = 0L;&#10;        }&#10;&#10;        // Simple ensureCapacity: if not enough space, allocate a fresh segment&#10;        // and swap; old contents are expected to be consumed in playback before&#10;        // reuse. For Phase 1 we keep it simple and single-chunk per lane.&#10;        void ensureCapacity(long needed, Arena arena) {&#10;            long remaining = segment.byteSize() - offset;&#10;            if (remaining &gt;= needed) return;&#10;            // allocate a new chunk and reset offset&#10;            this.segment = arena.allocate(Math.max(LANE_CAPACITY, needed));&#10;            this.offset = 0L;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lightweight, zero-allocation facade to record commands into a lane.&#10;     */&#10;    public static final class ParallelWriter {&#10;        private final ECBWriterLane lane;&#10;        private final ArchetypeWorld world;&#10;&#10;        public ParallelWriter(ECBWriterLane lane, ArchetypeWorld world) {&#10;            this.lane = lane;&#10;            this.world = world;&#10;        }&#10;&#10;        public void addComponent(int entityId, Class&lt;?&gt; type) {&#10;            // getComponentTypeId returns Integer; handle unknown types cheaply&#10;            Integer typeId = world.getComponentTypeId(type);&#10;            if (typeId == null) return; // or throw, but write side should be cheap&#10;            long bytes = 12L; // opcode + entityId + typeId&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_ADD_COMPONENT);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, typeId);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        public void removeComponent(int entityId, Class&lt;?&gt; type) {&#10;            Integer typeId = world.getComponentTypeId(type);&#10;            if (typeId == null) return;&#10;            long bytes = 12L;&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_REMOVE_COMPONENT);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, typeId);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        public void destroyEntity(int entityId) {&#10;            long bytes = 8L; // opcode + entityId&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_DESTROY_ENTITY);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        // New: record a shared-managed component assignment.&#10;        public void setSharedManaged(int entityId, Object sharedValue) {&#10;            if (sharedValue == null) return;&#10;            Class&lt;?&gt; type = sharedValue.getClass();&#10;            Integer typeId = world.getComponentTypeId(type);&#10;            if (typeId == null) return; // unknown type: ignore at write side&#10;            // Ensure the value has a stable shared index in the store.&#10;            // Using getOrAddSharedIndex here guarantees we never encode -1,&#10;            // and that playback can always reconstruct the value via the store.&#10;            int sharedIndex = world.sharedStore.getOrAddSharedIndex(sharedValue);&#10;            long bytes = 16L; // cmdId + entityId + typeId + sharedIndex&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_SET_SHARED_MANAGED);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, typeId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 12, sharedIndex);&#10;            lane.offset = off + bytes;&#10;        }&#10;&#10;        /**&#10;         * Multi-component structural mutation for a single entity: add/remove multiple component types.&#10;         * This encodes a compact command that playback can batch across entities with the same add/remove sets.&#10;         */&#10;        public void mutateComponents(int entityId, Class&lt;?&gt;[] addTypes, Class&lt;?&gt;[] removeTypes) {&#10;            int addCount = addTypes != null ? addTypes.length : 0;&#10;            int remCount = removeTypes != null ? removeTypes.length : 0;&#10;            if (addCount == 0 &amp;&amp; remCount == 0) return;&#10;            int[] addIds = new int[addCount];&#10;            int[] remIds = new int[remCount];&#10;            for (int i = 0; i &lt; addCount; i++) {&#10;                Integer tid = world.getComponentTypeId(addTypes[i]);&#10;                if (tid == null) throw new IllegalArgumentException(&quot;Unregistered component: &quot; + addTypes[i]);&#10;                addIds[i] = tid;&#10;            }&#10;            for (int i = 0; i &lt; remCount; i++) {&#10;                Integer tid = world.getComponentTypeId(removeTypes[i]);&#10;                if (tid == null) throw new IllegalArgumentException(&quot;Unregistered component: &quot; + removeTypes[i]);&#10;                remIds[i] = tid;&#10;            }&#10;            // Encode: [cmdId, entityId, addCount, remCount, addIds..., remIds...]&#10;            long bytes = 16L + 4L * (addCount + remCount);&#10;            lane.ensureCapacity(bytes, world.getArena());&#10;            long off = lane.offset;&#10;            MemorySegment seg = lane.segment;&#10;            seg.set(ValueLayout.JAVA_INT, off, CMD_MUTATE_COMPONENTS);&#10;            seg.set(ValueLayout.JAVA_INT, off + 4, entityId);&#10;            seg.set(ValueLayout.JAVA_INT, off + 8, addCount);&#10;            seg.set(ValueLayout.JAVA_INT, off + 12, remCount);&#10;            long p = off + 16L;&#10;            for (int id : addIds) {&#10;                seg.set(ValueLayout.JAVA_INT, p, id);&#10;                p += 4L;&#10;            }&#10;            for (int id : remIds) {&#10;                seg.set(ValueLayout.JAVA_INT, p, id);&#10;                p += 4L;&#10;            }&#10;            lane.offset = p;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Decoded command representation used for sorting &amp; batching.&#10;     */&#10;    private static final class InterpretedCommand implements Comparable&lt;InterpretedCommand&gt; {&#10;        final int commandId;&#10;        final int entityId;&#10;        final int typeId1;   // primary component type (for add/remove/shared)&#10;        final int typeId2;   // used as sharedIndex for CMD_SET_SHARED_MANAGED&#10;        final int[] addTypeIds;    // for CMD_MUTATE_COMPONENTS&#10;        final int[] removeTypeIds; // for CMD_MUTATE_COMPONENTS&#10;&#10;        private InterpretedCommand(int commandId, int entityId, int typeId1, int typeId2,&#10;                                   int[] addTypeIds, int[] removeTypeIds) {&#10;            this.commandId = commandId;&#10;            this.entityId = entityId;&#10;            this.typeId1 = typeId1;&#10;            this.typeId2 = typeId2;&#10;            this.addTypeIds = addTypeIds;&#10;            this.removeTypeIds = removeTypeIds;&#10;        }&#10;&#10;        static InterpretedCommand addComponent(int entityId, int typeId) {&#10;            return new InterpretedCommand(CMD_ADD_COMPONENT, entityId, typeId, -1, null, null);&#10;        }&#10;&#10;        static InterpretedCommand removeComponent(int entityId, int typeId) {&#10;            return new InterpretedCommand(CMD_REMOVE_COMPONENT, entityId, typeId, -1, null, null);&#10;        }&#10;&#10;        static InterpretedCommand destroyEntity(int entityId) {&#10;            return new InterpretedCommand(CMD_DESTROY_ENTITY, entityId, -1, -1, null, null);&#10;        }&#10;&#10;        static InterpretedCommand setSharedManaged(int entityId, int typeId, int sharedIndex) {&#10;            return new InterpretedCommand(CMD_SET_SHARED_MANAGED, entityId, typeId, sharedIndex, null, null);&#10;        }&#10;&#10;        static InterpretedCommand mutateComponents(int entityId, int[] addIds, int[] remIds) {&#10;            // For sorting/batching, we normalize (sort) the id arrays&#10;            int[] a = addIds != null ? addIds.clone() : new int[0];&#10;            int[] r = remIds != null ? remIds.clone() : new int[0];&#10;            java.util.Arrays.sort(a);&#10;            java.util.Arrays.sort(r);&#10;            return new InterpretedCommand(CMD_MUTATE_COMPONENTS, entityId, 0, 0, a, r);&#10;        }&#10;&#10;        @Override&#10;        public int compareTo(InterpretedCommand other) {&#10;            // 1) Destroy trước&#10;            boolean thisDestroy = this.commandId == CMD_DESTROY_ENTITY;&#10;            boolean otherDestroy = other.commandId == CMD_DESTROY_ENTITY;&#10;            if (thisDestroy &amp;&amp; !otherDestroy) return -1;&#10;            if (!thisDestroy &amp;&amp; otherDestroy) return 1;&#10;&#10;            // 2) Gom theo loại lệnh&#10;            int c = Integer.compare(this.commandId, other.commandId);&#10;            if (c != 0) return c;&#10;&#10;            // 3) Với multi-mutate, gom theo add/remove sets&#10;            if (this.commandId == CMD_MUTATE_COMPONENTS) {&#10;                int lenA = this.addTypeIds.length;&#10;                int lenB = other.addTypeIds.length;&#10;                c = Integer.compare(lenA, lenB);&#10;                if (c != 0) return c;&#10;                for (int i = 0; i &lt; lenA; i++) {&#10;                    c = Integer.compare(this.addTypeIds[i], other.addTypeIds[i]);&#10;                    if (c != 0) return c;&#10;                }&#10;                int lenRA = this.removeTypeIds.length;&#10;                int lenRB = other.removeTypeIds.length;&#10;                c = Integer.compare(lenRA, lenRB);&#10;                if (c != 0) return c;&#10;                for (int i = 0; i &lt; lenRA; i++) {&#10;                    c = Integer.compare(this.removeTypeIds[i], other.removeTypeIds[i]);&#10;                    if (c != 0) return c;&#10;                }&#10;            } else {&#10;                // 3b) Các loại lệnh khác gom theo typeId1 (component type) và sharedIndex nếu cần&#10;                c = Integer.compare(this.typeId1, other.typeId1);&#10;                if (c != 0) return c;&#10;                if (this.commandId == CMD_SET_SHARED_MANAGED) {&#10;                    c = Integer.compare(this.typeId2, other.typeId2);&#10;                    if (c != 0) return c;&#10;                }&#10;            }&#10;&#10;            // 4) Cuối cùng theo entity id&#10;            return Integer.compare(this.entityId, other.entityId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Key describing a batch of structural mutations by command kind and component type.&#10;     */&#10;    private static final class MutateKey {&#10;        final int commandId;&#10;        final int typeId;&#10;        final int sharedIndex; // only meaningful for CMD_SET_SHARED_MANAGED&#10;        final int[] addTypeIds;    // for CMD_MUTATE_COMPONENTS&#10;        final int[] removeTypeIds; // for CMD_MUTATE_COMPONENTS&#10;&#10;        MutateKey(int commandId, int typeId, int sharedIndex) {&#10;            this(commandId, typeId, sharedIndex, null, null);&#10;        }&#10;&#10;        MutateKey(int commandId, int typeId, int sharedIndex, int[] addTypeIds, int[] removeTypeIds) {&#10;            this.commandId = commandId;&#10;            this.typeId = typeId;&#10;            this.sharedIndex = sharedIndex;&#10;            this.addTypeIds = addTypeIds;&#10;            this.removeTypeIds = removeTypeIds;&#10;        }&#10;&#10;        boolean isDestroy() { return commandId == CMD_DESTROY_ENTITY; }&#10;        boolean isAdd()     { return commandId == CMD_ADD_COMPONENT; }&#10;        boolean isRemove()  { return commandId == CMD_REMOVE_COMPONENT; }&#10;        boolean isSetShared() { return commandId == CMD_SET_SHARED_MANAGED; }&#10;        boolean isMutateMulti() { return commandId == CMD_MUTATE_COMPONENTS; }&#10;&#10;        @Override&#10;        public boolean equals(Object o) {&#10;            if (this == o) return true;&#10;            if (!(o instanceof MutateKey other)) return false;&#10;            if (commandId != other.commandId) return false;&#10;            if (commandId == CMD_MUTATE_COMPONENTS) {&#10;                return java.util.Arrays.equals(this.addTypeIds, other.addTypeIds)&#10;                        &amp;&amp; java.util.Arrays.equals(this.removeTypeIds, other.removeTypeIds);&#10;            }&#10;            return typeId == other.typeId &amp;&amp; sharedIndex == other.sharedIndex;&#10;        }&#10;&#10;        @Override&#10;        public int hashCode() {&#10;            int result = commandId;&#10;            if (commandId == CMD_MUTATE_COMPONENTS) {&#10;                result = 31 * result + java.util.Arrays.hashCode(addTypeIds);&#10;                result = 31 * result + java.util.Arrays.hashCode(removeTypeIds);&#10;            } else {&#10;                result = 31 * result + typeId;&#10;                result = 31 * result + sharedIndex;&#10;            }&#10;            return result;&#10;        }&#10;    }&#10;&#10;    private void executeSortedCommands(List&lt;InterpretedCommand&gt; sortedCommands, ArchetypeWorld world) {&#10;        List&lt;Integer&gt; entityBatch = new ArrayList&lt;&gt;();&#10;        MutateKey currentKey = null;&#10;&#10;        for (InterpretedCommand cmd : sortedCommands) {&#10;            MutateKey cmdKey;&#10;            if (cmd.commandId == CMD_MUTATE_COMPONENTS) {&#10;                cmdKey = new MutateKey(cmd.commandId, 0, 0, cmd.addTypeIds, cmd.removeTypeIds);&#10;            } else {&#10;                int sharedIndex = (cmd.commandId == CMD_SET_SHARED_MANAGED) ? cmd.typeId2 : -1;&#10;                cmdKey = new MutateKey(cmd.commandId, cmd.typeId1, sharedIndex);&#10;            }&#10;            if (currentKey != null &amp;&amp; cmdKey.equals(currentKey)) {&#10;                entityBatch.add(cmd.entityId);&#10;            } else {&#10;                if (!entityBatch.isEmpty()) {&#10;                    flushBatch(currentKey, entityBatch, world);&#10;                }&#10;                entityBatch.clear();&#10;                entityBatch.add(cmd.entityId);&#10;                currentKey = cmdKey;&#10;            }&#10;        }&#10;        if (!entityBatch.isEmpty() &amp;&amp; currentKey != null) {&#10;            flushBatch(currentKey, entityBatch, world);&#10;        }&#10;    }&#10;&#10;    private void flushBatch(MutateKey key, List&lt;Integer&gt; entityBatch, ArchetypeWorld world) {&#10;        int size = entityBatch.size();&#10;        int[] ids = new int[size];&#10;        for (int i = 0; i &lt; size; i++) ids[i] = entityBatch.get(i);&#10;        ArchetypeWorld.EntityBatch batch = ArchetypeWorld.EntityBatch.of(ids);&#10;&#10;        if (key.isDestroy()) {&#10;            for (int id : ids) {&#10;                world.destroyEntity(id);&#10;            }&#10;        } else if (key.isAdd()) {&#10;            Class&lt;?&gt; componentClass = world.getComponentMetadata(key.typeId).type();&#10;            world.addComponents(batch, componentClass);&#10;        } else if (key.isRemove()) {&#10;            Class&lt;?&gt; componentClass = world.getComponentMetadata(key.typeId).type();&#10;            world.removeComponents(batch, componentClass);&#10;        } else if (key.isSetShared()) {&#10;            Object sharedValue = world.sharedStore.getValue(key.sharedIndex);&#10;            if (sharedValue != null) {&#10;                // Use batch shared API to leverage O(M + N*M_intersect) path.&#10;                world.setSharedComponent(batch, sharedValue);&#10;            }&#10;        } else if (key.isMutateMulti()) {&#10;            // Multi-component mutate: map type ids back to classes and delegate to ArchetypeWorld&#10;            Class&lt;?&gt;[] addClasses = new Class&lt;?&gt;[key.addTypeIds.length];&#10;            for (int i = 0; i &lt; key.addTypeIds.length; i++) {&#10;                addClasses[i] = world.getComponentMetadata(key.addTypeIds[i]).type();&#10;            }&#10;            Class&lt;?&gt;[] remClasses = new Class&lt;?&gt;[key.removeTypeIds.length];&#10;            for (int i = 0; i &lt; key.removeTypeIds.length; i++) {&#10;                remClasses[i] = world.getComponentMetadata(key.removeTypeIds[i]).type();&#10;            }&#10;            world.mutateComponents(batch, addClasses, remClasses);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentDescriptor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentDescriptor.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.util.*;&#10;&#10;/**&#10; * Descriptor containing metadata about a component's memory layout&#10; * Generated by ComponentManager through reflection&#10; */&#10;public class ComponentDescriptor {&#10;    private final Class&lt;?&gt; componentClass;&#10;    private final long totalSize;&#10;    private final Map&lt;String, FieldDescriptor&gt; fields; // legacy name-&gt;descriptor&#10;    private final List&lt;FieldDescriptor&gt; fieldList;     // legacy ordered list (immutable)&#10;    private final FieldDescriptor[] fieldArray;        // fast array for index-based access&#10;    private final Map&lt;String, Integer&gt; fieldIndexMap;  // name -&gt; index (immutable)&#10;    private final Component.LayoutType layoutType;&#10;    // New: whether this component is managed (@Component.Managed) or unmanaged (default/@Unmanaged)&#10;    private final boolean managed;&#10;    // New: fine-grained kind distinguishing instance/shared and managed/unmanaged&#10;    public enum ComponentKind { INSTANCE_UNMANAGED, INSTANCE_MANAGED, SHARED_UNMANAGED, SHARED_MANAGED }&#10;    private final ComponentKind kind;&#10;&#10;    public ComponentDescriptor(Class&lt;?&gt; componentClass, long totalSize,&#10;                              List&lt;FieldDescriptor&gt; fields, Component.LayoutType layoutType) {&#10;        this(componentClass, totalSize, fields, layoutType, null);&#10;    }&#10;&#10;    // Overload that allows explicit kind; if null, derives from managed flag&#10;    public ComponentDescriptor(Class&lt;?&gt; componentClass, long totalSize,&#10;                               List&lt;FieldDescriptor&gt; fields, Component.LayoutType layoutType,&#10;                               ComponentKind explicitKind) {&#10;        this.componentClass = componentClass;&#10;        this.totalSize = totalSize;&#10;        this.fieldList = Collections.unmodifiableList(new ArrayList&lt;&gt;(fields));&#10;        this.fields = new HashMap&lt;&gt;();&#10;        for (FieldDescriptor field : fields) {&#10;            this.fields.put(field.name(), field);&#10;        }&#10;        // Build fast structures&#10;        this.fieldArray = this.fieldList.toArray(new FieldDescriptor[0]);&#10;        Map&lt;String, Integer&gt; indexMap = new HashMap&lt;&gt;(fieldArray.length);&#10;        for (int i = 0; i &lt; fieldArray.length; i++) {&#10;            indexMap.put(fieldArray[i].name(), i);&#10;        }&#10;        this.fieldIndexMap = Collections.unmodifiableMap(indexMap);&#10;&#10;        this.layoutType = layoutType;&#10;        // Determine managed kind from annotation on the component type&#10;        this.managed = componentClass.isAnnotationPresent(Component.Managed.class);&#10;        // Determine kind: prefer explicit, else derive from managed flag as instance component&#10;        this.kind = (explicitKind != null) ? explicitKind : (this.managed ? ComponentKind.INSTANCE_MANAGED : ComponentKind.INSTANCE_UNMANAGED);&#10;    }&#10;&#10;    public Class&lt;?&gt; getComponentClass() {&#10;        return componentClass;&#10;    }&#10;&#10;    public long getTotalSize() {&#10;        return totalSize;&#10;    }&#10;&#10;    // Legacy name-based lookup (setup-time, not hot-path)&#10;    public FieldDescriptor getField(String name) {&#10;        return fields.get(name);&#10;    }&#10;&#10;    // New: O(1) index-based access&#10;    public int getFieldIndex(String fieldName) {&#10;        Integer idx = fieldIndexMap.get(fieldName);&#10;        return idx == null ? -1 : idx;&#10;    }&#10;&#10;    public FieldDescriptor getField(int index) {&#10;        return fieldArray[index];&#10;    }&#10;&#10;    public int fieldCount() {&#10;        return fieldArray.length;&#10;    }&#10;&#10;    public List&lt;FieldDescriptor&gt; getFields() {&#10;        return fieldList;&#10;    }&#10;&#10;    public Component.LayoutType getLayoutType() {&#10;        return layoutType;&#10;    }&#10;&#10;    // New: managed flag&#10;    public boolean isManaged() { return managed; }&#10;&#10;    // New: fine-grained kind&#10;    public ComponentKind getKind() { return kind; }&#10;&#10;    /**&#10;     * Field descriptor with type and layout information&#10;     */&#10;    public record FieldDescriptor(&#10;        String name,&#10;        FieldType type,&#10;        long offset,&#10;        long size,&#10;        int alignment&#10;    ) {}&#10;&#10;    /**&#10;     * Supported field types&#10;     */&#10;    public enum FieldType {&#10;        BYTE(1, 1),&#10;        SHORT(2, 2),&#10;        INT(4, 4),&#10;        LONG(8, 8),&#10;        FLOAT(4, 4),&#10;        DOUBLE(8, 8),&#10;        BOOLEAN(1, 1),&#10;        CHAR(2, 2);&#10;&#10;        private final long size;&#10;        private final int naturalAlignment;&#10;&#10;        FieldType(long size, int naturalAlignment) {&#10;            this.size = size;&#10;            this.naturalAlignment = naturalAlignment;&#10;        }&#10;&#10;        public long getSize() {&#10;            return size;&#10;        }&#10;&#10;        public int getNaturalAlignment() {&#10;            return naturalAlignment;&#10;        }&#10;&#10;        public static FieldType fromJavaType(Class&lt;?&gt; type) {&#10;            if (type == byte.class || type == Byte.class) return BYTE;&#10;            if (type == short.class || type == Short.class) return SHORT;&#10;            if (type == int.class || type == Integer.class) return INT;&#10;            if (type == long.class || type == Long.class) return LONG;&#10;            if (type == float.class || type == Float.class) return FLOAT;&#10;            if (type == double.class || type == Double.class) return DOUBLE;&#10;            if (type == boolean.class || type == Boolean.class) return BOOLEAN;&#10;            if (type == char.class || type == Character.class) return CHAR;&#10;            throw new IllegalArgumentException(&quot;Unsupported field type: &quot; + type);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;ComponentDescriptor[&quot;)&#10;          .append(componentClass.getSimpleName())&#10;          .append(&quot;, size=&quot;).append(totalSize)&#10;          .append(&quot;, layout=&quot;).append(layoutType)&#10;          .append(&quot;, managed=&quot;).append(managed)&#10;          .append(&quot;, kind=&quot;).append(kind)&#10;          .append(&quot;, fields=[\n&quot;);&#10;        for (FieldDescriptor field : fieldList) {&#10;            sb.append(&quot;  &quot;).append(field.name())&#10;              .append(&quot;: &quot;).append(field.type())&#10;              .append(&quot; @&quot;).append(field.offset())&#10;              .append(&quot; (size=&quot;).append(field.size())&#10;              .append(&quot;, align=&quot;).append(field.alignment())&#10;              .append(&quot;)\n&quot;);&#10;        }&#10;        sb.append(&quot;]] &quot;);&#10;        return sb.toString();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.components;&#13;&#10;&#13;&#10;import java.util.*;&#13;&#10;&#13;&#10;/**&#13;&#10; * Descriptor containing metadata about a component's memory layout&#13;&#10; * Generated by ComponentManager through reflection&#13;&#10; */&#13;&#10;public class ComponentDescriptor {&#13;&#10;    private final Class&lt;?&gt; componentClass;&#13;&#10;    private final long totalSize;&#13;&#10;    private final Map&lt;String, FieldDescriptor&gt; fields; // legacy name-&gt;descriptor&#13;&#10;    private final List&lt;FieldDescriptor&gt; fieldList;     // legacy ordered list (immutable)&#13;&#10;    private final FieldDescriptor[] fieldArray;        // fast array for index-based access&#13;&#10;    private final Map&lt;String, Integer&gt; fieldIndexMap;  // name -&gt; index (immutable)&#13;&#10;    private final Component.LayoutType layoutType;&#13;&#10;    // New: whether this component is managed (@Component.Managed) or unmanaged (default/@Unmanaged)&#13;&#10;    private final boolean managed;&#13;&#10;    // New: fine-grained kind distinguishing instance/shared and managed/unmanaged&#13;&#10;    public enum ComponentKind { INSTANCE_UNMANAGED, INSTANCE_MANAGED, SHARED_UNMANAGED, SHARED_MANAGED }&#13;&#10;    private final ComponentKind kind;&#13;&#10;&#13;&#10;    public ComponentDescriptor(Class&lt;?&gt; componentClass, long totalSize,&#13;&#10;                              List&lt;FieldDescriptor&gt; fields, Component.LayoutType layoutType) {&#13;&#10;        this(componentClass, totalSize, fields, layoutType, null);&#13;&#10;    }&#13;&#10;&#13;&#10;    // Overload that allows explicit kind; if null, derives from managed flag&#13;&#10;    public ComponentDescriptor(Class&lt;?&gt; componentClass, long totalSize,&#13;&#10;                               List&lt;FieldDescriptor&gt; fields, Component.LayoutType layoutType,&#13;&#10;                               ComponentKind explicitKind) {&#13;&#10;        this.componentClass = componentClass;&#13;&#10;        this.totalSize = totalSize;&#13;&#10;        this.fieldList = Collections.unmodifiableList(new ArrayList&lt;&gt;(fields));&#13;&#10;        this.fields = new HashMap&lt;&gt;();&#13;&#10;        for (FieldDescriptor field : fields) {&#13;&#10;            this.fields.put(field.name(), field);&#13;&#10;        }&#13;&#10;        // Build fast structures&#13;&#10;        this.fieldArray = this.fieldList.toArray(new FieldDescriptor[0]);&#13;&#10;        Map&lt;String, Integer&gt; indexMap = new HashMap&lt;&gt;(fieldArray.length);&#13;&#10;        for (int i = 0; i &lt; fieldArray.length; i++) {&#13;&#10;            indexMap.put(fieldArray[i].name(), i);&#13;&#10;        }&#13;&#10;        this.fieldIndexMap = Collections.unmodifiableMap(indexMap);&#13;&#10;&#13;&#10;        this.layoutType = layoutType;&#13;&#10;        // Determine managed kind from annotation on the component type&#13;&#10;        this.managed = componentClass.isAnnotationPresent(Component.Managed.class);&#13;&#10;        // Determine kind: prefer explicit, else derive from managed flag as instance component&#13;&#10;        this.kind = (explicitKind != null) ? explicitKind : (this.managed ? ComponentKind.INSTANCE_MANAGED : ComponentKind.INSTANCE_UNMANAGED);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Class&lt;?&gt; getComponentClass() {&#13;&#10;        return componentClass;&#13;&#10;    }&#13;&#10;&#13;&#10;    public long getTotalSize() {&#13;&#10;        return totalSize;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Legacy name-based lookup (setup-time, not hot-path)&#13;&#10;    public FieldDescriptor getField(String name) {&#13;&#10;        return fields.get(name);&#13;&#10;    }&#13;&#10;&#13;&#10;    // New: O(1) index-based access&#13;&#10;    public int getFieldIndex(String fieldName) {&#13;&#10;        Integer idx = fieldIndexMap.get(fieldName);&#13;&#10;        return idx == null ? -1 : idx;&#13;&#10;    }&#13;&#10;&#13;&#10;    public FieldDescriptor getField(int index) {&#13;&#10;        return fieldArray[index];&#13;&#10;    }&#13;&#10;&#13;&#10;    public int fieldCount() {&#13;&#10;        return fieldArray.length;&#13;&#10;    }&#13;&#10;&#13;&#10;    public List&lt;FieldDescriptor&gt; getFields() {&#13;&#10;        return fieldList;&#13;&#10;    }&#13;&#10;&#13;&#10;    public Component.LayoutType getLayoutType() {&#13;&#10;        return layoutType;&#13;&#10;    }&#13;&#10;&#13;&#10;    // New: managed flag&#13;&#10;    public boolean isManaged() { return managed; }&#13;&#10;&#13;&#10;    // New: fine-grained kind&#13;&#10;    public ComponentKind getKind() { return kind; }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Field descriptor with type and layout information&#13;&#10;     */&#13;&#10;    public record FieldDescriptor(&#13;&#10;        String name,&#13;&#10;        FieldType type,&#13;&#10;        long offset,&#13;&#10;        long size,&#13;&#10;        int alignment&#13;&#10;    ) {}&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Supported field types&#13;&#10;     */&#13;&#10;    public enum FieldType {&#13;&#10;        BYTE(1, 1),&#13;&#10;        SHORT(2, 2),&#13;&#10;        INT(4, 4),&#13;&#10;        LONG(8, 8),&#13;&#10;        FLOAT(4, 4),&#13;&#10;        DOUBLE(8, 8),&#13;&#10;        BOOLEAN(1, 1),&#13;&#10;        CHAR(2, 2);&#13;&#10;&#13;&#10;        private final long size;&#13;&#10;        private final int naturalAlignment;&#13;&#10;&#13;&#10;        FieldType(long size, int naturalAlignment) {&#13;&#10;            this.size = size;&#13;&#10;            this.naturalAlignment = naturalAlignment;&#13;&#10;        }&#13;&#10;&#13;&#10;        public long getSize() {&#13;&#10;            return size;&#13;&#10;        }&#13;&#10;&#13;&#10;        public int getNaturalAlignment() {&#13;&#10;            return naturalAlignment;&#13;&#10;        }&#13;&#10;&#13;&#10;        public static FieldType fromJavaType(Class&lt;?&gt; type) {&#13;&#10;            if (type == byte.class || type == Byte.class) return BYTE;&#13;&#10;            if (type == short.class || type == Short.class) return SHORT;&#13;&#10;            if (type == int.class || type == Integer.class) return INT;&#13;&#10;            if (type == long.class || type == Long.class) return LONG;&#13;&#10;            if (type == float.class || type == Float.class) return FLOAT;&#13;&#10;            if (type == double.class || type == Double.class) return DOUBLE;&#13;&#10;            if (type == boolean.class || type == Boolean.class) return BOOLEAN;&#13;&#10;            if (type == char.class || type == Character.class) return CHAR;&#13;&#10;            throw new IllegalArgumentException(&quot;Unsupported field type: &quot; + type);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public String toString() {&#13;&#10;        StringBuilder sb = new StringBuilder();&#13;&#10;        sb.append(&quot;ComponentDescriptor[&quot;)&#13;&#10;          .append(componentClass.getSimpleName())&#13;&#10;          .append(&quot;, size=&quot;).append(totalSize)&#13;&#10;          .append(&quot;, layout=&quot;).append(layoutType)&#13;&#10;          .append(&quot;, managed=&quot;).append(managed)&#13;&#10;          .append(&quot;, kind=&quot;).append(kind)&#13;&#10;          .append(&quot;, fields=[\n&quot;);&#13;&#10;        for (FieldDescriptor field : fieldList) {&#13;&#10;            sb.append(&quot;  &quot;).append(field.name())&#13;&#10;              .append(&quot;: &quot;).append(field.type())&#13;&#10;              .append(&quot; @&quot;).append(field.offset())&#13;&#10;              .append(&quot; (size=&quot;).append(field.size())&#13;&#10;              .append(&quot;, align=&quot;).append(field.alignment())&#13;&#10;              .append(&quot;)\n&quot;);&#13;&#10;        }&#13;&#10;        sb.append(&quot;]] &quot;);&#13;&#10;        return sb.toString();&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/ComponentManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Method;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    // Thread-safe registries&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;    // [THÊM VÀO] Map ID -&gt; Descriptor để tra cứu O(1) theo typeId&#10;    private final ConcurrentHashMap&lt;Integer, ComponentDescriptor&gt; idToDescriptorMap = new ConcurrentHashMap&lt;&gt;();&#10;    private final AtomicInteger nextTypeId = new AtomicInteger(0);&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    // Typed handle pools keyed by component class, used by AP-generated code for PositionHandle, etc.&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, HandlePool&lt;? extends IBindableHandle&gt;&gt; typedHandlePools = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Lightweight validation for shared component annotations&#10;        validateSharedAnnotations(componentClass);&#10;&#10;        // Assign a stable type id exactly once, even under races&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;&#10;        // Prefer generated descriptor if present; else build via reflection&#10;        descriptors.computeIfAbsent(componentClass, cls -&gt; {&#10;            ComponentDescriptor gen = tryLoadGeneratedDescriptor(cls);&#10;            ComponentDescriptor desc = gen != null ? gen : buildDescriptor(cls);&#10;            // Cập nhật map ID -&gt; Descriptor cho lookup O(1)&#10;            idToDescriptorMap.put(typeId, desc);&#10;            return desc;&#10;        });&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Register a component class with a prebuilt descriptor (e.g., from generated meta).&#10;     * Thread-safe and idempotent: type id is assigned once; descriptor installed if absent.&#10;     */&#10;    public &lt;T&gt; int registerComponentWithDescriptor(Class&lt;T&gt; componentClass, ComponentDescriptor descriptor) {&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;        // Validate shared annotations even if descriptor is provided&#10;        validateSharedAnnotations(componentClass);&#10;&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;descriptor must not be null for &quot; + componentClass.getName());&#10;        }&#10;        descriptors.putIfAbsent(componentClass, descriptor);&#10;        // Cập nhật cả map ID -&gt; Descriptor (không ghi đè nếu đã có)&#10;        idToDescriptorMap.putIfAbsent(typeId, descriptor);&#10;        return typeId;&#10;    }&#10;&#10;    // High-level registration used by AP-generated code to install both descriptor and typed handle pool.&#10;    public &lt;T extends IBindableHandle&gt; void registerComponentWithHandle(&#10;        Class&lt;?&gt; componentClass,&#10;        ComponentDescriptor descriptor,&#10;        java.util.function.Supplier&lt;T&gt; handleFactory&#10;    ) {&#10;        int typeId = registerComponentWithDescriptor(componentClass, descriptor);&#10;        HandlePool&lt;T&gt; pool = new HandlePool&lt;&gt;(handleFactory);&#10;        typedHandlePools.put(componentClass, pool);&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Determine kind from annotations&#10;        ComponentDescriptor.ComponentKind kind = getComponentKind(componentClass);&#10;&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType, kind);&#10;    }&#10;&#10;    private static ComponentDescriptor.ComponentKind getComponentKind(Class&lt;?&gt; componentClass) {&#10;        boolean isManaged = componentClass.isAnnotationPresent(Component.Managed.class);&#10;        boolean isShared = componentClass.isAnnotationPresent(Component.Shared.class);&#10;        ComponentDescriptor.ComponentKind kind;&#10;        if (isShared) {&#10;            kind = isManaged ? ComponentDescriptor.ComponentKind.SHARED_MANAGED : ComponentDescriptor.ComponentKind.SHARED_UNMANAGED;&#10;        } else {&#10;            kind = isManaged ? ComponentDescriptor.ComponentKind.INSTANCE_MANAGED : ComponentDescriptor.ComponentKind.INSTANCE_UNMANAGED;&#10;        }&#10;        return kind;&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;&#10;    // Try to load a generated meta class &lt;FQN&gt; + &quot;Meta&quot; exposing DESCRIPTOR field or descriptor() method.&#10;    private ComponentDescriptor tryLoadGeneratedDescriptor(Class&lt;?&gt; componentClass) {&#10;        String metaName = componentClass.getName() + &quot;Meta&quot;;&#10;        try {&#10;            Class&lt;?&gt; meta = Class.forName(metaName, false, componentClass.getClassLoader());&#10;            try {&#10;                java.lang.reflect.Field f = meta.getField(&quot;DESCRIPTOR&quot;);&#10;                Object v = f.get(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchFieldException ignored) { }&#10;            try {&#10;                java.lang.reflect.Method m = meta.getMethod(&quot;descriptor&quot;);&#10;                Object v = m.invoke(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchMethodException ignored) { }&#10;        } catch (Throwable ignored) {&#10;            // not generated/present&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Lightweight validation for shared component annotations.&#10;     * or setters (1-arg int/long, returns void).&#10;     */&#10;    private void validateSharedAnnotations(Class&lt;?&gt; cls) {&#10;        boolean hasShared = cls.isAnnotationPresent(Component.Shared.class);&#10;        boolean hasManaged = cls.isAnnotationPresent(Component.Managed.class);&#10;&#10;        if (!hasShared) return; // nothing to validate&#10;&#10;        // Managed-shared: @Shared + @Managed must be a class overriding equals/hashCode&#10;        if (hasManaged) {&#10;            if (cls.isInterface()) {&#10;                throw new IllegalArgumentException(&quot;@Shared (managed) must be placed on a class, not an interface: &quot; + cls.getName());&#10;            }&#10;            try {&#10;                Method eq = cls.getMethod(&quot;equals&quot;, Object.class);&#10;                if (eq.getDeclaringClass() == Object.class) throw new NoSuchMethodException();&#10;            } catch (NoSuchMethodException e) {&#10;                throw new IllegalArgumentException(&quot;Class &quot; + cls.getName() + &quot; is annotated @Shared but does not override equals(Object)&quot;);&#10;            }&#10;            try {&#10;                Method hc = cls.getMethod(&quot;hashCode&quot;);&#10;                if (hc.getDeclaringClass() == Object.class) throw new NoSuchMethodException();&#10;            } catch (NoSuchMethodException e) {&#10;                throw new IllegalArgumentException(&quot;Class &quot; + cls.getName() + &quot; is annotated @Shared but does not override hashCode()&quot;);&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Unmanaged-shared: @Shared without @Managed must be an class with at least one field (primitive types)&#10;        if (cls.isInterface()) {&#10;            throw new IllegalArgumentException(&quot;@Shared (unmanaged) must be placed on a class, not an interface: &quot; + cls.getName());&#10;        }&#10;        Field[] fields = cls.getDeclaredFields();&#10;        if (fields.length == 0) {&#10;            throw new IllegalArgumentException(&quot;Class &quot; + cls.getName() + &quot; is annotated @Shared but has no fields&quot;);&#10;        }&#10;&#10;        for( Field f : fields) {&#10;            Class&lt;?&gt; t = f.getType();&#10;            if (!(t == int.class || t == long.class || t == float.class || t == double.class || t == boolean.class)) {&#10;                throw new IllegalArgumentException(&quot;Field &quot; + f.getName() + &quot; in @Shared unmanaged component &quot; + cls.getName() +&#10;                    &quot; has unsupported type &quot; + t.getName() + &quot;. Only primitive types are allowed.&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Acquire a typed handle instance from the pool for the given component class.&#10;    public IBindableHandle acquireTypedHandle(Class&lt;?&gt; componentClass) {&#10;        HandlePool&lt;?&gt; pool = typedHandlePools.get(componentClass);&#10;        if (pool == null) {&#10;            throw new IllegalArgumentException(&quot;No typed handle pool registered for component: &quot; + componentClass.getName());&#10;        }&#10;        return pool.acquire();&#10;    }&#10;&#10;    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})&#10;    public void releaseTypedHandle(Class&lt;?&gt; componentClass, IBindableHandle handle) {&#10;        HandlePool pool = typedHandlePools.get(componentClass);&#10;        if (pool != null) {&#10;            pool.release(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Returns an unmodifiable view of the registered component-&gt;id mapping.&#10;     * This allows external clients (e.g., ArchetypeWorld) to resolve ids back to classes&#10;     * without duplicating ID ownership.&#10;     */&#10;    public Set&lt;Map.Entry&lt;Class&lt;?&gt;, Integer&gt;&gt; getRegisteredComponentIds() {&#10;        return componentTypeIds.entrySet();&#10;    }&#10;&#10;    /**&#10;     * Lấy ComponentDescriptor trực tiếp bằng Type ID (O(1)).&#10;     */&#10;    public ComponentDescriptor getDescriptor(int typeId) {&#10;        return idToDescriptorMap.get(typeId);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Method;&#10;import java.lang.reflect.Modifier;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedDeque;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * ComponentManager - Manages component registration and reflection&#10; * Uses Panama Foreign Memory API to create efficient memory layouts&#10; */&#10;public class ComponentManager {&#10;    // Thread-safe registries&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, ComponentDescriptor&gt; descriptors = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, Integer&gt; componentTypeIds = new ConcurrentHashMap&lt;&gt;();&#10;    // [THÊM VÀO] Map ID -&gt; Descriptor để tra cứu O(1) theo typeId&#10;    private final ConcurrentHashMap&lt;Integer, ComponentDescriptor&gt; idToDescriptorMap = new ConcurrentHashMap&lt;&gt;();&#10;    private final AtomicInteger nextTypeId = new AtomicInteger(0);&#10;&#10;    // Pool of reusable ComponentHandle instances to avoid allocations when mapping into archetype arrays&#10;    private final ConcurrentLinkedDeque&lt;ComponentHandle&gt; handlePool = new ConcurrentLinkedDeque&lt;&gt;();&#10;&#10;    // Typed handle pools keyed by component class, used by AP-generated code for PositionHandle, etc.&#10;    private final ConcurrentHashMap&lt;Class&lt;?&gt;, HandlePool&lt;? extends IBindableHandle&gt;&gt; typedHandlePools = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Register a component class and analyze its layout using reflection&#10;     */&#10;    public &lt;T&gt; int registerComponent(Class&lt;T&gt; componentClass) {&#10;        // Verify it implements Component interface&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(&#10;                componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;&#10;        // Lightweight validation for shared component annotations&#10;        validateSharedAnnotations(componentClass);&#10;&#10;        // Assign a stable type id exactly once, even under races&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;&#10;        // Prefer generated descriptor if present; else build via reflection&#10;        descriptors.computeIfAbsent(componentClass, cls -&gt; {&#10;            ComponentDescriptor gen = tryLoadGeneratedDescriptor(cls);&#10;            ComponentDescriptor desc = gen != null ? gen : buildDescriptor(cls);&#10;            // Cập nhật map ID -&gt; Descriptor cho lookup O(1)&#10;            idToDescriptorMap.put(typeId, desc);&#10;            return desc;&#10;        });&#10;&#10;        return typeId;&#10;    }&#10;&#10;    /**&#10;     * Register a component class with a prebuilt descriptor (e.g., from generated meta).&#10;     * Thread-safe and idempotent: type id is assigned once; descriptor installed if absent.&#10;     */&#10;    public &lt;T&gt; int registerComponentWithDescriptor(Class&lt;T&gt; componentClass, ComponentDescriptor descriptor) {&#10;        if (!Component.class.isAssignableFrom(componentClass)) {&#10;            throw new IllegalArgumentException(componentClass.getName() + &quot; must implement Component interface&quot;);&#10;        }&#10;        // Validate shared annotations even if descriptor is provided&#10;        validateSharedAnnotations(componentClass);&#10;&#10;        int typeId = componentTypeIds.computeIfAbsent(componentClass, k -&gt; nextTypeId.getAndIncrement());&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;descriptor must not be null for &quot; + componentClass.getName());&#10;        }&#10;        descriptors.putIfAbsent(componentClass, descriptor);&#10;        // Cập nhật cả map ID -&gt; Descriptor (không ghi đè nếu đã có)&#10;        idToDescriptorMap.putIfAbsent(typeId, descriptor);&#10;        return typeId;&#10;    }&#10;&#10;    // High-level registration used by AP-generated code to install both descriptor and typed handle pool.&#10;    public &lt;T extends IBindableHandle&gt; void registerComponentWithHandle(&#10;        Class&lt;?&gt; componentClass,&#10;        ComponentDescriptor descriptor,&#10;        java.util.function.Supplier&lt;T&gt; handleFactory&#10;    ) {&#10;        int typeId = registerComponentWithDescriptor(componentClass, descriptor);&#10;        HandlePool&lt;T&gt; pool = new HandlePool&lt;&gt;(handleFactory);&#10;        typedHandlePools.put(componentClass, pool);&#10;    }&#10;&#10;    /**&#10;     * Get component descriptor&#10;     */&#10;    public ComponentDescriptor getDescriptor(Class&lt;?&gt; componentClass) {&#10;        return descriptors.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get component type ID&#10;     */&#10;    public Integer getTypeId(Class&lt;?&gt; componentClass) {&#10;        return componentTypeIds.get(componentClass);&#10;    }&#10;&#10;    /**&#10;     * Get all registered component classes&#10;     */&#10;    public Set&lt;Class&lt;?&gt;&gt; getRegisteredComponents() {&#10;        return Collections.unmodifiableSet(componentTypeIds.keySet());&#10;    }&#10;&#10;    /**&#10;     * Acquire a reusable ComponentHandle from the pool (or create a new one).&#10;     */&#10;    public ComponentHandle acquireHandle() {&#10;        ComponentHandle h = handlePool.pollFirst();&#10;        if (h == null) {&#10;            h = new ComponentHandle();&#10;        }&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Release a handle back to the pool. The handle is cleared before pooling.&#10;     */&#10;    public void releaseHandle(ComponentHandle handle) {&#10;        if (handle == null) return;&#10;        handle.clear();&#10;        handlePool.offerFirst(handle);&#10;    }&#10;&#10;    /**&#10;     * Auto-closeable wrapper for a pooled ComponentHandle. Calling close() returns the handle to the pool.&#10;     */&#10;    public final class BoundHandle implements AutoCloseable {&#10;        private final ComponentHandle handle;&#10;&#10;        private BoundHandle(ComponentHandle handle) {&#10;            this.handle = handle;&#10;        }&#10;&#10;        public ComponentHandle handle() {&#10;            return handle;&#10;        }&#10;&#10;        @Override&#10;        public void close() {&#10;            releaseHandle(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acquire a BoundHandle (AutoCloseable) bound to the provided segment. Use try-with-resources to auto-release.&#10;     */&#10;    public BoundHandle acquireBoundHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentHandle h = createHandle(componentClass, segment);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentHandle h = createHandleFromArrayElement(componentClass, arraySegment, elementIndex, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    public BoundHandle acquireBoundHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentHandle h = createHandleFromSegmentOffset(componentClass, baseSegment, offset, elementSize);&#10;        return new BoundHandle(h);&#10;    }&#10;&#10;    /**&#10;     * Allocate memory for a component instance&#10;     */&#10;    public MemorySegment allocate(Class&lt;?&gt; componentClass, Arena arena) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        return arena.allocate(descriptor.getTotalSize(), 8); // 8-byte aligned&#10;    }&#10;&#10;    /**&#10;     * Create a handle for accessing component data (pooled)&#10;     */&#10;    public ComponentHandle createHandle(Class&lt;?&gt; componentClass, MemorySegment segment) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(segment, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle that points to an element inside a larger component array MemorySegment.&#10;     * This is useful when components are stored as contiguous arrays (ArchetypeChunk.componentArrays).&#10;     * The method uses the registered ComponentDescriptor total size to compute the element slice.&#10;     *&#10;     * This variant requires that the component descriptor size is &lt;= per-element size (stride).&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class&#10;     * @param arraySegment the larger MemorySegment containing N elements packed consecutively&#10;     * @param elementIndex the index of the element inside the array (0-based)&#10;     * @return ComponentHandle pointing to the element (slice) without copying&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long elemSize = descriptor.getTotalSize();&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elemSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elemSize * elementIndex, elemSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for an element when the per-element size is known/explicit.&#10;     * This variant is helpful if the array stores elements with a stride that differs from registered descriptor size.&#10;     * The method validates that the provided elementSize (stride) is at least as large as the descriptor size.&#10;     * The returned handle is from the pool; caller should call `releaseHandle(handle)` when done.&#10;     *&#10;     * @param componentClass the component class (for descriptor / layout info)&#10;     * @param arraySegment the larger MemorySegment containing elements&#10;     * @param elementIndex zero-based index inside the array&#10;     * @param elementSize size in bytes of each element inside the array (stride)&#10;     * @return ComponentHandle pointing to the element&#10;     */&#10;    public ComponentHandle createHandleFromArrayElement(Class&lt;?&gt; componentClass, MemorySegment arraySegment, long elementIndex, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long arraySize = arraySegment.byteSize();&#10;        long required = (elementIndex + 1) * elementSize;&#10;        if (arraySize &lt; required) {&#10;            throw new IllegalArgumentException(&quot;Array segment too small: arraySize=&quot; + arraySize + &quot;, required=&quot; + required);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;Provided elementSize (&quot; + elementSize + &quot;) is smaller than component descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment elementSlice = arraySegment.asSlice(elementSize * elementIndex, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(elementSlice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Create a ComponentHandle for a specific offset inside a MemorySegment.&#10;     * Useful when Archetype/Chunk provides a slice or when you want to map a handle onto&#10;     * an existing segment with a specific offset and stride.&#10;     * The returned handle is pooled; call `releaseHandle` after use.&#10;     *&#10;     * @param componentClass component class for descriptor lookup&#10;     * @param baseSegment base MemorySegment&#10;     * @param offset byte offset inside baseSegment where the element starts&#10;     * @param elementSize number of bytes to map for this element (must be &gt;= descriptor size)&#10;     * @return ComponentHandle referring to the slice [offset, offset+elementSize)&#10;     */&#10;    public ComponentHandle createHandleFromSegmentOffset(Class&lt;?&gt; componentClass, MemorySegment baseSegment, long offset, long elementSize) {&#10;        ComponentDescriptor descriptor = descriptors.get(componentClass);&#10;        if (descriptor == null) {&#10;            throw new IllegalArgumentException(&quot;Component &quot; + componentClass + &quot; not registered&quot;);&#10;        }&#10;        long baseSize = baseSegment.byteSize();&#10;        if (offset &lt; 0 || offset + elementSize &gt; baseSize) {&#10;            throw new IllegalArgumentException(&quot;Offset/size out of bounds: offset=&quot; + offset + &quot;, size=&quot; + elementSize + &quot;, baseSize=&quot; + baseSize);&#10;        }&#10;        long descriptorSize = descriptor.getTotalSize();&#10;        if (elementSize &lt; descriptorSize) {&#10;            throw new IllegalArgumentException(&quot;elementSize (&quot; + elementSize + &quot;) smaller than descriptor size (&quot; + descriptorSize + &quot;)&quot;);&#10;        }&#10;        MemorySegment slice = baseSegment.asSlice(offset, elementSize);&#10;        ComponentHandle h = acquireHandle();&#10;        h.reset(slice, descriptor);&#10;        return h;&#10;    }&#10;&#10;    /**&#10;     * Build component descriptor through reflection&#10;     */&#10;    private ComponentDescriptor buildDescriptor(Class&lt;?&gt; componentClass) {&#10;        // Determine kind from annotations&#10;        ComponentDescriptor.ComponentKind kind = getComponentKind(componentClass);&#10;&#10;        // Get layout annotation&#10;        Component.Layout layoutAnnotation = componentClass.getAnnotation(Component.Layout.class);&#10;        Component.LayoutType layoutType = layoutAnnotation != null ?&#10;            layoutAnnotation.value() : Component.LayoutType.SEQUENTIAL;&#10;&#10;        // Collect all annotated fields&#10;        List&lt;FieldInfo&gt; fieldInfos = new ArrayList&lt;&gt;();&#10;        for (Field field : componentClass.getDeclaredFields()) {&#10;            // Skip static and transient fields&#10;            if (Modifier.isStatic(field.getModifiers()) ||&#10;                Modifier.isTransient(field.getModifiers())) {&#10;                continue;&#10;            }&#10;&#10;            Component.Field fieldAnnotation = field.getAnnotation(Component.Field.class);&#10;            if (fieldAnnotation != null) {&#10;                fieldInfos.add(new FieldInfo(field, fieldAnnotation));&#10;            }&#10;        }&#10;&#10;        // Sort fields by explicit offset if using EXPLICIT layout&#10;        if (layoutType == Component.LayoutType.EXPLICIT) {&#10;            fieldInfos.sort(Comparator.comparingInt(f -&gt; f.annotation.offset()));&#10;        }&#10;&#10;        // Calculate field offsets and total size&#10;        List&lt;ComponentDescriptor.FieldDescriptor&gt; fieldDescriptors = new ArrayList&lt;&gt;();&#10;        long currentOffset = 0;&#10;&#10;        for (FieldInfo fieldInfo : fieldInfos) {&#10;            ComponentDescriptor.FieldType fieldType =&#10;                ComponentDescriptor.FieldType.fromJavaType(fieldInfo.field.getType());&#10;&#10;            long fieldSize = fieldInfo.annotation.size() &gt; 0 ?&#10;                fieldInfo.annotation.size() : fieldType.getSize();&#10;&#10;            int alignment = fieldInfo.annotation.alignment() &gt; 0 ?&#10;                fieldInfo.annotation.alignment() : fieldType.getNaturalAlignment();&#10;&#10;            // Calculate offset&#10;            long offset;&#10;            if (layoutType == Component.LayoutType.EXPLICIT &amp;&amp; fieldInfo.annotation.offset() &gt;= 0) {&#10;                offset = fieldInfo.annotation.offset();&#10;            } else if (layoutType == Component.LayoutType.PADDING) {&#10;                // Align to field's alignment requirement&#10;                offset = alignUp(currentOffset, alignment);&#10;            } else {&#10;                // SEQUENTIAL - no padding&#10;                offset = currentOffset;&#10;            }&#10;&#10;            fieldDescriptors.add(new ComponentDescriptor.FieldDescriptor(&#10;                fieldInfo.field.getName(),&#10;                fieldType,&#10;                offset,&#10;                fieldSize,&#10;                alignment&#10;            ));&#10;&#10;            currentOffset = offset + fieldSize;&#10;        }&#10;&#10;        // Calculate total size&#10;        long totalSize;&#10;        if (layoutAnnotation != null &amp;&amp; layoutAnnotation.size() &gt; 0) {&#10;            totalSize = layoutAnnotation.size();&#10;        } else if (layoutType == Component.LayoutType.PADDING &amp;&amp; !fieldDescriptors.isEmpty()) {&#10;            // Align to largest alignment requirement&#10;            int maxAlignment = fieldDescriptors.stream()&#10;                .mapToInt(ComponentDescriptor.FieldDescriptor::alignment)&#10;                .max()&#10;                .orElse(1);&#10;            totalSize = alignUp(currentOffset, maxAlignment);&#10;        } else {&#10;            totalSize = currentOffset;&#10;        }&#10;&#10;        return new ComponentDescriptor(componentClass, totalSize, fieldDescriptors, layoutType, kind);&#10;    }&#10;&#10;    private static ComponentDescriptor.ComponentKind getComponentKind(Class&lt;?&gt; componentClass) {&#10;        boolean isManaged = componentClass.isAnnotationPresent(Component.Managed.class);&#10;        boolean isShared = componentClass.isAnnotationPresent(Component.Shared.class);&#10;        ComponentDescriptor.ComponentKind kind;&#10;        if (isShared) {&#10;            kind = isManaged ? ComponentDescriptor.ComponentKind.SHARED_MANAGED : ComponentDescriptor.ComponentKind.SHARED_UNMANAGED;&#10;        } else {&#10;            kind = isManaged ? ComponentDescriptor.ComponentKind.INSTANCE_MANAGED : ComponentDescriptor.ComponentKind.INSTANCE_UNMANAGED;&#10;        }&#10;        return kind;&#10;    }&#10;&#10;    /**&#10;     * Align offset to specified alignment&#10;     */&#10;    private long alignUp(long offset, int alignment) {&#10;        return ((offset + alignment - 1) / alignment) * alignment;&#10;    }&#10;&#10;    /**&#10;     * Helper class to hold field info during reflection&#10;     */&#10;    private static class FieldInfo {&#10;        final Field field;&#10;        final Component.Field annotation;&#10;&#10;        FieldInfo(Field field, Component.Field annotation) {&#10;            this.field = field;&#10;            this.annotation = annotation;&#10;        }&#10;    }&#10;&#10;    // Try to load a generated meta class &lt;FQN&gt; + &quot;Meta&quot; exposing DESCRIPTOR field or descriptor() method.&#10;    private ComponentDescriptor tryLoadGeneratedDescriptor(Class&lt;?&gt; componentClass) {&#10;        String metaName = componentClass.getName() + &quot;Meta&quot;;&#10;        try {&#10;            Class&lt;?&gt; meta = Class.forName(metaName, false, componentClass.getClassLoader());&#10;            try {&#10;                java.lang.reflect.Field f = meta.getField(&quot;DESCRIPTOR&quot;);&#10;                Object v = f.get(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchFieldException ignored) { }&#10;            try {&#10;                java.lang.reflect.Method m = meta.getMethod(&quot;descriptor&quot;);&#10;                Object v = m.invoke(null);&#10;                if (v instanceof ComponentDescriptor cd) return cd;&#10;            } catch (NoSuchMethodException ignored) { }&#10;        } catch (Throwable ignored) {&#10;            // not generated/present&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Lightweight validation for shared component annotations.&#10;     * or setters (1-arg int/long, returns void).&#10;     */&#10;    private void validateSharedAnnotations(Class&lt;?&gt; cls) {&#10;        boolean hasShared = cls.isAnnotationPresent(Component.Shared.class);&#10;        boolean hasManaged = cls.isAnnotationPresent(Component.Managed.class);&#10;&#10;        if (!hasShared) return; // nothing to validate&#10;&#10;        // Managed-shared: @Shared + @Managed must be a class overriding equals/hashCode&#10;        if (hasManaged) {&#10;            if (cls.isInterface()) {&#10;                throw new IllegalArgumentException(&quot;@Shared (managed) must be placed on a class, not an interface: &quot; + cls.getName());&#10;            }&#10;            try {&#10;                Method eq = cls.getMethod(&quot;equals&quot;, Object.class);&#10;                if (eq.getDeclaringClass() == Object.class) throw new NoSuchMethodException();&#10;            } catch (NoSuchMethodException e) {&#10;                throw new IllegalArgumentException(&quot;Class &quot; + cls.getName() + &quot; is annotated @Shared but does not override equals(Object)&quot;);&#10;            }&#10;            try {&#10;                Method hc = cls.getMethod(&quot;hashCode&quot;);&#10;                if (hc.getDeclaringClass() == Object.class) throw new NoSuchMethodException();&#10;            } catch (NoSuchMethodException e) {&#10;                throw new IllegalArgumentException(&quot;Class &quot; + cls.getName() + &quot; is annotated @Shared but does not override hashCode()&quot;);&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Unmanaged-shared: @Shared without @Managed must be an class with at least one field (primitive types)&#10;        if (cls.isInterface()) {&#10;            throw new IllegalArgumentException(&quot;@Shared (unmanaged) must be placed on a class, not an interface: &quot; + cls.getName());&#10;        }&#10;        Field[] fields = cls.getDeclaredFields();&#10;        if (fields.length == 0) {&#10;            throw new IllegalArgumentException(&quot;Class &quot; + cls.getName() + &quot; is annotated @Shared but has no fields&quot;);&#10;        }&#10;&#10;        for( Field f : fields) {&#10;            Class&lt;?&gt; t = f.getType();&#10;            if (!(t == int.class || t == long.class || t == float.class || t == double.class || t == boolean.class)) {&#10;                throw new IllegalArgumentException(&quot;Field &quot; + f.getName() + &quot; in @Shared unmanaged component &quot; + cls.getName() +&#10;                    &quot; has unsupported type &quot; + t.getName() + &quot;. Only primitive types are allowed.&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Acquire a typed handle instance from the pool for the given component class.&#10;    public IBindableHandle acquireTypedHandle(Class&lt;?&gt; componentClass) {&#10;        HandlePool&lt;?&gt; pool = typedHandlePools.get(componentClass);&#10;        if (pool == null) {&#10;            throw new IllegalArgumentException(&quot;No typed handle pool registered for component: &quot; + componentClass.getName());&#10;        }&#10;        return pool.acquire();&#10;    }&#10;&#10;    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})&#10;    public void releaseTypedHandle(Class&lt;?&gt; componentClass, IBindableHandle handle) {&#10;        HandlePool pool = typedHandlePools.get(componentClass);&#10;        if (pool != null) {&#10;            pool.release(handle);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Returns an unmodifiable view of the registered component-&gt;id mapping.&#10;     * This allows external clients (e.g., ArchetypeWorld) to resolve ids back to classes&#10;     * without duplicating ID ownership.&#10;     */&#10;    public Set&lt;Map.Entry&lt;Class&lt;?&gt;, Integer&gt;&gt; getRegisteredComponentIds() {&#10;        return componentTypeIds.entrySet();&#10;    }&#10;&#10;    /**&#10;     * Lấy ComponentDescriptor trực tiếp bằng Type ID (O(1)).&#10;     */&#10;    public ComponentDescriptor getDescriptor(int typeId) {&#10;        return idToDescriptorMap.get(typeId);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/SharedComponentStore.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/components/SharedComponentStore.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Objects;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;&#10;/**&#10; * Thread-safe store for de-duplicating managed shared component values.&#10; * It maps a value to a stable index with reference counting.&#10; */&#10;public final class SharedComponentStore {&#10;    private final ConcurrentHashMap&lt;Object, Integer&gt; valueToIndex = new ConcurrentHashMap&lt;&gt;();&#10;    private final ArrayList&lt;Object&gt; indexToValue = new ArrayList&lt;&gt;();&#10;    private volatile int[] refCounts = new int[16];&#10;    private final ConcurrentLinkedQueue&lt;Integer&gt; freeIndices = new ConcurrentLinkedQueue&lt;&gt;();&#10;&#10;    private final Object resizeLock = new Object();&#10;&#10;    /**&#10;     * Get or add an index for the provided value. If value already exists, its refCount is incremented atomically.&#10;     * If it's a new value, a new or recycled index is created, stored, and refCount set to 1.&#10;     */&#10;    public int getOrAddSharedIndex(Object value) {&#10;        Objects.requireNonNull(value, &quot;value&quot;);&#10;        return valueToIndex.compute(value, (k, existingIdx) -&gt; {&#10;            synchronized (resizeLock) {&#10;                if (existingIdx == null) {&#10;                    Integer reuse = freeIndices.poll();&#10;                    int index;&#10;                    if (reuse != null) {&#10;                        index = reuse;&#10;                        ensureRefCapacity(index + 1);&#10;                        if (index &lt; indexToValue.size()) {&#10;                            indexToValue.set(index, k);&#10;                        } else {&#10;                            while (indexToValue.size() &lt; index) indexToValue.add(null);&#10;                            indexToValue.add(k);&#10;                        }&#10;                    } else {&#10;                        index = indexToValue.size();&#10;                        indexToValue.add(k);&#10;                        ensureRefCapacity(index + 1);&#10;                    }&#10;                    refCounts[index] = 1;&#10;                    return index;&#10;                } else {&#10;                    int idx = existingIdx;&#10;                    ensureRefCapacity(idx + 1);&#10;                    refCounts[idx]++;&#10;                    return idx;&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Release a previously acquired shared index. When refCount reaches zero, the value is removed and index recycled.&#10;     */&#10;    public void releaseSharedIndex(int index) {&#10;        synchronized (resizeLock) {&#10;            if (index &lt; 0 || index &gt;= indexToValue.size()) return;&#10;            Object value = indexToValue.get(index);&#10;            if (value == null) return; // already removed&#10;            int rc = --refCounts[index];&#10;            if (rc &gt; 0) return;&#10;            // remove entry and mapping&#10;            indexToValue.set(index, null);&#10;            valueToIndex.remove(value, index);&#10;            // advertise recycled index&#10;            freeIndices.offer(index);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find existing index for a value without creating a new entry or changing ref counts. Returns -1 if absent.&#10;     */&#10;    public int findIndex(Object value) {&#10;        Integer idx = valueToIndex.get(value);&#10;        return idx != null ? idx : -1;&#10;    }&#10;&#10;    private void ensureRefCapacity(int min) {&#10;        int[] cur = refCounts;&#10;        if (min &lt;= cur.length) return;&#10;        int newLen = Math.max(min, Math.max(16, cur.length &lt;&lt; 1));&#10;        int[] next = new int[newLen];&#10;        System.arraycopy(cur, 0, next, 0, cur.length);&#10;        refCounts = next;&#10;    }&#10;&#10;    // Testing/helpers&#10;    public Object getValue(int index) {&#10;        synchronized (resizeLock) {&#10;            return (index &gt;= 0 &amp;&amp; index &lt; indexToValue.size()) ? indexToValue.get(index) : null;&#10;        }&#10;    }&#10;&#10;    public int getRefCount(int index) {&#10;        synchronized (resizeLock) {&#10;            return (index &gt;= 0 &amp;&amp; index &lt; indexToValue.size()) ? refCounts[index] : 0;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.components;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Objects;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;&#10;/**&#10; * Thread-safe store for de-duplicating managed shared component values.&#10; * It maps a value to a stable index with reference counting.&#10; */&#10;public final class SharedComponentStore {&#10;    private final ConcurrentHashMap&lt;Object, Integer&gt; valueToIndex = new ConcurrentHashMap&lt;&gt;();&#10;    private final ArrayList&lt;Object&gt; indexToValue = new ArrayList&lt;&gt;();&#10;    private volatile int[] refCounts = new int[16];&#10;    private final ConcurrentLinkedQueue&lt;Integer&gt; freeIndices = new ConcurrentLinkedQueue&lt;&gt;();&#10;&#10;    private final Object resizeLock = new Object();&#10;&#10;    /**&#10;     * Get or add an index for the provided value. If value already exists, its refCount is incremented atomically.&#10;     * If it's a new value, a new or recycled index is created, stored, and refCount set to 1.&#10;     */&#10;    public int getOrAddSharedIndex(Object value) {&#10;        Objects.requireNonNull(value, &quot;value&quot;);&#10;        return valueToIndex.compute(value, (k, existingIdx) -&gt; {&#10;            synchronized (resizeLock) {&#10;                if (existingIdx == null) {&#10;                    Integer reuse = freeIndices.poll();&#10;                    int index;&#10;                    if (reuse != null) {&#10;                        index = reuse;&#10;                        ensureRefCapacity(index + 1);&#10;                        if (index &lt; indexToValue.size()) {&#10;                            indexToValue.set(index, k);&#10;                        } else {&#10;                            while (indexToValue.size() &lt; index) indexToValue.add(null);&#10;                            indexToValue.add(k);&#10;                        }&#10;                    } else {&#10;                        index = indexToValue.size();&#10;                        indexToValue.add(k);&#10;                        ensureRefCapacity(index + 1);&#10;                    }&#10;                    refCounts[index] = 1;&#10;                    return index;&#10;                } else {&#10;                    int idx = existingIdx;&#10;                    ensureRefCapacity(idx + 1);&#10;                    refCounts[idx]++;&#10;                    return idx;&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Release a previously acquired shared index. When refCount reaches zero, the value is removed and index recycled.&#10;     */&#10;    public void releaseSharedIndex(int index) {&#10;        synchronized (resizeLock) {&#10;            if (index &lt; 0 || index &gt;= indexToValue.size()) return;&#10;            Object value = indexToValue.get(index);&#10;            if (value == null) return; // already removed&#10;            int rc = --refCounts[index];&#10;            if (rc &gt; 0) return;&#10;            // remove entry and mapping&#10;            indexToValue.set(index, null);&#10;            valueToIndex.remove(value, index);&#10;            // advertise recycled index&#10;            freeIndices.offer(index);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find existing index for a value without creating a new entry or changing ref counts. Returns -1 if absent.&#10;     */&#10;    public int findIndex(Object value) {&#10;        Integer idx = valueToIndex.get(value);&#10;        return idx != null ? idx : -1;&#10;    }&#10;&#10;    private void ensureRefCapacity(int min) {&#10;        int[] cur = refCounts;&#10;        if (min &lt;= cur.length) return;&#10;        int newLen = Math.max(min, Math.max(16, cur.length &lt;&lt; 1));&#10;        int[] next = new int[newLen];&#10;        System.arraycopy(cur, 0, next, 0, cur.length);&#10;        refCounts = next;&#10;    }&#10;&#10;    // Testing/helpers&#10;    public Object getValue(int index) {&#10;        synchronized (resizeLock) {&#10;            return (index &gt;= 0 &amp;&amp; index &lt; indexToValue.size()) ? indexToValue.get(index) : null;&#10;        }&#10;    }&#10;&#10;    public int getRefCount(int index) {&#10;        synchronized (resizeLock) {&#10;            return (index &gt;= 0 &amp;&amp; index &lt; indexToValue.size()) ? refCounts[index] : 0;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/GameLoop.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/GameLoop.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.system;&#10;&#10;/**&#10; * GameLoop - fixed-timestep loop coordinator built on top of {@link SystemManager}.&#10; *&#10; * Implements the &quot;Fix Your Timestep&quot; pattern:&#10; * - Variable update for all VARIABLE-mode groups every frame.&#10; * - Fixed-step update for all FIXED-mode groups at a configurable tick rate.&#10; */&#10;public final class GameLoop {&#10;&#10;    private final SystemManager systems;&#10;    private final float fixedDeltaTime; // seconds per physics/simulation tick&#10;    private volatile boolean running = false;&#10;&#10;    /**&#10;     * @param systems        the SystemManager controlling execution groups&#10;     * @param targetTickRate desired fixed update rate in Hz (e.g. 60 =&gt; 1/60s)&#10;     */&#10;    public GameLoop(SystemManager systems, float targetTickRate) {&#10;        if (systems == null) throw new IllegalArgumentException(&quot;systems must not be null&quot;);&#10;        if (targetTickRate &lt;= 0f) throw new IllegalArgumentException(&quot;targetTickRate must be &gt; 0&quot;);&#10;        this.systems = systems;&#10;        this.fixedDeltaTime = 1.0f / targetTickRate;&#10;    }&#10;&#10;    /**&#10;     * Convenience constructor with default 60 Hz fixed tick rate.&#10;     */&#10;    public GameLoop(SystemManager systems) {&#10;        this(systems, 60.0f);&#10;    }&#10;&#10;    /**&#10;     * Start the main loop and block until {@link #stop()} is called from another thread&#10;     * or the current thread is interrupted.&#10;     */&#10;    public void run() {&#10;        running = true;&#10;&#10;        double accumulator = 0.0;&#10;        long previousTime = System.nanoTime();&#10;&#10;        while (running &amp;&amp; !Thread.currentThread().isInterrupted()) {&#10;            long now = System.nanoTime();&#10;            double frameTime = (now - previousTime) / 1_000_000_000.0; // seconds&#10;            previousTime = now;&#10;&#10;            // Clamp to avoid spiral-of-death if the app hitches&#10;            if (frameTime &gt; 0.25) frameTime = 0.25;&#10;&#10;            accumulator += frameTime;&#10;            float deltaTime = (float) frameTime;&#10;&#10;            // Fixed-step update: all FIXED groups first&#10;            while (accumulator &gt;= fixedDeltaTime) {&#10;                for (SystemGroup group : systems.getFixedGroups()) {&#10;                    systems.updateGroup(group, fixedDeltaTime);&#10;                }&#10;                accumulator -= fixedDeltaTime;&#10;            }&#10;&#10;            // Then variable update: all VARIABLE groups&#10;            for (SystemGroup group : systems.getVariableGroups()) {&#10;                systems.updateGroup(group, deltaTime);&#10;            }&#10;&#10;            // Optional: yield to avoid 100% CPU spin if nothing else throttles&#10;            Thread.onSpinWait();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Request the loop to stop gracefully. The current iteration will finish and then exit.&#10;     */&#10;    public void stop() {&#10;        running = false;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.system;&#10;&#10;/**&#10; * GameLoop - fixed-timestep loop coordinator built on top of {@link SystemManager}.&#10; *&#10; * Implements the &quot;Fix Your Timestep&quot; pattern:&#10; * - Variable update for all VARIABLE-mode groups every frame.&#10; * - Fixed-step update for all FIXED-mode groups at a configurable tick rate.&#10; */&#10;public final class GameLoop {&#10;&#10;    private final SystemManager systems;&#10;    private final float fixedDeltaTime; // seconds per physics/simulation tick&#10;    private volatile boolean running = false;&#10;&#10;    /**&#10;     * @param systems        the SystemManager controlling execution groups&#10;     * @param targetTickRate desired fixed update rate in Hz (e.g. 60 =&gt; 1/60s)&#10;     */&#10;    public GameLoop(SystemManager systems, float targetTickRate) {&#10;        if (systems == null) throw new IllegalArgumentException(&quot;systems must not be null&quot;);&#10;        if (targetTickRate &lt;= 0f) throw new IllegalArgumentException(&quot;targetTickRate must be &gt; 0&quot;);&#10;        this.systems = systems;&#10;        this.fixedDeltaTime = 1.0f / targetTickRate;&#10;    }&#10;&#10;    /**&#10;     * Convenience constructor with default 60 Hz fixed tick rate.&#10;     */&#10;    public GameLoop(SystemManager systems) {&#10;        this(systems, 60.0f);&#10;    }&#10;&#10;    /**&#10;     * Start the main loop and block until {@link #stop()} is called from another thread&#10;     * or the current thread is interrupted.&#10;     */&#10;    public void run() {&#10;        running = true;&#10;&#10;        double accumulator = 0.0;&#10;        long previousTime = System.nanoTime();&#10;&#10;        while (running &amp;&amp; !Thread.currentThread().isInterrupted()) {&#10;            long now = System.nanoTime();&#10;            double frameTime = (now - previousTime) / 1_000_000_000.0; // seconds&#10;            previousTime = now;&#10;&#10;            // Clamp to avoid spiral-of-death if the app hitches&#10;            if (frameTime &gt; 0.25) frameTime = 0.25;&#10;&#10;            accumulator += frameTime;&#10;            float deltaTime = (float) frameTime;&#10;&#10;            // Fixed-step update: all FIXED groups first&#10;            while (accumulator &gt;= fixedDeltaTime) {&#10;                for (SystemGroup group : systems.getFixedGroups()) {&#10;                    systems.updateGroup(group, fixedDeltaTime);&#10;                }&#10;                accumulator -= fixedDeltaTime;&#10;            }&#10;&#10;            // Then variable update: all VARIABLE groups&#10;            for (SystemGroup group : systems.getVariableGroups()) {&#10;                systems.updateGroup(group, deltaTime);&#10;            }&#10;&#10;            // Optional: yield to avoid 100% CPU spin if nothing else throttles&#10;            Thread.onSpinWait();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Request the loop to stop gracefully. The current iteration will finish and then exit.&#10;     */&#10;    public void stop() {&#10;        running = false;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/SystemGroup.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/SystemGroup.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.system;&#10;&#10;import java.util.Objects;&#10;&#10;/**&#10; * Represents a phase in the game loop execution pipeline.&#10; * &lt;p&gt;&#10; * Users can define their own groups by instantiating this class.&#10; * Groups are sorted by priority (lower runs first).&#10; */&#10;public record SystemGroup(String name, int priority, UpdateMode mode) implements Comparable&lt;SystemGroup&gt; {&#10;&#10;    public SystemGroup {&#10;        Objects.requireNonNull(name, &quot;name&quot;);&#10;        Objects.requireNonNull(mode, &quot;mode&quot;);&#10;    }&#10;&#10;    @Override&#10;    public int compareTo(SystemGroup other) {&#10;        // Sort by priority first&#10;        int cmp = Integer.compare(this.priority, other.priority);&#10;        if (cmp != 0) return cmp;&#10;        // Tie-breaker by name to maintain stable sort&#10;        return this.name.compareTo(other.name);&#10;    }&#10;&#10;    // === Define Standard Groups for Convenience ===&#10;    public static final SystemGroup INPUT = new SystemGroup(&quot;Input&quot;, 0, UpdateMode.VARIABLE);&#10;    public static final SystemGroup SIMULATION = new SystemGroup(&quot;Simulation&quot;, 1000, UpdateMode.FIXED);&#10;    public static final SystemGroup PHYSICS = new SystemGroup(&quot;Physics&quot;, 2000, UpdateMode.FIXED);&#10;    public static final SystemGroup RENDER = new SystemGroup(&quot;Render&quot;, 3000, UpdateMode.VARIABLE);&#10;    public static final SystemGroup CLEANUP = new SystemGroup(&quot;Cleanup&quot;, 4000, UpdateMode.VARIABLE);&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.system;&#10;&#10;import java.util.Objects;&#10;&#10;/**&#10; * Represents a phase in the game loop execution pipeline.&#10; * &lt;p&gt;&#10; * Users can define their own groups by instantiating this class.&#10; * Groups are sorted by priority (lower runs first).&#10; */&#10;public record SystemGroup(String name, int priority, UpdateMode mode) implements Comparable&lt;SystemGroup&gt; {&#10;&#10;    public SystemGroup {&#10;        Objects.requireNonNull(name, &quot;name&quot;);&#10;        Objects.requireNonNull(mode, &quot;mode&quot;);&#10;    }&#10;&#10;    @Override&#10;    public int compareTo(SystemGroup other) {&#10;        // Sort by priority first&#10;        int cmp = Integer.compare(this.priority, other.priority);&#10;        if (cmp != 0) return cmp;&#10;        // Tie-breaker by name to maintain stable sort&#10;        return this.name.compareTo(other.name);&#10;    }&#10;&#10;    // === Define Standard Groups for Convenience ===&#10;    public static final SystemGroup INPUT = new SystemGroup(&quot;Input&quot;, 0, UpdateMode.VARIABLE);&#10;    public static final SystemGroup SIMULATION = new SystemGroup(&quot;Simulation&quot;, 1000, UpdateMode.FIXED);&#10;    public static final SystemGroup PHYSICS = new SystemGroup(&quot;Physics&quot;, 2000, UpdateMode.FIXED);&#10;    public static final SystemGroup RENDER = new SystemGroup(&quot;Render&quot;, 3000, UpdateMode.VARIABLE);&#10;    public static final SystemGroup CLEANUP = new SystemGroup(&quot;Cleanup&quot;, 4000, UpdateMode.VARIABLE);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/SystemManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/SystemManager.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.system;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;&#10;import java.util.*;&#10;&#10;/**&#10; * Manages ECS Systems and delegates dependency injection to generated code.&#10; * &lt;p&gt;&#10; * The SystemManager is responsible for:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Registering systems into execution groups&lt;/li&gt;&#10; *   &lt;li&gt;Invoking the annotation-processor generated injector for each system&lt;/li&gt;&#10; *   &lt;li&gt;Running systems in a deterministic pipeline via {@link #update(float)}&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; * &lt;p&gt;&#10; * All legacy reflection/Proxy-based query injection has been removed in favor of&#10; * the AP-generated injectors (see {@code QueryProcessor}).&#10; */&#10;public class SystemManager {&#10;    private final ArchetypeWorld world;&#10;    // Systems organized by group instance for the new pipeline API&#10;    private final Map&lt;SystemGroup, List&lt;ISystem&gt;&gt; systemsByGroup = new HashMap&lt;&gt;();&#10;    // Sorted views of groups by update mode&#10;    private final List&lt;SystemGroup&gt; fixedGroups = new ArrayList&lt;&gt;();&#10;    private final List&lt;SystemGroup&gt; variableGroups = new ArrayList&lt;&gt;();&#10;&#10;    public SystemManager(ArchetypeWorld world) {&#10;        this.world = world;&#10;        // Pre-register standard groups so they maintain stable ordering&#10;        registerGroupIfAbsent(SystemGroup.INPUT);&#10;        registerGroupIfAbsent(SystemGroup.SIMULATION);&#10;        registerGroupIfAbsent(SystemGroup.PHYSICS);&#10;        registerGroupIfAbsent(SystemGroup.RENDER);&#10;        registerGroupIfAbsent(SystemGroup.CLEANUP);&#10;        rebuildGroupOrdering();&#10;    }&#10;&#10;    private void registerGroupIfAbsent(SystemGroup group) {&#10;        systemsByGroup.computeIfAbsent(group, g -&gt; new ArrayList&lt;&gt;());&#10;    }&#10;&#10;    private void rebuildGroupOrdering() {&#10;        fixedGroups.clear();&#10;        variableGroups.clear();&#10;        for (SystemGroup group : systemsByGroup.keySet()) {&#10;            if (group.mode() == UpdateMode.FIXED) {&#10;                fixedGroups.add(group);&#10;            } else {&#10;                variableGroups.add(group);&#10;            }&#10;        }&#10;        Collections.sort(fixedGroups);&#10;        Collections.sort(variableGroups);&#10;    }&#10;&#10;    private void tryInvokeGeneratedInjector(Object system) {&#10;        Class&lt;?&gt; cls = system.getClass();&#10;        String injectorName1 = cls.getName() + &quot;__QueryInjector&quot;;&#10;        String injectorName2 = cls.getPackageName() + &quot;.&quot; + cls.getSimpleName() + &quot;__QueryInjector&quot;;&#10;        ReflectiveOperationException last = null;&#10;        for (String injectorName : new String[]{ injectorName1, injectorName2 }) {&#10;            try {&#10;                Class&lt;?&gt; inj = Class.forName(injectorName, false, cls.getClassLoader());&#10;                java.lang.reflect.Method m = inj.getMethod(&quot;inject&quot;, Object.class, com.ethnicthv.ecs.core.archetype.ArchetypeWorld.class);&#10;                m.invoke(null, system, world);&#10;                return; // success&#10;            } catch (ClassNotFoundException e) {&#10;                last = e; // try next variant&#10;            } catch (ReflectiveOperationException e) {&#10;                last = e;&#10;                break; // found class but failed to invoke&#10;            }&#10;        }&#10;        if (!(last instanceof ClassNotFoundException)) {&#10;            throw new IllegalStateException(&quot;Failed to invoke generated injector for &quot; + cls.getName(), last);&#10;        }&#10;        // If no injector class is found, we silently skip injection to keep&#10;        // non-annotated systems working.&#10;    }&#10;&#10;    /**&#10;     * Register a system into the default {@link SystemGroup#SIMULATION} group.&#10;     */&#10;    public &lt;T extends ISystem&gt; T registerSystem(T system) {&#10;        return registerPipelineSystem(system, SystemGroup.SIMULATION);&#10;    }&#10;&#10;    /**&#10;     * Register a system into an explicit execution group for the pipeline API.&#10;     */&#10;    public &lt;T extends ISystem&gt; T registerPipelineSystem(T system, SystemGroup group) {&#10;        if (system == null) {&#10;            throw new IllegalArgumentException(&quot;System cannot be null&quot;);&#10;        }&#10;        if (group == null) {&#10;            throw new IllegalArgumentException(&quot;SystemGroup cannot be null&quot;);&#10;        }&#10;&#10;        tryInvokeGeneratedInjector(system);&#10;        system.onAwake(world);&#10;&#10;        systemsByGroup.computeIfAbsent(group, g -&gt; new ArrayList&lt;&gt;()).add(system);&#10;        rebuildGroupOrdering();&#10;        return system;&#10;    }&#10;&#10;    /**&#10;     * Returns a snapshot of all registered systems across all groups (pipeline systems only).&#10;     */&#10;    public List&lt;ISystem&gt; getRegisteredSystems() {&#10;        List&lt;ISystem&gt; all = new ArrayList&lt;&gt;();&#10;        for (List&lt;ISystem&gt; list : systemsByGroup.values()) {&#10;            all.addAll(list);&#10;        }&#10;        return all;&#10;    }&#10;&#10;    /**&#10;     * Returns the systems registered under a specific group.&#10;     */&#10;    public List&lt;ISystem&gt; getSystems(SystemGroup group) {&#10;        List&lt;ISystem&gt; list = systemsByGroup.get(group);&#10;        return list == null ? List.of() : new ArrayList&lt;&gt;(list);&#10;    }&#10;&#10;    /**&#10;     * Execute all enabled systems in a single group.&#10;     * This is useful for game loops that want fine-grained control, e.g. fixed-step PHYSICS.&#10;     */&#10;    public void updateGroup(SystemGroup group, float deltaTime) {&#10;        List&lt;ISystem&gt; list = systemsByGroup.get(group);&#10;        if (list == null) return;&#10;        for (ISystem sys : list) {&#10;            if (sys.isEnabled()) {&#10;                sys.onUpdate(deltaTime);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute all enabled systems in group-priority order (fixed + variable),&#10;     * primarily useful for simple demos.&#10;     */&#10;    public void update(float deltaTime) {&#10;        // First fixed groups in priority order&#10;        for (SystemGroup group : fixedGroups) {&#10;            updateGroup(group, deltaTime);&#10;        }&#10;        // Then variable groups in priority order&#10;        for (SystemGroup group : variableGroups) {&#10;            updateGroup(group, deltaTime);&#10;        }&#10;    }&#10;&#10;    /** Package-private accessors used by GameLoop for orchestration. */&#10;    List&lt;SystemGroup&gt; getFixedGroups() {&#10;        return new ArrayList&lt;&gt;(fixedGroups);&#10;    }&#10;&#10;    List&lt;SystemGroup&gt; getVariableGroups() {&#10;        return new ArrayList&lt;&gt;(variableGroups);&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.system;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;&#10;import java.util.*;&#10;&#10;/**&#10; * Manages ECS Systems and delegates dependency injection to generated code.&#10; * &lt;p&gt;&#10; * The SystemManager is responsible for:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Registering systems into execution groups&lt;/li&gt;&#10; *   &lt;li&gt;Invoking the annotation-processor generated injector for each system&lt;/li&gt;&#10; *   &lt;li&gt;Running systems in a deterministic pipeline via {@link #update(float)}&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; * &lt;p&gt;&#10; * All legacy reflection/Proxy-based query injection has been removed in favor of&#10; * the AP-generated injectors (see {@code QueryProcessor}).&#10; */&#10;public class SystemManager {&#10;    private final ArchetypeWorld world;&#10;    // Systems organized by group instance for the new pipeline API&#10;    private final Map&lt;SystemGroup, List&lt;ISystem&gt;&gt; systemsByGroup = new HashMap&lt;&gt;();&#10;    // Sorted views of groups by update mode&#10;    private final List&lt;SystemGroup&gt; fixedGroups = new ArrayList&lt;&gt;();&#10;    private final List&lt;SystemGroup&gt; variableGroups = new ArrayList&lt;&gt;();&#10;&#10;    public SystemManager(ArchetypeWorld world) {&#10;        this.world = world;&#10;        // Pre-register standard groups so they maintain stable ordering&#10;        registerGroupIfAbsent(SystemGroup.INPUT);&#10;        registerGroupIfAbsent(SystemGroup.SIMULATION);&#10;        registerGroupIfAbsent(SystemGroup.PHYSICS);&#10;        registerGroupIfAbsent(SystemGroup.RENDER);&#10;        registerGroupIfAbsent(SystemGroup.CLEANUP);&#10;        rebuildGroupOrdering();&#10;    }&#10;&#10;    private void registerGroupIfAbsent(SystemGroup group) {&#10;        systemsByGroup.computeIfAbsent(group, g -&gt; new ArrayList&lt;&gt;());&#10;    }&#10;&#10;    private void rebuildGroupOrdering() {&#10;        fixedGroups.clear();&#10;        variableGroups.clear();&#10;        for (SystemGroup group : systemsByGroup.keySet()) {&#10;            if (group.mode() == UpdateMode.FIXED) {&#10;                fixedGroups.add(group);&#10;            } else {&#10;                variableGroups.add(group);&#10;            }&#10;        }&#10;        Collections.sort(fixedGroups);&#10;        Collections.sort(variableGroups);&#10;    }&#10;&#10;    private void tryInvokeGeneratedInjector(Object system) {&#10;        Class&lt;?&gt; cls = system.getClass();&#10;        String injectorName1 = cls.getName() + &quot;__QueryInjector&quot;;&#10;        String injectorName2 = cls.getPackageName() + &quot;.&quot; + cls.getSimpleName() + &quot;__QueryInjector&quot;;&#10;        ReflectiveOperationException last = null;&#10;        for (String injectorName : new String[]{ injectorName1, injectorName2 }) {&#10;            try {&#10;                Class&lt;?&gt; inj = Class.forName(injectorName, false, cls.getClassLoader());&#10;                java.lang.reflect.Method m = inj.getMethod(&quot;inject&quot;, Object.class, com.ethnicthv.ecs.core.archetype.ArchetypeWorld.class);&#10;                m.invoke(null, system, world);&#10;                return; // success&#10;            } catch (ClassNotFoundException e) {&#10;                last = e; // try next variant&#10;            } catch (ReflectiveOperationException e) {&#10;                last = e;&#10;                break; // found class but failed to invoke&#10;            }&#10;        }&#10;        if (!(last instanceof ClassNotFoundException)) {&#10;            throw new IllegalStateException(&quot;Failed to invoke generated injector for &quot; + cls.getName(), last);&#10;        }&#10;        // If no injector class is found, we silently skip injection to keep&#10;        // non-annotated systems working.&#10;    }&#10;&#10;    /**&#10;     * Register a system into the default {@link SystemGroup#SIMULATION} group.&#10;     */&#10;    public &lt;T extends ISystem&gt; T registerSystem(T system) {&#10;        return registerPipelineSystem(system, SystemGroup.SIMULATION);&#10;    }&#10;&#10;    /**&#10;     * Register a system into an explicit execution group for the pipeline API.&#10;     */&#10;    public &lt;T extends ISystem&gt; T registerPipelineSystem(T system, SystemGroup group) {&#10;        if (system == null) {&#10;            throw new IllegalArgumentException(&quot;System cannot be null&quot;);&#10;        }&#10;        if (group == null) {&#10;            throw new IllegalArgumentException(&quot;SystemGroup cannot be null&quot;);&#10;        }&#10;&#10;        tryInvokeGeneratedInjector(system);&#10;        system.onAwake(world);&#10;&#10;        systemsByGroup.computeIfAbsent(group, g -&gt; new ArrayList&lt;&gt;()).add(system);&#10;        rebuildGroupOrdering();&#10;        return system;&#10;    }&#10;&#10;    /**&#10;     * Returns a snapshot of all registered systems across all groups (pipeline systems only).&#10;     */&#10;    public List&lt;ISystem&gt; getRegisteredSystems() {&#10;        List&lt;ISystem&gt; all = new ArrayList&lt;&gt;();&#10;        for (List&lt;ISystem&gt; list : systemsByGroup.values()) {&#10;            all.addAll(list);&#10;        }&#10;        return all;&#10;    }&#10;&#10;    /**&#10;     * Returns the systems registered under a specific group.&#10;     */&#10;    public List&lt;ISystem&gt; getSystems(SystemGroup group) {&#10;        List&lt;ISystem&gt; list = systemsByGroup.get(group);&#10;        return list == null ? List.of() : new ArrayList&lt;&gt;(list);&#10;    }&#10;&#10;    /**&#10;     * Execute all enabled systems in a single group.&#10;     * This is useful for game loops that want fine-grained control, e.g. fixed-step PHYSICS.&#10;     */&#10;    public void updateGroup(SystemGroup group, float deltaTime) {&#10;        List&lt;ISystem&gt; list = systemsByGroup.get(group);&#10;        if (list == null) return;&#10;        for (ISystem sys : list) {&#10;            if (sys.isEnabled()) {&#10;                sys.onUpdate(deltaTime);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute all enabled systems in group-priority order (fixed + variable),&#10;     * primarily useful for simple demos.&#10;     */&#10;    public void update(float deltaTime) {&#10;        // First fixed groups in priority order&#10;        for (SystemGroup group : fixedGroups) {&#10;            updateGroup(group, deltaTime);&#10;        }&#10;        // Then variable groups in priority order&#10;        for (SystemGroup group : variableGroups) {&#10;            updateGroup(group, deltaTime);&#10;        }&#10;    }&#10;&#10;    /** Package-private accessors used by GameLoop for orchestration. */&#10;    List&lt;SystemGroup&gt; getFixedGroups() {&#10;        return new ArrayList&lt;&gt;(fixedGroups);&#10;    }&#10;&#10;    List&lt;SystemGroup&gt; getVariableGroups() {&#10;        return new ArrayList&lt;&gt;(variableGroups);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/annotation/Id.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ethnicthv/ecs/core/system/annotation/Id.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.core.system.annotation;&#10;&#10;import java.lang.annotation.ElementType;&#10;import java.lang.annotation.Retention;&#10;import java.lang.annotation.RetentionPolicy;&#10;import java.lang.annotation.Target;&#10;&#10;/**&#10; * Marks a system field or parameter to receive the current entity id during a query run.&#10; * Constraints: at most one per @Query method and it must be of type int (or Integer for parameters).&#10; */&#10;@Retention(RetentionPolicy.RUNTIME)&#10;@Target({ElementType.FIELD, ElementType.PARAMETER})&#10;public @interface Id {&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.core.system.annotation;&#10;&#10;import java.lang.annotation.ElementType;&#10;import java.lang.annotation.Retention;&#10;import java.lang.annotation.RetentionPolicy;&#10;import java.lang.annotation.Target;&#10;&#10;/**&#10; * Marks a system field or parameter to receive the current entity id during a query run.&#10; * Constraints: at most one per @Query method and it must be of type int (or Integer for parameters).&#10; */&#10;@Retention(RetentionPolicy.RUNTIME)&#10;@Target({ElementType.FIELD, ElementType.PARAMETER})&#10;public @interface Id {&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeChunkTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeChunkTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.Assumptions;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Comprehensive tests for ArchetypeChunk&#10; */&#10;public class ArchetypeChunkTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private long[] elementSizes;&#10;    private static final int DEFAULT_CAPACITY = 64;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        elementSizes = new long[]{16, 8};&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        // Don't close shared arena - it may be used across tests&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testChunkInitialization() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(DEFAULT_CAPACITY, chunk.capacity());&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertTrue(chunk.hasFree());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateSingleSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertTrue(slot &gt;= 0 &amp;&amp; slot &lt; DEFAULT_CAPACITY);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.isEmpty());&#10;        assertEquals(100, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateMultipleSlots() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int slot = chunk.allocateSlot(1000 + i);&#10;            assertTrue(slot &gt;= 0);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slots should be unique&quot;);&#10;            assertEquals(1000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(10, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateUpToCapacity() {&#10;        int capacity = 16;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            int slot = chunk.allocateSlot(i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot &quot; + i);&#10;        }&#10;&#10;        assertEquals(capacity, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        // Try to allocate one more - should fail&#10;        int extraSlot = chunk.allocateSlot(999);&#10;        assertEquals(-1, extraSlot, &quot;Should not allocate beyond capacity&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testFreeSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertEquals(-1, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateFreeAllocate() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate&#10;        int slot1 = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        // Free&#10;        chunk.freeSlot(slot1);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Allocate again - might reuse same slot&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertTrue(slot2 &gt;= 0);&#10;        assertEquals(1, chunk.size());&#10;        assertEquals(200, chunk.getEntityId(slot2));&#10;    }&#10;&#10;    @Test&#10;    void testDoubleFree() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Double free should be safe&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testGetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Get component data for component 0&#10;        MemorySegment data = chunk.getComponentData(0, slot);&#10;        assertNotNull(data);&#10;        assertEquals(16, data.byteSize());&#10;&#10;        // Get component data for component 1&#10;        MemorySegment data2 = chunk.getComponentData(1, slot);&#10;        assertNotNull(data2);&#10;        assertEquals(8, data2.byteSize());&#10;    }&#10;&#10;    @Test&#10;    void testSetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Create test data&#10;        MemorySegment testData = arena.allocate(16);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 12345L);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 8, 67890L);&#10;&#10;        // Set component data&#10;        chunk.setComponentData(0, slot, testData);&#10;&#10;        // Retrieve and verify&#10;        MemorySegment retrieved = chunk.getComponentData(0, slot);&#10;        assertEquals(12345L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;        assertEquals(67890L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 8));&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate some slots&#10;        chunk.allocateSlot(100);&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;&#10;        // Find first occupied&#10;        int first = chunk.nextOccupiedIndex(0);&#10;        assertTrue(first &gt;= 0);&#10;        assertNotEquals(-1, chunk.getEntityId(first));&#10;&#10;        // Find next after first&#10;        int second = chunk.nextOccupiedIndex(first + 1);&#10;        assertTrue(second &gt; first);&#10;        assertNotEquals(-1, chunk.getEntityId(second));&#10;&#10;        // Count all occupied&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndexWithGaps() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate several slots&#10;        int[] slots = new int[5];&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            slots[i] = chunk.allocateSlot(100 + i);&#10;        }&#10;&#10;        // Free some to create gaps&#10;        chunk.freeSlot(slots[1]);&#10;        chunk.freeSlot(slots[3]);&#10;&#10;        // Count occupied (should be 3)&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            assertNotEquals(-1, chunk.getEntityId(idx), &quot;Occupied slot should have valid entity ID&quot;);&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testQueueingMechanism() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Initially not queued&#10;        assertTrue(chunk.tryMarkQueued());&#10;&#10;        // Should fail second time&#10;        assertFalse(chunk.tryMarkQueued());&#10;&#10;        // Mark dequeued&#10;        chunk.markDequeued();&#10;&#10;        // Should succeed again&#10;        assertTrue(chunk.tryMarkQueued());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations() throws InterruptedException {&#10;        int capacity = 128;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 4;&#10;        int allocationsPerThread = capacity / threads;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * allocationsPerThread;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; allocationsPerThread; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(10, TimeUnit.SECONDS), &quot;Timed out waiting for allocations to complete&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        assertEquals(capacity, successCount.get());&#10;        assertEquals(capacity, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocateAndFree() throws InterruptedException {&#10;        int capacity = 256;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int operations = 1000;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operations;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; operations; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                // Free every other allocation&#10;                                if (i % 2 == 0) {&#10;                                    chunk.freeSlot(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for concurrent operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        // Size should be reasonable (between 0 and capacity)&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity,&#10;                &quot;Final size &quot; + finalSize + &quot; should be in [0, &quot; + capacity + &quot;]&quot;);&#10;&#10;        // All occupied slots should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSlotDataIsZeroedOnAllocation() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate a slot and set some data&#10;        int slot1 = chunk.allocateSlot(100);&#10;        MemorySegment data1 = chunk.getComponentData(0, slot1);&#10;        data1.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 0xDEADBEEFL);&#10;&#10;        // Free the slot&#10;        chunk.freeSlot(slot1);&#10;&#10;        // Allocate again (might get the same slot)&#10;        int slot2 = chunk.allocateSlot(200);&#10;        MemorySegment data2 = chunk.getComponentData(0, slot2);&#10;&#10;        // Data should be zeroed&#10;        assertEquals(0L, data2.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidComponentIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(-1, slot));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(descriptors.length, slot));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidElementIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, -1));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, DEFAULT_CAPACITY));&#10;    }&#10;&#10;    @Test&#10;    void testZeroCapacityChunk() {&#10;        // Zero capacity should throw IllegalArgumentException because bytes = elementSize * 0 = 0&#10;        assertThrows(IllegalArgumentException.class, () -&gt;&#10;                new ArchetypeChunk(descriptors, elementSizes, 0, arena)&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testLargeScaleAllocations_1000Entities() {&#10;        int capacity = 1024;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        // Allocate 1000 entities&#10;        int entityCount = 1000;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            int slot = chunk.allocateSlot(10000 + i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot for entity &quot; + i);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slot should be unique&quot;);&#10;            assertEquals(10000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(entityCount, chunk.size());&#10;        assertEquals(entityCount, allocatedSlots.size());&#10;&#10;        // Verify all allocated entities are accessible&#10;        int verifiedCount = 0;&#10;        for (int slot : allocatedSlots) {&#10;            int entityId = chunk.getEntityId(slot);&#10;            assertTrue(entityId &gt;= 10000 &amp;&amp; entityId &lt; 10000 + entityCount);&#10;            verifiedCount++;&#10;        }&#10;        assertEquals(entityCount, verifiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScaleAllocationsAndFrees_5000Operations() {&#10;        int capacity = 2048;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        // Perform 5000 mixed allocate/free operations&#10;        Set&lt;Integer&gt; activeSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 5000; i++) {&#10;            if (i % 3 == 0 &amp;&amp; !activeSlots.isEmpty()) {&#10;                // Free a random slot&#10;                Integer slotToFree = activeSlots.iterator().next();&#10;                chunk.freeSlot(slotToFree);&#10;                activeSlots.remove(slotToFree);&#10;            } else {&#10;                // Allocate new slot&#10;                int slot = chunk.allocateSlot(20000 + i);&#10;                if (slot &gt;= 0) {&#10;                    activeSlots.add(slot);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Verify chunk consistency&#10;        assertEquals(activeSlots.size(), chunk.size());&#10;&#10;        // Verify all active slots have valid entity IDs&#10;        for (int slot : activeSlots) {&#10;            int entityId = chunk.getEntityId(slot);&#10;            assertNotEquals(-1, entityId, &quot;Active slot should have valid entity ID&quot;);&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations_10000Entities() throws InterruptedException {&#10;        int capacity = 10240;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int entitiesPerThread = 1250; // 8 * 1250 = 10000&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        Set&lt;Integer&gt; allEntityIds = ConcurrentHashMap.newKeySet();&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * entitiesPerThread + 30000;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; entitiesPerThread; i++) {&#10;                            int entityId = baseId + i;&#10;                            int slot = chunk.allocateSlot(entityId);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                                allEntityIds.add(entityId);&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for allocations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;        }&#10;&#10;        assertEquals(10000, successCount.get(), &quot;Should successfully allocate 10000 entities&quot;);&#10;        assertEquals(10000, allEntityIds.size(), &quot;All entity IDs should be unique&quot;);&#10;        assertEquals(10000, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentChurn_20000Operations() throws InterruptedException {&#10;        // This is a heavy stress-style test that can be sensitive to scheduler / timing.&#10;        // Only run it when explicitly enabled, to avoid flakiness in the default suite.&#10;        Assumptions.assumeTrue(&#10;                Boolean.getBoolean(&quot;ecs.enableChunkChurnStress&quot;),&#10;                &quot;Skipping testConcurrentChurn_20000Operations; enable with -Decs.enableChunkChurnStress=true&quot;&#10;        );&#10;&#10;        int capacity = 4096;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 10;&#10;        int operationsPerThread = 2000; // 10 * 2000 = 20000&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operationsPerThread + 40000;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        Set&lt;Integer&gt; mySlots = new HashSet&lt;&gt;();&#10;                        for (int i = 0; i &lt; operationsPerThread; i++) {&#10;                            if (i % 4 == 0 &amp;&amp; !mySlots.isEmpty()) {&#10;                                // Free one of our slots&#10;                                Integer slot = mySlots.iterator().next();&#10;                                chunk.freeSlot(slot);&#10;                                mySlots.remove(slot);&#10;                            } else {&#10;                                // Allocate new&#10;                                int slot = chunk.allocateSlot(baseId + i);&#10;                                if (slot &gt;= 0) {&#10;                                    mySlots.add(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                        // Clean up our remaining slots&#10;                        for (int slot : mySlots) {&#10;                            chunk.freeSlot(slot);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(60, TimeUnit.SECONDS), &quot;Timed out waiting for operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;        }&#10;&#10;        // After all threads clean up, chunk should be empty or have very few entities&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity);&#10;&#10;        // All slots marked as occupied should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSingleSlotCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, 1, arena);&#10;&#10;        assertEquals(1, chunk.capacity());&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(0, slot);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertEquals(-1, slot2);&#10;&#10;        chunk.freeSlot(slot);&#10;        assertTrue(chunk.hasFree());&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testArenaAccess() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertNotNull(chunk.getArena());&#10;        assertEquals(arena, chunk.getArena());&#10;    }&#10;&#10;    @Test&#10;    void testGetEntityCount() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(0, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;        assertEquals(3, chunk.getEntityCount());&#10;    }&#10;&#10;    @Test&#10;    void testGetCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertEquals(DEFAULT_CAPACITY, chunk.getCapacity());&#10;    }&#10;&#10;    // Test component classes&#10;    static final class TestComponent1 {&#10;    }&#10;&#10;    static final class TestComponent2 {&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.Assumptions;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Comprehensive tests for ArchetypeChunk&#10; */&#10;public class ArchetypeChunkTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private long[] elementSizes;&#10;    private static final int DEFAULT_CAPACITY = 64;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        elementSizes = new long[]{16, 8};&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        // Don't close shared arena - it may be used across tests&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testChunkInitialization() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(DEFAULT_CAPACITY, chunk.capacity());&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertTrue(chunk.hasFree());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateSingleSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertTrue(slot &gt;= 0 &amp;&amp; slot &lt; DEFAULT_CAPACITY);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.isEmpty());&#10;        assertEquals(100, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateMultipleSlots() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int slot = chunk.allocateSlot(1000 + i);&#10;            assertTrue(slot &gt;= 0);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slots should be unique&quot;);&#10;            assertEquals(1000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(10, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testAllocateUpToCapacity() {&#10;        int capacity = 16;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            int slot = chunk.allocateSlot(i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot &quot; + i);&#10;        }&#10;&#10;        assertEquals(capacity, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        // Try to allocate one more - should fail&#10;        int extraSlot = chunk.allocateSlot(999);&#10;        assertEquals(-1, extraSlot, &quot;Should not allocate beyond capacity&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testFreeSlot() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;        assertTrue(chunk.isEmpty());&#10;        assertEquals(-1, chunk.getEntityId(slot));&#10;    }&#10;&#10;    @Test&#10;    void testAllocateFreeAllocate() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate&#10;        int slot1 = chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.size());&#10;&#10;        // Free&#10;        chunk.freeSlot(slot1);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Allocate again - might reuse same slot&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertTrue(slot2 &gt;= 0);&#10;        assertEquals(1, chunk.size());&#10;        assertEquals(200, chunk.getEntityId(slot2));&#10;    }&#10;&#10;    @Test&#10;    void testDoubleFree() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;&#10;        // Double free should be safe&#10;        chunk.freeSlot(slot);&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testGetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Get component data for component 0&#10;        MemorySegment data = chunk.getComponentData(0, slot);&#10;        assertNotNull(data);&#10;        assertEquals(16, data.byteSize());&#10;&#10;        // Get component data for component 1&#10;        MemorySegment data2 = chunk.getComponentData(1, slot);&#10;        assertNotNull(data2);&#10;        assertEquals(8, data2.byteSize());&#10;    }&#10;&#10;    @Test&#10;    void testSetComponentData() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        // Create test data&#10;        MemorySegment testData = arena.allocate(16);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 12345L);&#10;        testData.set(java.lang.foreign.ValueLayout.JAVA_LONG, 8, 67890L);&#10;&#10;        // Set component data&#10;        chunk.setComponentData(0, slot, testData);&#10;&#10;        // Retrieve and verify&#10;        MemorySegment retrieved = chunk.getComponentData(0, slot);&#10;        assertEquals(12345L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;        assertEquals(67890L, retrieved.get(java.lang.foreign.ValueLayout.JAVA_LONG, 8));&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate some slots&#10;        chunk.allocateSlot(100);&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;&#10;        // Find first occupied&#10;        int first = chunk.nextOccupiedIndex(0);&#10;        assertTrue(first &gt;= 0);&#10;        assertNotEquals(-1, chunk.getEntityId(first));&#10;&#10;        // Find next after first&#10;        int second = chunk.nextOccupiedIndex(first + 1);&#10;        assertTrue(second &gt; first);&#10;        assertNotEquals(-1, chunk.getEntityId(second));&#10;&#10;        // Count all occupied&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testNextOccupiedIndexWithGaps() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate several slots&#10;        int[] slots = new int[5];&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            slots[i] = chunk.allocateSlot(100 + i);&#10;        }&#10;&#10;        // Free some to create gaps&#10;        chunk.freeSlot(slots[1]);&#10;        chunk.freeSlot(slots[3]);&#10;&#10;        // Count occupied (should be 3)&#10;        int count = 0;&#10;        int idx = chunk.nextOccupiedIndex(0);&#10;        while (idx &gt;= 0) {&#10;            assertNotEquals(-1, chunk.getEntityId(idx), &quot;Occupied slot should have valid entity ID&quot;);&#10;            count++;&#10;            idx = chunk.nextOccupiedIndex(idx + 1);&#10;        }&#10;        assertEquals(3, count);&#10;    }&#10;&#10;    @Test&#10;    void testQueueingMechanism() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Initially not queued&#10;        assertTrue(chunk.tryMarkQueued());&#10;&#10;        // Should fail second time&#10;        assertFalse(chunk.tryMarkQueued());&#10;&#10;        // Mark dequeued&#10;        chunk.markDequeued();&#10;&#10;        // Should succeed again&#10;        assertTrue(chunk.tryMarkQueued());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations() throws InterruptedException {&#10;        int capacity = 128;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 4;&#10;        int allocationsPerThread = capacity / threads;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * allocationsPerThread;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; allocationsPerThread; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(10, TimeUnit.SECONDS), &quot;Timed out waiting for allocations to complete&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        assertEquals(capacity, successCount.get());&#10;        assertEquals(capacity, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocateAndFree() throws InterruptedException {&#10;        int capacity = 256;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int operations = 1000;&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operations;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; operations; i++) {&#10;                            int slot = chunk.allocateSlot(baseId + i);&#10;                            if (slot &gt;= 0) {&#10;                                // Free every other allocation&#10;                                if (i % 2 == 0) {&#10;                                    chunk.freeSlot(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for concurrent operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS), &quot;Executor did not terminate in time&quot;);&#10;        }&#10;&#10;        // Size should be reasonable (between 0 and capacity)&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity,&#10;                &quot;Final size &quot; + finalSize + &quot; should be in [0, &quot; + capacity + &quot;]&quot;);&#10;&#10;        // All occupied slots should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSlotDataIsZeroedOnAllocation() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        // Allocate a slot and set some data&#10;        int slot1 = chunk.allocateSlot(100);&#10;        MemorySegment data1 = chunk.getComponentData(0, slot1);&#10;        data1.set(java.lang.foreign.ValueLayout.JAVA_LONG, 0, 0xDEADBEEFL);&#10;&#10;        // Free the slot&#10;        chunk.freeSlot(slot1);&#10;&#10;        // Allocate again (might get the same slot)&#10;        int slot2 = chunk.allocateSlot(200);&#10;        MemorySegment data2 = chunk.getComponentData(0, slot2);&#10;&#10;        // Data should be zeroed&#10;        assertEquals(0L, data2.get(java.lang.foreign.ValueLayout.JAVA_LONG, 0));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidComponentIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        int slot = chunk.allocateSlot(100);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(-1, slot));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(descriptors.length, slot));&#10;    }&#10;&#10;    @Test&#10;    void testInvalidElementIndex() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, -1));&#10;&#10;        assertThrows(IndexOutOfBoundsException.class, () -&gt; chunk.getComponentData(0, DEFAULT_CAPACITY));&#10;    }&#10;&#10;    @Test&#10;    void testZeroCapacityChunk() {&#10;        // Zero capacity should throw IllegalArgumentException because bytes = elementSize * 0 = 0&#10;        assertThrows(IllegalArgumentException.class, () -&gt;&#10;                new ArchetypeChunk(descriptors, elementSizes, 0, arena)&#10;        );&#10;    }&#10;&#10;    @Test&#10;    void testLargeScaleAllocations_1000Entities() {&#10;        int capacity = 1024;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        // Allocate 1000 entities&#10;        int entityCount = 1000;&#10;        Set&lt;Integer&gt; allocatedSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; entityCount; i++) {&#10;            int slot = chunk.allocateSlot(10000 + i);&#10;            assertTrue(slot &gt;= 0, &quot;Should allocate slot for entity &quot; + i);&#10;            assertTrue(allocatedSlots.add(slot), &quot;Slot should be unique&quot;);&#10;            assertEquals(10000 + i, chunk.getEntityId(slot));&#10;        }&#10;&#10;        assertEquals(entityCount, chunk.size());&#10;        assertEquals(entityCount, allocatedSlots.size());&#10;&#10;        // Verify all allocated entities are accessible&#10;        int verifiedCount = 0;&#10;        for (int slot : allocatedSlots) {&#10;            int entityId = chunk.getEntityId(slot);&#10;            assertTrue(entityId &gt;= 10000 &amp;&amp; entityId &lt; 10000 + entityCount);&#10;            verifiedCount++;&#10;        }&#10;        assertEquals(entityCount, verifiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScaleAllocationsAndFrees_5000Operations() {&#10;        int capacity = 2048;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        // Perform 5000 mixed allocate/free operations&#10;        Set&lt;Integer&gt; activeSlots = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; 5000; i++) {&#10;            if (i % 3 == 0 &amp;&amp; !activeSlots.isEmpty()) {&#10;                // Free a random slot&#10;                Integer slotToFree = activeSlots.iterator().next();&#10;                chunk.freeSlot(slotToFree);&#10;                activeSlots.remove(slotToFree);&#10;            } else {&#10;                // Allocate new slot&#10;                int slot = chunk.allocateSlot(20000 + i);&#10;                if (slot &gt;= 0) {&#10;                    activeSlots.add(slot);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Verify chunk consistency&#10;        assertEquals(activeSlots.size(), chunk.size());&#10;&#10;        // Verify all active slots have valid entity IDs&#10;        for (int slot : activeSlots) {&#10;            int entityId = chunk.getEntityId(slot);&#10;            assertNotEquals(-1, entityId, &quot;Active slot should have valid entity ID&quot;);&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentAllocations_10000Entities() throws InterruptedException {&#10;        int capacity = 10240;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 8;&#10;        int entitiesPerThread = 1250; // 8 * 1250 = 10000&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;        AtomicInteger successCount = new AtomicInteger(0);&#10;        Set&lt;Integer&gt; allEntityIds = ConcurrentHashMap.newKeySet();&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * entitiesPerThread + 30000;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        for (int i = 0; i &lt; entitiesPerThread; i++) {&#10;                            int entityId = baseId + i;&#10;                            int slot = chunk.allocateSlot(entityId);&#10;                            if (slot &gt;= 0) {&#10;                                successCount.incrementAndGet();&#10;                                allEntityIds.add(entityId);&#10;                            }&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(30, TimeUnit.SECONDS), &quot;Timed out waiting for allocations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;        }&#10;&#10;        assertEquals(10000, successCount.get(), &quot;Should successfully allocate 10000 entities&quot;);&#10;        assertEquals(10000, allEntityIds.size(), &quot;All entity IDs should be unique&quot;);&#10;        assertEquals(10000, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testConcurrentChurn_20000Operations() throws InterruptedException {&#10;        // This is a heavy stress-style test that can be sensitive to scheduler / timing.&#10;        // Only run it when explicitly enabled, to avoid flakiness in the default suite.&#10;        Assumptions.assumeTrue(&#10;                Boolean.getBoolean(&quot;ecs.enableChunkChurnStress&quot;),&#10;                &quot;Skipping testConcurrentChurn_20000Operations; enable with -Decs.enableChunkChurnStress=true&quot;&#10;        );&#10;&#10;        int capacity = 4096;&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, capacity, arena);&#10;&#10;        int threads = 10;&#10;        int operationsPerThread = 2000; // 10 * 2000 = 20000&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch doneLatch = new CountDownLatch(threads);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        try {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                final int baseId = t * operationsPerThread + 40000;&#10;                executor.submit(() -&gt; {&#10;                    try {&#10;                        startLatch.await();&#10;                        Set&lt;Integer&gt; mySlots = new HashSet&lt;&gt;();&#10;                        for (int i = 0; i &lt; operationsPerThread; i++) {&#10;                            if (i % 4 == 0 &amp;&amp; !mySlots.isEmpty()) {&#10;                                // Free one of our slots&#10;                                Integer slot = mySlots.iterator().next();&#10;                                chunk.freeSlot(slot);&#10;                                mySlots.remove(slot);&#10;                            } else {&#10;                                // Allocate new&#10;                                int slot = chunk.allocateSlot(baseId + i);&#10;                                if (slot &gt;= 0) {&#10;                                    mySlots.add(slot);&#10;                                }&#10;                            }&#10;                        }&#10;                        // Clean up our remaining slots&#10;                        for (int slot : mySlots) {&#10;                            chunk.freeSlot(slot);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        doneLatch.countDown();&#10;                    }&#10;                });&#10;            }&#10;&#10;            startLatch.countDown();&#10;            assertTrue(doneLatch.await(60, TimeUnit.SECONDS), &quot;Timed out waiting for operations&quot;);&#10;        } finally {&#10;            executor.shutdown();&#10;            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;        }&#10;&#10;        // After all threads clean up, chunk should be empty or have very few entities&#10;        int finalSize = chunk.size();&#10;        assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity);&#10;&#10;        // All slots marked as occupied should have valid entity IDs&#10;        int occupiedCount = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) {&#10;                occupiedCount++;&#10;            }&#10;        }&#10;        assertEquals(finalSize, occupiedCount);&#10;    }&#10;&#10;    @Test&#10;    void testSingleSlotCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, 1, arena);&#10;&#10;        assertEquals(1, chunk.capacity());&#10;&#10;        int slot = chunk.allocateSlot(100);&#10;        assertEquals(0, slot);&#10;        assertEquals(1, chunk.size());&#10;        assertFalse(chunk.hasFree());&#10;&#10;        int slot2 = chunk.allocateSlot(200);&#10;        assertEquals(-1, slot2);&#10;&#10;        chunk.freeSlot(slot);&#10;        assertTrue(chunk.hasFree());&#10;        assertEquals(0, chunk.size());&#10;    }&#10;&#10;    @Test&#10;    void testArenaAccess() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertNotNull(chunk.getArena());&#10;        assertEquals(arena, chunk.getArena());&#10;    }&#10;&#10;    @Test&#10;    void testGetEntityCount() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;&#10;        assertEquals(0, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(100);&#10;        assertEquals(1, chunk.getEntityCount());&#10;&#10;        chunk.allocateSlot(101);&#10;        chunk.allocateSlot(102);&#10;        assertEquals(3, chunk.getEntityCount());&#10;    }&#10;&#10;    @Test&#10;    void testGetCapacity() {&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descriptors, elementSizes, DEFAULT_CAPACITY, arena);&#10;        assertEquals(DEFAULT_CAPACITY, chunk.getCapacity());&#10;    }&#10;&#10;    // Test component classes&#10;    static final class TestComponent1 {&#10;    }&#10;&#10;    static final class TestComponent2 {&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeDataIntegrityTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeDataIntegrityTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * QA/QC Test Suite: Data Integrity và Consistency&#10; * Đảm bảo tính toàn vẹn dữ liệu trong mọi trường hợp&#10; */&#10;@DisplayName(&quot;QA/QC: Data Integrity Tests&quot;)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class ArchetypeDataIntegrityTest {&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;TC-DI-001: Data persistence across operations&quot;)&#10;    void testDataPersistence() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities with specific data&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i * 1000);&#10;            data.set(ValueLayout.JAVA_LONG, 8, (long) i * 2000);&#10;        }&#10;&#10;        // Verify all data persists&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            assertEquals((long) i * 1000, value1,&#10;                    &quot;First value corrupted for entity &quot; + i);&#10;            assertEquals((long) i * 2000, value2,&#10;                    &quot;Second value corrupted for entity &quot; + i);&#10;        }&#10;&#10;        System.out.println(&quot;✓ Data persistence verified for 100 entities&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;TC-DI-002: Data isolation between entities&quot;)&#10;    void testDataIsolationBetweenEntities() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities with unique values&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i);&#10;            data.set(ValueLayout.JAVA_LONG, 8, (long) i * 10);&#10;        }&#10;&#10;        // Modify every other entity&#10;        for (int i = 0; i &lt; 50; i += 2) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, 99999L);&#10;        }&#10;&#10;        // Verify unmodified entities are intact&#10;        for (int i = 1; i &lt; 50; i += 2) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            assertEquals((long) i, value1, &quot;Entity &quot; + i + &quot; was corrupted&quot;);&#10;            assertEquals((long) i * 10, value2, &quot;Entity &quot; + i + &quot; was corrupted&quot;);&#10;        }&#10;&#10;        System.out.println(&quot;✓ Data isolation verified between entities&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;TC-DI-003: Data consistency after removal&quot;)&#10;    void testDataConsistencyAfterRemoval() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i);&#10;        }&#10;&#10;        // Remove middle entities&#10;        for (int i = 25; i &lt; 75; i++) {&#10;            archetype.removeEntity(locations.get(i));&#10;        }&#10;&#10;        // Verify remaining entities' data&#10;        for (int i = 0; i &lt; 25; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value = data.get(ValueLayout.JAVA_LONG, 0);&#10;            assertEquals((long) i, value, &quot;Entity &quot; + i + &quot; corrupted after removal&quot;);&#10;        }&#10;&#10;        for (int i = 75; i &lt; 100; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value = data.get(ValueLayout.JAVA_LONG, 0);&#10;            assertEquals((long) i, value, &quot;Entity &quot; + i + &quot; corrupted after removal&quot;);&#10;        }&#10;&#10;        System.out.println(&quot;✓ Data consistency maintained after entity removal&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;TC-DI-004: Multi-component data consistency&quot;)&#10;    void testMultiComponentDataConsistency() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(Component1.class, 8),&#10;                makeDesc(Component2.class, 16),&#10;                makeDesc(Component3.class, 32)&#10;        };&#10;        int[] componentIds = new int[]{1, 2, 3};&#10;        ComponentMask mask = new ComponentMask();&#10;        for (int id : componentIds) {&#10;            mask = mask.set(id);&#10;        }&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities with data in all components&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data1 = archetype.getComponentData(loc, 0);&#10;            MemorySegment data2 = archetype.getComponentData(loc, 1);&#10;            MemorySegment data3 = archetype.getComponentData(loc, 2);&#10;&#10;            data1.set(ValueLayout.JAVA_LONG, 0, (long) i * 1);&#10;            data2.set(ValueLayout.JAVA_LONG, 0, (long) i * 2);&#10;            data2.set(ValueLayout.JAVA_LONG, 8, (long) i * 3);&#10;            data3.set(ValueLayout.JAVA_LONG, 0, (long) i * 4);&#10;            data3.set(ValueLayout.JAVA_LONG, 8, (long) i * 5);&#10;            data3.set(ValueLayout.JAVA_LONG, 16, (long) i * 6);&#10;            data3.set(ValueLayout.JAVA_LONG, 24, (long) i * 7);&#10;        }&#10;&#10;        // Verify all components maintain data correctly&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            MemorySegment data1 = archetype.getComponentData(locations.get(i), 0);&#10;            MemorySegment data2 = archetype.getComponentData(locations.get(i), 1);&#10;            MemorySegment data3 = archetype.getComponentData(locations.get(i), 2);&#10;&#10;            assertEquals((long) i * 1, data1.get(ValueLayout.JAVA_LONG, 0));&#10;            assertEquals((long) i * 2, data2.get(ValueLayout.JAVA_LONG, 0));&#10;            assertEquals((long) i * 3, data2.get(ValueLayout.JAVA_LONG, 8));&#10;            assertEquals((long) i * 4, data3.get(ValueLayout.JAVA_LONG, 0));&#10;            assertEquals((long) i * 5, data3.get(ValueLayout.JAVA_LONG, 8));&#10;            assertEquals((long) i * 6, data3.get(ValueLayout.JAVA_LONG, 16));&#10;            assertEquals((long) i * 7, data3.get(ValueLayout.JAVA_LONG, 24));&#10;        }&#10;&#10;        System.out.println(&quot;✓ Multi-component data consistency verified&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;TC-DI-005: Cross-chunk data integrity&quot;)&#10;    void testCrossChunkDataIntegrity() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int entitiesPerChunk = archetype.getEntitiesPerChunk();&#10;&#10;        // Add entities across multiple chunks&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        int totalEntities = entitiesPerChunk * 3 + 50; // 3+ chunks&#10;&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i);&#10;            data.set(ValueLayout.JAVA_LONG, 8, (long) i * 100);&#10;        }&#10;&#10;        assertTrue(archetype.getChunkCount() &gt;= 3, &quot;Should span multiple chunks&quot;);&#10;&#10;        // Verify data across all chunks&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            assertEquals((long) i, value1, &quot;Cross-chunk data corrupted at &quot; + i);&#10;            assertEquals((long) i * 100, value2, &quot;Cross-chunk data corrupted at &quot; + i);&#10;        }&#10;&#10;        System.out.printf(&quot;✓ Cross-chunk integrity verified across %d chunks%n&quot;,&#10;                archetype.getChunkCount());&#10;    }&#10;&#10;    @Test&#10;    @Order(6)&#10;    @DisplayName(&quot;TC-DI-006: Archetype mask integrity&quot;)&#10;    void testArchetypeMaskIntegrity() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16),&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{5, 10};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(5);&#10;        mask = mask.set(10);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add many entities&#10;        for (int i = 0; i &lt; 1000; i++) {&#10;            archetype.addEntity(i);&#10;        }&#10;&#10;        // Verify mask remains consistent&#10;        ComponentMask retrievedMask = archetype.getMask();&#10;        assertTrue(retrievedMask.has(5), &quot;Component 5 should be set&quot;);&#10;        assertTrue(retrievedMask.has(10), &quot;Component 10 should be set&quot;);&#10;        assertFalse(retrievedMask.has(1), &quot;Component 1 should not be set&quot;);&#10;&#10;        // Verify component IDs&#10;        assertArrayEquals(componentIds, archetype.getComponentIds());&#10;&#10;        System.out.println(&quot;✓ Archetype mask integrity maintained&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(7)&#10;    @DisplayName(&quot;TC-DI-007: Entity count accuracy&quot;)&#10;    void testEntityCountAccuracy() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        assertEquals(0, archetype.getEntityCount(), &quot;Initial count should be 0&quot;);&#10;&#10;        // Add entities&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            locations.add(archetype.addEntity(i));&#10;            assertEquals(i + 1, archetype.getEntityCount(),&#10;                    &quot;Count should match after adding entity &quot; + i);&#10;        }&#10;&#10;        // Remove entities&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            archetype.removeEntity(locations.get(i));&#10;            assertEquals(100 - i - 1, archetype.getEntityCount(),&#10;                    &quot;Count should match after removing entity &quot; + i);&#10;        }&#10;&#10;        System.out.println(&quot;✓ Entity count accuracy verified through operations&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(8)&#10;    @DisplayName(&quot;TC-DI-008: No data corruption under stress&quot;)&#10;    void testNoDataCorruptionUnderStress() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        int testSize = 1000;&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;&#10;        // Add entities with checksums&#10;        for (int i = 0; i &lt; testSize; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            long checksum = (long) i * 12345 + 67890;&#10;            data.set(ValueLayout.JAVA_LONG, 0, checksum);&#10;            data.set(ValueLayout.JAVA_LONG, 8, ~checksum); // Inverted checksum&#10;        }&#10;&#10;        // Perform random operations&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            int idx = i % testSize;&#10;            MemorySegment data = archetype.getComponentData(locations.get(idx), 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, data.get(ValueLayout.JAVA_LONG, 0) + 1);&#10;        }&#10;&#10;        // Verify checksums&#10;        int corruptedCount = 0;&#10;        for (int i = 0; i &lt; testSize; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            long expectedBase = (long) i * 12345 + 67890;&#10;&#10;            // Account for modifications&#10;            if (i &lt; 100 &amp;&amp; value1 != expectedBase + 1) {&#10;                corruptedCount++;&#10;            } else if (i &gt;= 100 &amp;&amp; value1 != expectedBase) {&#10;                corruptedCount++;&#10;            }&#10;        }&#10;&#10;        assertEquals(0, corruptedCount, &quot;No data should be corrupted&quot;);&#10;        System.out.println(&quot;✓ No corruption detected under stress testing&quot;);&#10;    }&#10;&#10;    // Test component classes&#10;    static class TestComponent {&#10;        long value1;&#10;        long value2;&#10;    }&#10;&#10;    static class Component1 {&#10;        long value;&#10;    }&#10;&#10;    static class Component2 {&#10;        long value1, value2;&#10;    }&#10;&#10;    static class Component3 {&#10;        long value1, value2, value3, value4;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.lang.foreign.MemorySegment;&#10;import java.lang.foreign.ValueLayout;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * QA/QC Test Suite: Data Integrity và Consistency&#10; * Đảm bảo tính toàn vẹn dữ liệu trong mọi trường hợp&#10; */&#10;@DisplayName(&quot;QA/QC: Data Integrity Tests&quot;)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class ArchetypeDataIntegrityTest {&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;TC-DI-001: Data persistence across operations&quot;)&#10;    void testDataPersistence() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities with specific data&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i * 1000);&#10;            data.set(ValueLayout.JAVA_LONG, 8, (long) i * 2000);&#10;        }&#10;&#10;        // Verify all data persists&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            assertEquals((long) i * 1000, value1,&#10;                    &quot;First value corrupted for entity &quot; + i);&#10;            assertEquals((long) i * 2000, value2,&#10;                    &quot;Second value corrupted for entity &quot; + i);&#10;        }&#10;&#10;        System.out.println(&quot;✓ Data persistence verified for 100 entities&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;TC-DI-002: Data isolation between entities&quot;)&#10;    void testDataIsolationBetweenEntities() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities with unique values&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i);&#10;            data.set(ValueLayout.JAVA_LONG, 8, (long) i * 10);&#10;        }&#10;&#10;        // Modify every other entity&#10;        for (int i = 0; i &lt; 50; i += 2) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, 99999L);&#10;        }&#10;&#10;        // Verify unmodified entities are intact&#10;        for (int i = 1; i &lt; 50; i += 2) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            assertEquals((long) i, value1, &quot;Entity &quot; + i + &quot; was corrupted&quot;);&#10;            assertEquals((long) i * 10, value2, &quot;Entity &quot; + i + &quot; was corrupted&quot;);&#10;        }&#10;&#10;        System.out.println(&quot;✓ Data isolation verified between entities&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;TC-DI-003: Data consistency after removal&quot;)&#10;    void testDataConsistencyAfterRemoval() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i);&#10;        }&#10;&#10;        // Remove middle entities&#10;        for (int i = 25; i &lt; 75; i++) {&#10;            archetype.removeEntity(locations.get(i));&#10;        }&#10;&#10;        // Verify remaining entities' data&#10;        for (int i = 0; i &lt; 25; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value = data.get(ValueLayout.JAVA_LONG, 0);&#10;            assertEquals((long) i, value, &quot;Entity &quot; + i + &quot; corrupted after removal&quot;);&#10;        }&#10;&#10;        for (int i = 75; i &lt; 100; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value = data.get(ValueLayout.JAVA_LONG, 0);&#10;            assertEquals((long) i, value, &quot;Entity &quot; + i + &quot; corrupted after removal&quot;);&#10;        }&#10;&#10;        System.out.println(&quot;✓ Data consistency maintained after entity removal&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;TC-DI-004: Multi-component data consistency&quot;)&#10;    void testMultiComponentDataConsistency() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(Component1.class, 8),&#10;                makeDesc(Component2.class, 16),&#10;                makeDesc(Component3.class, 32)&#10;        };&#10;        int[] componentIds = new int[]{1, 2, 3};&#10;        ComponentMask mask = new ComponentMask();&#10;        for (int id : componentIds) {&#10;            mask = mask.set(id);&#10;        }&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add entities with data in all components&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data1 = archetype.getComponentData(loc, 0);&#10;            MemorySegment data2 = archetype.getComponentData(loc, 1);&#10;            MemorySegment data3 = archetype.getComponentData(loc, 2);&#10;&#10;            data1.set(ValueLayout.JAVA_LONG, 0, (long) i * 1);&#10;            data2.set(ValueLayout.JAVA_LONG, 0, (long) i * 2);&#10;            data2.set(ValueLayout.JAVA_LONG, 8, (long) i * 3);&#10;            data3.set(ValueLayout.JAVA_LONG, 0, (long) i * 4);&#10;            data3.set(ValueLayout.JAVA_LONG, 8, (long) i * 5);&#10;            data3.set(ValueLayout.JAVA_LONG, 16, (long) i * 6);&#10;            data3.set(ValueLayout.JAVA_LONG, 24, (long) i * 7);&#10;        }&#10;&#10;        // Verify all components maintain data correctly&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            MemorySegment data1 = archetype.getComponentData(locations.get(i), 0);&#10;            MemorySegment data2 = archetype.getComponentData(locations.get(i), 1);&#10;            MemorySegment data3 = archetype.getComponentData(locations.get(i), 2);&#10;&#10;            assertEquals((long) i * 1, data1.get(ValueLayout.JAVA_LONG, 0));&#10;            assertEquals((long) i * 2, data2.get(ValueLayout.JAVA_LONG, 0));&#10;            assertEquals((long) i * 3, data2.get(ValueLayout.JAVA_LONG, 8));&#10;            assertEquals((long) i * 4, data3.get(ValueLayout.JAVA_LONG, 0));&#10;            assertEquals((long) i * 5, data3.get(ValueLayout.JAVA_LONG, 8));&#10;            assertEquals((long) i * 6, data3.get(ValueLayout.JAVA_LONG, 16));&#10;            assertEquals((long) i * 7, data3.get(ValueLayout.JAVA_LONG, 24));&#10;        }&#10;&#10;        System.out.println(&quot;✓ Multi-component data consistency verified&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;TC-DI-005: Cross-chunk data integrity&quot;)&#10;    void testCrossChunkDataIntegrity() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int entitiesPerChunk = archetype.getEntitiesPerChunk();&#10;&#10;        // Add entities across multiple chunks&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        int totalEntities = entitiesPerChunk * 3 + 50; // 3+ chunks&#10;&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, (long) i);&#10;            data.set(ValueLayout.JAVA_LONG, 8, (long) i * 100);&#10;        }&#10;&#10;        assertTrue(archetype.getChunkCount() &gt;= 3, &quot;Should span multiple chunks&quot;);&#10;&#10;        // Verify data across all chunks&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            assertEquals((long) i, value1, &quot;Cross-chunk data corrupted at &quot; + i);&#10;            assertEquals((long) i * 100, value2, &quot;Cross-chunk data corrupted at &quot; + i);&#10;        }&#10;&#10;        System.out.printf(&quot;✓ Cross-chunk integrity verified across %d chunks%n&quot;,&#10;                archetype.getChunkCount());&#10;    }&#10;&#10;    @Test&#10;    @Order(6)&#10;    @DisplayName(&quot;TC-DI-006: Archetype mask integrity&quot;)&#10;    void testArchetypeMaskIntegrity() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16),&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{5, 10};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(5);&#10;        mask = mask.set(10);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add many entities&#10;        for (int i = 0; i &lt; 1000; i++) {&#10;            archetype.addEntity(i);&#10;        }&#10;&#10;        // Verify mask remains consistent&#10;        ComponentMask retrievedMask = archetype.getMask();&#10;        assertTrue(retrievedMask.has(5), &quot;Component 5 should be set&quot;);&#10;        assertTrue(retrievedMask.has(10), &quot;Component 10 should be set&quot;);&#10;        assertFalse(retrievedMask.has(1), &quot;Component 1 should not be set&quot;);&#10;&#10;        // Verify component IDs&#10;        assertArrayEquals(componentIds, archetype.getComponentIds());&#10;&#10;        System.out.println(&quot;✓ Archetype mask integrity maintained&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(7)&#10;    @DisplayName(&quot;TC-DI-007: Entity count accuracy&quot;)&#10;    void testEntityCountAccuracy() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        assertEquals(0, archetype.getEntityCount(), &quot;Initial count should be 0&quot;);&#10;&#10;        // Add entities&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            locations.add(archetype.addEntity(i));&#10;            assertEquals(i + 1, archetype.getEntityCount(),&#10;                    &quot;Count should match after adding entity &quot; + i);&#10;        }&#10;&#10;        // Remove entities&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            archetype.removeEntity(locations.get(i));&#10;            assertEquals(100 - i - 1, archetype.getEntityCount(),&#10;                    &quot;Count should match after removing entity &quot; + i);&#10;        }&#10;&#10;        System.out.println(&quot;✓ Entity count accuracy verified through operations&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(8)&#10;    @DisplayName(&quot;TC-DI-008: No data corruption under stress&quot;)&#10;    void testNoDataCorruptionUnderStress() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        int testSize = 1000;&#10;        List&lt;ArchetypeChunk.ChunkLocation&gt; locations = new ArrayList&lt;&gt;();&#10;&#10;        // Add entities with checksums&#10;        for (int i = 0; i &lt; testSize; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            locations.add(loc);&#10;&#10;            MemorySegment data = archetype.getComponentData(loc, 0);&#10;            long checksum = (long) i * 12345 + 67890;&#10;            data.set(ValueLayout.JAVA_LONG, 0, checksum);&#10;            data.set(ValueLayout.JAVA_LONG, 8, ~checksum); // Inverted checksum&#10;        }&#10;&#10;        // Perform random operations&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            int idx = i % testSize;&#10;            MemorySegment data = archetype.getComponentData(locations.get(idx), 0);&#10;            data.set(ValueLayout.JAVA_LONG, 0, data.get(ValueLayout.JAVA_LONG, 0) + 1);&#10;        }&#10;&#10;        // Verify checksums&#10;        int corruptedCount = 0;&#10;        for (int i = 0; i &lt; testSize; i++) {&#10;            MemorySegment data = archetype.getComponentData(locations.get(i), 0);&#10;            long value1 = data.get(ValueLayout.JAVA_LONG, 0);&#10;            long value2 = data.get(ValueLayout.JAVA_LONG, 8);&#10;&#10;            long expectedBase = (long) i * 12345 + 67890;&#10;&#10;            // Account for modifications&#10;            if (i &lt; 100 &amp;&amp; value1 != expectedBase + 1) {&#10;                corruptedCount++;&#10;            } else if (i &gt;= 100 &amp;&amp; value1 != expectedBase) {&#10;                corruptedCount++;&#10;            }&#10;        }&#10;&#10;        assertEquals(0, corruptedCount, &quot;No data should be corrupted&quot;);&#10;        System.out.println(&quot;✓ No corruption detected under stress testing&quot;);&#10;    }&#10;&#10;    // Test component classes&#10;    static class TestComponent {&#10;        long value1;&#10;        long value2;&#10;    }&#10;&#10;    static class Component1 {&#10;        long value;&#10;    }&#10;&#10;    static class Component2 {&#10;        long value1, value2;&#10;    }&#10;&#10;    static class Component3 {&#10;        long value1, value2, value3, value4;&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeEdgeCasesTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeEdgeCasesTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * QA/QC Test Suite: Edge Cases và Boundary Conditions&#10; * Kiểm tra các trường hợp biên, ngoại lệ và điều kiện giới hạn&#10; */&#10;@DisplayName(&quot;QA/QC: Edge Cases Tests&quot;)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class ArchetypeEdgeCasesTest {&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;TC-EC-001: Empty component mask handling&quot;)&#10;    void testEmptyComponentMask() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[0];&#10;        int[] componentIds = new int[0];&#10;        ComponentMask mask = new ComponentMask();&#10;&#10;        // System allows empty archetype - verify it's created successfully&#10;        Archetype archetype = assertDoesNotThrow(() -&gt; {&#10;            return new Archetype(mask, componentIds, descriptors, arena);&#10;        }, &quot;Empty archetype should be created successfully&quot;);&#10;&#10;        assertNotNull(archetype, &quot;Empty archetype should not be null&quot;);&#10;        assertEquals(0, archetype.getComponentIds().length, &quot;Should have 0 components&quot;);&#10;        assertEquals(0, archetype.getDescriptors().length, &quot;Should have 0 descriptors&quot;);&#10;&#10;        // Should be able to add entities even with no components&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(1);&#10;        assertNotNull(loc, &quot;Should be able to add entity to empty archetype&quot;);&#10;        assertEquals(1, archetype.getEntityCount(), &quot;Should have 1 entity&quot;);&#10;&#10;        System.out.println(&quot;✓ Empty component mask handled correctly - system allows empty archetypes&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;TC-EC-002: Single component archetype&quot;)&#10;    void testSingleComponentArchetype() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(SingleComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            assertNotNull(loc);&#10;        }&#10;&#10;        assertEquals(100, archetype.getEntityCount());&#10;        System.out.println(&quot;✓ Single component archetype works correctly&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;TC-EC-003: Maximum components per archetype&quot;)&#10;    void testMaximumComponents() {&#10;        Arena arena = Arena.ofShared();&#10;        int maxComponents = 32; // Reasonable limit&#10;&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[maxComponents];&#10;        int[] componentIds = new int[maxComponents];&#10;        ComponentMask mask = new ComponentMask();&#10;&#10;        for (int i = 0; i &lt; maxComponents; i++) {&#10;            descriptors[i] = makeDesc(TestComponent.class, 8);&#10;            componentIds[i] = i + 1;&#10;            mask = mask.set(i + 1);&#10;        }&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(1);&#10;        assertNotNull(loc);&#10;&#10;        System.out.printf(&quot;✓ Archetype with %d components created successfully%n&quot;, maxComponents);&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;TC-EC-004: Component index boundary tests&quot;)&#10;    void testComponentIndexBoundaries() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8),&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1, 2};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;        mask = mask.set(2);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Valid indices&#10;        assertEquals(0, archetype.indexOfComponentType(1));&#10;        assertEquals(1, archetype.indexOfComponentType(2));&#10;&#10;        // Invalid index&#10;        assertEquals(-1, archetype.indexOfComponentType(999));&#10;        assertEquals(-1, archetype.indexOfComponentType(-1));&#10;        assertEquals(-1, archetype.indexOfComponentType(0));&#10;&#10;        System.out.println(&quot;✓ Component index boundaries validated&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;TC-EC-005: Entity ID edge cases&quot;)&#10;    void testEntityIdEdgeCases() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Test various entity IDs&#10;        int[] testIds = {&#10;                0,                    // Zero&#10;                1,                    // Small positive&#10;                -1,                   // Negative&#10;                Integer.MAX_VALUE,    // Max int&#10;                Integer.MIN_VALUE     // Min int&#10;        };&#10;&#10;        for (int id : testIds) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(id);&#10;            assertNotNull(loc, &quot;Should handle entity ID: &quot; + id);&#10;        }&#10;&#10;        assertEquals(testIds.length, archetype.getEntityCount());&#10;        System.out.println(&quot;✓ Entity ID edge cases handled correctly&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(6)&#10;    @DisplayName(&quot;TC-EC-006: Chunk capacity boundary&quot;)&#10;    void testChunkCapacityBoundary() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int entitiesPerChunk = archetype.getEntitiesPerChunk();&#10;        int initialChunkCount = archetype.getChunkCount();&#10;&#10;        // Add enough entities to exceed multiple chunks&#10;        int totalEntities = entitiesPerChunk * 3;&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            archetype.addEntity(i);&#10;        }&#10;&#10;        // Verify we have more chunks now&#10;        int finalChunkCount = archetype.getChunkCount();&#10;        assertTrue(finalChunkCount &gt; initialChunkCount,&#10;                &quot;Should have created additional chunks after adding &quot; + totalEntities + &quot; entities&quot;);&#10;        assertEquals(totalEntities, archetype.getEntityCount(),&#10;                &quot;Should have all entities added&quot;);&#10;&#10;        System.out.printf(&quot;✓ Chunk capacity boundary tested: %d entities per chunk, created %d chunks for %d entities%n&quot;,&#10;                entitiesPerChunk, finalChunkCount, totalEntities);&#10;    }&#10;&#10;    @Test&#10;    @Order(7)&#10;    @DisplayName(&quot;TC-EC-007: Remove from invalid location&quot;)&#10;    void testRemoveInvalidLocation() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        archetype.addEntity(1);&#10;&#10;        // Try to remove from invalid locations&#10;        ArchetypeChunk.ChunkLocation invalidLoc1 = new ArchetypeChunk.ChunkLocation(-1, 0);&#10;        ArchetypeChunk.ChunkLocation invalidLoc2 = new ArchetypeChunk.ChunkLocation(0, -1);&#10;        ArchetypeChunk.ChunkLocation invalidLoc3 = new ArchetypeChunk.ChunkLocation(999, 0);&#10;&#10;        // Should handle gracefully&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(invalidLoc1));&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(invalidLoc2));&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(invalidLoc3));&#10;&#10;        System.out.println(&quot;✓ Invalid remove locations handled gracefully&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(8)&#10;    @DisplayName(&quot;TC-EC-008: Duplicate entity addition&quot;)&#10;    void testDuplicateEntityAddition() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add same entity ID multiple times&#10;        ArchetypeChunk.ChunkLocation loc1 = archetype.addEntity(42);&#10;        ArchetypeChunk.ChunkLocation loc2 = archetype.addEntity(42);&#10;        ArchetypeChunk.ChunkLocation loc3 = archetype.addEntity(42);&#10;&#10;        assertNotNull(loc1);&#10;        assertNotNull(loc2);&#10;        assertNotNull(loc3);&#10;&#10;        // System allows duplicate entity IDs (by design or should be prevented?)&#10;        assertTrue(archetype.getEntityCount() &gt;= 1);&#10;&#10;        System.out.println(&quot;✓ Duplicate entity addition behavior verified&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(9)&#10;    @DisplayName(&quot;TC-EC-009: Component type mismatch&quot;)&#10;    void testComponentTypeMismatch() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(1);&#10;&#10;        // Try to get component at invalid index&#10;        assertThrows(Exception.class, () -&gt; {&#10;            archetype.getComponentData(loc, 999);&#10;        }, &quot;Should throw exception for invalid component index&quot;);&#10;&#10;        System.out.println(&quot;✓ Component type mismatch handled correctly&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(10)&#10;    @DisplayName(&quot;TC-EC-010: Rapid add-remove cycles&quot;)&#10;    void testRapidAddRemoveCycles() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Rapid cycles&#10;        for (int cycle = 0; cycle &lt; 10; cycle++) {&#10;            // Add&#10;            for (int i = 0; i &lt; 100; i++) {&#10;                archetype.addEntity(cycle * 100 + i);&#10;            }&#10;&#10;            // Remove all from first chunk&#10;            for (int i = 0; i &lt; Math.min(100, archetype.getEntitiesPerChunk()); i++) {&#10;                archetype.removeEntity(new ArchetypeChunk.ChunkLocation(0, i));&#10;            }&#10;        }&#10;&#10;        assertTrue(archetype.getEntityCount() &gt;= 0, &quot;Entity count should be valid&quot;);&#10;        System.out.printf(&quot;✓ Survived 10 rapid add-remove cycles, final count: %d%n&quot;,&#10;                archetype.getEntityCount());&#10;    }&#10;&#10;    @Test&#10;    @Order(11)&#10;    @DisplayName(&quot;TC-EC-011: Component mask consistency&quot;)&#10;    void testComponentMaskConsistency() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8),&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{5, 10}; // Non-sequential IDs&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(5);&#10;        mask = mask.set(10);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Verify mask consistency&#10;        ComponentMask retrievedMask = archetype.getMask();&#10;        assertTrue(retrievedMask.has(5), &quot;Mask should have component 5&quot;);&#10;        assertTrue(retrievedMask.has(10), &quot;Mask should have component 10&quot;);&#10;        assertFalse(retrievedMask.has(1), &quot;Mask should not have component 1&quot;);&#10;        assertFalse(retrievedMask.has(15), &quot;Mask should not have component 15&quot;);&#10;&#10;        System.out.println(&quot;✓ Component mask consistency verified&quot;);&#10;    }&#10;&#10;    // Test component classes&#10;    static class SingleComponent {&#10;        long value;&#10;    }&#10;&#10;    static class TestComponent {&#10;        long value1;&#10;        long value2;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * QA/QC Test Suite: Edge Cases và Boundary Conditions&#10; * Kiểm tra các trường hợp biên, ngoại lệ và điều kiện giới hạn&#10; */&#10;@DisplayName(&quot;QA/QC: Edge Cases Tests&quot;)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class ArchetypeEdgeCasesTest {&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;TC-EC-001: Empty component mask handling&quot;)&#10;    void testEmptyComponentMask() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[0];&#10;        int[] componentIds = new int[0];&#10;        ComponentMask mask = new ComponentMask();&#10;&#10;        // System allows empty archetype - verify it's created successfully&#10;        Archetype archetype = assertDoesNotThrow(() -&gt; {&#10;            return new Archetype(mask, componentIds, descriptors, arena);&#10;        }, &quot;Empty archetype should be created successfully&quot;);&#10;&#10;        assertNotNull(archetype, &quot;Empty archetype should not be null&quot;);&#10;        assertEquals(0, archetype.getComponentIds().length, &quot;Should have 0 components&quot;);&#10;        assertEquals(0, archetype.getDescriptors().length, &quot;Should have 0 descriptors&quot;);&#10;&#10;        // Should be able to add entities even with no components&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(1);&#10;        assertNotNull(loc, &quot;Should be able to add entity to empty archetype&quot;);&#10;        assertEquals(1, archetype.getEntityCount(), &quot;Should have 1 entity&quot;);&#10;&#10;        System.out.println(&quot;✓ Empty component mask handled correctly - system allows empty archetypes&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;TC-EC-002: Single component archetype&quot;)&#10;    void testSingleComponentArchetype() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(SingleComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        for (int i = 0; i &lt; 100; i++) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(i);&#10;            assertNotNull(loc);&#10;        }&#10;&#10;        assertEquals(100, archetype.getEntityCount());&#10;        System.out.println(&quot;✓ Single component archetype works correctly&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;TC-EC-003: Maximum components per archetype&quot;)&#10;    void testMaximumComponents() {&#10;        Arena arena = Arena.ofShared();&#10;        int maxComponents = 32; // Reasonable limit&#10;&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[maxComponents];&#10;        int[] componentIds = new int[maxComponents];&#10;        ComponentMask mask = new ComponentMask();&#10;&#10;        for (int i = 0; i &lt; maxComponents; i++) {&#10;            descriptors[i] = makeDesc(TestComponent.class, 8);&#10;            componentIds[i] = i + 1;&#10;            mask = mask.set(i + 1);&#10;        }&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(1);&#10;        assertNotNull(loc);&#10;&#10;        System.out.printf(&quot;✓ Archetype with %d components created successfully%n&quot;, maxComponents);&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;TC-EC-004: Component index boundary tests&quot;)&#10;    void testComponentIndexBoundaries() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8),&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{1, 2};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;        mask = mask.set(2);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Valid indices&#10;        assertEquals(0, archetype.indexOfComponentType(1));&#10;        assertEquals(1, archetype.indexOfComponentType(2));&#10;&#10;        // Invalid index&#10;        assertEquals(-1, archetype.indexOfComponentType(999));&#10;        assertEquals(-1, archetype.indexOfComponentType(-1));&#10;        assertEquals(-1, archetype.indexOfComponentType(0));&#10;&#10;        System.out.println(&quot;✓ Component index boundaries validated&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;TC-EC-005: Entity ID edge cases&quot;)&#10;    void testEntityIdEdgeCases() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Test various entity IDs&#10;        int[] testIds = {&#10;                0,                    // Zero&#10;                1,                    // Small positive&#10;                -1,                   // Negative&#10;                Integer.MAX_VALUE,    // Max int&#10;                Integer.MIN_VALUE     // Min int&#10;        };&#10;&#10;        for (int id : testIds) {&#10;            ArchetypeChunk.ChunkLocation loc = archetype.addEntity(id);&#10;            assertNotNull(loc, &quot;Should handle entity ID: &quot; + id);&#10;        }&#10;&#10;        assertEquals(testIds.length, archetype.getEntityCount());&#10;        System.out.println(&quot;✓ Entity ID edge cases handled correctly&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(6)&#10;    @DisplayName(&quot;TC-EC-006: Chunk capacity boundary&quot;)&#10;    void testChunkCapacityBoundary() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int entitiesPerChunk = archetype.getEntitiesPerChunk();&#10;        int initialChunkCount = archetype.getChunkCount();&#10;&#10;        // Add enough entities to exceed multiple chunks&#10;        int totalEntities = entitiesPerChunk * 3;&#10;        for (int i = 0; i &lt; totalEntities; i++) {&#10;            archetype.addEntity(i);&#10;        }&#10;&#10;        // Verify we have more chunks now&#10;        int finalChunkCount = archetype.getChunkCount();&#10;        assertTrue(finalChunkCount &gt; initialChunkCount,&#10;                &quot;Should have created additional chunks after adding &quot; + totalEntities + &quot; entities&quot;);&#10;        assertEquals(totalEntities, archetype.getEntityCount(),&#10;                &quot;Should have all entities added&quot;);&#10;&#10;        System.out.printf(&quot;✓ Chunk capacity boundary tested: %d entities per chunk, created %d chunks for %d entities%n&quot;,&#10;                entitiesPerChunk, finalChunkCount, totalEntities);&#10;    }&#10;&#10;    @Test&#10;    @Order(7)&#10;    @DisplayName(&quot;TC-EC-007: Remove from invalid location&quot;)&#10;    void testRemoveInvalidLocation() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        archetype.addEntity(1);&#10;&#10;        // Try to remove from invalid locations&#10;        ArchetypeChunk.ChunkLocation invalidLoc1 = new ArchetypeChunk.ChunkLocation(-1, 0);&#10;        ArchetypeChunk.ChunkLocation invalidLoc2 = new ArchetypeChunk.ChunkLocation(0, -1);&#10;        ArchetypeChunk.ChunkLocation invalidLoc3 = new ArchetypeChunk.ChunkLocation(999, 0);&#10;&#10;        // Should handle gracefully&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(invalidLoc1));&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(invalidLoc2));&#10;        assertDoesNotThrow(() -&gt; archetype.removeEntity(invalidLoc3));&#10;&#10;        System.out.println(&quot;✓ Invalid remove locations handled gracefully&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(8)&#10;    @DisplayName(&quot;TC-EC-008: Duplicate entity addition&quot;)&#10;    void testDuplicateEntityAddition() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Add same entity ID multiple times&#10;        ArchetypeChunk.ChunkLocation loc1 = archetype.addEntity(42);&#10;        ArchetypeChunk.ChunkLocation loc2 = archetype.addEntity(42);&#10;        ArchetypeChunk.ChunkLocation loc3 = archetype.addEntity(42);&#10;&#10;        assertNotNull(loc1);&#10;        assertNotNull(loc2);&#10;        assertNotNull(loc3);&#10;&#10;        // System allows duplicate entity IDs (by design or should be prevented?)&#10;        assertTrue(archetype.getEntityCount() &gt;= 1);&#10;&#10;        System.out.println(&quot;✓ Duplicate entity addition behavior verified&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(9)&#10;    @DisplayName(&quot;TC-EC-009: Component type mismatch&quot;)&#10;    void testComponentTypeMismatch() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(1);&#10;&#10;        // Try to get component at invalid index&#10;        assertThrows(Exception.class, () -&gt; {&#10;            archetype.getComponentData(loc, 999);&#10;        }, &quot;Should throw exception for invalid component index&quot;);&#10;&#10;        System.out.println(&quot;✓ Component type mismatch handled correctly&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(10)&#10;    @DisplayName(&quot;TC-EC-010: Rapid add-remove cycles&quot;)&#10;    void testRapidAddRemoveCycles() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8)&#10;        };&#10;        int[] componentIds = new int[]{1};&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Rapid cycles&#10;        for (int cycle = 0; cycle &lt; 10; cycle++) {&#10;            // Add&#10;            for (int i = 0; i &lt; 100; i++) {&#10;                archetype.addEntity(cycle * 100 + i);&#10;            }&#10;&#10;            // Remove all from first chunk&#10;            for (int i = 0; i &lt; Math.min(100, archetype.getEntitiesPerChunk()); i++) {&#10;                archetype.removeEntity(new ArchetypeChunk.ChunkLocation(0, i));&#10;            }&#10;        }&#10;&#10;        assertTrue(archetype.getEntityCount() &gt;= 0, &quot;Entity count should be valid&quot;);&#10;        System.out.printf(&quot;✓ Survived 10 rapid add-remove cycles, final count: %d%n&quot;,&#10;                archetype.getEntityCount());&#10;    }&#10;&#10;    @Test&#10;    @Order(11)&#10;    @DisplayName(&quot;TC-EC-011: Component mask consistency&quot;)&#10;    void testComponentMaskConsistency() {&#10;        Arena arena = Arena.ofShared();&#10;        ComponentDescriptor[] descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent.class, 8),&#10;                makeDesc(TestComponent.class, 16)&#10;        };&#10;        int[] componentIds = new int[]{5, 10}; // Non-sequential IDs&#10;        ComponentMask mask = new ComponentMask();&#10;        mask = mask.set(5);&#10;        mask = mask.set(10);&#10;&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Verify mask consistency&#10;        ComponentMask retrievedMask = archetype.getMask();&#10;        assertTrue(retrievedMask.has(5), &quot;Mask should have component 5&quot;);&#10;        assertTrue(retrievedMask.has(10), &quot;Mask should have component 10&quot;);&#10;        assertFalse(retrievedMask.has(1), &quot;Mask should not have component 1&quot;);&#10;        assertFalse(retrievedMask.has(15), &quot;Mask should not have component 15&quot;);&#10;&#10;        System.out.println(&quot;✓ Component mask consistency verified&quot;);&#10;    }&#10;&#10;    // Test component classes&#10;    static class SingleComponent {&#10;        long value;&#10;    }&#10;&#10;    static class TestComponent {&#10;        long value1;&#10;        long value2;&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeThreadSafetyTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ArchetypeThreadSafetyTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;import java.util.concurrent.*;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * QA/QC Test Suite: Thread Safety và Concurrency&#10; * Đảm bảo hệ thống hoạt động an toàn trong môi trường đa luồng&#10; */&#10;@DisplayName(&quot;QA/QC: Thread Safety Tests&quot;)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class ArchetypeThreadSafetyTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private int[] componentIds;&#10;    private ComponentMask mask;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        componentIds = new int[]{1, 2};&#10;        mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;        mask = mask.set(2);&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;TC-TS-001: Concurrent entity additions should be thread-safe&quot;)&#10;    void testConcurrentEntityAdditions() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int threadCount = 10;&#10;        int entitiesPerThread = 100;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threadCount);&#10;        CountDownLatch latch = new CountDownLatch(threadCount);&#10;        ConcurrentHashMap&lt;Integer, ArchetypeChunk.ChunkLocation&gt; locations = new ConcurrentHashMap&lt;&gt;();&#10;        AtomicInteger errorCount = new AtomicInteger(0);&#10;&#10;        for (int t = 0; t &lt; threadCount; t++) {&#10;            final int threadId = t;&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int i = 0; i &lt; entitiesPerThread; i++) {&#10;                        int entityId = threadId * entitiesPerThread + i;&#10;                        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(entityId);&#10;                        assertNotNull(loc, &quot;Location should not be null for entity &quot; + entityId);&#10;&#10;                        ArchetypeChunk.ChunkLocation previous = locations.putIfAbsent(entityId, loc);&#10;                        if (previous != null) {&#10;                            errorCount.incrementAndGet();&#10;                            System.err.println(&quot;Duplicate entity location detected: &quot; + entityId);&#10;                        }&#10;                    }&#10;                } catch (Exception e) {&#10;                    errorCount.incrementAndGet();&#10;                    e.printStackTrace();&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(30, TimeUnit.SECONDS), &quot;Test timeout - threads did not complete&quot;);&#10;        executor.shutdown();&#10;        assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;&#10;        assertEquals(0, errorCount.get(), &quot;No errors should occur during concurrent additions&quot;);&#10;        assertEquals(threadCount * entitiesPerThread, locations.size(),&#10;                &quot;All entities should be added uniquely&quot;);&#10;&#10;        System.out.printf(&quot;✓ Successfully added %d entities concurrently from %d threads%n&quot;,&#10;                threadCount * entitiesPerThread, threadCount);&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;TC-TS-002: Concurrent add and remove operations should maintain consistency&quot;)&#10;    void testConcurrentAddRemove() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int operations = 1000;&#10;        ExecutorService executor = Executors.newFixedThreadPool(4);&#10;        ConcurrentHashMap&lt;Integer, ArchetypeChunk.ChunkLocation&gt; activeEntities = new ConcurrentHashMap&lt;&gt;();&#10;        AtomicInteger entityIdCounter = new AtomicInteger(0);&#10;        AtomicInteger addCount = new AtomicInteger(0);&#10;        AtomicInteger removeCount = new AtomicInteger(0);&#10;&#10;        // Adder threads (2 threads)&#10;        for (int i = 0; i &lt; 2; i++) {&#10;            executor.submit(() -&gt; {&#10;                for (int j = 0; j &lt; operations; j++) {&#10;                    try {&#10;                        int entityId = entityIdCounter.incrementAndGet();&#10;                        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(entityId);&#10;                        activeEntities.put(entityId, loc);&#10;                        addCount.incrementAndGet();&#10;                    } catch (Exception e) {&#10;                        System.err.println(&quot;Error adding entity: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        // Remover threads (2 threads)&#10;        for (int i = 0; i &lt; 2; i++) {&#10;            executor.submit(() -&gt; {&#10;                for (int j = 0; j &lt; operations / 2; j++) {&#10;                    try {&#10;                        activeEntities.keySet().stream().findAny().ifPresent(entityId -&gt; {&#10;                            ArchetypeChunk.ChunkLocation loc = activeEntities.remove(entityId);&#10;                            if (loc != null) {&#10;                                try {&#10;                                    archetype.removeEntity(loc);&#10;                                    removeCount.incrementAndGet();&#10;                                } catch (Exception e) {&#10;                                    System.err.println(&quot;Error removing entity: &quot; + e.getMessage());&#10;                                }&#10;                            }&#10;                        });&#10;                        Thread.sleep(1);&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        executor.shutdown();&#10;        assertTrue(executor.awaitTermination(60, TimeUnit.SECONDS), &quot;Concurrent operations timeout&quot;);&#10;&#10;        System.out.printf(&quot;✓ Concurrent operations completed: %d adds, %d removes%n&quot;,&#10;                addCount.get(), removeCount.get());&#10;        System.out.printf(&quot;✓ Final state: %d active entities%n&quot;, activeEntities.size());&#10;&#10;        // Verify final consistency&#10;        assertTrue(activeEntities.size() &gt;= 0, &quot;Active entities count should be non-negative&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;TC-TS-003: Parallel chunk iteration should be consistent&quot;)&#10;    void testParallelChunkIteration() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Pre-populate with entities&#10;        for (int i = 0; i &lt; 1000; i++) {&#10;            archetype.addEntity(i);&#10;        }&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(5);&#10;        AtomicInteger totalIterations = new AtomicInteger(0);&#10;        CountDownLatch latch = new CountDownLatch(5);&#10;&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int j = 0; j &lt; 100; j++) {&#10;                        archetype.getChunks().forEach(chunk -&gt; {&#10;                            assertNotNull(chunk);&#10;                            totalIterations.incrementAndGet();&#10;                        });&#10;                    }&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(30, TimeUnit.SECONDS));&#10;        executor.shutdown();&#10;&#10;        System.out.printf(&quot;✓ Completed %d parallel chunk iterations%n&quot;, totalIterations.get());&#10;        assertTrue(totalIterations.get() &gt; 0, &quot;Should have performed iterations&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;TC-TS-004: Race condition stress test&quot;)&#10;    void testRaceConditionStress() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int threadCount = 20;&#10;        int operationsPerThread = 500;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threadCount);&#10;        CountDownLatch latch = new CountDownLatch(threadCount);&#10;        AtomicInteger successfulOps = new AtomicInteger(0);&#10;        AtomicInteger failedOps = new AtomicInteger(0);&#10;&#10;        for (int t = 0; t &lt; threadCount; t++) {&#10;            final int threadId = t;&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int i = 0; i &lt; operationsPerThread; i++) {&#10;                        try {&#10;                            int entityId = threadId * operationsPerThread + i;&#10;                            archetype.addEntity(entityId);&#10;                            successfulOps.incrementAndGet();&#10;                        } catch (Exception e) {&#10;                            failedOps.incrementAndGet();&#10;                        }&#10;                    }&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(60, TimeUnit.SECONDS), &quot;Stress test timeout&quot;);&#10;        executor.shutdown();&#10;&#10;        int totalOps = threadCount * operationsPerThread;&#10;        System.out.printf(&quot;✓ Stress test: %d successful, %d failed out of %d operations%n&quot;,&#10;                successfulOps.get(), failedOps.get(), totalOps);&#10;&#10;        assertTrue(successfulOps.get() &gt; 0, &quot;Should have some successful operations&quot;);&#10;        assertTrue((double) successfulOps.get() / totalOps &gt; 0.95,&#10;                &quot;Success rate should be &gt; 95%&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;TC-TS-005: Deadlock detection test&quot;)&#10;    @Timeout(value = 30, unit = TimeUnit.SECONDS)&#10;    void testNoDeadlock() throws InterruptedException {&#10;        Archetype archetype1 = new Archetype(mask, componentIds, descriptors, arena);&#10;        Archetype archetype2 = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(4);&#10;        CountDownLatch latch = new CountDownLatch(4);&#10;&#10;        // Thread 1: archetype1 -&gt; archetype2&#10;        executor.submit(() -&gt; {&#10;            try {&#10;                for (int i = 0; i &lt; 100; i++) {&#10;                    archetype1.addEntity(i);&#10;                    archetype2.addEntity(i + 1000);&#10;                }&#10;            } finally {&#10;                latch.countDown();&#10;            }&#10;        });&#10;&#10;        // Thread 2: archetype2 -&gt; archetype1&#10;        executor.submit(() -&gt; {&#10;            try {&#10;                for (int i = 0; i &lt; 100; i++) {&#10;                    archetype2.addEntity(i + 2000);&#10;                    archetype1.addEntity(i + 3000);&#10;                }&#10;            } finally {&#10;                latch.countDown();&#10;            }&#10;        });&#10;&#10;        // Thread 3 &amp; 4: Mixed operations&#10;        for (int t = 0; t &lt; 2; t++) {&#10;            final int offset = t * 4000;&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int i = 0; i &lt; 100; i++) {&#10;                        if (i % 2 == 0) {&#10;                            archetype1.addEntity(i + offset);&#10;                        } else {&#10;                            archetype2.addEntity(i + offset);&#10;                        }&#10;                    }&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(25, TimeUnit.SECONDS), &quot;Deadlock detected or timeout&quot;);&#10;        executor.shutdown();&#10;&#10;        System.out.println(&quot;✓ No deadlock detected in cross-archetype operations&quot;);&#10;    }&#10;&#10;    // Test component classes&#10;    static class TestComponent1 {&#10;        long value1;&#10;        long value2;&#10;    }&#10;&#10;    static class TestComponent2 {&#10;        long value;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;import java.util.concurrent.*;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * QA/QC Test Suite: Thread Safety và Concurrency&#10; * Đảm bảo hệ thống hoạt động an toàn trong môi trường đa luồng&#10; */&#10;@DisplayName(&quot;QA/QC: Thread Safety Tests&quot;)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class ArchetypeThreadSafetyTest {&#10;&#10;    private Arena arena;&#10;    private ComponentDescriptor[] descriptors;&#10;    private int[] componentIds;&#10;    private ComponentMask mask;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        arena = Arena.ofShared();&#10;        descriptors = new ComponentDescriptor[]{&#10;                makeDesc(TestComponent1.class, 16),&#10;                makeDesc(TestComponent2.class, 8)&#10;        };&#10;        componentIds = new int[]{1, 2};&#10;        mask = new ComponentMask();&#10;        mask = mask.set(1);&#10;        mask = mask.set(2);&#10;    }&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;TC-TS-001: Concurrent entity additions should be thread-safe&quot;)&#10;    void testConcurrentEntityAdditions() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int threadCount = 10;&#10;        int entitiesPerThread = 100;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threadCount);&#10;        CountDownLatch latch = new CountDownLatch(threadCount);&#10;        ConcurrentHashMap&lt;Integer, ArchetypeChunk.ChunkLocation&gt; locations = new ConcurrentHashMap&lt;&gt;();&#10;        AtomicInteger errorCount = new AtomicInteger(0);&#10;&#10;        for (int t = 0; t &lt; threadCount; t++) {&#10;            final int threadId = t;&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int i = 0; i &lt; entitiesPerThread; i++) {&#10;                        int entityId = threadId * entitiesPerThread + i;&#10;                        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(entityId);&#10;                        assertNotNull(loc, &quot;Location should not be null for entity &quot; + entityId);&#10;&#10;                        ArchetypeChunk.ChunkLocation previous = locations.putIfAbsent(entityId, loc);&#10;                        if (previous != null) {&#10;                            errorCount.incrementAndGet();&#10;                            System.err.println(&quot;Duplicate entity location detected: &quot; + entityId);&#10;                        }&#10;                    }&#10;                } catch (Exception e) {&#10;                    errorCount.incrementAndGet();&#10;                    e.printStackTrace();&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(30, TimeUnit.SECONDS), &quot;Test timeout - threads did not complete&quot;);&#10;        executor.shutdown();&#10;        assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));&#10;&#10;        assertEquals(0, errorCount.get(), &quot;No errors should occur during concurrent additions&quot;);&#10;        assertEquals(threadCount * entitiesPerThread, locations.size(),&#10;                &quot;All entities should be added uniquely&quot;);&#10;&#10;        System.out.printf(&quot;✓ Successfully added %d entities concurrently from %d threads%n&quot;,&#10;                threadCount * entitiesPerThread, threadCount);&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;TC-TS-002: Concurrent add and remove operations should maintain consistency&quot;)&#10;    void testConcurrentAddRemove() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int operations = 1000;&#10;        ExecutorService executor = Executors.newFixedThreadPool(4);&#10;        ConcurrentHashMap&lt;Integer, ArchetypeChunk.ChunkLocation&gt; activeEntities = new ConcurrentHashMap&lt;&gt;();&#10;        AtomicInteger entityIdCounter = new AtomicInteger(0);&#10;        AtomicInteger addCount = new AtomicInteger(0);&#10;        AtomicInteger removeCount = new AtomicInteger(0);&#10;&#10;        // Adder threads (2 threads)&#10;        for (int i = 0; i &lt; 2; i++) {&#10;            executor.submit(() -&gt; {&#10;                for (int j = 0; j &lt; operations; j++) {&#10;                    try {&#10;                        int entityId = entityIdCounter.incrementAndGet();&#10;                        ArchetypeChunk.ChunkLocation loc = archetype.addEntity(entityId);&#10;                        activeEntities.put(entityId, loc);&#10;                        addCount.incrementAndGet();&#10;                    } catch (Exception e) {&#10;                        System.err.println(&quot;Error adding entity: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        // Remover threads (2 threads)&#10;        for (int i = 0; i &lt; 2; i++) {&#10;            executor.submit(() -&gt; {&#10;                for (int j = 0; j &lt; operations / 2; j++) {&#10;                    try {&#10;                        activeEntities.keySet().stream().findAny().ifPresent(entityId -&gt; {&#10;                            ArchetypeChunk.ChunkLocation loc = activeEntities.remove(entityId);&#10;                            if (loc != null) {&#10;                                try {&#10;                                    archetype.removeEntity(loc);&#10;                                    removeCount.incrementAndGet();&#10;                                } catch (Exception e) {&#10;                                    System.err.println(&quot;Error removing entity: &quot; + e.getMessage());&#10;                                }&#10;                            }&#10;                        });&#10;                        Thread.sleep(1);&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        executor.shutdown();&#10;        assertTrue(executor.awaitTermination(60, TimeUnit.SECONDS), &quot;Concurrent operations timeout&quot;);&#10;&#10;        System.out.printf(&quot;✓ Concurrent operations completed: %d adds, %d removes%n&quot;,&#10;                addCount.get(), removeCount.get());&#10;        System.out.printf(&quot;✓ Final state: %d active entities%n&quot;, activeEntities.size());&#10;&#10;        // Verify final consistency&#10;        assertTrue(activeEntities.size() &gt;= 0, &quot;Active entities count should be non-negative&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;TC-TS-003: Parallel chunk iteration should be consistent&quot;)&#10;    void testParallelChunkIteration() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        // Pre-populate with entities&#10;        for (int i = 0; i &lt; 1000; i++) {&#10;            archetype.addEntity(i);&#10;        }&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(5);&#10;        AtomicInteger totalIterations = new AtomicInteger(0);&#10;        CountDownLatch latch = new CountDownLatch(5);&#10;&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int j = 0; j &lt; 100; j++) {&#10;                        archetype.getChunks().forEach(chunk -&gt; {&#10;                            assertNotNull(chunk);&#10;                            totalIterations.incrementAndGet();&#10;                        });&#10;                    }&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(30, TimeUnit.SECONDS));&#10;        executor.shutdown();&#10;&#10;        System.out.printf(&quot;✓ Completed %d parallel chunk iterations%n&quot;, totalIterations.get());&#10;        assertTrue(totalIterations.get() &gt; 0, &quot;Should have performed iterations&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;TC-TS-004: Race condition stress test&quot;)&#10;    void testRaceConditionStress() throws InterruptedException {&#10;        Archetype archetype = new Archetype(mask, componentIds, descriptors, arena);&#10;        int threadCount = 20;&#10;        int operationsPerThread = 500;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threadCount);&#10;        CountDownLatch latch = new CountDownLatch(threadCount);&#10;        AtomicInteger successfulOps = new AtomicInteger(0);&#10;        AtomicInteger failedOps = new AtomicInteger(0);&#10;&#10;        for (int t = 0; t &lt; threadCount; t++) {&#10;            final int threadId = t;&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int i = 0; i &lt; operationsPerThread; i++) {&#10;                        try {&#10;                            int entityId = threadId * operationsPerThread + i;&#10;                            archetype.addEntity(entityId);&#10;                            successfulOps.incrementAndGet();&#10;                        } catch (Exception e) {&#10;                            failedOps.incrementAndGet();&#10;                        }&#10;                    }&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(60, TimeUnit.SECONDS), &quot;Stress test timeout&quot;);&#10;        executor.shutdown();&#10;&#10;        int totalOps = threadCount * operationsPerThread;&#10;        System.out.printf(&quot;✓ Stress test: %d successful, %d failed out of %d operations%n&quot;,&#10;                successfulOps.get(), failedOps.get(), totalOps);&#10;&#10;        assertTrue(successfulOps.get() &gt; 0, &quot;Should have some successful operations&quot;);&#10;        assertTrue((double) successfulOps.get() / totalOps &gt; 0.95,&#10;                &quot;Success rate should be &gt; 95%&quot;);&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;TC-TS-005: Deadlock detection test&quot;)&#10;    @Timeout(value = 30, unit = TimeUnit.SECONDS)&#10;    void testNoDeadlock() throws InterruptedException {&#10;        Archetype archetype1 = new Archetype(mask, componentIds, descriptors, arena);&#10;        Archetype archetype2 = new Archetype(mask, componentIds, descriptors, arena);&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(4);&#10;        CountDownLatch latch = new CountDownLatch(4);&#10;&#10;        // Thread 1: archetype1 -&gt; archetype2&#10;        executor.submit(() -&gt; {&#10;            try {&#10;                for (int i = 0; i &lt; 100; i++) {&#10;                    archetype1.addEntity(i);&#10;                    archetype2.addEntity(i + 1000);&#10;                }&#10;            } finally {&#10;                latch.countDown();&#10;            }&#10;        });&#10;&#10;        // Thread 2: archetype2 -&gt; archetype1&#10;        executor.submit(() -&gt; {&#10;            try {&#10;                for (int i = 0; i &lt; 100; i++) {&#10;                    archetype2.addEntity(i + 2000);&#10;                    archetype1.addEntity(i + 3000);&#10;                }&#10;            } finally {&#10;                latch.countDown();&#10;            }&#10;        });&#10;&#10;        // Thread 3 &amp; 4: Mixed operations&#10;        for (int t = 0; t &lt; 2; t++) {&#10;            final int offset = t * 4000;&#10;            executor.submit(() -&gt; {&#10;                try {&#10;                    for (int i = 0; i &lt; 100; i++) {&#10;                        if (i % 2 == 0) {&#10;                            archetype1.addEntity(i + offset);&#10;                        } else {&#10;                            archetype2.addEntity(i + offset);&#10;                        }&#10;                    }&#10;                } finally {&#10;                    latch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        assertTrue(latch.await(25, TimeUnit.SECONDS), &quot;Deadlock detected or timeout&quot;);&#10;        executor.shutdown();&#10;&#10;        System.out.println(&quot;✓ No deadlock detected in cross-archetype operations&quot;);&#10;    }&#10;&#10;    // Test component classes&#10;    static class TestComponent1 {&#10;        long value1;&#10;        long value2;&#10;    }&#10;&#10;    static class TestComponent2 {&#10;        long value;&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/LargeScaleTestSuite.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/LargeScaleTestSuite.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import org.junit.platform.suite.api.SelectClasses;&#10;import org.junit.platform.suite.api.Suite;&#10;import org.junit.platform.suite.api.SuiteDisplayName;&#10;&#10;/**&#10; * Comprehensive test suite for large-scale entity operations.&#10; * This suite runs all large-scale tests for ArchetypeChunk and LockFreeAllocator.&#10; */&#10;@Suite&#10;@SuiteDisplayName(&quot;Large Scale ECS Test Suite&quot;)&#10;@SelectClasses({&#10;    ArchetypeChunkTest.class,&#10;    LockFreeAllocatorTest.class,&#10;    ParallelQueryTest.class&#10;})&#10;public class LargeScaleTestSuite {&#10;    // This class remains empty, it is used only as a holder for the suite annotations&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import org.junit.platform.suite.api.SelectClasses;&#10;import org.junit.platform.suite.api.Suite;&#10;import org.junit.platform.suite.api.SuiteDisplayName;&#10;&#10;/**&#10; * Comprehensive test suite for large-scale entity operations.&#10; * This suite runs all large-scale tests for ArchetypeChunk and LockFreeAllocator.&#10; */&#10;@Suite&#10;@SuiteDisplayName(&quot;Large Scale ECS Test Suite&quot;)&#10;@SelectClasses({&#10;    ArchetypeChunkTest.class,&#10;    LockFreeAllocatorTest.class,&#10;    ParallelQueryTest.class&#10;})&#10;public class LargeScaleTestSuite {&#10;    // This class remains empty, it is used only as a holder for the suite annotations&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/LockFreeAllocatorTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/LockFreeAllocatorTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import org.junit.jupiter.api.AfterAll;&#10;import org.junit.jupiter.api.Assertions;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;public class LockFreeAllocatorTest {&#10;&#10;    static final Arena shared = Arena.ofShared();&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @AfterAll&#10;    static void tearDown() {&#10;        // do not close shared arena; it is shared across tests/world&#10;    }&#10;&#10;    @Test&#10;    void allocateUpToCapacityConcurrently() throws InterruptedException {&#10;        if (!Boolean.getBoolean(&quot;ecs.enableLockFreeAllocatorStress&quot;)) {&#10;            // Skip this stress-oriented test unless explicitly enabled via system property&#10;            return;&#10;        }&#10;        int capacity = 256;&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        long[] sizes = new long[] { 16, 8 };&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descs, sizes, capacity, shared);&#10;&#10;        int threads = 8;&#10;        int attemptsPerThread = 1000; // will saturate chunk multiple times&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * attemptsPerThread;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; attemptsPerThread; i++) {&#10;                        int eid = baseId + i;&#10;                        int idx = chunk.allocateSlot(eid);&#10;                        if (idx &gt;= 0) {&#10;                            // immediately free half of allocations to churn&#10;                            if ((eid &amp; 1) == 0) {&#10;                                chunk.freeSlot(idx);&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        done.await(30, TimeUnit.SECONDS);&#10;        pool.shutdownNow();&#10;&#10;        // size must be within [0, capacity]&#10;        var size = chunk.size();&#10;        Assertions.assertTrue(chunk.size() &gt;= 0, &quot;Chunk size should be non-negative&quot;);&#10;        Assertions.assertTrue(chunk.size() &lt;= capacity, &quot;Chunk size should not exceed capacity&quot;);&#10;&#10;        // All occupied slots must have a valid entity id != -1&#10;        int occupied = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            int eid = chunk.getEntityId(i);&#10;            if (eid != -1) occupied++;&#10;            else continue;&#10;        }&#10;        Assertions.assertEquals(chunk.size(), occupied);&#10;    }&#10;&#10;    @Test&#10;    void archetypeConcurrentAddsScaleAcrossChunks() throws InterruptedException {&#10;        // Small capacity to force multiple chunks&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 8;&#10;        int entities = 10_000;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        int perThread = entities / threads;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * perThread + 1;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; perThread; i++) {&#10;                        archetype.addEntity(baseId + i);&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        done.await(30, TimeUnit.SECONDS);&#10;        pool.shutdownNow();&#10;&#10;        // Count entities discovered by iteration; weakly consistent but should reach expected count&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(entities, count[0]);&#10;&#10;        // sanity: at least more than one chunk should exist&#10;        Assertions.assertTrue(archetype.getChunks().size() &gt;= 1);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScale_50000Entities() throws InterruptedException {&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 16;&#10;        int entities = 50_000;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        int perThread = entities / threads;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * perThread + 100_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; perThread; i++) {&#10;                        archetype.addEntity(baseId + i);&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(60, TimeUnit.SECONDS), &quot;Should complete within 60 seconds&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Count all entities&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(entities, count[0], &quot;All 50,000 entities should be present&quot;);&#10;&#10;        // Verify multiple chunks were created&#10;        Assertions.assertTrue(archetype.getChunks().size() &gt; 1, &quot;Should have created multiple chunks&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScale_100000EntitiesWithChurn() throws InterruptedException {&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 20;&#10;        int totalOperations = 100_000;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        int perThread = totalOperations / threads;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * perThread + 200_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; perThread; i++) {&#10;                        archetype.addEntity(baseId + i);&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(120, TimeUnit.SECONDS), &quot;Should complete within 120 seconds&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Verify entity count&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(totalOperations, count[0], &quot;All 100,000 entities should be present&quot;);&#10;&#10;        // Verify chunk distribution&#10;        int chunkCount = archetype.getChunks().size();&#10;        Assertions.assertTrue(chunkCount &gt; 1, &quot;Should have created multiple chunks for 100k entities&quot;);&#10;        System.out.println(&quot;Created &quot; + chunkCount + &quot; chunks for 100,000 entities&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testHighContentionScenario_10000Entities() throws InterruptedException {&#10;        int capacity = 128; // Small capacity to force more chunk allocations&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        long[] sizes = new long[] { 16, 8 };&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descs, sizes, capacity, shared);&#10;&#10;        int threads = 32; // High thread count for contention&#10;        int attemptsPerThread = 500;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        AtomicInteger successfulAllocs = new AtomicInteger(0);&#10;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * attemptsPerThread + 300_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; attemptsPerThread; i++) {&#10;                        int idx = chunk.allocateSlot(baseId + i);&#10;                        if (idx &gt;= 0) {&#10;                            successfulAllocs.incrementAndGet();&#10;                            // Free half immediately to create churn&#10;                            if (i % 2 == 0) {&#10;                                chunk.freeSlot(idx);&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(60, TimeUnit.SECONDS), &quot;High contention test should complete&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Verify chunk state is consistent&#10;        int finalSize = chunk.size();&#10;        Assertions.assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity, &quot;Size should be within bounds&quot;);&#10;&#10;        // Count actual occupied slots&#10;        int occupied = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) occupied++;&#10;        }&#10;        Assertions.assertEquals(finalSize, occupied, &quot;Occupied count should match size&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testMixedOperations_20000Cycles() throws InterruptedException {&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 10;&#10;        int cyclesPerThread = 2000; // Total 20,000 cycles&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * cyclesPerThread + 400_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; cyclesPerThread; i++) {&#10;                        // Add entity&#10;                        archetype.addEntity(baseId + i);&#10;&#10;                        // Simulate some processing time&#10;                        if (i % 100 == 0) {&#10;                            Thread.sleep(0, 1000); // 1 microsecond&#10;                        }&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(90, TimeUnit.SECONDS), &quot;Mixed operations should complete&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Final verification&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(threads * cyclesPerThread, count[0], &quot;All entities should be accounted for&quot;);&#10;    }&#10;&#10;    @Test&#10;    void allocateUpToCapacityConcurrently_manyRounds() throws InterruptedException {&#10;        // NOTE: This is a stress-only test and can be flaky when run with the full suite&#10;        // because it amplifies scheduler timing differences.&#10;        // Temporarily disabled to keep the main suite stable; re-enable when investigating&#10;        // allocator behavior in isolation.&#10;        if (Boolean.getBoolean(&quot;ecs.enableLockFreeAllocatorStress&quot;)) {&#10;            for (int i = 0; i &lt; 20; i++) {&#10;                allocateUpToCapacityConcurrently();&#10;            }&#10;        }&#10;    }&#10;&#10;    // Dummy component classes for descriptor construction&#10;    static final class DummyC1 {}&#10;    static final class DummyC2 {}&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentDescriptor;&#10;import com.ethnicthv.ecs.core.archetype.Archetype;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeChunk;&#10;import com.ethnicthv.ecs.core.archetype.ComponentMask;&#10;import org.junit.jupiter.api.AfterAll;&#10;import org.junit.jupiter.api.Assertions;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.lang.foreign.Arena;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;public class LockFreeAllocatorTest {&#10;&#10;    static final Arena shared = Arena.ofShared();&#10;&#10;    private static ComponentDescriptor makeDesc(Class&lt;?&gt; clazz, long size) {&#10;        return new ComponentDescriptor(&#10;                clazz,&#10;                size,&#10;                List.of(),&#10;                Component.LayoutType.SEQUENTIAL&#10;        );&#10;    }&#10;&#10;    @AfterAll&#10;    static void tearDown() {&#10;        // do not close shared arena; it is shared across tests/world&#10;    }&#10;&#10;    @Test&#10;    void allocateUpToCapacityConcurrently() throws InterruptedException {&#10;        if (!Boolean.getBoolean(&quot;ecs.enableLockFreeAllocatorStress&quot;)) {&#10;            // Skip this stress-oriented test unless explicitly enabled via system property&#10;            return;&#10;        }&#10;        int capacity = 256;&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        long[] sizes = new long[] { 16, 8 };&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descs, sizes, capacity, shared);&#10;&#10;        int threads = 8;&#10;        int attemptsPerThread = 1000; // will saturate chunk multiple times&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * attemptsPerThread;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; attemptsPerThread; i++) {&#10;                        int eid = baseId + i;&#10;                        int idx = chunk.allocateSlot(eid);&#10;                        if (idx &gt;= 0) {&#10;                            // immediately free half of allocations to churn&#10;                            if ((eid &amp; 1) == 0) {&#10;                                chunk.freeSlot(idx);&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        done.await(30, TimeUnit.SECONDS);&#10;        pool.shutdownNow();&#10;&#10;        // size must be within [0, capacity]&#10;        var size = chunk.size();&#10;        Assertions.assertTrue(chunk.size() &gt;= 0, &quot;Chunk size should be non-negative&quot;);&#10;        Assertions.assertTrue(chunk.size() &lt;= capacity, &quot;Chunk size should not exceed capacity&quot;);&#10;&#10;        // All occupied slots must have a valid entity id != -1&#10;        int occupied = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            int eid = chunk.getEntityId(i);&#10;            if (eid != -1) occupied++;&#10;            else continue;&#10;        }&#10;        Assertions.assertEquals(chunk.size(), occupied);&#10;    }&#10;&#10;    @Test&#10;    void archetypeConcurrentAddsScaleAcrossChunks() throws InterruptedException {&#10;        // Small capacity to force multiple chunks&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 8;&#10;        int entities = 10_000;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        int perThread = entities / threads;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * perThread + 1;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; perThread; i++) {&#10;                        archetype.addEntity(baseId + i);&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        done.await(30, TimeUnit.SECONDS);&#10;        pool.shutdownNow();&#10;&#10;        // Count entities discovered by iteration; weakly consistent but should reach expected count&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(entities, count[0]);&#10;&#10;        // sanity: at least more than one chunk should exist&#10;        Assertions.assertTrue(archetype.getChunks().size() &gt;= 1);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScale_50000Entities() throws InterruptedException {&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 16;&#10;        int entities = 50_000;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        int perThread = entities / threads;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * perThread + 100_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; perThread; i++) {&#10;                        archetype.addEntity(baseId + i);&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(60, TimeUnit.SECONDS), &quot;Should complete within 60 seconds&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Count all entities&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(entities, count[0], &quot;All 50,000 entities should be present&quot;);&#10;&#10;        // Verify multiple chunks were created&#10;        Assertions.assertTrue(archetype.getChunks().size() &gt; 1, &quot;Should have created multiple chunks&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLargeScale_100000EntitiesWithChurn() throws InterruptedException {&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 20;&#10;        int totalOperations = 100_000;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        int perThread = totalOperations / threads;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * perThread + 200_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; perThread; i++) {&#10;                        archetype.addEntity(baseId + i);&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(120, TimeUnit.SECONDS), &quot;Should complete within 120 seconds&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Verify entity count&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(totalOperations, count[0], &quot;All 100,000 entities should be present&quot;);&#10;&#10;        // Verify chunk distribution&#10;        int chunkCount = archetype.getChunks().size();&#10;        Assertions.assertTrue(chunkCount &gt; 1, &quot;Should have created multiple chunks for 100k entities&quot;);&#10;        System.out.println(&quot;Created &quot; + chunkCount + &quot; chunks for 100,000 entities&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testHighContentionScenario_10000Entities() throws InterruptedException {&#10;        int capacity = 128; // Small capacity to force more chunk allocations&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        long[] sizes = new long[] { 16, 8 };&#10;        ArchetypeChunk chunk = new ArchetypeChunk(descs, sizes, capacity, shared);&#10;&#10;        int threads = 32; // High thread count for contention&#10;        int attemptsPerThread = 500;&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        AtomicInteger successfulAllocs = new AtomicInteger(0);&#10;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * attemptsPerThread + 300_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; attemptsPerThread; i++) {&#10;                        int idx = chunk.allocateSlot(baseId + i);&#10;                        if (idx &gt;= 0) {&#10;                            successfulAllocs.incrementAndGet();&#10;                            // Free half immediately to create churn&#10;                            if (i % 2 == 0) {&#10;                                chunk.freeSlot(idx);&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(60, TimeUnit.SECONDS), &quot;High contention test should complete&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Verify chunk state is consistent&#10;        int finalSize = chunk.size();&#10;        Assertions.assertTrue(finalSize &gt;= 0 &amp;&amp; finalSize &lt;= capacity, &quot;Size should be within bounds&quot;);&#10;&#10;        // Count actual occupied slots&#10;        int occupied = 0;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            if (chunk.getEntityId(i) != -1) occupied++;&#10;        }&#10;        Assertions.assertEquals(finalSize, occupied, &quot;Occupied count should match size&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testMixedOperations_20000Cycles() throws InterruptedException {&#10;        ComponentDescriptor[] descs = new ComponentDescriptor[] {&#10;                makeDesc(DummyC1.class, 16),&#10;                makeDesc(DummyC2.class, 8)&#10;        };&#10;        ComponentMask empty = new ComponentMask();&#10;        int[] compIds = new int[] {0, 1};&#10;        Archetype archetype = new Archetype(empty, compIds, descs, shared);&#10;&#10;        int threads = 10;&#10;        int cyclesPerThread = 2000; // Total 20,000 cycles&#10;        ExecutorService pool = Executors.newFixedThreadPool(threads);&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;&#10;        for (int t = 0; t &lt; threads; t++) {&#10;            final int baseId = t * cyclesPerThread + 400_000;&#10;            pool.submit(() -&gt; {&#10;                try {&#10;                    start.await();&#10;                    for (int i = 0; i &lt; cyclesPerThread; i++) {&#10;                        // Add entity&#10;                        archetype.addEntity(baseId + i);&#10;&#10;                        // Simulate some processing time&#10;                        if (i % 100 == 0) {&#10;                            Thread.sleep(0, 1000); // 1 microsecond&#10;                        }&#10;                    }&#10;                } catch (InterruptedException ignored) {&#10;                } finally {&#10;                    done.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        start.countDown();&#10;        Assertions.assertTrue(done.await(90, TimeUnit.SECONDS), &quot;Mixed operations should complete&quot;);&#10;        pool.shutdownNow();&#10;&#10;        // Final verification&#10;        final int[] count = {0};&#10;        archetype.forEach((eid, loc, chunk) -&gt; count[0]++);&#10;        Assertions.assertEquals(threads * cyclesPerThread, count[0], &quot;All entities should be accounted for&quot;);&#10;    }&#10;&#10;    @Test&#10;    void allocateUpToCapacityConcurrently_manyRounds() throws InterruptedException {&#10;        // NOTE: This is a stress-only test and can be flaky when run with the full suite&#10;        // because it amplifies scheduler timing differences.&#10;        // Temporarily disabled to keep the main suite stable; re-enable when investigating&#10;        // allocator behavior in isolation.&#10;        if (Boolean.getBoolean(&quot;ecs.enableLockFreeAllocatorStress&quot;)) {&#10;            for (int i = 0; i &lt; 20; i++) {&#10;                allocateUpToCapacityConcurrently();&#10;            }&#10;        }&#10;    }&#10;&#10;    // Dummy component classes for descriptor construction&#10;    static final class DummyC1 {}&#10;    static final class DummyC2 {}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ManagedComponentStoreTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ManagedComponentStoreTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.ManagedComponentStore;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;public class ManagedComponentStoreTest {&#10;&#10;    @Test&#10;    void storeGetRelease_basic() {&#10;        ManagedComponentStore store = new ManagedComponentStore(4);&#10;        int a = store.store(&quot;A&quot;);&#10;        int b = store.store(&quot;B&quot;);&#10;        assertNotEquals(a, b);&#10;        assertEquals(&quot;A&quot;, store.get(a));&#10;        assertEquals(&quot;B&quot;, store.get(b));&#10;        store.release(a);&#10;        assertNull(store.get(a));&#10;        int c = store.store(&quot;C&quot;);&#10;        // c can reuse 'a' slot&#10;        assertEquals(&quot;C&quot;, store.get(c));&#10;    }&#10;&#10;    @Test&#10;    void concurrent_store_and_release() throws InterruptedException {&#10;        ManagedComponentStore store = new ManagedComponentStore(8);&#10;        int threads = 8;&#10;        int ops = 1000;&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;        try (ExecutorService es = Executors.newFixedThreadPool(threads)) {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                es.submit(() -&gt; {&#10;                    try {&#10;                        start.await();&#10;                        List&lt;Integer&gt; tickets = new ArrayList&lt;&gt;();&#10;                        for (int i = 0; i &lt; ops; i++) {&#10;                            int id = store.store(&quot;x&quot; + i);&#10;                            tickets.add(id);&#10;                            if ((i &amp; 1) == 0) {&#10;                                // release half of them&#10;                                store.release(id);&#10;                            }&#10;                        }&#10;                        // release the rest&#10;                        for (int id : tickets) {&#10;                            store.release(id);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        done.countDown();&#10;                    }&#10;                });&#10;            }&#10;            start.countDown();&#10;            assertTrue(done.await(30, TimeUnit.SECONDS));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void deterministicReuse_smallCapacity() {&#10;        ManagedComponentStore store = new ManagedComponentStore(2);&#10;        int t0 = store.store(&quot;A&quot;);&#10;        int t1 = store.store(&quot;B&quot;);&#10;        assertNotEquals(t0, t1);&#10;        // Release first, it should be reused by next store&#10;        store.release(t0);&#10;        assertNull(store.get(t0));&#10;        int t2 = store.store(&quot;C&quot;);&#10;        assertEquals(t0, t2, &quot;Expected first released ticket to be reused&quot;);&#10;        // Release second, then reused&#10;        store.release(t1);&#10;        assertNull(store.get(t1));&#10;        int t3 = store.store(&quot;D&quot;);&#10;        assertEquals(t1, t3, &quot;Expected second released ticket to be reused&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.ManagedComponentStore;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;public class ManagedComponentStoreTest {&#10;&#10;    @Test&#10;    void storeGetRelease_basic() {&#10;        ManagedComponentStore store = new ManagedComponentStore(4);&#10;        int a = store.store(&quot;A&quot;);&#10;        int b = store.store(&quot;B&quot;);&#10;        assertNotEquals(a, b);&#10;        assertEquals(&quot;A&quot;, store.get(a));&#10;        assertEquals(&quot;B&quot;, store.get(b));&#10;        store.release(a);&#10;        assertNull(store.get(a));&#10;        int c = store.store(&quot;C&quot;);&#10;        // c can reuse 'a' slot&#10;        assertEquals(&quot;C&quot;, store.get(c));&#10;    }&#10;&#10;    @Test&#10;    void concurrent_store_and_release() throws InterruptedException {&#10;        ManagedComponentStore store = new ManagedComponentStore(8);&#10;        int threads = 8;&#10;        int ops = 1000;&#10;        CountDownLatch start = new CountDownLatch(1);&#10;        CountDownLatch done = new CountDownLatch(threads);&#10;        try (ExecutorService es = Executors.newFixedThreadPool(threads)) {&#10;            for (int t = 0; t &lt; threads; t++) {&#10;                es.submit(() -&gt; {&#10;                    try {&#10;                        start.await();&#10;                        List&lt;Integer&gt; tickets = new ArrayList&lt;&gt;();&#10;                        for (int i = 0; i &lt; ops; i++) {&#10;                            int id = store.store(&quot;x&quot; + i);&#10;                            tickets.add(id);&#10;                            if ((i &amp; 1) == 0) {&#10;                                // release half of them&#10;                                store.release(id);&#10;                            }&#10;                        }&#10;                        // release the rest&#10;                        for (int id : tickets) {&#10;                            store.release(id);&#10;                        }&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    } finally {&#10;                        done.countDown();&#10;                    }&#10;                });&#10;            }&#10;            start.countDown();&#10;            assertTrue(done.await(30, TimeUnit.SECONDS));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void deterministicReuse_smallCapacity() {&#10;        ManagedComponentStore store = new ManagedComponentStore(2);&#10;        int t0 = store.store(&quot;A&quot;);&#10;        int t1 = store.store(&quot;B&quot;);&#10;        assertNotEquals(t0, t1);&#10;        // Release first, it should be reused by next store&#10;        store.release(t0);&#10;        assertNull(store.get(t0));&#10;        int t2 = store.store(&quot;C&quot;);&#10;        assertEquals(t0, t2, &quot;Expected first released ticket to be reused&quot;);&#10;        // Release second, then reused&#10;        store.release(t1);&#10;        assertNull(store.get(t1));&#10;        int t3 = store.store(&quot;D&quot;);&#10;        assertEquals(t1, t3, &quot;Expected second released ticket to be reused&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ManagedIntegrationTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/ManagedIntegrationTest.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;public class ManagedIntegrationTest {&#10;&#10;    @Component.Managed&#10;    static class PlayerName implements Component {&#10;        final String name;&#10;        PlayerName(String n) { this.name = n; }&#10;    }&#10;&#10;    @Test&#10;    void add_get_replace_remove_managed_component() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            world.registerComponent(PlayerName.class);&#10;            int e = world.createEntity();&#10;&#10;            // Add managed component instance&#10;            world.addComponent(e, new PlayerName(&quot;Ethnic&quot;));&#10;            PlayerName pn = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pn);&#10;            assertEquals(&quot;Ethnic&quot;, pn.name);&#10;&#10;            // Replace instance&#10;            world.setManagedComponent(e, new PlayerName(&quot;Neo&quot;));&#10;            PlayerName pn2 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pn2);&#10;            assertEquals(&quot;Neo&quot;, pn2.name);&#10;&#10;            // Remove&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;&#10;            // Destroy shouldn't throw&#10;            world.destroyEntity(e);&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void move_between_archetypes_preserves_managed_ticket_if_present() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            // Define an unmanaged component too&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class Dummy implements Component { @Component.Field int v; }&#10;            world.registerComponent(PlayerName.class);&#10;            world.registerComponent(Dummy.class);&#10;&#10;            int e = world.createEntity(Dummy.class);&#10;            world.addComponent(e, new PlayerName(&quot;A&quot;));&#10;            PlayerName p = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p);&#10;            assertEquals(&quot;A&quot;, p.name);&#10;&#10;            // Add another unmanaged component class to force move&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class Dummy2 implements Component { @Component.Field int x; }&#10;            world.registerComponent(Dummy2.class);&#10;&#10;            // Add Dummy2 -&gt; structural move; ticket should persist&#10;            world.addComponent(e, Dummy2.class, cm.allocate(Dummy2.class, java.lang.foreign.Arena.ofShared()));&#10;            PlayerName p2 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p2);&#10;            assertEquals(&quot;A&quot;, p2.name);&#10;&#10;            // Now remove PlayerName -&gt; should become null&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void interleave_managed_unmanaged_ops_no_ticket_leaks() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            // Define a couple unmanaged components&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class U1 implements Component { @Component.Field int a; }&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class U2 implements Component { @Component.Field int b; }&#10;&#10;            world.registerComponent(PlayerName.class);&#10;            world.registerComponent(U1.class);&#10;            world.registerComponent(U2.class);&#10;&#10;            int e = world.createEntity(U1.class);&#10;&#10;            // Add managed, then add another unmanaged -&gt; triggers move&#10;            world.addComponent(e, new PlayerName(&quot;P0&quot;));&#10;            world.addComponent(e, U2.class, cm.allocate(U2.class, java.lang.foreign.Arena.ofShared()));&#10;            PlayerName p0 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p0);&#10;            assertEquals(&quot;P0&quot;, p0.name);&#10;&#10;            // Remove unmanaged U1 -&gt; move&#10;            world.removeComponent(e, U1.class);&#10;            PlayerName pAfterMove = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pAfterMove);&#10;            assertEquals(&quot;P0&quot;, pAfterMove.name);&#10;&#10;            // Replace managed instance&#10;            world.setManagedComponent(e, new PlayerName(&quot;P1&quot;));&#10;            PlayerName p1 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p1);&#10;            assertEquals(&quot;P1&quot;, p1.name);&#10;&#10;            // Remove managed&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;&#10;            // Add again and then destroy entity -&gt; should release&#10;            world.addComponent(e, new PlayerName(&quot;P2&quot;));&#10;            assertNotNull(world.getManagedComponent(e, PlayerName.class));&#10;            world.destroyEntity(e);&#10;            // Entity gone; can't directly check store, but absence via accessor indicates ticket release or entity removal&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.archetype.ArchetypeWorld;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;import com.ethnicthv.ecs.core.components.ComponentManager;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;public class ManagedIntegrationTest {&#10;&#10;    @Component.Managed&#10;    static class PlayerName implements Component {&#10;        final String name;&#10;        PlayerName(String n) { this.name = n; }&#10;    }&#10;&#10;    @Test&#10;    void add_get_replace_remove_managed_component() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            world.registerComponent(PlayerName.class);&#10;            int e = world.createEntity();&#10;&#10;            // Add managed component instance&#10;            world.addComponent(e, new PlayerName(&quot;Ethnic&quot;));&#10;            PlayerName pn = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pn);&#10;            assertEquals(&quot;Ethnic&quot;, pn.name);&#10;&#10;            // Replace instance&#10;            world.setManagedComponent(e, new PlayerName(&quot;Neo&quot;));&#10;            PlayerName pn2 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pn2);&#10;            assertEquals(&quot;Neo&quot;, pn2.name);&#10;&#10;            // Remove&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;&#10;            // Destroy shouldn't throw&#10;            world.destroyEntity(e);&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void move_between_archetypes_preserves_managed_ticket_if_present() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            // Define an unmanaged component too&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class Dummy implements Component { @Component.Field int v; }&#10;            world.registerComponent(PlayerName.class);&#10;            world.registerComponent(Dummy.class);&#10;&#10;            int e = world.createEntity(Dummy.class);&#10;            world.addComponent(e, new PlayerName(&quot;A&quot;));&#10;            PlayerName p = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p);&#10;            assertEquals(&quot;A&quot;, p.name);&#10;&#10;            // Add another unmanaged component class to force move&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class Dummy2 implements Component { @Component.Field int x; }&#10;            world.registerComponent(Dummy2.class);&#10;&#10;            // Add Dummy2 -&gt; structural move; ticket should persist&#10;            world.addComponent(e, Dummy2.class, cm.allocate(Dummy2.class, java.lang.foreign.Arena.ofShared()));&#10;            PlayerName p2 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p2);&#10;            assertEquals(&quot;A&quot;, p2.name);&#10;&#10;            // Now remove PlayerName -&gt; should become null&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void interleave_managed_unmanaged_ops_no_ticket_leaks() {&#10;        ComponentManager cm = new ComponentManager();&#10;        try (ArchetypeWorld world = new ArchetypeWorld(cm)) {&#10;            // Define a couple unmanaged components&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class U1 implements Component { @Component.Field int a; }&#10;            @Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;            class U2 implements Component { @Component.Field int b; }&#10;&#10;            world.registerComponent(PlayerName.class);&#10;            world.registerComponent(U1.class);&#10;            world.registerComponent(U2.class);&#10;&#10;            int e = world.createEntity(U1.class);&#10;&#10;            // Add managed, then add another unmanaged -&gt; triggers move&#10;            world.addComponent(e, new PlayerName(&quot;P0&quot;));&#10;            world.addComponent(e, U2.class, cm.allocate(U2.class, java.lang.foreign.Arena.ofShared()));&#10;            PlayerName p0 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p0);&#10;            assertEquals(&quot;P0&quot;, p0.name);&#10;&#10;            // Remove unmanaged U1 -&gt; move&#10;            world.removeComponent(e, U1.class);&#10;            PlayerName pAfterMove = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(pAfterMove);&#10;            assertEquals(&quot;P0&quot;, pAfterMove.name);&#10;&#10;            // Replace managed instance&#10;            world.setManagedComponent(e, new PlayerName(&quot;P1&quot;));&#10;            PlayerName p1 = world.getManagedComponent(e, PlayerName.class);&#10;            assertNotNull(p1);&#10;            assertEquals(&quot;P1&quot;, p1.name);&#10;&#10;            // Remove managed&#10;            world.removeComponent(e, PlayerName.class);&#10;            assertNull(world.getManagedComponent(e, PlayerName.class));&#10;&#10;            // Add again and then destroy entity -&gt; should release&#10;            world.addComponent(e, new PlayerName(&quot;P2&quot;));&#10;            assertNotNull(world.getManagedComponent(e, PlayerName.class));&#10;            world.destroyEntity(e);&#10;            // Entity gone; can't directly check store, but absence via accessor indicates ticket release or entity removal&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/TestComponent1.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/ethnicthv/ecs/archetype/TestComponent1.java" />
              <option name="originalContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;&#10;@Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;public final class TestComponent1 implements Component {&#10;    @Component.Field(offset = 0, size = 4, alignment = 4)&#10;    int value;&#10;}&#10;" />
              <option name="updatedContent" value="package com.ethnicthv.ecs.archetype;&#10;&#10;import com.ethnicthv.ecs.core.components.Component;&#10;&#10;@Component.Layout(Component.LayoutType.SEQUENTIAL)&#10;public final class TestComponent1 implements Component {&#10;    @Component.Field(offset = 0, size = 4, alignment = 4)&#10;    int value;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>